ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 1
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                              1 ;	EMUBASIC based on GRANT's BASIC
                              2 ;	TARGET: EMUZ80
                              3 ;	ASSEMBLER: ARCPIT XZ80.EXE
                              4 ;
                              5 ;	START UP ROUTINE
                              6 ;	VERSION 1.0, 2022/02/15
                              7 ;	WRITTEN by TETSUYA SUZUKI
                              8 ;
                              9 ;	MEMORY ASIGN
o  0000                      10 ROMTOP	EQU	0000H
o  0000                      11 RAMTOP	EQU	8000H
o  0000                      12 RAMSIZ	EQU	1000H
o  0000                      13 TSTACK	EQU	80EDH
                             14 ;
                             15 ;	UART REGISTER ADDRESS
o  0000                      16 UARTDR	EQU	0E000H	; UART DATA REGISTOR
o  0000                      17 UARTCR	EQU	0E001H	; UART CONTROL REGISTOR
                             18 ;
                             19 ;	RESET (RST 00H)
o  0000                      20 	ORG	ROMTOP
   0000 F3            [ 4]   21 	DI
u  0001 31 00 00      [10]   22 	LD	SP,TSTACK
   0004 C3 30 00      [10]   23 	JP	SINIT
                             24 ;
                             25 ;	PUT 1CHAR (RST 08H)
o  0007                      26 	ORG	ROMTOP+08H
   0007 C3 23 00      [10]   27 	JP	TXA
                             28 ;
                             29 ;	GET 1CHAR (RST 10H)
o  000A                      30 	ORG	ROMTOP+10H
   000A C3 10 00      [10]   31 	JP	RXA
                             32 ;
                             33 ;	KBHIT (RST 18H)
o  000D                      34 	ORG	ROMTOP+18H
   000D C3 1D 00      [10]   35 	JP	KBHIT
                             36 ;
                             37 ;	UART -> A
u  0010 3A 00 00      [13]   38 RXA:	LD	A,(UARTCR)
   0013 CB 47         [ 8]   39 	BIT	0,A
   0015 28 F9         [12]   40 	JR	Z,RXA
u  0017 3A 00 00      [13]   41 	LD	A,(UARTDR)
q  001A                      42 	CP	'a'
   001A D8            [11]   43 	RET	C
q  001B                      44 	CP	'z'+1
   001B D0            [11]   45 	RET	NC
kq 001C                      46 	AND	0DFH
   001C C9            [10]   47 	RET
                             48 ;
                             49 ;	CHECK RECEIVE STATUS
u  001D 3A 00 00      [13]   50 KBHIT:	LD	A,(UARTCR)
   0020 CB 47         [ 8]   51 	BIT	0,A
   0022 C9            [10]   52 	RET
                             53 ;
                             54 ;	A -> UART
   0023 F5            [11]   55 TXA:	PUSH	AF
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 2
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  0024 3A 00 00      [13]   56 TXAST1:	LD	A,(UARTCR)
   0027 CB 4F         [ 8]   57 	BIT	1,A
   0029 28 F9         [12]   58 	JR	Z,TXAST1
   002B F1            [10]   59 	POP	AF
u  002C 32 00 00      [13]   60 	LD	(UARTDR),A
   002F C9            [10]   61 	RET
                             62 ;
                             63 ;
                             64 ;	SYSTEM INITIALIZE
   0030                      65 SINIT:
   0030 C3 33 00      [10]   66 	JP	COLD
                             67 ;
                             68 ;==================================================================================
                             69 ; The updates to the original BASIC within this file are copyright Grant Searle
                             70 ;
                             71 ; You have permission to use this for NON COMMERCIAL USE ONLY
                             72 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                             73 ;
                             74 ; http://searle.hostei.com/grant/index.html
                             75 ;
                             76 ; eMail: home.micros01@btinternet.com
                             77 ;
                             78 ; If the above don't work, please perform an Internet search to see if I have
                             79 ; updated the web page hosting service.
                             80 ;
                             81 ;==================================================================================
                             82 ;
                             83 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                             84 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                             85 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                             86 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                             87 ; the original ROM code (checksum A934H). PA
                             88 ;
                             89 ; GENERAL EQUATES
                             90 ;
o  0033                      91 CTRLC	EQU	03H		; Control "C"
o  0033                      92 CTRLG	EQU	07H		; Control "G"
o  0033                      93 BKSP	EQU	08H		; Back space
o  0033                      94 LF	EQU	0AH		; Line feed
o  0033                      95 CS	EQU	0CH		; Clear screen
o  0033                      96 CR	EQU	0DH		; Carriage return
o  0033                      97 CTRLO	EQU	0FH		; Control "O"
o  0033                      98 CTRLQ	EQU	11H		; Control "Q"
o  0033                      99 CTRLR	EQU	12H		; Control "R"
o  0033                     100 CTRLS	EQU	13H		; Control "S"
o  0033                     101 CTRLU	EQU	15H		; Control "U"
o  0033                     102 ESC	EQU	1BH		; Escape
o  0033                     103 DEL	EQU	7FH		; Delete
                            104 ;
                            105 ; BASIC WORK SPACE LOCATIONS
                            106 ;
o  0033                     107 WRKSPC	EQU	8045H		; BASIC Work space
o  0033                     108 USR	EQU	WRKSPC+3H	; "USR (x)" jump
o  0033                     109 OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
o  0033                     110 OTPORT	EQU	WRKSPC+7H	; Port (p)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 3
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



o  0033                     111 DIVSUP	EQU	WRKSPC+9H	; Division support routine
o  0033                     112 DIV1	EQU	WRKSPC+0AH	; <- Values
o  0033                     113 DIV2	EQU	WRKSPC+0EH	; <- to
o  0033                     114 DIV3	EQU	WRKSPC+12H	; <- be
o  0033                     115 DIV4	EQU	WRKSPC+15H	; <- inserted
o  0033                     116 SEED	EQU	WRKSPC+17H	; Random number seed
o  0033                     117 LSTRND	EQU	WRKSPC+3AH	; Last random number
o  0033                     118 INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
o  0033                     119 INPORT	EQU	WRKSPC+3FH	; PORT (x)
o  0033                     120 NULLS	EQU	WRKSPC+41H	; Number of nulls
o  0033                     121 LWIDTH	EQU	WRKSPC+42H	; Terminal width
o  0033                     122 COMMAN	EQU	WRKSPC+43H	; Width for commas
o  0033                     123 NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
o  0033                     124 CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
o  0033                     125 LINESC	EQU	WRKSPC+46H	; Lines counter
o  0033                     126 LINESN	EQU	WRKSPC+48H	; Lines number
o  0033                     127 CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
o  0033                     128 NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
o  0033                     129 BRKFLG	EQU	WRKSPC+4DH	; Break flag
o  0033                     130 RINPUT	EQU	WRKSPC+4EH	; Input reflection
o  0033                     131 POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
o  0033                     132 PSET	EQU	WRKSPC+54H	; "SET"	reflection
o  0033                     133 RESET	EQU	WRKSPC+57H	; "RESET" reflection
o  0033                     134 STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
o  0033                     135 LINEAT	EQU	WRKSPC+5CH	; Current line number
o  0033                     136 BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
o  0033                     137 BUFFER	EQU	WRKSPC+61H	; Input buffer
o  0033                     138 STACK	EQU	WRKSPC+66H	; Initial stack
o  0033                     139 CURPOS	EQU	WRKSPC+0ABH	; Character position on line
o  0033                     140 LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
o  0033                     141 TYPE	EQU	WRKSPC+0ADH	; Data type flag
o  0033                     142 DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
o  0033                     143 LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
o  0033                     144 TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
o  0033                     145 TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
o  0033                     146 TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
o  0033                     147 STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
o  0033                     148 CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
o  0033                     149 LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
o  0033                     150 DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
o  0033                     151 FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
o  0033                     152 LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
o  0033                     153 READFG	EQU	WRKSPC+0CDH	; Read/Input flag
o  0033                     154 BRKLIN	EQU	WRKSPC+0CEH	; Line of break
o  0033                     155 NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
o  0033                     156 ERRLIN	EQU	WRKSPC+0D2H	; Line of error
o  0033                     157 CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
o  0033                     158 PROGND	EQU	WRKSPC+0D6H	; End of program
o  0033                     159 VAREND	EQU	WRKSPC+0D8H	; End of variables
o  0033                     160 ARREND	EQU	WRKSPC+0DAH	; End of arrays
o  0033                     161 NXTDAT	EQU	WRKSPC+0DCH	; Next data item
o  0033                     162 FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
o  0033                     163 FNARG	EQU	WRKSPC+0E0H	; FN argument value
o  0033                     164 FPREG	EQU	WRKSPC+0E4H	; Floating point register
o  0033                     165 FPEXP	EQU	FPREG+3		; Floating point exponent
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 4
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



o  0033                     166 SGNRES	EQU	WRKSPC+0E8H	; Sign of result
o  0033                     167 PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
o  0033                     168 MULVAL	EQU	WRKSPC+0F6H	; Multiplier
o  0033                     169 PROGST	EQU	WRKSPC+0F9H	; Start of program text area
o  0033                     170 STLOOK	EQU	WRKSPC+15DH	; Start of memory test
                            171 ;
                            172 ; BASIC ERROR CODE VALUES
                            173 ;
o  0033                     174 NF	EQU	00H		; NEXT without FOR
o  0033                     175 SN	EQU	02H		; Syntax error
o  0033                     176 RG	EQU	04H		; RETURN without GOSUB
o  0033                     177 OD	EQU	06H		; Out of DATA
o  0033                     178 FC	EQU	08H		; Function call error
o  0033                     179 OV	EQU	0AH		; Overflow
o  0033                     180 OM	EQU	0CH		; Out of memory
o  0033                     181 UL	EQU	0EH		; Undefined line number
o  0033                     182 BS	EQU	10H		; Bad subscript
o  0033                     183 RD	EQU	12H		; Re-DIMensioned array
o  0033                     184 DZ	EQU	14H		; Division by zero (/0)
o  0033                     185 ID	EQU	16H		; Illegal direct
o  0033                     186 TM	EQU	18H		; Type miss-match
o  0033                     187 OS	EQU	1AH		; Out of string space
o  0033                     188 LS	EQU	1CH		; String too long
o  0033                     189 ST	EQU	1EH		; String formula too complex
o  0033                     190 CN	EQU	20H		; Can't CONTinue
o  0033                     191 UF	EQU	22H		; UnDEFined FN function
o  0033                     192 MO	EQU	24H		; Missing operand
o  0033                     193 HX	EQU	26H		; HEX error
o  0033                     194 BN	EQU	28H		; BIN error
                            195 ;
   0033 C3 39 00      [10]  196 COLD:	JP	STARTB		; Jump for cold start
   0036 C3 AA 00      [10]  197 WARM:	JP	WARMST		; Jump for warm start
   0039 C3 3C 00      [10]  198 STARTB: JP	CSTART		; Jump to initialise
                            199 ;
o  003C                     200 	DW	DEINT		; Get integer -32768 to 32767
o  003C                     201 	DW	ABPASS		; Return integer in AB
                            202 ;
u  003C 21 00 00      [10]  203 CSTART: LD	HL,WRKSPC	; Start of workspace RAM
   003F F9            [ 6]  204 	LD	SP,HL		; Set up a temporary stack
   0040 C3 26 18      [10]  205 	JP	INITST		; Go to initialise
                            206 ;
   0043 11 BC 00      [10]  207 INIT:	LD	DE,INITAB	; Initialise workspace
   0046 06 29         [ 7]  208 	LD	B,INITBE-INITAB+3; Bytes to copy
u  0048 21 00 00      [10]  209 	LD	HL,WRKSPC	; Into workspace RAM
   004B 1A            [ 7]  210 COPY:	LD	A,(DE)		; Get source
   004C 77            [ 7]  211 	LD	(HL),A		; To destination
   004D 23            [ 6]  212 	INC	HL		; Next destination
   004E 13            [ 6]  213 	INC	DE		; Next source
   004F 05            [ 4]  214 	DEC	B		; Count bytes
   0050 C2 4B 00      [10]  215 	JP	NZ,COPY		; More to move
   0053 F9            [ 6]  216 	LD	SP,HL		; Temporary stack
   0054 CD 63 02      [17]  217 	CALL	CLREG		; Clear registers and stack
   0057 CD E5 07      [17]  218 	CALL	PRCRLF		; Output CRLF
u  005A 32 49 00      [13]  219 	LD	(BUFFER+72+1),A	; Mark end of buffer
u  005D 32 00 00      [13]  220 	LD	(PROGST),A	; Initialise program area
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 5
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  0060 21 00 00      [10]  221 MSIZE:	LD	HL,STLOOK	; Point to start of RAM
   0063 23            [ 6]  222 MLOOP:	INC	HL		; Next byte
   0064 7C            [ 4]  223 	LD	A,H		; Above address FFFF ?
   0065 B5            [ 4]  224 	OR	L
   0066 CA 72 00      [10]  225 	JP	Z,SETTOP	; Yes - 64K RAM
   0069 7E            [ 7]  226 	LD	A,(HL)		; Get contents
   006A 47            [ 4]  227 	LD	B,A		; Save it
   006B 2F            [ 4]  228 	CPL			; Flip all bits
   006C 77            [ 7]  229 	LD	(HL),A		; Put it back
   006D BE            [ 7]  230 	CP	(HL)		; RAM there if same
   006E 70            [ 7]  231 	LD	(HL),B		; Restore old contents
   006F CA 63 00      [10]  232 	JP	Z,MLOOP		; If RAM - test next byte
                            233 ;
   0072 2B            [ 6]  234 SETTOP: DEC	HL		; Back one byte
u  0073 11 FF FF      [10]  235 	LD	DE,STLOOK-1	; See if enough RAM
   0076 CD D8 03      [17]  236 	CALL	CPDEHL		; Compare DE with HL
   0079 DA B3 00      [10]  237 	JP	C,NEMEM		; If not enough RAM
   007C 11 CE FF      [10]  238 	LD	DE,0-50		; 50 Bytes string space
u  007F 22 00 00      [16]  239 	LD	(LSTRAM),HL	; Save last available RAM
   0082 19            [11]  240 	ADD	HL,DE		; Allocate string space
u  0083 22 00 00      [16]  241 	LD	(STRSPC),HL	; Save string space
   0086 CD 3E 02      [17]  242 	CALL	CLRPTR		; Clear program area
u  0089 2A 00 00      [16]  243 	LD	HL,(STRSPC)	; Get end of memory
   008C 11 EF FF      [10]  244 	LD	DE,0-17		; Offset for free bytes
   008F 19            [11]  245 	ADD	HL,DE		; Adjust HL
u  0090 11 00 00      [10]  246 	LD	DE,PROGST	; Start of program text
   0093 7D            [ 4]  247 	LD	A,L		; Get LSB
   0094 93            [ 4]  248 	SUB	E		; Adjust it
   0095 6F            [ 4]  249 	LD	L,A		; Re-save
   0096 7C            [ 4]  250 	LD	A,H		; Get MSB
   0097 9A            [ 4]  251 	SBC	A,D		; Adjust it
   0098 67            [ 4]  252 	LD	H,A		; Re-save
   0099 E5            [11]  253 	PUSH	HL		; Save bytes free
   009A 21 BC 00      [10]  254 	LD	HL,SIGNON	; Sign-on message
   009D CD 27 0E      [17]  255 	CALL	PRS		; Output string
   00A0 E1            [10]  256 	POP	HL		; Get bytes free back
   00A1 CD 91 14      [17]  257 	CALL	PRNTHL		; Output amount of free memory
   00A4 21 BC 00      [10]  258 	LD	HL,BFREE	; " Bytes free" message
   00A7 CD 27 0E      [17]  259 	CALL	PRS		; Output string
                            260 ;
u  00AA 31 00 00      [10]  261 WARMST: LD	SP,STACK	; Temporary stack
   00AD CD 63 02      [17]  262 BRKRET: CALL	CLREG		; Clear registers and stack
   00B0 C3 7C 01      [10]  263 	JP	PRNTOK		; Go to get command line
                            264 ;
   00B3 21 BC 00      [10]  265 NEMEM:	LD	HL,MEMMSG	; Memory size not enough
   00B6 CD 27 0E      [17]  266 	CALL	PRS		; Print it
   00B9 C3 B9 00      [10]  267 XXXXX:	JP	XXXXX		; Stop
                            268 ;
q  00BC                     269 BFREE:	DB	" Bytes free",CR,LF,0,0
                            270 ;
q  00BC                     271 SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
                            272 	DB	"Copyright ",40,"C",41
                            273 	DB	" 1978 by Microsoft",CR,LF,0,0
                            274 ;
q  00BC                     275 MEMMSG: DB	"Memory size not enough",CR,LF
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 6
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                            276 	DB	"The system is stopped.",CR,LF,0,0
                            277 ;
                            278 ; FUNCTION ADDRESS TABLE
                            279 ;
o  00BC                     280 FNCTAB: DW	SGN
o  00BC                     281 	DW	INT
o  00BC                     282 	DW	ABS
o  00BC                     283 	DW	USR
o  00BC                     284 	DW	FRE
o  00BC                     285 	DW	INP
o  00BC                     286 	DW	POS
o  00BC                     287 	DW	SQR
o  00BC                     288 	DW	RND
o  00BC                     289 	DW	LOG
o  00BC                     290 	DW	EXP
o  00BC                     291 	DW	COS
o  00BC                     292 	DW	SIN
o  00BC                     293 	DW	TAN
o  00BC                     294 	DW	ATN
o  00BC                     295 	DW	PEEK
o  00BC                     296 	DW	DEEK
o  00BC                     297 	DW	POINT
o  00BC                     298 	DW	LEN
o  00BC                     299 	DW	STR
o  00BC                     300 	DW	VAL
o  00BC                     301 	DW	ASC
o  00BC                     302 	DW	CHR
o  00BC                     303 	DW	HEX
o  00BC                     304 	DW	BIN
o  00BC                     305 	DW	LEFT
o  00BC                     306 	DW	RIGHT
o  00BC                     307 	DW	MID
                            308 ;
                            309 ; RESERVED WORD LIST
                            310 ;
q  00BC                     311 WORDS:	DB	0C5H,"ND"
                            312 	DB	0C6H,"OR"
                            313 	DB	0CEH,"EXT"
                            314 	DB	0C4H,"ATA"
                            315 	DB	0C9H,"NPUT"
                            316 	DB	0C4H,"IM"
                            317 	DB	0D2H,"EAD"
                            318 	DB	0CCH,"ET"
                            319 	DB	0C7H,"OTO"
                            320 	DB	0D2H,"UN"
                            321 	DB	0C9H,"F"
                            322 	DB	0D2H,"ESTORE"
                            323 	DB	0C7H,"OSUB"
                            324 	DB	0D2H,"ETURN"
                            325 	DB	0D2H,"EM"
                            326 	DB	0D3H,"TOP"
                            327 	DB	0CFH,"UT"
                            328 	DB	0CFH,"N"
                            329 	DB	0CEH,"ULL"
                            330 	DB	0D7H,"AIT"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 7
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                            331 	DB	0C4H,"EF"
                            332 	DB	0D0H,"OKE"
                            333 	DB	0C4H,"OKE"
                            334 	DB	0D3H,"CREEN"
                            335 	DB	0CCH,"INES"
                            336 	DB	0C3H,"LS"
                            337 	DB	0D7H,"IDTH"
                            338 	DB	0CDH,"ONITOR"
                            339 	DB	0D3H,"ET"
                            340 	DB	0D2H,"ESET"
                            341 	DB	0D0H,"RINT"
                            342 	DB	0C3H,"ONT"
                            343 	DB	0CCH,"IST"
                            344 	DB	0C3H,"LEAR"
                            345 	DB	0C3H,"LOAD"
                            346 	DB	0C3H,"SAVE"
                            347 	DB	0CEH,"EW"
                            348 ;
                            349 	DB	0D4H,"AB("
                            350 	DB	0D4H,"O"
                            351 	DB	0C6H,"N"
                            352 	DB	0D3H,"PC("
                            353 	DB	0D4H,"HEN"
                            354 	DB	0CEH,"OT"
                            355 	DB	0D3H,"TEP"
                            356 ;
                            357 	DB	0ABH
                            358 	DB	0ADH
                            359 	DB	0AAH
                            360 	DB	0AFH
                            361 	DB	0DEH
                            362 	DB	0C1H,"ND"
                            363 	DB	0CFH,"R"
                            364 	DB	0BEH
                            365 	DB	0BDH
                            366 	DB	0BCH
                            367 ;
                            368 	DB	0D3H,"GN"
                            369 	DB	0C9H,"NT"
                            370 	DB	0C1H,"BS"
                            371 	DB	0D5H,"SR"
                            372 	DB	0C6H,"RE"
                            373 	DB	0C9H,"NP"
                            374 	DB	0D0H,"OS"
                            375 	DB	0D3H,"QR"
                            376 	DB	0D2H,"ND"
                            377 	DB	0CCH,"OG"
                            378 	DB	0C5H,"XP"
                            379 	DB	0C3H,"OS"
                            380 	DB	0D3H,"IN"
                            381 	DB	0D4H,"AN"
                            382 	DB	0C1H,"TN"
                            383 	DB	0D0H,"EEK"
                            384 	DB	0C4H,"EEK"
                            385 	DB	0D0H,"OINT"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 8
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                            386 	DB	0CCH,"EN"
                            387 	DB	0D3H,"TR$"
                            388 	DB	0D6H,"AL"
                            389 	DB	0C1H,"SC"
                            390 	DB	0C3H,"HR$"
                            391 	DB	0C8H,"EX$"
                            392 	DB	0C2H,"IN$"
                            393 	DB	0CCH,"EFT$"
                            394 	DB	0D2H,"IGHT$"
                            395 	DB	0CDH,"ID$"
                            396 	DB	80H		; End of list marker
                            397 ;
                            398 ; KEYWORD ADDRESS TABLE
                            399 ;
o  00BC                     400 WORDTB: DW	PEND
o  00BC                     401 	DW	FOR
o  00BC                     402 	DW	NEXT
o  00BC                     403 	DW	DATA
o  00BC                     404 	DW	INPUT
o  00BC                     405 	DW	DIM
o  00BC                     406 	DW	READ
o  00BC                     407 	DW	LET
o  00BC                     408 	DW	GOTO
o  00BC                     409 	DW	RUN
o  00BC                     410 	DW	IF
o  00BC                     411 	DW	RESTOR
o  00BC                     412 	DW	GOSUB
o  00BC                     413 	DW	RETURN
o  00BC                     414 	DW	REM
o  00BC                     415 	DW	STOP
o  00BC                     416 	DW	POUT
o  00BC                     417 	DW	ON
o  00BC                     418 	DW	NULL
o  00BC                     419 	DW	WAIT
o  00BC                     420 	DW	DEF
o  00BC                     421 	DW	POKE
o  00BC                     422 	DW	DOKE
o  00BC                     423 	DW	REM
o  00BC                     424 	DW	LINES
o  00BC                     425 	DW	CLS
o  00BC                     426 	DW	WIDTH
o  00BC                     427 	DW	MONITR
o  00BC                     428 	DW	PSET
o  00BC                     429 	DW	RESET
o  00BC                     430 	DW	PRINT
o  00BC                     431 	DW	CONT
o  00BC                     432 	DW	LIST
o  00BC                     433 	DW	CLEAR
o  00BC                     434 	DW	REM
o  00BC                     435 	DW	REM
o  00BC                     436 	DW	NEW
                            437 ;
                            438 ; RESERVED WORD TOKEN VALUES
                            439 ;
o  00BC                     440 ZEND	EQU	080H		; END
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 9
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



o  00BC                     441 ZFOR	EQU	081H		; FOR
o  00BC                     442 ZDATA	EQU	083H		; DATA
o  00BC                     443 ZGOTO	EQU	088H		; GOTO
o  00BC                     444 ZGOSUB	EQU	08CH		; GOSUB
o  00BC                     445 ZREM	EQU	08EH		; REM
o  00BC                     446 ZPRINT	EQU	09EH		; PRINT
o  00BC                     447 ZNEW	EQU	0A4H		; NEW
                            448 ;
o  00BC                     449 ZTAB	EQU	0A5H		; TAB
o  00BC                     450 ZTO	EQU	0A6H		; TO
o  00BC                     451 ZFN	EQU	0A7H		; FN
o  00BC                     452 ZSPC	EQU	0A8H		; SPC
o  00BC                     453 ZTHEN	EQU	0A9H		; THEN
o  00BC                     454 ZNOT	EQU	0AAH		; NOT
o  00BC                     455 ZSTEP	EQU	0ABH		; STEP
                            456 ;
o  00BC                     457 ZPLUS	EQU	0ACH		; +
o  00BC                     458 ZMINUS	EQU	0ADH		; -
o  00BC                     459 ZTIMES	EQU	0AEH		; *
o  00BC                     460 ZDIV	EQU	0AFH		; /
o  00BC                     461 ZOR	EQU	0B2H		; OR
o  00BC                     462 ZGTR	EQU	0B3H		; >
o  00BC                     463 ZEQUAL	EQU	0B4H		; M
o  00BC                     464 ZLTH	EQU	0B5H		; <
o  00BC                     465 ZSGN	EQU	0B6H		; SGN
o  00BC                     466 ZPOINT	EQU	0C7H		; POINT
o  00BC                     467 ZLEFT	EQU	0CDH +2		; LEFT$
                            468 ;
                            469 ; ARITHMETIC PRECEDENCE TABLE
                            470 ;
q  00BC                     471 PRITAB: DB	79H		; Precedence value
o  00BC                     472 	DW	PADD		; FPREG = <last> + FPREG
                            473 ;
                            474 	DB	79H		; Precedence value
o  00BC                     475 	DW	PSUB		; FPREG = <last> - FPREG
                            476 ;
                            477 	DB	7CH		; Precedence value
o  00BC                     478 	DW	MULT		; PPREG = <last> * FPREG
                            479 ;
                            480 	DB	7CH		; Precedence value
o  00BC                     481 	DW	DIV		; FPREG = <last> / FPREG
                            482 ;
                            483 	DB	7FH		; Precedence value
o  00BC                     484 	DW	POWER		; FPREG = <last> ^ FPREG
                            485 ;
                            486 	DB	50H		; Precedence value
o  00BC                     487 	DW	PAND		; FPREG = <last> AND FPREG
                            488 ;
                            489 	DB	46H		; Precedence value
o  00BC                     490 	DW	POR		; FPREG = <last> OR FPREG
                            491 ;
                            492 ; BASIC ERROR CODE LIST
                            493 ;
q  00BC                     494 ERRORS: DB	"NF"		; NEXT without FOR
                            495 	DB	"SN"		; Syntax error
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 10
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                            496 	DB	"RG"		; RETURN without GOSUB
                            497 	DB	"OD"		; Out of DATA
                            498 	DB	"FC"		; Illegal function call
                            499 	DB	"OV"		; Overflow error
                            500 	DB	"OM"		; Out of memory
                            501 	DB	"UL"		; Undefined line
                            502 	DB	"BS"		; Bad subscript
                            503 	DB	"DD"		; Re-DIMensioned array
                            504 	DB	"/0"		; Division by zero
                            505 	DB	"ID"		; Illegal direct
                            506 	DB	"TM"		; Type mis-match
                            507 	DB	"OS"		; Out of string space
                            508 	DB	"LS"		; String too long
                            509 	DB	"ST"		; String formula too complex
                            510 	DB	"CN"		; Can't CONTinue
                            511 	DB	"UF"		; Undefined FN function
                            512 	DB	"MO"		; Missing operand
                            513 	DB	"HX"		; HEX error
                            514 	DB	"BN"		; BIN error
                            515 ;
                            516 ; INITIALISATION TABLE -------------------------------------------------------
                            517 ;
   00BC C3 AA 00      [10]  518 INITAB: JP	WARMST		; Warm start jump
   00BF C3 14 06      [10]  519 	JP	FCERR		; "USR (X)" jump (Set to Error)
   00C2 D3 00         [11]  520 	OUT	(0),A		; "OUT p,n" skeleton
   00C4 C9            [10]  521 	RET
   00C5 D6 00         [ 7]  522 	SUB	0		; Division support routine
   00C7 6F            [ 4]  523 	LD	L,A
   00C8 7C            [ 4]  524 	LD	A,H
   00C9 DE 00         [ 7]  525 	SBC	A,0
   00CB 67            [ 4]  526 	LD	H,A
   00CC 78            [ 4]  527 	LD	A,B
   00CD DE 00         [ 7]  528 	SBC	A,0
   00CF 47            [ 4]  529 	LD	B,A
   00D0 3E 00         [ 7]  530 	LD	A,0
   00D2 C9            [10]  531 	RET
                            532 	DB	0,0,0			; Random number seed table used by RND
                            533 	DB	035H,04AH,0CAH,099H	;-2.65145E+07
                            534 	DB	039H,01CH,076H,098H	; 1.61291E+07
                            535 	DB	022H,095H,0B3H,098H	;-1.17691E+07
                            536 	DB	00AH,0DDH,047H,098H	; 1.30983E+07
                            537 	DB	053H,0D1H,099H,099H	;-2-01612E+07
                            538 	DB	00AH,01AH,09FH,098H	;-1.04269E+07
                            539 	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
                            540 	DB	0D6H,077H,03EH,098H	; 1.24825E+07
                            541 	DB	052H,0C7H,04FH,080H	; Last random number
   00D3 DB 00         [11]  542 	IN	A,(0)		; INP (x) skeleton
   00D5 C9            [10]  543 	RET
                            544 	DB	1		; POS (x) number (1)
                            545 	DB	255		; Terminal width (255 = no auto CRLF)
                            546 	DB	28		; Width for commas (3 columns)
                            547 	DB	0		; No nulls after input bytes
                            548 	DB	0		; Output enabled (^O off)
                            549 	DW	20		; Initial lines counter
                            550 	DW	20		; Initial lines number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 11
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                            551 	DW	0		; Array load/save check sum
                            552 	DB	0		; Break not by NMI
                            553 	DB	0		; Break flag
   00D6 C3 5B 03      [10]  554 	JP	TTYLIN		; Input reflection (set to TTY)
q  00D9 C3 00 00      [10]  555 	JP	0000H		; POINT reflection unused
q  00DC C3 00 00      [10]  556 	JP	0000H		; SET reflection
q  00DF C3 00 00      [10]  557 	JP	0000H			; RESET reflection
o  00E2                     558 	DW	STLOOK		; Temp string space
                            559 	DW	-2		; Current line number (cold)
o  00E2                     560 	DW	PROGST+1	; Start of program text
   00E2                     561 INITBE:			 
                            562 ;
                            563 ; END OF INITIALISATION TABLE ---------------------------------------------------
                            564 ;
q  00E2                     565 ERRMSG: DB	" Error",0
q  00E2                     566 INMSG:	DB	" in ",0
o  00E2                     567 ZERBYT	EQU	$-1		; A zero byte
q  00E2                     568 OKMSG:	DB	"Ok",CR,LF,0,0
q  00E2                     569 BRKMSG: DB	"Break",0
                            570 ;
   00E2 21 04 00      [10]  571 BAKSTK: LD	HL,4		; Look for "FOR" block with
   00E5 39            [11]  572 	ADD	HL,SP		; same index as specified
   00E6 7E            [ 7]  573 LOKFOR: LD	A,(HL)		; Get block ID
   00E7 23            [ 6]  574 	INC	HL		; Point to index address
u  00E8 FE 00         [ 7]  575 	CP	ZFOR		; Is it a "FOR" token
   00EA C0            [11]  576 	RET	NZ		; No - exit
   00EB 4E            [ 7]  577 	LD	C,(HL)		; BC = Address of "FOR" index
   00EC 23            [ 6]  578 	INC	HL
   00ED 46            [ 7]  579 	LD	B,(HL)
   00EE 23            [ 6]  580 	INC	HL		; Point to sign of STEP
   00EF E5            [11]  581 	PUSH	HL		; Save pointer to sign
   00F0 69            [ 4]  582 	LD	L,C		; HL = address of "FOR" index
   00F1 60            [ 4]  583 	LD	H,B
   00F2 7A            [ 4]  584 	LD	A,D		; See if an index was specified
   00F3 B3            [ 4]  585 	OR	E		; DE = 0 if no index specified
   00F4 EB            [ 4]  586 	EX	DE,HL		; Specified index into HL
   00F5 CA FC 00      [10]  587 	JP	Z,INDFND	; Skip if no index given
   00F8 EB            [ 4]  588 	EX	DE,HL		; Index back into DE
   00F9 CD D8 03      [17]  589 	CALL	CPDEHL		; Compare index with one given
   00FC 01 0D 00      [10]  590 INDFND: LD	BC,16-3		; Offset to next block
   00FF E1            [10]  591 	POP	HL		; Restore pointer to sign
   0100 C8            [11]  592 	RET	Z		; Return if block found
   0101 09            [11]  593 	ADD	HL,BC		; Point to next block
   0102 C3 E6 00      [10]  594 	JP	LOKFOR		; Keep on looking
                            595 ;
   0105 CD 1E 01      [17]  596 MOVUP:	CALL	ENFMEM		; See if enough memory
   0108 C5            [11]  597 MOVSTR: PUSH	BC		; Save end of source
   0109 E3            [19]  598 	EX	(SP),HL		; Swap source and dest" end
   010A C1            [10]  599 	POP	BC		; Get end of destination
   010B CD D8 03      [17]  600 MOVLP:	CALL	CPDEHL		; See if list moved
   010E 7E            [ 7]  601 	LD	A,(HL)		; Get byte
   010F 02            [ 7]  602 	LD	(BC),A		; Move it
   0110 C8            [11]  603 	RET	Z		; Exit if all done
   0111 0B            [ 6]  604 	DEC	BC		; Next byte to move to
   0112 2B            [ 6]  605 	DEC	HL		; Next byte to move
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 12
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0113 C3 0B 01      [10]  606 	JP	MOVLP		; Loop until all bytes moved
                            607 ;
   0116 E5            [11]  608 CHKSTK: PUSH	HL		; Save code string address
u  0117 2A 00 00      [16]  609 	LD	HL,(ARREND)	; Lowest free memory
   011A 06 00         [ 7]  610 	LD	B,0		; BC = Number of levels to test
   011C 09            [11]  611 	ADD	HL,BC		; 2 Bytes for each level
   011D 09            [11]  612 	ADD	HL,BC
                            613 	DB	3EH		; Skip "PUSH HL"
   011E E5            [11]  614 ENFMEM: PUSH	HL		; Save code string address
q  011F 3E 00         [ 7]  615 	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
   0121 95            [ 4]  616 	SUB	L
   0122 6F            [ 4]  617 	LD	L,A
kq 0123 3E 00         [ 7]  618 	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
   0125 9C            [ 4]  619 	SBC	A,H
   0126 DA 2D 01      [10]  620 	JP	C,OMERR		; Not enough - ?OM Error
   0129 67            [ 4]  621 	LD	H,A
   012A 39            [11]  622 	ADD	HL,SP		; Test if stack is overflowed
   012B E1            [10]  623 	POP	HL		; Restore code string address
   012C D8            [11]  624 	RET	C		; Return if enough mmory
u  012D 1E 00         [ 7]  625 OMERR:	LD	E,OM		; ?OM Error
   012F C3 46 01      [10]  626 	JP	ERROR
                            627 ;
u  0132 2A 00 00      [16]  628 DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
u  0135 22 00 00      [16]  629 	LD	(LINEAT),HL	; Save as current line
u  0138 1E 00         [ 7]  630 SNERR:	LD	E,SN		; ?SN Error
                            631 	DB	01H		; Skip "LD E,DZ"
u  013A 1E 00         [ 7]  632 DZERR:	LD	E,DZ		; ?/0 Error
                            633 	DB	01H		; Skip "LD E,NF"
u  013C 1E 00         [ 7]  634 NFERR:	LD	E,NF		; ?NF Error
                            635 	DB	01H		; Skip "LD E,RD"
u  013E 1E 00         [ 7]  636 DDERR:	LD	E,RD		; ?DD Error
                            637 	DB	01H		; Skip "LD E,UF"
u  0140 1E 00         [ 7]  638 UFERR:	LD	E,UF		; ?UF Error
                            639 	DB	01H		; Skip "LD E,OV
u  0142 1E 00         [ 7]  640 OVERR:	LD	E,OV		; ?OV Error
                            641 	DB	01H		; Skip "LD E,TM"
u  0144 1E 00         [ 7]  642 TMERR:	LD	E,TM		; ?TM Error
                            643 ;
   0146 CD 63 02      [17]  644 ERROR:	CALL	CLREG		; Clear registers and stack
u  0149 32 00 00      [13]  645 	LD	(CTLOFG),A	; Enable output (A is 0)
   014C CD D8 07      [17]  646 	CALL	STTLIN		; Start new line
   014F 21 BC 00      [10]  647 	LD	HL,ERRORS	; Point to error codes
   0152 57            [ 4]  648 	LD	D,A		; D = 0 (A is 0)
q  0153 3E 3F         [ 7]  649 	LD	A,'?'
   0155 CD E9 03      [17]  650 	CALL	OUTC		; Output '?'
   0158 19            [11]  651 	ADD	HL,DE		; Offset to correct error code
   0159 7E            [ 7]  652 	LD	A,(HL)		; First character
   015A CD E9 03      [17]  653 	CALL	OUTC		; Output it
   015D CD 5F 05      [17]  654 	CALL	GETCHR		; Get next character
   0160 CD E9 03      [17]  655 	CALL	OUTC		; Output it
   0163 21 E2 00      [10]  656 	LD	HL,ERRMSG	; "Error" message
   0166 CD 27 0E      [17]  657 ERRIN:	CALL	PRS		; Output message
u  0169 2A 00 00      [16]  658 	LD	HL,(LINEAT)	; Get line of error
   016C 11 FE FF      [10]  659 	LD	DE,-2		; Cold start error if -2
   016F CD D8 03      [17]  660 	CALL	CPDEHL		; See if cold start error
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 13
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0172 CA 3C 00      [10]  661 	JP	Z,CSTART	; Cold start error - Restart
   0175 7C            [ 4]  662 	LD	A,H		; Was it a direct error?
   0176 A5            [ 4]  663 	AND	L		; Line = -1 if direct error
   0177 3C            [ 4]  664 	INC	A
   0178 C4 89 14      [17]  665 	CALL	NZ,LINEIN	; No - output line of error
                            666 	DB	3EH		; Skip "POP BC"
   017B C1            [10]  667 POPNOK: POP	BC		; Drop address in input buffer
                            668 ;
   017C AF            [ 4]  669 PRNTOK: XOR	A		; Output "Ok" and get command
u  017D 32 00 00      [13]  670 	LD	(CTLOFG),A	; Enable output
   0180 CD D8 07      [17]  671 	CALL	STTLIN		; Start new line
   0183 21 E2 00      [10]  672 	LD	HL,OKMSG	; "Ok" message
   0186 CD 27 0E      [17]  673 	CALL	PRS		; Output "Ok"
   0189 21 FF FF      [10]  674 GETCMD: LD	HL,-1		; Flag direct mode
u  018C 22 00 00      [16]  675 	LD	(LINEAT),HL	; Save as current line
   018F CD 5B 03      [17]  676 	CALL	GETLIN		; Get an input line
   0192 DA 89 01      [10]  677 	JP	C,GETCMD	; Get line again if break
   0195 CD 5F 05      [17]  678 	CALL	GETCHR		; Get first character
   0198 3C            [ 4]  679 	INC	A		; Test if end of line
   0199 3D            [ 4]  680 	DEC	A		; Without affecting Carry
   019A CA 89 01      [10]  681 	JP	Z,GETCMD	; Nothing entered - Get another
   019D F5            [11]  682 	PUSH	AF		; Save Carry status
   019E CD 19 06      [17]  683 	CALL	ATOH		; Get line number into DE
   01A1 D5            [11]  684 	PUSH	DE		; Save line number
   01A2 CD 8D 02      [17]  685 	CALL	CRUNCH		; Tokenise rest of line
   01A5 47            [ 4]  686 	LD	B,A		; Length of tokenised line
   01A6 D1            [10]  687 	POP	DE		; Restore line number
   01A7 F1            [10]  688 	POP	AF		; Restore Carry
   01A8 D2 3F 05      [10]  689 	JP	NC,EXCUTE	; No line number - Direct mode
   01AB D5            [11]  690 	PUSH	DE		; Save line number
   01AC C5            [11]  691 	PUSH	BC		; Save length of tokenised line
   01AD AF            [ 4]  692 	XOR	A
u  01AE 32 00 00      [13]  693 	LD	(LSTBIN),A	; Clear last byte input
   01B1 CD 5F 05      [17]  694 	CALL	GETCHR		; Get next character
   01B4 B7            [ 4]  695 	OR	A		; Set flags
   01B5 F5            [11]  696 	PUSH	AF		; And save them
   01B6 CD 1D 02      [17]  697 	CALL	SRCHLN		; Search for line number in DE
   01B9 DA C2 01      [10]  698 	JP	C,LINFND	; Jump if line found
   01BC F1            [10]  699 	POP	AF		; Get status
   01BD F5            [11]  700 	PUSH	AF		; And re-save
   01BE CA B7 06      [10]  701 	JP	Z,ULERR	; Nothing after number - Error
   01C1 B7            [ 4]  702 	OR	A		; Clear Carry
   01C2 C5            [11]  703 LINFND: PUSH	BC		; Save address of line in prog
   01C3 D2 D9 01      [10]  704 	JP	NC,INEWLN	; Line not found - Insert new
   01C6 EB            [ 4]  705 	EX	DE,HL		; Next line address in DE
u  01C7 2A 00 00      [16]  706 	LD	HL,(PROGND)	; End of program
   01CA 1A            [ 7]  707 SFTPRG: LD	A,(DE)		; Shift rest of program down
   01CB 02            [ 7]  708 	LD	(BC),A
   01CC 03            [ 6]  709 	INC	BC		; Next destination
   01CD 13            [ 6]  710 	INC	DE		; Next source
   01CE CD D8 03      [17]  711 	CALL	CPDEHL		; All done?
   01D1 C2 CA 01      [10]  712 	JP	NZ,SFTPRG	; More to do
   01D4 60            [ 4]  713 	LD	H,B		; HL - New end of program
   01D5 69            [ 4]  714 	LD	L,C
u  01D6 22 00 00      [16]  715 	LD	(PROGND),HL	; Update end of program
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 14
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                            716 ;
   01D9 D1            [10]  717 INEWLN: POP	DE		; Get address of line,
   01DA F1            [10]  718 	POP	AF		; Get status
   01DB CA 00 02      [10]  719 	JP	Z,SETPTR	; No text - Set up pointers
u  01DE 2A 00 00      [16]  720 	LD	HL,(PROGND)	; Get end of program
   01E1 E3            [19]  721 	EX	(SP),HL		; Get length of input line
   01E2 C1            [10]  722 	POP	BC		; End of program to BC
   01E3 09            [11]  723 	ADD	HL,BC		; Find new end
   01E4 E5            [11]  724 	PUSH	HL		; Save new end
   01E5 CD 05 01      [17]  725 	CALL	MOVUP		; Make space for line
   01E8 E1            [10]  726 	POP	HL		; Restore new end
u  01E9 22 00 00      [16]  727 	LD	(PROGND),HL	; Update end of program pointer
   01EC EB            [ 4]  728 	EX	DE,HL		; Get line to move up in HL
   01ED 74            [ 7]  729 	LD	(HL),H		; Save MSB
   01EE D1            [10]  730 	POP	DE		; Get new line number
   01EF 23            [ 6]  731 	INC	HL		; Skip pointer
   01F0 23            [ 6]  732 	INC	HL
   01F1 73            [ 7]  733 	LD	(HL),E		; Save LSB of line number
   01F2 23            [ 6]  734 	INC	HL
   01F3 72            [ 7]  735 	LD	(HL),D		; Save MSB of line number
   01F4 23            [ 6]  736 	INC	HL		; To first byte in line
u  01F5 11 00 00      [10]  737 	LD	DE,BUFFER	; Copy buffer to program
   01F8 1A            [ 7]  738 MOVBUF: LD	A,(DE)		; Get source
   01F9 77            [ 7]  739 	LD	(HL),A		; Save destinations
   01FA 23            [ 6]  740 	INC	HL		; Next source
   01FB 13            [ 6]  741 	INC	DE		; Next destination
   01FC B7            [ 4]  742 	OR	A		; Done?
   01FD C2 F8 01      [10]  743 	JP	NZ,MOVBUF	; No - Repeat
   0200 CD 49 02      [17]  744 SETPTR: CALL	RUNFST		; Set line pointers
   0203 23            [ 6]  745 	INC	HL		; To LSB of pointer
   0204 EB            [ 4]  746 	EX	DE,HL		; Address to DE
   0205 62            [ 4]  747 PTRLP:	LD	H,D		; Address to HL
   0206 6B            [ 4]  748 	LD	L,E
   0207 7E            [ 7]  749 	LD	A,(HL)		; Get LSB of pointer
   0208 23            [ 6]  750 	INC	HL		; To MSB of pointer
   0209 B6            [ 7]  751 	OR	(HL)		; Compare with MSB pointer
   020A CA 89 01      [10]  752 	JP	Z,GETCMD	; Get command line if end
   020D 23            [ 6]  753 	INC	HL		; To LSB of line number
   020E 23            [ 6]  754 	INC	HL		; Skip line number
   020F 23            [ 6]  755 	INC	HL		; Point to first byte in line
   0210 AF            [ 4]  756 	XOR	A		; Looking for 00 byte
   0211 BE            [ 7]  757 FNDEND: CP	(HL)		; Found end of line?
   0212 23            [ 6]  758 	INC	HL		; Move to next byte
   0213 C2 11 02      [10]  759 	JP	NZ,FNDEND	; No - Keep looking
   0216 EB            [ 4]  760 	EX	DE,HL		; Next line address to HL
   0217 73            [ 7]  761 	LD	(HL),E		; Save LSB of pointer
   0218 23            [ 6]  762 	INC	HL
   0219 72            [ 7]  763 	LD	(HL),D		; Save MSB of pointer
   021A C3 05 02      [10]  764 	JP	PTRLP		; Do next line
                            765 ;
u  021D 2A 00 00      [16]  766 SRCHLN: LD	HL,(BASTXT)	; Start of program text
   0220 44            [ 4]  767 SRCHLP: LD	B,H		; BC = Address to look at
   0221 4D            [ 4]  768 	LD	C,L
   0222 7E            [ 7]  769 	LD	A,(HL)		; Get address of next line
   0223 23            [ 6]  770 	INC	HL
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 15
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0224 B6            [ 7]  771 	OR	(HL)		; End of program found?
   0225 2B            [ 6]  772 	DEC	HL
   0226 C8            [11]  773 	RET	Z		; Yes - Line not found
   0227 23            [ 6]  774 	INC	HL
   0228 23            [ 6]  775 	INC	HL
   0229 7E            [ 7]  776 	LD	A,(HL)		; Get LSB of line number
   022A 23            [ 6]  777 	INC	HL
   022B 66            [ 7]  778 	LD	H,(HL)		; Get MSB of line number
   022C 6F            [ 4]  779 	LD	L,A
   022D CD D8 03      [17]  780 	CALL	CPDEHL		; Compare with line in DE
   0230 60            [ 4]  781 	LD	H,B		; HL = Start of this line
   0231 69            [ 4]  782 	LD	L,C
   0232 7E            [ 7]  783 	LD	A,(HL)		; Get LSB of next line address
   0233 23            [ 6]  784 	INC	HL
   0234 66            [ 7]  785 	LD	H,(HL)		; Get MSB of next line address
   0235 6F            [ 4]  786 	LD	L,A		; Next line to HL
   0236 3F            [ 4]  787 	CCF
   0237 C8            [11]  788 	RET	Z		; Lines found - Exit
   0238 3F            [ 4]  789 	CCF
   0239 D0            [11]  790 	RET	NC		; Line not found,at line after
   023A C3 20 02      [10]  791 	JP	SRCHLP		; Keep looking
                            792 ;
   023D C0            [11]  793 NEW:	RET	NZ		; Return if any more on line
u  023E 2A 00 00      [16]  794 CLRPTR: LD	HL,(BASTXT)	; Point to start of program
   0241 AF            [ 4]  795 	XOR	A		; Set program area to empty
   0242 77            [ 7]  796 	LD	(HL),A		; Save LSB = 00
   0243 23            [ 6]  797 	INC	HL
   0244 77            [ 7]  798 	LD	(HL),A		; Save MSB = 00
   0245 23            [ 6]  799 	INC	HL
u  0246 22 00 00      [16]  800 	LD	(PROGND),HL	; Set program end
                            801 ;
u  0249 2A 00 00      [16]  802 RUNFST: LD	HL,(BASTXT)	; Clear all variables
   024C 2B            [ 6]  803 	DEC	HL
                            804 ;
u  024D 22 00 00      [16]  805 INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
u  0250 2A 00 00      [16]  806 	LD	HL,(LSTRAM)	; Get end of RAM
u  0253 22 00 00      [16]  807 	LD	(STRBOT),HL	; Clear string space
   0256 AF            [ 4]  808 	XOR	A
   0257 CD 69 05      [17]  809 	CALL	RESTOR		; Reset DATA pointers
u  025A 2A 00 00      [16]  810 	LD	HL,(PROGND)	; Get end of program
u  025D 22 00 00      [16]  811 	LD	(VAREND),HL	; Clear variables
u  0260 22 00 00      [16]  812 	LD	(ARREND),HL	; Clear arrays
                            813 ;
   0263 C1            [10]  814 CLREG:	POP	BC		; Save return address
u  0264 2A 00 00      [16]  815 	LD	HL,(STRSPC)	; Get end of working RAN
   0267 F9            [ 6]  816 	LD	SP,HL		; Set stack
u  0268 21 00 00      [10]  817 	LD	HL,TMSTPL	; Temporary string pool
u  026B 22 00 00      [16]  818 	LD	(TMSTPT),HL	; Reset temporary string ptr
   026E AF            [ 4]  819 	XOR	A		; A = 00
   026F 6F            [ 4]  820 	LD	L,A		; HL = 0000
   0270 67            [ 4]  821 	LD	H,A
u  0271 22 00 00      [16]  822 	LD	(CONTAD),HL	; No CONTinue
u  0274 32 00 00      [13]  823 	LD	(FORFLG),A	; Clear FOR flag
u  0277 22 00 00      [16]  824 	LD	(FNRGNM),HL	; Clear FN argument
   027A E5            [11]  825 	PUSH	HL		; HL = 0000
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 16
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   027B C5            [11]  826 	PUSH	BC		; Put back return
u  027C 2A 00 00      [16]  827 DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
   027F C9            [10]  828 	RET			; Return to execution driver
                            829 ;
q  0280 3E 3F         [ 7]  830 PROMPT: LD	A,'?'		; '?'
   0282 CD E9 03      [17]  831 	CALL	OUTC		; Output character
q  0285 3E 20         [ 7]  832 	LD	A,' '		; Space
   0287 CD E9 03      [17]  833 	CALL	OUTC		; Output character
u  028A C3 00 00      [10]  834 	JP	RINPUT		; Get input line
                            835 ;
   028D AF            [ 4]  836 CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
u  028E 32 00 00      [13]  837 	LD	(DATFLG),A	; Reset literal flag
   0291 0E 05         [ 7]  838 	LD	C,2+3		; 2 byte number and 3 nulls
u  0293 11 00 00      [10]  839 	LD	DE,BUFFER	; Start of input buffer
   0296 7E            [ 7]  840 CRNCLP: LD	A,(HL)		; Get byte
q  0297                     841 	CP	' '		; Is it a space?
   0297 CA 01 03      [10]  842 	JP	Z,MOVDIR	; Yes - Copy direct
   029A 47            [ 4]  843 	LD	B,A		; Save character
q  029B                     844 	CP	'"'		; Is it a quote?
   029B CA 1B 03      [10]  845 	JP	Z,CPYLIT	; Yes - Copy literal string
   029E B7            [ 4]  846 	OR	A		; Is it end of buffer?
   029F CA 22 03      [10]  847 	JP	Z,ENDBUF	; Yes - End buffer
u  02A2 3A 00 00      [13]  848 	LD	A,(DATFLG)	; Get data type
   02A5 B7            [ 4]  849 	OR	A		; Literal?
   02A6 7E            [ 7]  850 	LD	A,(HL)		; Get byte to copy
   02A7 C2 01 03      [10]  851 	JP	NZ,MOVDIR	; Literal - Copy direct
q  02AA                     852 	CP	'?'		; Is it '?' short for PRINT
u  02AA 3E 00         [ 7]  853 	LD	A,ZPRINT	; "PRINT" token
   02AC CA 01 03      [10]  854 	JP	Z,MOVDIR	; Yes - replace it
   02AF 7E            [ 7]  855 	LD	A,(HL)		; Get byte again
q  02B0                     856 	CP	'0'		; Is it less than '0'
   02B0 DA B8 02      [10]  857 	JP	C,FNDWRD	; Yes - Look for reserved words
   02B3 FE 3C         [ 7]  858 	CP	60		; ";"+1; Is it "0123456789:;" ?
   02B5 DA 01 03      [10]  859 	JP	C,MOVDIR	; Yes - copy it direct
   02B8 D5            [11]  860 FNDWRD: PUSH	DE		; Look for reserved words
   02B9 11 BB 00      [10]  861 	LD	DE,WORDS-1	; Point to table
   02BC C5            [11]  862 	PUSH	BC		; Save count
   02BD 01 FD 02      [10]  863 	LD	BC,RETNAD	; Where to return to
   02C0 C5            [11]  864 	PUSH	BC		; Save return address
u  02C1 06 FF         [ 7]  865 	LD	B,ZEND-1	; First token value -1
   02C3 7E            [ 7]  866 	LD	A,(HL)		; Get byte
q  02C4                     867 	CP	'a'		; Less than 'a' ?
   02C4 DA CB 02      [10]  868 	JP	C,SEARCH	; Yes - search for words
q  02C7                     869 	CP	'z'+1		; Greater than 'z' ?
   02C7 D2 CB 02      [10]  870 	JP	NC,SEARCH	; Yes - search for words
kq 02CA                     871 	AND	01011111B	; Force upper case
   02CA 77            [ 7]  872 	LD	(HL),A		; Replace byte
   02CB 4E            [ 7]  873 SEARCH: LD	C,(HL)		; Search for a word
   02CC EB            [ 4]  874 	EX	DE,HL
   02CD 23            [ 6]  875 GETNXT: INC	HL		; Get next reserved word
   02CE B6            [ 7]  876 	OR	(HL)		; Start of word?
   02CF F2 CD 02      [10]  877 	JP	P,GETNXT	; No - move on
   02D2 04            [ 4]  878 	INC	B		; Increment token value
   02D3 7E            [ 7]  879 	LD	A, (HL)		; Get byte from table
kq 02D4                     880 	AND	01111111B	; Strip bit 7
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 17
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   02D4 C8            [11]  881 	RET	Z		; Return if end of list
   02D5 B9            [ 4]  882 	CP	C		; Same character as in buffer?
   02D6 C2 CD 02      [10]  883 	JP	NZ,GETNXT	; No - get next word
   02D9 EB            [ 4]  884 	EX	DE,HL
   02DA E5            [11]  885 	PUSH	HL		; Save start of word
                            886 ;
   02DB 13            [ 6]  887 NXTBYT: INC	DE		; Look through rest of word
   02DC 1A            [ 7]  888 	LD	A,(DE)		; Get byte from table
   02DD B7            [ 4]  889 	OR	A		; End of word ?
   02DE FA F9 02      [10]  890 	JP	M,MATCH		; Yes - Match found
   02E1 4F            [ 4]  891 	LD	C,A		; Save it
   02E2 78            [ 4]  892 	LD	A,B		; Get token value
u  02E3 FE 00         [ 7]  893 	CP	ZGOTO		; Is it "GOTO" token ?
   02E5 C2 EC 02      [10]  894 	JP	NZ,NOSPC	; No - Don't allow spaces
   02E8 CD 5F 05      [17]  895 	CALL	GETCHR		; Get next character
   02EB 2B            [ 6]  896 	DEC	HL		; Cancel increment from GETCHR
   02EC 23            [ 6]  897 NOSPC:	INC	HL		; Next byte
   02ED 7E            [ 7]  898 	LD	A,(HL)		; Get byte
q  02EE                     899 	CP	'a'		; Less than 'a' ?
   02EE DA F1 02      [10]  900 	JP	C,NOCHNG	; Yes - don't change
kq 02F1                     901 	AND	01011111B	; Make upper case
   02F1 B9            [ 4]  902 NOCHNG: CP	C		; Same as in buffer ?
   02F2 CA DB 02      [10]  903 	JP	Z,NXTBYT	; Yes - keep testing
   02F5 E1            [10]  904 	POP	HL		; Get back start of word
   02F6 C3 CB 02      [10]  905 	JP	SEARCH		; Look at next word
                            906 ;
   02F9 48            [ 4]  907 MATCH:	LD	C,B		; Word found - Save token value
   02FA F1            [10]  908 	POP	AF		; Throw away return
   02FB EB            [ 4]  909 	EX	DE,HL
   02FC C9            [10]  910 	RET			; Return to "RETNAD"
   02FD EB            [ 4]  911 RETNAD: EX	DE,HL		; Get address in string
   02FE 79            [ 4]  912 	LD	A,C		; Get token value
   02FF C1            [10]  913 	POP	BC		; Restore buffer length
   0300 D1            [10]  914 	POP	DE		; Get destination address
   0301 23            [ 6]  915 MOVDIR: INC	HL		; Next source in buffer
   0302 12            [ 7]  916 	LD	(DE),A		; Put byte in buffer
   0303 13            [ 6]  917 	INC	DE		; Move up buffer
   0304 0C            [ 4]  918 	INC	C		; Increment length of buffer
q  0305                     919 	SUB	':'		; End of statement?
   0305 CA 0B 03      [10]  920 	JP	Z,SETLIT	; Jump if multi-statement line
uk 0308                     921 	CP	ZDATA-3AH	; Is it DATA statement ?
   0308 C2 0E 03      [10]  922 	JP	NZ,TSTREM	; No - see if REM
u  030B 32 00 00      [13]  923 SETLIT: LD	(DATFLG),A	; Set literal flag
uk 030E                     924 TSTREM: SUB	ZREM-3AH	; Is it REM?
   030E C2 96 02      [10]  925 	JP	NZ,CRNCLP	; No - Leave flag
   0311 47            [ 4]  926 	LD	B,A		; Copy rest of buffer
   0312 7E            [ 7]  927 NXTCHR: LD	A,(HL)		; Get byte
   0313 B7            [ 4]  928 	OR	A		; End of line ?
   0314 CA 22 03      [10]  929 	JP	Z,ENDBUF	; Yes - Terminate buffer
   0317 B8            [ 4]  930 	CP	B		; End of statement ?
   0318 CA 01 03      [10]  931 	JP	Z,MOVDIR	; Yes - Get next one
   031B 23            [ 6]  932 CPYLIT: INC	HL		; Move up source string
   031C 12            [ 7]  933 	LD	(DE),A		; Save in destination
   031D 0C            [ 4]  934 	INC	C		; Increment length
   031E 13            [ 6]  935 	INC	DE		; Move up destination
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 18
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   031F C3 12 03      [10]  936 	JP	NXTCHR		; Repeat
                            937 ;
u  0322 21 FF FF      [10]  938 ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
   0325 12            [ 7]  939 	LD	(DE),A		; Mark end of buffer (A = 00)
   0326 13            [ 6]  940 	INC	DE
   0327 12            [ 7]  941 	LD	(DE),A		; A = 00
   0328 13            [ 6]  942 	INC	DE
   0329 12            [ 7]  943 	LD	(DE),A		; A = 00
   032A C9            [10]  944 	RET
                            945 ;
u  032B 3A 00 00      [13]  946 DODEL:	LD	A,(NULFLG)	; Get null flag status
   032E B7            [ 4]  947 	OR	A		; Is it zero?
   032F 3E 00         [ 7]  948 	LD	A,0		; Zero A - Leave flags
u  0331 32 00 00      [13]  949 	LD	(NULFLG),A	; Zero null flag
   0334 C2 3E 03      [10]  950 	JP	NZ,ECHDEL	; Set - Echo it
   0337 05            [ 4]  951 	DEC	B		; Decrement length
   0338 CA 5B 03      [10]  952 	JP	Z,GETLIN	; Get line again if empty
   033B CD E9 03      [17]  953 	CALL	OUTC		; Output null character
                            954 	DB	3EH		; Skip "DEC B"
   033E 05            [ 4]  955 ECHDEL: DEC	B		; Count bytes in buffer
   033F 2B            [ 6]  956 	DEC	HL		; Back space buffer
   0340 CA 52 03      [10]  957 	JP	Z,OTKLN		; No buffer - Try again
   0343 7E            [ 7]  958 	LD	A,(HL)		; Get deleted byte
   0344 CD E9 03      [17]  959 	CALL	OUTC		; Echo it
   0347 C3 64 03      [10]  960 	JP	MORINP		; Get more input
                            961 ;
   034A 05            [ 4]  962 DELCHR: DEC	B		; Count bytes in buffer
   034B 2B            [ 6]  963 	DEC	HL		; Back space buffer
   034C CD E9 03      [17]  964 	CALL	OUTC		; Output character in A
   034F C2 64 03      [10]  965 	JP	NZ,MORINP	; Not end - Get more
   0352 CD E9 03      [17]  966 OTKLN:	CALL	OUTC		; Output character in A
   0355 CD E5 07      [17]  967 KILIN:	CALL	PRCRLF		; Output CRLF
   0358 C3 5B 03      [10]  968 	JP	TTYLIN		; Get line again
                            969 ;
   035B                     970 GETLIN:
u  035B 21 00 00      [10]  971 TTYLIN: LD	HL,BUFFER	; Get a line by character
   035E 06 01         [ 7]  972 	LD	B,1		; Set buffer as empty
   0360 AF            [ 4]  973 	XOR	A
u  0361 32 00 00      [13]  974 	LD	(NULFLG),A	; Clear null flag
   0364 CD 11 04      [17]  975 MORINP: CALL	CLOTST		; Get character and test ^O
   0367 4F            [ 4]  976 	LD	C,A		; Save character in C
u  0368 FE 00         [ 7]  977 	CP	DEL		; Delete character?
   036A CA 2B 03      [10]  978 	JP	Z,DODEL	; Yes - Process it
u  036D 3A 00 00      [13]  979 	LD	A,(NULFLG)	; Get null flag
   0370 B7            [ 4]  980 	OR	A		; Test null flag status
   0371 CA 7D 03      [10]  981 	JP	Z,PROCES	; Reset - Process character
   0374 3E 00         [ 7]  982 	LD	A,0		; Set a null
   0376 CD E9 03      [17]  983 	CALL	OUTC		; Output null
   0379 AF            [ 4]  984 	XOR	A		; Clear A
u  037A 32 00 00      [13]  985 	LD	(NULFLG),A	; Reset null flag
   037D 79            [ 4]  986 PROCES: LD	A,C		; Get character
u  037E FE 00         [ 7]  987 	CP	CTRLG		; Bell?
   0380 CA BB 03      [10]  988 	JP	Z,PUTCTL	; Yes - Save it
u  0383 FE 00         [ 7]  989 	CP	CTRLC		; Is it control "C"?
   0385 CC E5 07      [17]  990 	CALL	Z,PRCRLF	; Yes - Output CRLF
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 19
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0388 37            [ 4]  991 	SCF			; Flag break
   0389 C8            [11]  992 	RET	Z		; Return if control "C"
u  038A FE 00         [ 7]  993 	CP	CR		; Is it enter?
   038C CA E0 07      [10]  994 	JP	Z,ENDINP	; Yes - Terminate input
u  038F FE 00         [ 7]  995 	CP	CTRLU		; Is it control "U"?
   0391 CA 55 03      [10]  996 	JP	Z,KILIN		; Yes - Get another line
q  0394                     997 	CP	'@'		; Is it "kill line"?
   0394 CA 52 03      [10]  998 	JP	Z,OTKLN		; Yes - Kill line
q  0397                     999 	CP	'_'		; Is it delete?
   0397 CA 4A 03      [10] 1000 	JP	Z,DELCHR	; Yes - Delete character
u  039A FE 00         [ 7] 1001 	CP	BKSP		; Is it backspace?
   039C CA 4A 03      [10] 1002 	JP	Z,DELCHR	; Yes - Delete character
u  039F FE 00         [ 7] 1003 	CP	CTRLR		; Is it control "R"?
   03A1 C2 B8 03      [10] 1004 	JP	NZ,PUTBUF	; No - Put in buffer
   03A4 C5            [11] 1005 	PUSH	BC		; Save buffer length
   03A5 D5            [11] 1006 	PUSH	DE		; Save DE
   03A6 E5            [11] 1007 	PUSH	HL		; Save buffer address
   03A7 36 00         [10] 1008 	LD	(HL),0		; Mark end of buffer
   03A9 CD 35 18      [17] 1009 	CALL	OUTNCR		; Output and do CRLF
u  03AC 21 00 00      [10] 1010 	LD	HL,BUFFER	; Point to buffer start
   03AF CD 27 0E      [17] 1011 	CALL	PRS		; Output buffer
   03B2 E1            [10] 1012 	POP	HL		; Restore buffer address
   03B3 D1            [10] 1013 	POP	DE		; Restore DE
   03B4 C1            [10] 1014 	POP	BC		; Restore buffer length
   03B5 C3 64 03      [10] 1015 	JP	MORINP		; Get another character
                           1016 ;
q  03B8                    1017 PUTBUF: CP	' '		; Is it a control code?
   03B8 DA 64 03      [10] 1018 	JP	C,MORINP	; Yes - Ignore
   03BB 78            [ 4] 1019 PUTCTL: LD	A,B		; Get number of bytes in buffer
   03BC FE 49         [ 7] 1020 	CP	72+1		; Test for line overflow
u  03BE 3E 00         [ 7] 1021 	LD	A,CTRLG		; Set a bell
   03C0 D2 D0 03      [10] 1022 	JP	NC,OUTNBS	; Ring bell if buffer full
   03C3 79            [ 4] 1023 	LD	A,C		; Get character
   03C4 71            [ 7] 1024 	LD	(HL),C		; Save in buffer
u  03C5 32 00 00      [13] 1025 	LD	(LSTBIN),A	; Save last input byte
   03C8 23            [ 6] 1026 	INC	HL		; Move up buffer
   03C9 04            [ 4] 1027 	INC	B		; Increment length
   03CA CD E9 03      [17] 1028 OUTIT:	CALL	OUTC		; Output the character entered
   03CD C3 64 03      [10] 1029 	JP	MORINP		; Get another character
                           1030 ;
   03D0 CD E9 03      [17] 1031 OUTNBS: CALL	OUTC		; Output bell and back over it
u  03D3 3E 00         [ 7] 1032 	LD	A,BKSP		; Set back space
   03D5 C3 CA 03      [10] 1033 	JP	OUTIT		; Output it and get more
                           1034 ;
   03D8 7C            [ 4] 1035 CPDEHL: LD	A,H		; Get H
   03D9 92            [ 4] 1036 	SUB	D		; Compare with D
   03DA C0            [11] 1037 	RET	NZ		; Different - Exit
   03DB 7D            [ 4] 1038 	LD	A,L		; Get L
   03DC 93            [ 4] 1039 	SUB	E		; Compare with E
   03DD C9            [10] 1040 	RET			; Return status
                           1041 ;
   03DE 7E            [ 7] 1042 CHKSYN: LD	A,(HL)		; Check syntax of character
   03DF E3            [19] 1043 	EX	(SP),HL		; Address of test byte
   03E0 BE            [ 7] 1044 	CP	(HL)		; Same as in code string?
   03E1 23            [ 6] 1045 	INC	HL		; Return address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 20
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   03E2 E3            [19] 1046 	EX	(SP),HL		; Put it back
   03E3 CA 5F 05      [10] 1047 	JP	Z,GETCHR	; Yes - Get next character
   03E6 C3 38 01      [10] 1048 	JP	SNERR		; Different - ?SN Error
                           1049 ;
   03E9 F5            [11] 1050 OUTC:	PUSH	AF		; Save character
u  03EA 3A 00 00      [13] 1051 	LD	A,(CTLOFG)	; Get control "O" flag
   03ED B7            [ 4] 1052 	OR	A		; Is it set?
   03EE C2 5B 0E      [10] 1053 	JP	NZ,POPAF	; Yes - don't output
   03F1 F1            [10] 1054 	POP	AF		; Restore character
   03F2 C5            [11] 1055 	PUSH	BC		; Save buffer length
   03F3 F5            [11] 1056 	PUSH	AF		; Save character
q  03F4                    1057 	CP	' '		; Is it a control code?
   03F4 DA 0B 04      [10] 1058 	JP	C,DINPOS	; Yes - Don't INC POS(X)
u  03F7 3A 00 00      [13] 1059 	LD	A,(LWIDTH)	; Get line width
   03FA 47            [ 4] 1060 	LD	B,A		; To B
u  03FB 3A 00 00      [13] 1061 	LD	A,(CURPOS)	; Get cursor position
   03FE 04            [ 4] 1062 	INC	B		; Width 255?
   03FF CA 07 04      [10] 1063 	JP	Z,INCLEN	; Yes - No width limit
   0402 05            [ 4] 1064 	DEC	B		; Restore width
   0403 B8            [ 4] 1065 	CP	B		; At end of line?
   0404 CC E5 07      [17] 1066 	CALL	Z,PRCRLF	; Yes - output CRLF
   0407 3C            [ 4] 1067 INCLEN: INC	A		; Move on one character
u  0408 32 00 00      [13] 1068 	LD	(CURPOS),A	; Save new position
   040B F1            [10] 1069 DINPOS: POP	AF		; Restore character
   040C C1            [10] 1070 	POP	BC		; Restore buffer length
   040D CD 20 18      [17] 1071 	CALL	MONOUT		; Send it
   0410 C9            [10] 1072 	RET
                           1073 ;
   0411 CD 17 17      [17] 1074 CLOTST: CALL	GETINP		; Get input character
kq 0414                    1075 	AND	01111111B	; Strip bit 7
u  0414 FE 00         [ 7] 1076 	CP	CTRLO		; Is it control "O"?
   0416 C0            [11] 1077 	RET	NZ		; No don't flip flag
u  0417 3A 00 00      [13] 1078 	LD	A,(CTLOFG)	; Get flag
   041A 2F            [ 4] 1079 	CPL			; Flip it
u  041B 32 00 00      [13] 1080 	LD	(CTLOFG),A	; Put it back
   041E AF            [ 4] 1081 	XOR	A		; Null character
   041F C9            [10] 1082 	RET
                           1083 ;
   0420 CD 19 06      [17] 1084 LIST:	CALL	ATOH		; ASCII number to DE
   0423 C0            [11] 1085 	RET	NZ		; Return if anything extra
   0424 C1            [10] 1086 	POP	BC		; Rubbish - Not needed
   0425 CD 1D 02      [17] 1087 	CALL	SRCHLN		; Search for line number in DE
   0428 C5            [11] 1088 	PUSH	BC		; Save address of line
   0429 CD 74 04      [17] 1089 	CALL	SETLIN		; Set up lines counter
   042C E1            [10] 1090 LISTLP: POP	HL		; Restore address of line
   042D 4E            [ 7] 1091 	LD	C,(HL)		; Get LSB of next line
   042E 23            [ 6] 1092 	INC	HL
   042F 46            [ 7] 1093 	LD	B,(HL)		; Get MSB of next line
   0430 23            [ 6] 1094 	INC	HL
   0431 78            [ 4] 1095 	LD	A,B		; BC = 0 (End of program)?
   0432 B1            [ 4] 1096 	OR	C
   0433 CA 7C 01      [10] 1097 	JP	Z,PRNTOK	; Yes - Go to command mode
   0436 CD 7D 04      [17] 1098 	CALL	COUNT		; Count lines
   0439 CD 84 05      [17] 1099 	CALL	TSTBRK		; Test for break key
   043C C5            [11] 1100 	PUSH	BC		; Save address of next line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 21
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   043D CD E5 07      [17] 1101 	CALL	PRCRLF		; Output CRLF
   0440 5E            [ 7] 1102 	LD	E,(HL)		; Get LSB of line number
   0441 23            [ 6] 1103 	INC	HL
   0442 56            [ 7] 1104 	LD	D,(HL)		; Get MSB of line number
   0443 23            [ 6] 1105 	INC	HL
   0444 E5            [11] 1106 	PUSH	HL		; Save address of line start
   0445 EB            [ 4] 1107 	EX	DE,HL		; Line number to HL
   0446 CD 91 14      [17] 1108 	CALL	PRNTHL		; Output line number in decimal
q  0449 3E 20         [ 7] 1109 	LD	A,' '		; Space after line number
   044B E1            [10] 1110 	POP	HL		; Restore start of line address
   044C CD E9 03      [17] 1111 LSTLP2: CALL	OUTC		; Output character in A
   044F 7E            [ 7] 1112 LSTLP3: LD	A,(HL)		; Get next byte in line
   0450 B7            [ 4] 1113 	OR	A		; End of line?
   0451 23            [ 6] 1114 	INC	HL		; To next byte in line
   0452 CA 2C 04      [10] 1115 	JP	Z,LISTLP	; Yes - get next line
   0455 F2 4C 04      [10] 1116 	JP	P,LSTLP2	; No token - output it
u  0458 D6 FF         [ 7] 1117 	SUB	ZEND-1		; Find and output word
   045A 4F            [ 4] 1118 	LD	C,A		; Token offset+1 to C
   045B 11 BC 00      [10] 1119 	LD	DE,WORDS	; Reserved word list
   045E 1A            [ 7] 1120 FNDTOK: LD	A,(DE)		; Get character in list
   045F 13            [ 6] 1121 	INC	DE		; Move on to next
   0460 B7            [ 4] 1122 	OR	A		; Is it start of word?
   0461 F2 5E 04      [10] 1123 	JP	P,FNDTOK	; No - Keep looking for word
   0464 0D            [ 4] 1124 	DEC	C		; Count words
   0465 C2 5E 04      [10] 1125 	JP	NZ,FNDTOK	; Not there - keep looking
kq 0468                    1126 OUTWRD: AND	01111111B	; Strip bit 7
   0468 CD E9 03      [17] 1127 	CALL	OUTC		; Output first character
   046B 1A            [ 7] 1128 	LD	A,(DE)		; Get next character
   046C 13            [ 6] 1129 	INC	DE		; Move on to next
   046D B7            [ 4] 1130 	OR	A		; Is it end of word?
   046E F2 68 04      [10] 1131 	JP	P,OUTWRD	; No - output the rest
   0471 C3 4F 04      [10] 1132 	JP	LSTLP3		; Next byte in line
                           1133 ;
   0474 E5            [11] 1134 SETLIN: PUSH	HL		; Set up LINES counter
u  0475 2A 00 00      [16] 1135 	LD	HL,(LINESN)	; Get LINES number
u  0478 22 00 00      [16] 1136 	LD	(LINESC),HL	; Save in LINES counter
   047B E1            [10] 1137 	POP	HL
   047C C9            [10] 1138 	RET
                           1139 ;
   047D E5            [11] 1140 COUNT:	PUSH	HL		; Save code string address
   047E D5            [11] 1141 	PUSH	DE
u  047F 2A 00 00      [16] 1142 	LD	HL,(LINESC)	; Get LINES counter
   0482 11 FF FF      [10] 1143 	LD	DE,-1
   0485 ED 5A         [15] 1144 	ADC	HL,DE		; Decrement
u  0487 22 00 00      [16] 1145 	LD	(LINESC),HL	; Put it back
   048A D1            [10] 1146 	POP	DE
   048B E1            [10] 1147 	POP	HL		; Restore code string address
   048C F0            [11] 1148 	RET	P		; Return if more lines to go
   048D E5            [11] 1149 	PUSH	HL		; Save code string address
u  048E 2A 00 00      [16] 1150 	LD	HL,(LINESN)	; Get LINES number
u  0491 22 00 00      [16] 1151 	LD	(LINESC),HL	; Reset LINES counter
   0494 CD 17 17      [17] 1152 	CALL	GETINP		; Get input character
u  0497 FE 00         [ 7] 1153 	CP	CTRLC		; Is it control "C"?
   0499 CA A0 04      [10] 1154 	JP	Z,RSLNBK	; Yes - Reset LINES and break
   049C E1            [10] 1155 	POP	HL		; Restore code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 22
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   049D C3 7D 04      [10] 1156 	JP	COUNT		; Keep on counting
                           1157 ;
u  04A0 2A 00 00      [16] 1158 RSLNBK: LD	HL,(LINESN)	; Get LINES number
u  04A3 22 00 00      [16] 1159 	LD	(LINESC),HL	; Reset LINES counter
   04A6 C3 AD 00      [10] 1160 	JP	BRKRET		; Go and output "Break"
                           1161 ;
q  04A9 3E 40         [ 7] 1162 FOR:	LD	A,64H		; Flag "FOR" assignment
u  04AB 32 00 00      [13] 1163 	LD	(FORFLG),A	; Save "FOR" flag
   04AE CD F3 06      [17] 1164 	CALL	LET		; Set up initial index
   04B1 C1            [10] 1165 	POP	BC		; Drop RETurn address
   04B2 E5            [11] 1166 	PUSH	HL		; Save code string address
   04B3 CD E0 06      [17] 1167 	CALL	DATA		; Get next statement address
u  04B6 22 00 00      [16] 1168 	LD	(LOOPST),HL	; Save it for start of loop
   04B9 21 02 00      [10] 1169 	LD	HL,2		; Offset for "FOR" block
   04BC 39            [11] 1170 	ADD	HL,SP		; Point to it
   04BD CD E6 00      [17] 1171 FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
   04C0 D1            [10] 1172 	POP	DE		; Get code string address
   04C1 C2 D9 04      [10] 1173 	JP	NZ,FORFND	; No nesting found
   04C4 09            [11] 1174 	ADD	HL,BC		; Move into "FOR" block
   04C5 D5            [11] 1175 	PUSH	DE		; Save code string address
   04C6 2B            [ 6] 1176 	DEC	HL
   04C7 56            [ 7] 1177 	LD	D,(HL)		; Get MSB of loop statement
   04C8 2B            [ 6] 1178 	DEC	HL
   04C9 5E            [ 7] 1179 	LD	E,(HL)		; Get LSB of loop statement
   04CA 23            [ 6] 1180 	INC	HL
   04CB 23            [ 6] 1181 	INC	HL
   04CC E5            [11] 1182 	PUSH	HL		; Save block address
u  04CD 2A 00 00      [16] 1183 	LD	HL,(LOOPST)	; Get address of loop statement
   04D0 CD D8 03      [17] 1184 	CALL	CPDEHL		; Compare the FOR loops
   04D3 E1            [10] 1185 	POP	HL		; Restore block address
   04D4 C2 BD 04      [10] 1186 	JP	NZ,FORSLP	; Different FORs - Find another
   04D7 D1            [10] 1187 	POP	DE		; Restore code string address
   04D8 F9            [ 6] 1188 	LD	SP,HL		; Remove all nested loops
                           1189 ;
   04D9 EB            [ 4] 1190 FORFND: EX	DE,HL		; Code string address to HL
   04DA 0E 08         [ 7] 1191 	LD	C,8
   04DC CD 16 01      [17] 1192 	CALL	CHKSTK		; Check for 8 levels of stack
   04DF E5            [11] 1193 	PUSH	HL		; Save code string address
u  04E0 2A 00 00      [16] 1194 	LD	HL,(LOOPST)	; Get first statement of loop
   04E3 E3            [19] 1195 	EX	(SP),HL		; Save and restore code string
   04E4 E5            [11] 1196 	PUSH	HL		; Re-save code string address
u  04E5 2A 00 00      [16] 1197 	LD	HL,(LINEAT)	; Get current line number
   04E8 E3            [19] 1198 	EX	(SP),HL		; Save and restore code string
   04E9 CD 7A 09      [17] 1199 	CALL	TSTNUM		; Make sure it's a number
   04EC CD DE 03      [17] 1200 	CALL	CHKSYN		; Make sure "TO" is next
o  04EF                    1201 	DB	ZTO		; "TO" token
   04EF CD 77 09      [17] 1202 	CALL	GETNUM		; Get "TO" expression value
   04F2 E5            [11] 1203 	PUSH	HL		; Save code string address
   04F3 CD 51 13      [17] 1204 	CALL	BCDEFP		; Move "TO" value to BCDE
   04F6 E1            [10] 1205 	POP	HL		; Restore code string address
   04F7 C5            [11] 1206 	PUSH	BC		; Save "TO" value in block
   04F8 D5            [11] 1207 	PUSH	DE
q  04F9 01 A4 1F      [10] 1208 	LD	BC,8100H	; BCDE - 1 (default STEP)
   04FC 51            [ 4] 1209 	LD	D,C		; C=0
   04FD 5A            [ 4] 1210 	LD	E,D		; D=0
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 23
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   04FE 7E            [ 7] 1211 	LD	A,(HL)		; Get next byte in code string
u  04FF FE 00         [ 7] 1212 	CP	ZSTEP		; See if "STEP" is stated
   0501 3E 01         [ 7] 1213 	LD	A,1		; Sign of step = 1
   0503 C2 14 05      [10] 1214 	JP	NZ,SAVSTP	; No STEP given - Default to 1
   0506 CD 5F 05      [17] 1215 	CALL	GETCHR		; Jump over "STEP" token
   0509 CD 77 09      [17] 1216 	CALL	GETNUM		; Get step value
   050C E5            [11] 1217 	PUSH	HL		; Save code string address
   050D CD 51 13      [17] 1218 	CALL	BCDEFP		; Move STEP to BCDE
   0510 CD 08 13      [17] 1219 	CALL	TSTSGN		; Test sign of FPREG
   0513 E1            [10] 1220 	POP	HL		; Restore code string address
   0514 C5            [11] 1221 SAVSTP: PUSH	BC		; Save the STEP value in block
   0515 D5            [11] 1222 	PUSH	DE
   0516 F5            [11] 1223 	PUSH	AF		; Save sign of STEP
   0517 33            [ 6] 1224 	INC	SP		; Don't save flags
   0518 E5            [11] 1225 	PUSH	HL		; Save code string address
u  0519 2A 00 00      [16] 1226 	LD	HL,(BRKLIN)	; Get address of index variable
   051C E3            [19] 1227 	EX	(SP),HL		; Save and restore code string
u  051D 06 00         [ 7] 1228 PUTFID: LD	B,ZFOR		; "FOR" block marker
   051F C5            [11] 1229 	PUSH	BC		; Save it
   0520 33            [ 6] 1230 	INC	SP		; Don't save C
                           1231 ;
   0521 CD 84 05      [17] 1232 RUNCNT: CALL	TSTBRK		; Execution driver - Test break
u  0524 22 00 00      [16] 1233 	LD	(BRKLIN),HL	; Save code address for break
   0527 7E            [ 7] 1234 	LD	A,(HL)		; Get next byte in code string
q  0528                    1235 	CP	':'		; Multi statement line?
   0528 CA 3F 05      [10] 1236 	JP	Z,EXCUTE	; Yes - Execute it
   052B B7            [ 4] 1237 	OR	A		; End of line?
   052C C2 38 01      [10] 1238 	JP	NZ,SNERR	; No - Syntax error
   052F 23            [ 6] 1239 	INC	HL		; Point to address of next line
   0530 7E            [ 7] 1240 	LD	A,(HL)		; Get LSB of line pointer
   0531 23            [ 6] 1241 	INC	HL
   0532 B6            [ 7] 1242 	OR	(HL)		; Is it zero (End of prog)?
   0533 CA A5 05      [10] 1243 	JP	Z,ENDPRG	; Yes - Terminate execution
   0536 23            [ 6] 1244 	INC	HL		; Point to line number
   0537 5E            [ 7] 1245 	LD	E,(HL)		; Get LSB of line number
   0538 23            [ 6] 1246 	INC	HL
   0539 56            [ 7] 1247 	LD	D,(HL)		; Get MSB of line number
   053A EB            [ 4] 1248 	EX	DE,HL		; Line number to HL
u  053B 22 00 00      [16] 1249 	LD	(LINEAT),HL	; Save as current line number
   053E EB            [ 4] 1250 	EX	DE,HL		; Line number back to DE
   053F CD 5F 05      [17] 1251 EXCUTE: CALL	GETCHR		; Get key word
   0542 11 21 05      [10] 1252 	LD	DE,RUNCNT	; Where to RETurn to
   0545 D5            [11] 1253 	PUSH	DE		; Save for RETurn
   0546 C8            [11] 1254 IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
u  0547 D6 00         [ 7] 1255 ONJMP:	SUB	ZEND		; Is it a token?
   0549 DA F3 06      [10] 1256 	JP	C,LET		; No - try to assign it
u  054C FE 01         [ 7] 1257 	CP	ZNEW+1-ZEND	; END to NEW ?
   054E D2 38 01      [10] 1258 	JP	NC,SNERR	; Not a key word - ?SN Error
   0551 07            [ 4] 1259 	RLCA			; Double it
   0552 4F            [ 4] 1260 	LD	C,A		; BC = Offset into table
   0553 06 00         [ 7] 1261 	LD	B,0
   0555 EB            [ 4] 1262 	EX	DE,HL		; Save code string address
   0556 21 BC 00      [10] 1263 	LD	HL,WORDTB	; Keyword address table
   0559 09            [11] 1264 	ADD	HL,BC		; Point to routine address
   055A 4E            [ 7] 1265 	LD	C,(HL)		; Get LSB of routine address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 24
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   055B 23            [ 6] 1266 	INC	HL
   055C 46            [ 7] 1267 	LD	B,(HL)		; Get MSB of routine address
   055D C5            [11] 1268 	PUSH	BC		; Save routine address
   055E EB            [ 4] 1269 	EX	DE,HL		; Restore code string address
                           1270 ;
   055F 23            [ 6] 1271 GETCHR: INC	HL		; Point to next character
   0560 7E            [ 7] 1272 	LD	A,(HL)		; Get next code string byte
q  0561                    1273 	CP	':'		; Z if ':'
   0561 D0            [11] 1274 	RET	NC		; NC if > "9"
q  0562                    1275 	CP	' '
   0562 CA 5F 05      [10] 1276 	JP	Z,GETCHR	; Skip over spaces
q  0565                    1277 	CP	'0'
   0565 3F            [ 4] 1278 	CCF			; NC if < '0'
   0566 3C            [ 4] 1279 	INC	A		; Test for zero - Leave carry
   0567 3D            [ 4] 1280 	DEC	A		; Z if Null
   0568 C9            [10] 1281 	RET
                           1282 ;
   0569 EB            [ 4] 1283 RESTOR: EX	DE,HL		; Save code string address
u  056A 2A 00 00      [16] 1284 	LD	HL,(BASTXT)	; Point to start of program
   056D CA 7E 05      [10] 1285 	JP	Z,RESTNL	; Just RESTORE - reset pointer
   0570 EB            [ 4] 1286 	EX	DE,HL		; Restore code string address
   0571 CD 19 06      [17] 1287 	CALL	ATOH		; Get line number to DE
   0574 E5            [11] 1288 	PUSH	HL		; Save code string address
   0575 CD 1D 02      [17] 1289 	CALL	SRCHLN		; Search for line number in DE
   0578 60            [ 4] 1290 	LD	H,B		; HL = Address of line
   0579 69            [ 4] 1291 	LD	L,C
   057A D1            [10] 1292 	POP	DE		; Restore code string address
   057B D2 B7 06      [10] 1293 	JP	NC,ULERR	; ?UL Error if not found
   057E 2B            [ 6] 1294 RESTNL: DEC	HL		; Byte before DATA statement
u  057F 22 00 00      [16] 1295 UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
   0582 EB            [ 4] 1296 	EX	DE,HL		; Restore code string address
   0583 C9            [10] 1297 	RET
                           1298 ;
                           1299 
aq 0584 C7            [11] 1300 TSTBRK: RST	18H		; Check input status
   0585 C8            [11] 1301 	RET	Z		; No key, go back
aq 0586 C7            [11] 1302 	RST	10H		; Get the key into A
u  0587 FE 00         [ 7] 1303 	CP	ESC		; Escape key?
u  0589 28 00         [12] 1304 	JR	Z,BRK		; Yes, break
u  058B FE 00         [ 7] 1305 	CP	CTRLC		; <Ctrl-C>
u  058D 28 00         [12] 1306 	JR	Z,BRK		; Yes, break
u  058F FE 00         [ 7] 1307 	CP	CTRLS		; Stop scrolling?
   0591 C0            [11] 1308 	RET	NZ		; Other key, ignore
                           1309 ;
                           1310 
aq 0592 C7            [11] 1311 STALL:	RST	10H		; Wait for key
u  0593 FE 00         [ 7] 1312 	CP	CTRLQ		; Resume scrolling?
   0595 C8            [11] 1313 	RET	Z		; Release the chokehold
u  0596 FE 00         [ 7] 1314 	CP	CTRLC		; Second break?
   0598 28 05         [12] 1315 	JR	Z,STOP		; Break during hold exits prog
   059A 18 F6         [12] 1316 	JR	STALL		; Loop until <Ctrl-Q> or <brk>
                           1317 ;
o  059C                    1318 BRK	LD	A,0FFH		; Set BRKFLG
u  059C 32 00 00      [13] 1319 	LD	(BRKFLG),A	; Store it
                           1320 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 25
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                           1321 
   059F C0            [11] 1322 STOP:	RET	NZ		; Exit if anything else
                           1323 	DB	0F6H		; Flag "STOP"
   05A0 C0            [11] 1324 PEND:	RET	NZ		; Exit if anything else
u  05A1 22 00 00      [16] 1325 	LD	(BRKLIN),HL	; Save point of break
                           1326 	DB	21H		; Skip "OR 11111111B"
kq 05A4                    1327 INPBRK: OR	11111111B	; Flag "Break" wanted
   05A4 C1            [10] 1328 	POP	BC		; Return not needed and more
u  05A5 2A 00 00      [16] 1329 ENDPRG: LD	HL,(LINEAT)	; Get current line number
   05A8 F5            [11] 1330 	PUSH	AF		; Save STOP / END status
   05A9 7D            [ 4] 1331 	LD	A,L		; Is it direct break?
   05AA A4            [ 4] 1332 	AND	H
   05AB 3C            [ 4] 1333 	INC	A		; Line is -1 if direct break
   05AC CA B8 05      [10] 1334 	JP	Z,NOLIN		; Yes - No line number
u  05AF 22 00 00      [16] 1335 	LD	(ERRLIN),HL	; Save line of break
u  05B2 2A 00 00      [16] 1336 	LD	HL,(BRKLIN)	; Get point of break
u  05B5 22 00 00      [16] 1337 	LD	(CONTAD),HL	; Save point to CONTinue
   05B8 AF            [ 4] 1338 NOLIN:	XOR	A
u  05B9 32 00 00      [13] 1339 	LD	(CTLOFG),A	; Enable output
   05BC CD D8 07      [17] 1340 	CALL	STTLIN		; Start a new line
   05BF F1            [10] 1341 	POP	AF		; Restore STOP / END status
   05C0 21 E2 00      [10] 1342 	LD	HL,BRKMSG	; "Break" message
   05C3 C2 66 01      [10] 1343 	JP	NZ,ERRIN	; "in line" wanted?
   05C6 C3 7C 01      [10] 1344 	JP	PRNTOK		; Go to command mode
                           1345 ;
u  05C9 2A 00 00      [16] 1346 CONT:	LD	HL,(CONTAD)	; Get CONTinue address
   05CC 7C            [ 4] 1347 	LD	A,H		; Is it zero?
   05CD B5            [ 4] 1348 	OR	L
u  05CE 1E 00         [ 7] 1349 	LD	E,CN		; ?CN Error
   05D0 CA 46 01      [10] 1350 	JP	Z,ERROR		; Yes - output "?CN Error"
   05D3 EB            [ 4] 1351 	EX	DE,HL		; Save code string address
u  05D4 2A 00 00      [16] 1352 	LD	HL,(ERRLIN)	; Get line of last break
u  05D7 22 00 00      [16] 1353 	LD	(LINEAT),HL	; Set up current line number
   05DA EB            [ 4] 1354 	EX	DE,HL		; Restore code string address
   05DB C9            [10] 1355 	RET			; CONTinue where left off
                           1356 ;
   05DC CD A0 10      [17] 1357 NULL:	CALL	GETINT		; Get integer 0-255
   05DF C0            [11] 1358 	RET	NZ		; Return if bad value
u  05E0 32 00 00      [13] 1359 	LD	(NULLS),A	; Set nulls number
   05E3 C9            [10] 1360 	RET
                           1361 ;
                           1362 
   05E4 E5            [11] 1363 ACCSUM: PUSH	HL		; Save address in array
u  05E5 2A 00 00      [16] 1364 	LD	HL,(CHKSUM)	; Get check sum
   05E8 06 00         [ 7] 1365 	LD	B,0		; BC - Value of byte
   05EA 4F            [ 4] 1366 	LD	C,A
   05EB 09            [11] 1367 	ADD	HL,BC		; Add byte to check sum
u  05EC 22 00 00      [16] 1368 	LD	(CHKSUM),HL	; Re-save check sum
   05EF E1            [10] 1369 	POP	HL		; Restore address in array
   05F0 C9            [10] 1370 	RET
                           1371 ;
   05F1 7E            [ 7] 1372 CHKLTR: LD	A,(HL)		; Get byte
q  05F2                    1373 	CP	'A'		; < 'a' ?
   05F2 D8            [11] 1374 	RET	C		; Carry set if not letter
q  05F3                    1375 	CP	'Z'+1		; > 'z' ?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 26
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   05F3 3F            [ 4] 1376 	CCF
   05F4 C9            [10] 1377 	RET			; Carry set if not letter
                           1378 ;
   05F5 CD 5F 05      [17] 1379 FPSINT: CALL	GETCHR		; Get next character
   05F8 CD 77 09      [17] 1380 POSINT: CALL	GETNUM		; Get integer 0 to 32767
   05FB CD 08 13      [17] 1381 DEPINT: CALL	TSTSGN		; Test sign of FPREG
   05FE FA 14 06      [10] 1382 	JP	M,FCERR		; Negative - ?FC Error
u  0601 3A 00 00      [13] 1383 DEINT:	LD	A,(FPEXP)	; Get integer value to DE
q  0604                    1384 	CP	80H+16		; Exponent in range (16 bits)?
   0604 DA AD 13      [10] 1385 	JP	C,FPINT		; Yes - convert it
q  0607 01 78 23      [10] 1386 	LD	BC,9080H	; BCDE = -32768
   060A 11 00 00      [10] 1387 	LD	DE,0000
   060D E5            [11] 1388 	PUSH	HL		; Save code string address
   060E CD 80 13      [17] 1389 	CALL	CMPNUM		; Compare FPREG with BCDE
   0611 E1            [10] 1390 	POP	HL		; Restore code string address
   0612 51            [ 4] 1391 	LD	D,C		; MSB to D
   0613 C8            [11] 1392 	RET	Z		; Return if in range
u  0614 1E 00         [ 7] 1393 FCERR:	LD	E,FC		; ?FC Error
   0616 C3 46 01      [10] 1394 	JP	ERROR		; Output error-
                           1395 ;
   0619 2B            [ 6] 1396 ATOH:	DEC	HL		; ASCII number to DE binary
   061A 11 00 00      [10] 1397 GETLN:	LD	DE,0		; Get number to DE
   061D CD 5F 05      [17] 1398 GTLNLP: CALL	GETCHR		; Get next character
   0620 D0            [11] 1399 	RET	NC		; Exit if not a digit
   0621 E5            [11] 1400 	PUSH	HL		; Save code string address
   0622 F5            [11] 1401 	PUSH	AF		; Save digit
   0623 21 98 19      [10] 1402 	LD	HL,65529/10	; Largest number 65529
   0626 CD D8 03      [17] 1403 	CALL	CPDEHL		; Number in range?
   0629 DA 38 01      [10] 1404 	JP	C,SNERR		; No - ?SN Error
   062C 62            [ 4] 1405 	LD	H,D		; HL = Number
   062D 6B            [ 4] 1406 	LD	L,E
   062E 19            [11] 1407 	ADD	HL,DE		; Times 2
   062F 29            [11] 1408 	ADD	HL,HL		; Times 4
   0630 19            [11] 1409 	ADD	HL,DE		; Times 5
   0631 29            [11] 1410 	ADD	HL,HL		; Times 10
   0632 F1            [10] 1411 	POP	AF		; Restore digit
q  0633                    1412 	SUB	'0'		; Make it 0 to 9
   0633 5F            [ 4] 1413 	LD	E,A		; DE = Value of digit
   0634 16 00         [ 7] 1414 	LD	D,0
   0636 19            [11] 1415 	ADD	HL,DE		; Add to number
   0637 EB            [ 4] 1416 	EX	DE,HL		; Number to DE
   0638 E1            [10] 1417 	POP	HL		; Restore code string address
   0639 C3 1D 06      [10] 1418 	JP	GTLNLP		; Go to next character
                           1419 ;
   063C CA 4D 02      [10] 1420 CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
   063F CD F8 05      [17] 1421 	CALL	POSINT		; Get integer 0 to 32767 to DE
   0642 2B            [ 6] 1422 	DEC	HL		; Cancel increment
   0643 CD 5F 05      [17] 1423 	CALL	GETCHR		; Get next character
   0646 E5            [11] 1424 	PUSH	HL		; Save code string address
u  0647 2A 00 00      [16] 1425 	LD	HL,(LSTRAM)	; Get end of RAM
   064A CA 5E 06      [10] 1426 	JP	Z,STORED	; No value given - Use stored
   064D E1            [10] 1427 	POP	HL		; Restore code string address
   064E CD DE 03      [17] 1428 	CALL	CHKSYN		; Check for comma
                           1429 	DB	','
   0651 D5            [11] 1430 	PUSH	DE		; Save number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 27
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0652 CD F8 05      [17] 1431 	CALL	POSINT		; Get integer 0 to 32767
   0655 2B            [ 6] 1432 	DEC	HL		; Cancel increment
   0656 CD 5F 05      [17] 1433 	CALL	GETCHR		; Get next character
   0659 C2 38 01      [10] 1434 	JP	NZ,SNERR	; ?SN Error if more on line
   065C E3            [19] 1435 	EX	(SP),HL		; Save code string address
   065D EB            [ 4] 1436 	EX	DE,HL		; Number to DE
   065E 7D            [ 4] 1437 STORED: LD	A,L		; Get LSB of new RAM top
   065F 93            [ 4] 1438 	SUB	E		; Subtract LSB of string space
   0660 5F            [ 4] 1439 	LD	E,A		; Save LSB
   0661 7C            [ 4] 1440 	LD	A,H		; Get MSB of new RAM top
   0662 9A            [ 4] 1441 	SBC	A,D		; Subtract MSB of string space
   0663 57            [ 4] 1442 	LD	D,A		; Save MSB
   0664 DA 2D 01      [10] 1443 	JP	C,OMERR		; ?OM Error if not enough mem
   0667 E5            [11] 1444 	PUSH	HL		; Save RAM top
u  0668 2A 00 00      [16] 1445 	LD	HL,(PROGND)	; Get program end
   066B 01 28 00      [10] 1446 	LD	BC,40		; 40 Bytes minimum working RAM
   066E 09            [11] 1447 	ADD	HL,BC		; Get lowest address
   066F CD D8 03      [17] 1448 	CALL	CPDEHL		; Enough memory?
   0672 D2 2D 01      [10] 1449 	JP	NC,OMERR	; No - ?OM Error
   0675 EB            [ 4] 1450 	EX	DE,HL		; RAM top to HL
u  0676 22 00 00      [16] 1451 	LD	(STRSPC),HL	; Set new string space
   0679 E1            [10] 1452 	POP	HL		; End of memory to use
u  067A 22 00 00      [16] 1453 	LD	(LSTRAM),HL	; Set new top of RAM
   067D E1            [10] 1454 	POP	HL		; Restore code string address
   067E C3 4D 02      [10] 1455 	JP	INTVAR		; Initialise variables
                           1456 ;
   0681 CA 49 02      [10] 1457 RUN:	JP	Z,RUNFST	; RUN from start if just RUN
   0684 CD 4D 02      [17] 1458 	CALL	INTVAR		; Initialise variables
   0687 01 21 05      [10] 1459 	LD	BC,RUNCNT	; Execution driver loop
   068A C3 9D 06      [10] 1460 	JP	RUNLIN		; RUN from line number
                           1461 ;
   068D 0E 03         [ 7] 1462 GOSUB:	LD	C,3		; 3 Levels of stack needed
   068F CD 16 01      [17] 1463 	CALL	CHKSTK		; Check for 3 levels of stack
   0692 C1            [10] 1464 	POP	BC		; Get return address
   0693 E5            [11] 1465 	PUSH	HL		; Save code string for RETURN
   0694 E5            [11] 1466 	PUSH	HL		; And for GOSUB routine
u  0695 2A 00 00      [16] 1467 	LD	HL,(LINEAT)	; Get current line
   0698 E3            [19] 1468 	EX	(SP),HL		; Into stack - Code string out
u  0699 3E 00         [ 7] 1469 	LD	A,ZGOSUB	; "GOSUB" token
   069B F5            [11] 1470 	PUSH	AF		; Save token
   069C 33            [ 6] 1471 	INC	SP		; Don't save flags
                           1472 ;
   069D C5            [11] 1473 RUNLIN: PUSH	BC		; Save return address
   069E CD 19 06      [17] 1474 GOTO:	CALL	ATOH		; ASCII number to DE binary
   06A1 CD E0 06      [17] 1475 	CALL	REM		; Get end of line
   06A4 E5            [11] 1476 	PUSH	HL		; Save end of line
u  06A5 2A 00 00      [16] 1477 	LD	HL,(LINEAT)	; Get current line
   06A8 CD D8 03      [17] 1478 	CALL	CPDEHL		; Line after current?
   06AB E1            [10] 1479 	POP	HL		; Restore end of line
   06AC 23            [ 6] 1480 	INC	HL		; Start of next line
   06AD DC 20 02      [17] 1481 	CALL	C,SRCHLP	; Line is after current line
   06B0 D4 1D 02      [17] 1482 	CALL	NC,SRCHLN	; Line is before current line
   06B3 60            [ 4] 1483 	LD	H,B		; Set up code string address
   06B4 69            [ 4] 1484 	LD	L,C
   06B5 2B            [ 6] 1485 	DEC	HL		; Incremented after
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 28
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   06B6 D8            [11] 1486 	RET	C		; Line found
u  06B7 1E 00         [ 7] 1487 ULERR:	LD	E,UL		; ?UL Error
   06B9 C3 46 01      [10] 1488 	JP	ERROR		; Output error message
                           1489 ;
   06BC C0            [11] 1490 RETURN: RET	NZ		; Return if not just RETURN
   06BD 16 FF         [ 7] 1491 	LD	D,-1		; Flag "GOSUB" search
   06BF CD E2 00      [17] 1492 	CALL	BAKSTK		; Look "GOSUB" block
   06C2 F9            [ 6] 1493 	LD	SP,HL		; Kill all FORs in subroutine
u  06C3 FE 00         [ 7] 1494 	CP	ZGOSUB		; Test for "GOSUB" token
u  06C5 1E 00         [ 7] 1495 	LD	E,RG		; ?RG Error
   06C7 C2 46 01      [10] 1496 	JP	NZ,ERROR	; Error if no "GOSUB" found
   06CA E1            [10] 1497 	POP	HL		; Get RETURN line number
u  06CB 22 00 00      [16] 1498 	LD	(LINEAT),HL	; Save as current
   06CE 23            [ 6] 1499 	INC	HL		; Was it from direct statement?
   06CF 7C            [ 4] 1500 	LD	A,H
   06D0 B5            [ 4] 1501 	OR	L		; Return to line
   06D1 C2 DB 06      [10] 1502 	JP	NZ,RETLIN	; No - Return to line
u  06D4 3A 00 00      [13] 1503 	LD	A,(LSTBIN)	; Any INPUT in subroutine?
   06D7 B7            [ 4] 1504 	OR	A		; If so buffer is corrupted
   06D8 C2 7B 01      [10] 1505 	JP	NZ,POPNOK	; Yes - Go to command mode
   06DB 21 21 05      [10] 1506 RETLIN: LD	HL,RUNCNT	; Execution driver loop
   06DE E3            [19] 1507 	EX	(SP),HL		; Into stack - Code string out
                           1508 	DB	3EH		; Skip "POP HL"
   06DF E1            [10] 1509 NXTDTA: POP	HL		; Restore code string address
                           1510 ;
q  06E0                    1511 DATA:	DB	01H,3AH		; ':' End of statement
   06E0 0E 00         [ 7] 1512 REM:	LD	C,0		; 00	End of statement
   06E2 06 00         [ 7] 1513 	LD	B,0
   06E4 79            [ 4] 1514 NXTSTL: LD	A,C		; Statement and byte
   06E5 48            [ 4] 1515 	LD	C,B
   06E6 47            [ 4] 1516 	LD	B,A		; Statement end byte
   06E7 7E            [ 7] 1517 NXTSTT: LD	A,(HL)		; Get byte
   06E8 B7            [ 4] 1518 	OR	A		; End of line?
   06E9 C8            [11] 1519 	RET	Z		; Yes - Exit
   06EA B8            [ 4] 1520 	CP	B		; End of statement?
   06EB C8            [11] 1521 	RET	Z		; Yes - Exit
   06EC 23            [ 6] 1522 	INC	HL		; Next byte
q  06ED                    1523 	CP	'"'		; Literal string?
   06ED CA E4 06      [10] 1524 	JP	Z,NXTSTL	; Yes - Look for another '"'
   06F0 C3 E7 06      [10] 1525 	JP	NXTSTT		; Keep looking
                           1526 ;
   06F3 CD 54 0B      [17] 1527 LET:	CALL	GETVAR		; Get variable name
   06F6 CD DE 03      [17] 1528 	CALL	CHKSYN		; Make sure "=" follows
o  06F9                    1529 	DB	ZEQUAL		; "=" token
   06F9 D5            [11] 1530 	PUSH	DE		; Save address of variable
u  06FA 3A 00 00      [13] 1531 	LD	A,(TYPE)	; Get data type
   06FD F5            [11] 1532 	PUSH	AF		; Save type
   06FE CD 87 09      [17] 1533 	CALL	EVAL		; Evaluate expression
   0701 F1            [10] 1534 	POP	AF		; Restore type
   0702 E3            [19] 1535 	EX	(SP),HL		; Save code - Get var addr
u  0703 22 00 00      [16] 1536 	LD	(BRKLIN),HL	; Save address of variable
   0706 1F            [ 4] 1537 	RRA			; Adjust type
   0707 CD 7B 09      [17] 1538 	CALL	CHKTYP		; Check types are the same
   070A CA 44 07      [10] 1539 	JP	Z,LETNUM	; Numeric - Move value
   070D E5            [11] 1540 LETSTR: PUSH	HL		; Save address of string var
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 29
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  070E 2A 00 00      [16] 1541 	LD	HL,(FPREG)	; Pointer to string entry
   0711 E5            [11] 1542 	PUSH	HL		; Save it on stack
   0712 23            [ 6] 1543 	INC	HL		; Skip over length
   0713 23            [ 6] 1544 	INC	HL
   0714 5E            [ 7] 1545 	LD	E,(HL)		; LSB of string address
   0715 23            [ 6] 1546 	INC	HL
   0716 56            [ 7] 1547 	LD	D,(HL)		; MSB of string address
u  0717 2A 00 00      [16] 1548 	LD	HL,(BASTXT)	; Point to start of program
   071A CD D8 03      [17] 1549 	CALL	CPDEHL		; Is string before program?
   071D D2 33 07      [10] 1550 	JP	NC,CRESTR	; Yes - Create string entry
u  0720 2A 00 00      [16] 1551 	LD	HL,(STRSPC)	; Point to string space
   0723 CD D8 03      [17] 1552 	CALL	CPDEHL		; Is string literal in program?
   0726 D1            [10] 1553 	POP	DE		; Restore address of string
   0727 D2 3B 07      [10] 1554 	JP	NC,MVSTPT	; Yes - Set up pointer
u  072A 21 00 00      [10] 1555 	LD	HL,TMPSTR	; Temporary string pool
   072D CD D8 03      [17] 1556 	CALL	CPDEHL		; Is string in temporary pool?
   0730 D2 3B 07      [10] 1557 	JP	NC,MVSTPT	; No - Set up pointer
                           1558 	DB	3EH		; Skip "POP DE"
   0733 D1            [10] 1559 CRESTR: POP	DE		; Restore address of string
   0734 CD 85 0F      [17] 1560 	CALL	BAKTMP		; Back to last tmp-str entry
   0737 EB            [ 4] 1561 	EX	DE,HL		; Address of string entry
   0738 CD C3 0D      [17] 1562 	CALL	SAVSTR		; Save string in string area
   073B CD 85 0F      [17] 1563 MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
   073E E1            [10] 1564 	POP	HL		; Get string pointer
   073F CD 60 13      [17] 1565 	CALL	DETHL4		; Move string pointer to var
   0742 E1            [10] 1566 	POP	HL		; Restore code string address
   0743 C9            [10] 1567 	RET
                           1568 ;
   0744 E5            [11] 1569 LETNUM: PUSH	HL		; Save address of variable
   0745 CD 5D 13      [17] 1570 	CALL	FPTHL		; Move value to variable
   0748 D1            [10] 1571 	POP	DE		; Restore address of variable
   0749 E1            [10] 1572 	POP	HL		; Restore code string address
   074A C9            [10] 1573 	RET
                           1574 ;
   074B CD A0 10      [17] 1575 ON:	CALL	GETINT		; Get integer 0-255
   074E 7E            [ 7] 1576 	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
   074F 47            [ 4] 1577 	LD	B,A		; Save in B
u  0750 FE 00         [ 7] 1578 	CP	ZGOSUB		; "GOSUB" token?
   0752 CA 59 07      [10] 1579 	JP	Z,ONGO		; Yes - Find line number
   0755 CD DE 03      [17] 1580 	CALL	CHKSYN		; Make sure it's "GOTO"
o  0758                    1581 	DB	ZGOTO		; "GOTO" token
   0758 2B            [ 6] 1582 	DEC	HL		; Cancel increment
   0759 4B            [ 4] 1583 ONGO:	LD	C,E		; Integer of branch value
   075A 0D            [ 4] 1584 ONGOLP: DEC	C		; Count branches
   075B 78            [ 4] 1585 	LD	A,B		; Get "GOTO" or "GOSUB" token
   075C CA 47 05      [10] 1586 	JP	Z,ONJMP		; Go to that line if right one
   075F CD 1A 06      [17] 1587 	CALL	GETLN		; Get line number to DE
q  0762                    1588 	CP	','		; Another line number?
   0762 C0            [11] 1589 	RET	NZ		; No - Drop through
   0763 C3 5A 07      [10] 1590 	JP	ONGOLP		; Yes - loop
                           1591 ;
   0766 CD 87 09      [17] 1592 IF:	CALL	EVAL		; Evaluate expression
   0769 7E            [ 7] 1593 	LD	A,(HL)		; Get token
u  076A FE 00         [ 7] 1594 	CP	ZGOTO		; "GOTO" token?
   076C CA 73 07      [10] 1595 	JP	Z,IFGO		; Yes - Get line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 30
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   076F CD DE 03      [17] 1596 	CALL	CHKSYN		; Make sure it's "THEN"
o  0772                    1597 	DB	ZTHEN		; "THEN" token
   0772 2B            [ 6] 1598 	DEC	HL		; Cancel increment
   0773 CD 7A 09      [17] 1599 IFGO:	CALL	TSTNUM		; Make sure it's numeric
   0776 CD 08 13      [17] 1600 	CALL	TSTSGN		; Test state of expression
   0779 CA E0 06      [10] 1601 	JP	Z,REM		; False - Drop through
   077C CD 5F 05      [17] 1602 	CALL	GETCHR		; Get next character
   077F DA 9E 06      [10] 1603 	JP	C,GOTO		; Number - GOTO that line
   0782 C3 46 05      [10] 1604 	JP	IFJMP		; Otherwise do statement
                           1605 ;
   0785 2B            [ 6] 1606 MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
   0786 CD 5F 05      [17] 1607 	CALL	GETCHR		; Get next character
   0789 CA E5 07      [10] 1608 PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
   078C C8            [11] 1609 PRNTLP: RET	Z		; End of list - Exit
u  078D FE 00         [ 7] 1610 	CP	ZTAB		; "TAB(" token?
   078F CA 18 08      [10] 1611 	JP	Z,DOTAB		; Yes - Do TAB routine
u  0792 FE 00         [ 7] 1612 	CP	ZSPC		; "SPC(" token?
   0794 CA 18 08      [10] 1613 	JP	Z,DOTAB		; Yes - Do SPC routine
   0797 E5            [11] 1614 	PUSH	HL		; Save code string address
q  0798                    1615 	CP	','		; Comma?
   0798 CA 01 08      [10] 1616 	JP	Z,DOCOM		; Yes - Move to next zone
   079B FE 3B         [ 7] 1617 	CP	59;";"		; Semi-colon?
   079D CA 3A 08      [10] 1618 	JP	Z,NEXITM	; Do semi-colon routine
   07A0 C1            [10] 1619 	POP	BC		; Code string address to BC
   07A1 CD 87 09      [17] 1620 	CALL	EVAL		; Evaluate expression
   07A4 E5            [11] 1621 	PUSH	HL		; Save code string address
u  07A5 3A 00 00      [13] 1622 	LD	A,(TYPE)	; Get variable type
   07A8 B7            [ 4] 1623 	OR	A		; Is it a string variable?
   07A9 C2 D1 07      [10] 1624 	JP	NZ,PRNTST	; Yes - Output string contents
   07AC CD 9C 14      [17] 1625 	CALL	NUMASC		; Convert number to text
   07AF CD E7 0D      [17] 1626 	CALL	CRTST		; Create temporary string
q  07B2 36 20         [10] 1627 	LD	(HL),' '	; Followed by a space
u  07B4 2A 00 00      [16] 1628 	LD	HL,(FPREG)	; Get length of output
   07B7 34            [11] 1629 	INC	(HL)		; Plus 1 for the space
u  07B8 2A 00 00      [16] 1630 	LD	HL,(FPREG)	; < Not needed >
u  07BB 3A 00 00      [13] 1631 	LD	A,(LWIDTH)	; Get width of line
   07BE 47            [ 4] 1632 	LD	B,A		; To B
   07BF 04            [ 4] 1633 	INC	B		; Width 255 (No limit)?
   07C0 CA CD 07      [10] 1634 	JP	Z,PRNTNB	; Yes - Output number string
   07C3 04            [ 4] 1635 	INC	B		; Adjust it
u  07C4 3A 00 00      [13] 1636 	LD	A,(CURPOS)	; Get cursor position
   07C7 86            [ 7] 1637 	ADD	A,(HL)		; Add length of string
   07C8 3D            [ 4] 1638 	DEC	A		; Adjust it
   07C9 B8            [ 4] 1639 	CP	B		; Will output fit on this line?
   07CA D4 E5 07      [17] 1640 	CALL	NC,PRCRLF	; No - CRLF first
   07CD CD 2A 0E      [17] 1641 PRNTNB: CALL	PRS1		; Output string at (HL)
   07D0 AF            [ 4] 1642 	XOR	A		; Skip CALL by setting 'z' flag
   07D1 C4 2A 0E      [17] 1643 PRNTST: CALL	NZ,PRS1		; Output string at (HL)
   07D4 E1            [10] 1644 	POP	HL		; Restore code string address
   07D5 C3 85 07      [10] 1645 	JP	MRPRNT		; See if more to PRINT
                           1646 ;
u  07D8 3A 00 00      [13] 1647 STTLIN: LD	A,(CURPOS)	; Make sure on new line
   07DB B7            [ 4] 1648 	OR	A		; Already at start?
   07DC C8            [11] 1649 	RET	Z		; Yes - Do nothing
   07DD C3 E5 07      [10] 1650 	JP	PRCRLF		; Start a new line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 31
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                           1651 ;
   07E0 36 00         [10] 1652 ENDINP: LD	(HL),0		; Mark end of buffer
u  07E2 21 FF FF      [10] 1653 	LD	HL,BUFFER-1	; Point to buffer
u  07E5 3E 00         [ 7] 1654 PRCRLF: LD	A,CR		; Load a CR
   07E7 CD E9 03      [17] 1655 	CALL	OUTC		; Output character
u  07EA 3E 00         [ 7] 1656 	LD	A,LF		; Load a LF
   07EC CD E9 03      [17] 1657 	CALL	OUTC		; Output character
   07EF AF            [ 4] 1658 DONULL: XOR	A		; Set to position 0
u  07F0 32 00 00      [13] 1659 	LD	(CURPOS),A	; Store it
u  07F3 3A 00 00      [13] 1660 	LD	A,(NULLS)	; Get number of nulls
   07F6 3D            [ 4] 1661 NULLP:	DEC	A		; Count them
   07F7 C8            [11] 1662 	RET	Z		; Return if done
   07F8 F5            [11] 1663 	PUSH	AF		; Save count
   07F9 AF            [ 4] 1664 	XOR	A		; Load a null
   07FA CD E9 03      [17] 1665 	CALL	OUTC		; Output it
   07FD F1            [10] 1666 	POP	AF		; Restore count
   07FE C3 F6 07      [10] 1667 	JP	NULLP		; Keep counting
                           1668 ;
u  0801 3A 00 00      [13] 1669 DOCOM:	LD	A,(COMMAN)	; Get comma width
   0804 47            [ 4] 1670 	LD	B,A		; Save in B
u  0805 3A 00 00      [13] 1671 	LD	A,(CURPOS)	; Get current position
   0808 B8            [ 4] 1672 	CP	B		; Within the limit?
   0809 D4 E5 07      [17] 1673 	CALL	NC,PRCRLF	; No - output CRLF
   080C D2 3A 08      [10] 1674 	JP	NC,NEXITM	; Get next item
   080F D6 0E         [ 7] 1675 ZONELP: SUB	14		; Next zone of 14 characters
   0811 D2 0F 08      [10] 1676 	JP	NC,ZONELP	; Repeat if more zones
   0814 2F            [ 4] 1677 	CPL			; Number of spaces to output
   0815 C3 2F 08      [10] 1678 	JP	ASPCS		; Output them
                           1679 ;
   0818 F5            [11] 1680 DOTAB:	PUSH	AF		; Save token
   0819 CD 9D 10      [17] 1681 	CALL	FNDNUM		; Evaluate expression
   081C CD DE 03      [17] 1682 	CALL	CHKSYN		; Make sure ")" follows
                           1683 	DB	")"
   081F 2B            [ 6] 1684 	DEC	HL		; Back space on to ")"
   0820 F1            [10] 1685 	POP	AF		; Restore token
u  0821 D6 00         [ 7] 1686 	SUB	ZSPC		; Was it "SPC(" ?
   0823 E5            [11] 1687 	PUSH	HL		; Save code string address
   0824 CA 2A 08      [10] 1688 	JP	Z,DOSPC	; Yes - Do 'E' spaces
u  0827 3A 00 00      [13] 1689 	LD	A,(CURPOS)	; Get current position
   082A 2F            [ 4] 1690 DOSPC:	CPL			; Number of spaces to print to
   082B 83            [ 4] 1691 	ADD	A,E		; Total number to print
   082C D2 3A 08      [10] 1692 	JP	NC,NEXITM	; TAB < Current POS(X)
   082F 3C            [ 4] 1693 ASPCS:	INC	A		; Output A spaces
   0830 47            [ 4] 1694 	LD	B,A		; Save number to print
q  0831 3E 20         [ 7] 1695 	LD	A,' '		; Space
   0833 CD E9 03      [17] 1696 SPCLP:	CALL	OUTC		; Output character in A
   0836 05            [ 4] 1697 	DEC	B		; Count them
   0837 C2 33 08      [10] 1698 	JP	NZ,SPCLP	; Repeat if more
   083A E1            [10] 1699 NEXITM: POP	HL		; Restore code string address
   083B CD 5F 05      [17] 1700 	CALL	GETCHR		; Get next character
   083E C3 8C 07      [10] 1701 	JP	PRNTLP		; More to print
                           1702 ;
q  0841                    1703 REDO:	DB	"?Redo from start",CR,LF,0
                           1704 ;
u  0841 3A 00 00      [13] 1705 BADINP: LD	A,(READFG)	; READ or INPUT?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 32
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0844 B7            [ 4] 1706 	OR	A
   0845 C2 32 01      [10] 1707 	JP	NZ,DATSNR	; READ - ?SN Error
   0848 C1            [10] 1708 	POP	BC		; Throw away code string addr
   0849 21 41 08      [10] 1709 	LD	HL,REDO		; "Redo from start" message
   084C CD 27 0E      [17] 1710 	CALL	PRS		; Output string
   084F C3 7C 02      [10] 1711 	JP	DOAGN		; Do last INPUT again
                           1712 ;
   0852 CD 95 0D      [17] 1713 INPUT:	CALL	IDTEST		; Test for illegal direct
   0855 7E            [ 7] 1714 	LD	A,(HL)		; Get character after "INPUT"
q  0856                    1715 	CP	'"'		; Is there a prompt string?
   0856 3E 00         [ 7] 1716 	LD	A,0		; Clear A and leave flags
u  0858 32 00 00      [13] 1717 	LD	(CTLOFG),A	; Enable output
   085B C2 68 08      [10] 1718 	JP	NZ,NOPMPT	; No prompt - get input
   085E CD E8 0D      [17] 1719 	CALL	QTSTR		; Get string terminated by '"'
   0861 CD DE 03      [17] 1720 	CALL	CHKSYN		; Check for ';' after prompt
                           1721 	DB	';'
   0864 E5            [11] 1722 	PUSH	HL		; Save code string address
   0865 CD 2A 0E      [17] 1723 	CALL	PRS1		; Output prompt string
                           1724 	DB	3EH		; Skip "PUSH HL"
   0868 E5            [11] 1725 NOPMPT: PUSH	HL		; Save code string address
   0869 CD 80 02      [17] 1726 	CALL	PROMPT		; Get input with "? " prompt
   086C C1            [10] 1727 	POP	BC		; Restore code string address
   086D DA A4 05      [10] 1728 	JP	C,INPBRK	; Break pressed - Exit
   0870 23            [ 6] 1729 	INC	HL		; Next byte
   0871 7E            [ 7] 1730 	LD	A,(HL)		; Get it
   0872 B7            [ 4] 1731 	OR	A		; End of line?
   0873 2B            [ 6] 1732 	DEC	HL		; Back again
   0874 C5            [11] 1733 	PUSH	BC		; Re-save code string address
   0875 CA DF 06      [10] 1734 	JP	Z,NXTDTA	; Yes - Find next DATA stmt
q  0878 36 2C         [10] 1735 	LD	(HL),','	; Store comma as separator
   087A C3 81 08      [10] 1736 	JP	NXTITM		; Get next item
                           1737 ;
   087D E5            [11] 1738 READ:	PUSH	HL		; Save code string address
u  087E 2A 00 00      [16] 1739 	LD	HL,(NXTDAT)	; Next DATA statement
                           1740 	DB	0F6H		; Flag "READ"
   0881 AF            [ 4] 1741 NXTITM: XOR	A		; Flag "INPUT"
u  0882 32 00 00      [13] 1742 	LD	(READFG),A	; Save "READ"/"INPUT" flag
   0885 E3            [19] 1743 	EX	(SP),HL		; Get code str' , Save pointer
   0886 C3 8C 08      [10] 1744 	JP	GTVLUS		; Get values
                           1745 ;
   0889 CD DE 03      [17] 1746 NEDMOR: CALL	CHKSYN		; Check for comma between items
                           1747 	DB	','
   088C CD 54 0B      [17] 1748 GTVLUS: CALL	GETVAR		; Get variable name
   088F E3            [19] 1749 	EX	(SP),HL		; Save code str" , Get pointer
   0890 D5            [11] 1750 	PUSH	DE		; Save variable address
   0891 7E            [ 7] 1751 	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
q  0892                    1752 	CP	','		; Comma?
   0892 CA B2 08      [10] 1753 	JP	Z,ANTVLU	; Yes - Get another value
u  0895 3A 00 00      [13] 1754 	LD	A,(READFG)	; Is it READ?
   0898 B7            [ 4] 1755 	OR	A
   0899 C2 0A 09      [10] 1756 	JP	NZ,FDTLP	; Yes - Find next DATA stmt
q  089C 3E 3F         [ 7] 1757 	LD	A,'?'		; More INPUT needed
   089E CD E9 03      [17] 1758 	CALL	OUTC		; Output character
   08A1 CD 80 02      [17] 1759 	CALL	PROMPT		; Get INPUT with prompt
   08A4 D1            [10] 1760 	POP	DE		; Variable address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 33
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   08A5 C1            [10] 1761 	POP	BC		; Code string address
   08A6 DA A4 05      [10] 1762 	JP	C,INPBRK	; Break pressed
   08A9 23            [ 6] 1763 	INC	HL		; Point to next DATA byte
   08AA 7E            [ 7] 1764 	LD	A,(HL)		; Get byte
   08AB B7            [ 4] 1765 	OR	A		; Is it zero (No input) ?
   08AC 2B            [ 6] 1766 	DEC	HL		; Back space INPUT pointer
   08AD C5            [11] 1767 	PUSH	BC		; Save code string address
   08AE CA DF 06      [10] 1768 	JP	Z,NXTDTA	; Find end of buffer
   08B1 D5            [11] 1769 	PUSH	DE		; Save variable address
u  08B2 3A 00 00      [13] 1770 ANTVLU: LD	A,(TYPE)	; Check data type
   08B5 B7            [ 4] 1771 	OR	A		; Is it numeric?
   08B6 CA DA 08      [10] 1772 	JP	Z,INPBIN	; Yes - Convert to binary
   08B9 CD 5F 05      [17] 1773 	CALL	GETCHR		; Get next character
   08BC 57            [ 4] 1774 	LD	D,A		; Save input character
   08BD 47            [ 4] 1775 	LD	B,A		; Again
q  08BE                    1776 	CP	'"'		; Start of literal sting?
   08BE CA CE 08      [10] 1777 	JP	Z,STRENT	; Yes - Create string entry
u  08C1 3A 00 00      [13] 1778 	LD	A,(READFG)	; "READ" or "INPUT" ?
   08C4 B7            [ 4] 1779 	OR	A
   08C5 57            [ 4] 1780 	LD	D,A		; Save 00 if "INPUT"
   08C6 CA CB 08      [10] 1781 	JP	Z,ITMSEP	; "INPUT" - End with 00
q  08C9 16 3A         [ 7] 1782 	LD	D,':'		; "DATA" - End with 00 or ':'
q  08CB 06 2C         [ 7] 1783 ITMSEP: LD	B,','		; Item separator
   08CD 2B            [ 6] 1784 	DEC	HL		; Back space for DTSTR
   08CE CD EB 0D      [17] 1785 STRENT: CALL	DTSTR		; Get string terminated by D
   08D1 EB            [ 4] 1786 	EX	DE,HL		; String address to DE
   08D2 21 E5 08      [10] 1787 	LD	HL,LTSTND	; Where to go after LETSTR
   08D5 E3            [19] 1788 	EX	(SP),HL		; Save HL , get input pointer
   08D6 D5            [11] 1789 	PUSH	DE		; Save address of string
   08D7 C3 0D 07      [10] 1790 	JP	LETSTR		; Assign string to variable
                           1791 ;
   08DA CD 5F 05      [17] 1792 INPBIN: CALL	GETCHR		; Get next character
   08DD CD 0A 14      [17] 1793 	CALL	ASCTFP		; Convert ASCII to FP number
   08E0 E3            [19] 1794 	EX	(SP),HL		; Save input ptr, Get var addr
   08E1 CD 5D 13      [17] 1795 	CALL	FPTHL		; Move FPREG to variable
   08E4 E1            [10] 1796 	POP	HL		; Restore input pointer
   08E5 2B            [ 6] 1797 LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
   08E6 CD 5F 05      [17] 1798 	CALL	GETCHR		; Get next character
   08E9 CA EF 08      [10] 1799 	JP	Z,MORDT		; End of line - More needed?
q  08EC                    1800 	CP	','		; Another value?
   08EC C2 41 08      [10] 1801 	JP	NZ,BADINP	; No - Bad input
   08EF E3            [19] 1802 MORDT:	EX	(SP),HL		; Get code string address
   08F0 2B            [ 6] 1803 	DEC	HL		; DEC 'cos GETCHR INCs
   08F1 CD 5F 05      [17] 1804 	CALL	GETCHR		; Get next character
   08F4 C2 89 08      [10] 1805 	JP	NZ,NEDMOR	; More needed - Get it
   08F7 D1            [10] 1806 	POP	DE		; Restore DATA pointer
u  08F8 3A 00 00      [13] 1807 	LD	A,(READFG)	; "READ" or "INPUT" ?
   08FB B7            [ 4] 1808 	OR	A
   08FC EB            [ 4] 1809 	EX	DE,HL		; DATA pointer to HL
   08FD C2 7F 05      [10] 1810 	JP	NZ,UPDATA	; Update DATA pointer if "READ"
   0900 D5            [11] 1811 	PUSH	DE		; Save code string address
   0901 B6            [ 7] 1812 	OR	(HL)		; More input given?
   0902 21 0A 09      [10] 1813 	LD	HL,EXTIG	; "?Extra ignored" message
   0905 C4 27 0E      [17] 1814 	CALL	NZ,PRS		; Output string if extra given
   0908 E1            [10] 1815 	POP	HL		; Restore code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 34
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0909 C9            [10] 1816 	RET
                           1817 ;
q  090A                    1818 EXTIG:	DB	"?Extra ignored",CR,LF,0
                           1819 ;
   090A CD E0 06      [17] 1820 FDTLP:	CALL	DATA		; Get next statement
   090D B7            [ 4] 1821 	OR	A		; End of line?
   090E C2 23 09      [10] 1822 	JP	NZ,FANDT	; No - See if DATA statement
   0911 23            [ 6] 1823 	INC	HL
   0912 7E            [ 7] 1824 	LD	A,(HL)		; End of program?
   0913 23            [ 6] 1825 	INC	HL
   0914 B6            [ 7] 1826 	OR	(HL)		; 00 00 Ends program
u  0915 1E 00         [ 7] 1827 	LD	E,OD		; ?OD Error
   0917 CA 46 01      [10] 1828 	JP	Z,ERROR		; Yes - Out of DATA
   091A 23            [ 6] 1829 	INC	HL
   091B 5E            [ 7] 1830 	LD	E,(HL)		; LSB of line number
   091C 23            [ 6] 1831 	INC	HL
   091D 56            [ 7] 1832 	LD	D,(HL)		; MSB of line number
   091E EB            [ 4] 1833 	EX	DE,HL
u  091F 22 00 00      [16] 1834 	LD	(DATLIN),HL	; Set line of current DATA item
   0922 EB            [ 4] 1835 	EX	DE,HL
   0923 CD 5F 05      [17] 1836 FANDT:	CALL	GETCHR		; Get next character
u  0926 FE 00         [ 7] 1837 	CP	ZDATA		; "DATA" token
   0928 C2 0A 09      [10] 1838 	JP	NZ,FDTLP	; No "DATA" - Keep looking
   092B C3 B2 08      [10] 1839 	JP	ANTVLU		; Found - Convert input
                           1840 ;
   092E 11 00 00      [10] 1841 NEXT:	LD	DE,0		; In case no index given
   0931 C4 54 0B      [17] 1842 NEXT1:	CALL	NZ,GETVAR	; Get index address
u  0934 22 00 00      [16] 1843 	LD	(BRKLIN),HL	; Save code string address
   0937 CD E2 00      [17] 1844 	CALL	BAKSTK		; Look for "FOR" block
   093A C2 3C 01      [10] 1845 	JP	NZ,NFERR	; No "FOR" - ?NF Error
   093D F9            [ 6] 1846 	LD	SP,HL		; Clear nested loops
   093E D5            [11] 1847 	PUSH	DE		; Save index address
   093F 7E            [ 7] 1848 	LD	A,(HL)		; Get sign of STEP
   0940 23            [ 6] 1849 	INC	HL
   0941 F5            [11] 1850 	PUSH	AF		; Save sign of STEP
   0942 D5            [11] 1851 	PUSH	DE		; Save index address
   0943 CD 43 13      [17] 1852 	CALL	PHLTFP		; Move index value to FPREG
   0946 E3            [19] 1853 	EX	(SP),HL		; Save address of TO value
   0947 E5            [11] 1854 	PUSH	HL		; Save address of index
   0948 CD CB 10      [17] 1855 	CALL	ADDPHL		; Add STEP to index value
   094B E1            [10] 1856 	POP	HL		; Restore address of index
   094C CD 5D 13      [17] 1857 	CALL	FPTHL		; Move value to index variable
   094F E1            [10] 1858 	POP	HL		; Restore address of TO value
   0950 CD 54 13      [17] 1859 	CALL	LOADFP		; Move TO value to BCDE
   0953 E5            [11] 1860 	PUSH	HL		; Save address of line of FOR
   0954 CD 80 13      [17] 1861 	CALL	CMPNUM		; Compare index with TO value
   0957 E1            [10] 1862 	POP	HL		; Restore address of line num
   0958 C1            [10] 1863 	POP	BC		; Address of sign of STEP
   0959 90            [ 4] 1864 	SUB	B		; Compare with expected sign
   095A CD 54 13      [17] 1865 	CALL	LOADFP		; BC = Loop stmt,DE = Line num
   095D CA 69 09      [10] 1866 	JP	Z,KILFOR	; Loop finished - Terminate it
   0960 EB            [ 4] 1867 	EX	DE,HL		; Loop statement line number
u  0961 22 00 00      [16] 1868 	LD	(LINEAT),HL	; Set loop line number
   0964 69            [ 4] 1869 	LD	L,C		; Set code string to loop
   0965 60            [ 4] 1870 	LD	H,B
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 35
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0966 C3 1D 05      [10] 1871 	JP	PUTFID		; Put back "FOR" and continue
                           1872 ;
   0969 F9            [ 6] 1873 KILFOR: LD	SP,HL		; Remove "FOR" block
u  096A 2A 00 00      [16] 1874 	LD	HL,(BRKLIN)	; Code string after "NEXT"
   096D 7E            [ 7] 1875 	LD	A,(HL)		; Get next byte in code string
q  096E                    1876 	CP	','		; More NEXTs ?
   096E C2 21 05      [10] 1877 	JP	NZ,RUNCNT	; No - Do next statement
   0971 CD 5F 05      [17] 1878 	CALL	GETCHR		; Position to index name
   0974 CD 31 09      [17] 1879 	CALL	NEXT1		; Re-enter NEXT routine
                           1880 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1881 ;
   0977 CD 87 09      [17] 1882 GETNUM: CALL	EVAL		; Get a numeric expression
q  097A                    1883 TSTNUM: DB	0F6H		; Clear carry (numeric)
   097A 37            [ 4] 1884 TSTSTR: SCF			; Set carry (string)
u  097B 3A 00 00      [13] 1885 CHKTYP: LD	A,(TYPE)	; Check types match
   097E 8F            [ 4] 1886 	ADC	A,A		; Expected + actual
   097F B7            [ 4] 1887 	OR	A		; Clear carry , set parity
   0980 E8            [11] 1888 	RET	PE		; Even parity - Types match
   0981 C3 44 01      [10] 1889 	JP	TMERR		; Different types - Error
                           1890 ;
   0984 CD DE 03      [17] 1891 OPNPAR: CALL	CHKSYN		; Make sure "(" follows
                           1892 	DB	"("
   0987 2B            [ 6] 1893 EVAL:	DEC	HL		; Evaluate expression & save
   0988 16 00         [ 7] 1894 	LD	D,0		; Precedence value
   098A D5            [11] 1895 EVAL1:	PUSH	DE		; Save precedence
   098B 0E 01         [ 7] 1896 	LD	C,1
   098D CD 16 01      [17] 1897 	CALL	CHKSTK		; Check for 1 level of stack
   0990 CD FC 09      [17] 1898 	CALL	OPRND		; Get next expression value
u  0993 22 00 00      [16] 1899 EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
u  0996 2A 00 00      [16] 1900 EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
   0999 C1            [10] 1901 	POP	BC		; Precedence value and operator
   099A 78            [ 4] 1902 	LD	A,B		; Get precedence value
q  099B                    1903 	CP	78H		; "AND" or "OR" ?
   099B D4 7A 09      [17] 1904 	CALL	NC,TSTNUM	; No - Make sure it's a number
   099E 7E            [ 7] 1905 	LD	A,(HL)		; Get next operator / function
   099F 16 00         [ 7] 1906 	LD	D,0		; Clear Last relation
u  09A1 D6 00         [ 7] 1907 RLTLP:	SUB	ZGTR		; ">" Token
   09A3 DA BD 09      [10] 1908 	JP	C,FOPRND	; + - * / ^ AND OR - Test it
u  09A6 FE 01         [ 7] 1909 	CP	ZLTH+1-ZGTR	; < = >
   09A8 D2 BD 09      [10] 1910 	JP	NC,FOPRND	; Function - Call it
u  09AB FE 00         [ 7] 1911 	CP	ZEQUAL-ZGTR	; "="
   09AD 17            [ 4] 1912 	RLA			; <- Test for legal
   09AE AA            [ 4] 1913 	XOR	D		; <- combinations of < = >
   09AF BA            [ 4] 1914 	CP	D		; <- by combining last token
   09B0 57            [ 4] 1915 	LD	D,A		; <- with current one
   09B1 DA 38 01      [10] 1916 	JP	C,SNERR		; Error if "<<' '==" or ">>"
u  09B4 22 00 00      [16] 1917 	LD	(CUROPR),HL	; Save address of current token
   09B7 CD 5F 05      [17] 1918 	CALL	GETCHR		; Get next character
   09BA C3 A1 09      [10] 1919 	JP	RLTLP		; Treat the two as one
                           1920 ;
   09BD 7A            [ 4] 1921 FOPRND: LD	A,D		; < = > found ?
   09BE B7            [ 4] 1922 	OR	A
   09BF C2 D3 0A      [10] 1923 	JP	NZ,TSTRED	; Yes - Test for reduction
   09C2 7E            [ 7] 1924 	LD	A,(HL)		; Get operator token
u  09C3 22 00 00      [16] 1925 	LD	(CUROPR),HL	; Save operator address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 36
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  09C6 D6 00         [ 7] 1926 	SUB	ZPLUS		; Operator or function?
   09C8 D8            [11] 1927 	RET	C		; Neither - Exit
u  09C9 FE 01         [ 7] 1928 	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
   09CB D0            [11] 1929 	RET	NC		; No - Exit
   09CC 5F            [ 4] 1930 	LD	E,A		; Coded operator
u  09CD 3A 00 00      [13] 1931 	LD	A,(TYPE)	; Get data type
   09D0 3D            [ 4] 1932 	DEC	A		; FF = numeric , 00 = string
   09D1 B3            [ 4] 1933 	OR	E		; Combine with coded operator
   09D2 7B            [ 4] 1934 	LD	A,E		; Get coded operator
   09D3 CA 1A 0F      [10] 1935 	JP	Z,CONCAT	; String concatenation
   09D6 07            [ 4] 1936 	RLCA			; Times 2
   09D7 83            [ 4] 1937 	ADD	A,E		; Times 3
   09D8 5F            [ 4] 1938 	LD	E,A		; To DE (D is 0)
   09D9 21 BC 00      [10] 1939 	LD	HL,PRITAB	; Precedence table
   09DC 19            [11] 1940 	ADD	HL,DE		; To the operator concerned
   09DD 78            [ 4] 1941 	LD	A,B		; Last operator precedence
   09DE 56            [ 7] 1942 	LD	D,(HL)		; Get evaluation precedence
   09DF BA            [ 4] 1943 	CP	D		; Compare with eval precedence
   09E0 D0            [11] 1944 	RET	NC		; Exit if higher precedence
   09E1 23            [ 6] 1945 	INC	HL		; Point to routine address
   09E2 CD 7A 09      [17] 1946 	CALL	TSTNUM		; Make sure it's a number
                           1947 ;
   09E5 C5            [11] 1948 STKTHS: PUSH	BC		; Save last precedence & token
   09E6 01 96 09      [10] 1949 	LD	BC,EVAL3	; Where to go on prec' break
   09E9 C5            [11] 1950 	PUSH	BC		; Save on stack for return
   09EA 43            [ 4] 1951 	LD	B,E		; Save operator
   09EB 4A            [ 4] 1952 	LD	C,D		; Save precedence
   09EC CD 36 13      [17] 1953 	CALL	STAKFP		; Move value to stack
   09EF 58            [ 4] 1954 	LD	E,B		; Restore operator
   09F0 51            [ 4] 1955 	LD	D,C		; Restore precedence
   09F1 4E            [ 7] 1956 	LD	C,(HL)		; Get LSB of routine address
   09F2 23            [ 6] 1957 	INC	HL
   09F3 46            [ 7] 1958 	LD	B,(HL)		; Get MSB of routine address
   09F4 23            [ 6] 1959 	INC	HL
   09F5 C5            [11] 1960 	PUSH	BC		; Save routine address
u  09F6 2A 00 00      [16] 1961 	LD	HL,(CUROPR)	; Address of current operator
   09F9 C3 8A 09      [10] 1962 	JP	EVAL1		; Loop until prec' break
                           1963 ;
   09FC AF            [ 4] 1964 OPRND:	XOR	A		; Get operand routine
u  09FD 32 00 00      [13] 1965 	LD	(TYPE),A	; Set numeric expected
   0A00 CD 5F 05      [17] 1966 	CALL	GETCHR		; Get next character
u  0A03 1E 00         [ 7] 1967 	LD	E,MO		; ?MO Error
   0A05 CA 46 01      [10] 1968 	JP	Z,ERROR		; No operand - Error
   0A08 DA 0A 14      [10] 1969 	JP	C,ASCTFP	; Number - Get value
   0A0B CD F1 05      [17] 1970 	CALL	CHKLTR		; See if a letter
   0A0E D2 58 0A      [10] 1971 	JP	NC,CONVAR	; Letter - Find variable
q  0A11                    1972 	CP	'&'		; &H = HEX, &B = BINARY
   0A11 20 0E         [12] 1973 	JR	NZ, NOTAMP
   0A13 CD 5F 05      [17] 1974 	CALL	GETCHR		; Get next character
q  0A16                    1975 	CP	'H'		; Hex number indicated? [function added]
u  0A16 CA 00 00      [10] 1976 	JP	Z,HEXTFP	; Convert Hex to FPREG
q  0A19                    1977 	CP	'B'		; Binary number indicated? [function added]
   0A19 CA F5 17      [10] 1978 	JP	Z,BINTFP	; Convert Bin to FPREG
u  0A1C 1E 00         [ 7] 1979 	LD	E,SN		; If neither then a ?SN Error
   0A1E CA 46 01      [10] 1980 	JP	Z,ERROR
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 37
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  0A21 FE 00         [ 7] 1981 NOTAMP: CP	ZPLUS		; '+' Token ?
   0A23 CA FC 09      [10] 1982 	JP	Z,OPRND		; Yes - Look for operand
q  0A26                    1983 	CP	'.'		; '.' ?
   0A26 CA 0A 14      [10] 1984 	JP	Z,ASCTFP	; Yes - Create FP number
u  0A29 FE 00         [ 7] 1985 	CP	ZMINUS		; '-' Token ?
   0A2B CA 47 0A      [10] 1986 	JP	Z,MINUS		; Yes - Do minus
q  0A2E                    1987 	CP	'"'		; Literal string ?
   0A2E CA E8 0D      [10] 1988 	JP	Z,QTSTR		; Get string terminated by '"'
u  0A31 FE 00         [ 7] 1989 	CP	ZNOT		; "NOT" Token ?
   0A33 CA 31 0B      [10] 1990 	JP	Z,EVNOT		; Yes - Eval NOT expression
u  0A36 FE 00         [ 7] 1991 	CP	ZFN		; "FN" Token ?
   0A38 CA 4D 0D      [10] 1992 	JP	Z,DOFN		; Yes - Do FN routine
u  0A3B D6 00         [ 7] 1993 	SUB	ZSGN		; Is it a function?
   0A3D D2 69 0A      [10] 1994 	JP	NC,FNOFST	; Yes - Evaluate function
   0A40 CD 84 09      [17] 1995 EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
   0A43 CD DE 03      [17] 1996 	CALL	CHKSYN		; Make sure ")" follows
                           1997 	DB	")"
   0A46 C9            [10] 1998 	RET
                           1999 ;
kq 0A47 16 07         [ 7] 2000 MINUS:	LD	D,7DH		; '-' precedence
   0A49 CD 8A 09      [17] 2001 	CALL	EVAL1		; Evaluate until prec' break
u  0A4C 2A 00 00      [16] 2002 	LD	HL,(NXTOPR)	; Get next operator address
   0A4F E5            [11] 2003 	PUSH	HL		; Save next operator address
   0A50 CD 30 13      [17] 2004 	CALL	INVSGN		; Negate value
   0A53 CD 7A 09      [17] 2005 RETNUM: CALL	TSTNUM		; Make sure it's a number
   0A56 E1            [10] 2006 	POP	HL		; Restore next operator address
   0A57 C9            [10] 2007 	RET
                           2008 ;
   0A58 CD 54 0B      [17] 2009 CONVAR: CALL	GETVAR		; Get variable address to DE
   0A5B E5            [11] 2010 FRMEVL: PUSH	HL		; Save code string address
   0A5C EB            [ 4] 2011 	EX	DE,HL		; Variable address to HL
u  0A5D 22 00 00      [16] 2012 	LD	(FPREG),HL	; Save address of variable
u  0A60 3A 00 00      [13] 2013 	LD	A,(TYPE)	; Get type
   0A63 B7            [ 4] 2014 	OR	A		; Numeric?
   0A64 CC 43 13      [17] 2015 	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
   0A67 E1            [10] 2016 	POP	HL		; Restore code string address
   0A68 C9            [10] 2017 	RET
                           2018 ;
   0A69 06 00         [ 7] 2019 FNOFST: LD	B,0		; Get address of function
   0A6B 07            [ 4] 2020 	RLCA			; Double function offset
   0A6C 4F            [ 4] 2021 	LD	C,A		; BC = Offset in function table
   0A6D C5            [11] 2022 	PUSH	BC		; Save adjusted token value
   0A6E CD 5F 05      [17] 2023 	CALL	GETCHR		; Get next character
   0A71 79            [ 4] 2024 	LD	A,C		; Get adjusted token value
u  0A72 FE FF         [ 7] 2025 	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
   0A74 DA 8F 0A      [10] 2026 	JP	C,FNVAL		; No - Do function
   0A77 CD 84 09      [17] 2027 	CALL	OPNPAR		; Evaluate expression	(X,...
   0A7A CD DE 03      [17] 2028 	CALL	CHKSYN		; Make sure ',' follows
                           2029 	DB	','
   0A7D CD 7A 09      [17] 2030 	CALL	TSTSTR		; Make sure it's a string
   0A80 EB            [ 4] 2031 	EX	DE,HL		; Save code string address
u  0A81 2A 00 00      [16] 2032 	LD	HL,(FPREG)	; Get address of string
   0A84 E3            [19] 2033 	EX	(SP),HL		; Save address of string
   0A85 E5            [11] 2034 	PUSH	HL		; Save adjusted token value
   0A86 EB            [ 4] 2035 	EX	DE,HL		; Restore code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 38
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0A87 CD A0 10      [17] 2036 	CALL	GETINT		; Get integer 0-255
   0A8A EB            [ 4] 2037 	EX	DE,HL		; Save code string address
   0A8B E3            [19] 2038 	EX	(SP),HL		; Save integer,HL = adj' token
   0A8C C3 97 0A      [10] 2039 	JP	GOFUNC		; Jump to string function
                           2040 ;
   0A8F CD 40 0A      [17] 2041 FNVAL:	CALL	EVLPAR		; Evaluate expression
   0A92 E3            [19] 2042 	EX	(SP),HL		; HL = Adjusted token value
   0A93 11 53 0A      [10] 2043 	LD	DE,RETNUM	; Return number from function
   0A96 D5            [11] 2044 	PUSH	DE		; Save on stack
   0A97 01 BC 00      [10] 2045 GOFUNC: LD	BC,FNCTAB	; Function routine addresses
   0A9A 09            [11] 2046 	ADD	HL,BC		; Point to right address
   0A9B 4E            [ 7] 2047 	LD	C,(HL)		; Get LSB of address
   0A9C 23            [ 6] 2048 	INC	HL		;
   0A9D 66            [ 7] 2049 	LD	H,(HL)		; Get MSB of address
   0A9E 69            [ 4] 2050 	LD	L,C		; Address to HL
   0A9F E9            [ 4] 2051 	JP	(HL)		; Jump to function
                           2052 ;
   0AA0 15            [ 4] 2053 SGNEXP: DEC	D		; Dee to flag negative exponent
u  0AA1 FE 00         [ 7] 2054 	CP	ZMINUS		; '-' token ?
   0AA3 C8            [11] 2055 	RET	Z		; Yes - Return
q  0AA4                    2056 	CP	'-'		; '-' ASCII ?
   0AA4 C8            [11] 2057 	RET	Z		; Yes - Return
   0AA5 14            [ 4] 2058 	INC	D		; Inc to flag positive exponent
q  0AA6                    2059 	CP	'+'		; '+' ASCII ?
   0AA6 C8            [11] 2060 	RET	Z		; Yes - Return
u  0AA7 FE 00         [ 7] 2061 	CP	ZPLUS		; '+' token ?
   0AA9 C8            [11] 2062 	RET	Z		; Yes - Return
   0AAA 2B            [ 6] 2063 	DEC	HL		; DEC 'cos GETCHR INCs
   0AAB C9            [10] 2064 	RET			; Return "NZ"
                           2065 ;
q  0AAC                    2066 POR:	DB	0F6H		; Flag "OR"
   0AAC AF            [ 4] 2067 PAND:	XOR	A		; Flag "AND"
   0AAD F5            [11] 2068 	PUSH	AF		; Save "AND" / "OR" flag
   0AAE CD 7A 09      [17] 2069 	CALL	TSTNUM		; Make sure it's a number
   0AB1 CD 01 06      [17] 2070 	CALL	DEINT		; Get integer -32768 to 32767
   0AB4 F1            [10] 2071 	POP	AF		; Restore "AND" / "OR" flag
   0AB5 EB            [ 4] 2072 	EX	DE,HL		; <- Get last
   0AB6 C1            [10] 2073 	POP	BC		; <- value
   0AB7 E3            [19] 2074 	EX	(SP),HL		; <- from
   0AB8 EB            [ 4] 2075 	EX	DE,HL		; <- stack
   0AB9 CD 46 13      [17] 2076 	CALL	FPBCDE		; Move last value to FPREG
   0ABC F5            [11] 2077 	PUSH	AF		; Save "AND" / "OR" flag
   0ABD CD 01 06      [17] 2078 	CALL	DEINT		; Get integer -32768 to 32767
   0AC0 F1            [10] 2079 	POP	AF		; Restore "AND" / "OR" flag
   0AC1 C1            [10] 2080 	POP	BC		; Get value
   0AC2 79            [ 4] 2081 	LD	A,C		; Get LSB
   0AC3 21 0E 0D      [10] 2082 	LD	HL,ACPASS	; Address of save AC as current
   0AC6 C2 CE 0A      [10] 2083 	JP	NZ,POR1		; Jump if OR
   0AC9 A3            [ 4] 2084 	AND	E		; "AND" LSBs
   0ACA 4F            [ 4] 2085 	LD	C,A		; Save LSB
   0ACB 78            [ 4] 2086 	LD	A,B		; Get MBS
   0ACC A2            [ 4] 2087 	AND	D		; "AND" MSBs
   0ACD E9            [ 4] 2088 	JP	(HL)		; Save AC as current (ACPASS)
                           2089 ;
   0ACE B3            [ 4] 2090 POR1:	OR	E		; "OR" LSBs
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 39
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0ACF 4F            [ 4] 2091 	LD	C,A		; Save LSB
   0AD0 78            [ 4] 2092 	LD	A,B		; Get MSB
   0AD1 B2            [ 4] 2093 	OR	D		; "OR" MSBs
   0AD2 E9            [ 4] 2094 	JP	(HL)		; Save AC as current (ACPASS)
                           2095 ;
   0AD3 21 E5 0A      [10] 2096 TSTRED: LD	HL,CMPLOG	; Logical compare routine
u  0AD6 3A 00 00      [13] 2097 	LD	A,(TYPE)	; Get data type
   0AD9 1F            [ 4] 2098 	RRA			; Carry set = string
   0ADA 7A            [ 4] 2099 	LD	A,D		; Get last precedence value
   0ADB 17            [ 4] 2100 	RLA			; Times 2 plus carry
   0ADC 5F            [ 4] 2101 	LD	E,A		; To E
q  0ADD 16 40         [ 7] 2102 	LD	D,64H		; Relational precedence
   0ADF 78            [ 4] 2103 	LD	A,B		; Get current precedence
   0AE0 BA            [ 4] 2104 	CP	D		; Compare with last
   0AE1 D0            [11] 2105 	RET	NC		; Eval if last was rel' or log'
   0AE2 C3 E5 09      [10] 2106 	JP	STKTHS		; Stack this one and get next
                           2107 ;
o  0AE5                    2108 CMPLOG: DW	CMPLG1		; Compare two values / strings
   0AE5 79            [ 4] 2109 CMPLG1: LD	A,C		; Get data type
   0AE6 B7            [ 4] 2110 	OR	A
   0AE7 1F            [ 4] 2111 	RRA
   0AE8 C1            [10] 2112 	POP	BC		; Get last expression to BCDE
   0AE9 D1            [10] 2113 	POP	DE
   0AEA F5            [11] 2114 	PUSH	AF		; Save status
   0AEB CD 7B 09      [17] 2115 	CALL	CHKTYP		; Check that types match
   0AEE 21 27 0B      [10] 2116 	LD	HL,CMPRES	; Result to comparison
   0AF1 E5            [11] 2117 	PUSH	HL		; Save for RETurn
   0AF2 CA 80 13      [10] 2118 	JP	Z,CMPNUM	; Compare values if numeric
   0AF5 AF            [ 4] 2119 	XOR	A		; Compare two strings
u  0AF6 32 00 00      [13] 2120 	LD	(TYPE),A	; Set type to numeric
   0AF9 D5            [11] 2121 	PUSH	DE		; Save string name
   0AFA CD 67 0F      [17] 2122 	CALL	GSTRCU		; Get current string
   0AFD 7E            [ 7] 2123 	LD	A,(HL)		; Get length of string
   0AFE 23            [ 6] 2124 	INC	HL
   0AFF 23            [ 6] 2125 	INC	HL
   0B00 4E            [ 7] 2126 	LD	C,(HL)		; Get LSB of address
   0B01 23            [ 6] 2127 	INC	HL
   0B02 46            [ 7] 2128 	LD	B,(HL)		; Get MSB of address
   0B03 D1            [10] 2129 	POP	DE		; Restore string name
   0B04 C5            [11] 2130 	PUSH	BC		; Save address of string
   0B05 F5            [11] 2131 	PUSH	AF		; Save length of string
   0B06 CD 6B 0F      [17] 2132 	CALL	GSTRDE		; Get second string
   0B09 CD 54 13      [17] 2133 	CALL	LOADFP		; Get address of second string
   0B0C F1            [10] 2134 	POP	AF		; Restore length of string 1
   0B0D 57            [ 4] 2135 	LD	D,A		; Length to D
   0B0E E1            [10] 2136 	POP	HL		; Restore address of string 1
   0B0F 7B            [ 4] 2137 CMPSTR: LD	A,E		; Bytes of string 2 to do
   0B10 B2            [ 4] 2138 	OR	D		; Bytes of string 1 to do
   0B11 C8            [11] 2139 	RET	Z		; Exit if all bytes compared
   0B12 7A            [ 4] 2140 	LD	A,D		; Get bytes of string 1 to do
   0B13 D6 01         [ 7] 2141 	SUB	1
   0B15 D8            [11] 2142 	RET	C		; Exit if end of string 1
   0B16 AF            [ 4] 2143 	XOR	A
   0B17 BB            [ 4] 2144 	CP	E		; Bytes of string 2 to do
   0B18 3C            [ 4] 2145 	INC	A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 40
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0B19 D0            [11] 2146 	RET	NC		; Exit if end of string 2
   0B1A 15            [ 4] 2147 	DEC	D		; Count bytes in string 1
   0B1B 1D            [ 4] 2148 	DEC	E		; Count bytes in string 2
   0B1C 0A            [ 7] 2149 	LD	A,(BC)		; Byte in string 2
   0B1D BE            [ 7] 2150 	CP	(HL)		; Compare to byte in string 1
   0B1E 23            [ 6] 2151 	INC	HL		; Move up string 1
   0B1F 03            [ 6] 2152 	INC	BC		; Move up string 2
   0B20 CA 0F 0B      [10] 2153 	JP	Z,CMPSTR	; Same - Try next bytes
   0B23 3F            [ 4] 2154 	CCF			; Flag difference (">" or "<")
   0B24 C3 12 13      [10] 2155 	JP	FLGDIF		; "<" gives -1 , ">" gives +1
                           2156 ;
   0B27 3C            [ 4] 2157 CMPRES: INC	A		; Increment current value
   0B28 8F            [ 4] 2158 	ADC	A,A		; Double plus carry
   0B29 C1            [10] 2159 	POP	BC		; Get other value
   0B2A A0            [ 4] 2160 	AND	B		; Combine them
   0B2B C6 FF         [ 7] 2161 	ADD	A,-1		; Carry set if different
   0B2D 9F            [ 4] 2162 	SBC	A,A		; 00 - Equal , FF - Different
   0B2E C3 19 13      [10] 2163 	JP	FLGREL		; Set current value & continue
                           2164 ;
kq 0B31 16 05         [ 7] 2165 EVNOT:	LD	D,5AH		; Precedence value for "NOT"
   0B33 CD 8A 09      [17] 2166 	CALL	EVAL1		; Eval until precedence break
   0B36 CD 7A 09      [17] 2167 	CALL	TSTNUM		; Make sure it's a number
   0B39 CD 01 06      [17] 2168 	CALL	DEINT		; Get integer -32768 - 32767
   0B3C 7B            [ 4] 2169 	LD	A,E		; Get LSB
   0B3D 2F            [ 4] 2170 	CPL			; Invert LSB
   0B3E 4F            [ 4] 2171 	LD	C,A		; Save "NOT" of LSB
   0B3F 7A            [ 4] 2172 	LD	A,D		; Get MSB
   0B40 2F            [ 4] 2173 	CPL			; Invert MSB
   0B41 CD 0E 0D      [17] 2174 	CALL	ACPASS		; Save AC as current
   0B44 C1            [10] 2175 	POP	BC		; Clean up stack
   0B45 C3 96 09      [10] 2176 	JP	EVAL3		; Continue evaluation
                           2177 ;
   0B48 2B            [ 6] 2178 DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
   0B49 CD 5F 05      [17] 2179 	CALL	GETCHR		; Get next character
   0B4C C8            [11] 2180 	RET	Z		; End of DIM statement
   0B4D CD DE 03      [17] 2181 	CALL	CHKSYN		; Make sure ',' follows
                           2182 	DB	','
   0B50 01 48 0B      [10] 2183 DIM:	LD	BC,DIMRET	; Return to "DIMRET"
   0B53 C5            [11] 2184 	PUSH	BC		; Save on stack
                           2185 	DB	0F6H		; Flag "Create" variable
   0B54 AF            [ 4] 2186 GETVAR: XOR	A		; Find variable address,to DE
u  0B55 32 00 00      [13] 2187 	LD	(LCRFLG),A	; Set locate / create flag
   0B58 46            [ 7] 2188 	LD	B,(HL)		; Get First byte of name
   0B59 CD F1 05      [17] 2189 GTFNAM: CALL	CHKLTR		; See if a letter
   0B5C DA 38 01      [10] 2190 	JP	C,SNERR		; ?SN Error if not a letter
   0B5F AF            [ 4] 2191 	XOR	A
   0B60 4F            [ 4] 2192 	LD	C,A		; Clear second byte of name
u  0B61 32 00 00      [13] 2193 	LD	(TYPE),A	; Set type to numeric
   0B64 CD 5F 05      [17] 2194 	CALL	GETCHR		; Get next character
   0B67 DA 70 0B      [10] 2195 	JP	C,SVNAM2	; Numeric - Save in name
   0B6A CD F1 05      [17] 2196 	CALL	CHKLTR		; See if a letter
   0B6D DA 7D 0B      [10] 2197 	JP	C,CHARTY	; Not a letter - Check type
   0B70 4F            [ 4] 2198 SVNAM2: LD	C,A		; Save second byte of name
   0B71 CD 5F 05      [17] 2199 ENDNAM: CALL	GETCHR		; Get next character
   0B74 DA 71 0B      [10] 2200 	JP	C,ENDNAM	; Numeric - Get another
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 41
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0B77 CD F1 05      [17] 2201 	CALL	CHKLTR		; See if a letter
   0B7A D2 71 0B      [10] 2202 	JP	NC,ENDNAM	; Letter - Get another
q  0B7D                    2203 CHARTY: SUB	'$'		; String variable?
   0B7D C2 8A 0B      [10] 2204 	JP	NZ,NOTSTR	; No - Numeric variable
   0B80 3C            [ 4] 2205 	INC	A		; A = 1 (string type)
u  0B81 32 00 00      [13] 2206 	LD	(TYPE),A	; Set type to string
   0B84 0F            [ 4] 2207 	RRCA			; A = 80H , Flag for string
   0B85 81            [ 4] 2208 	ADD	A,C		; 2nd byte of name has bit 7 on
   0B86 4F            [ 4] 2209 	LD	C,A		; Resave second byte on name
   0B87 CD 5F 05      [17] 2210 	CALL	GETCHR		; Get next character
u  0B8A 3A 00 00      [13] 2211 NOTSTR: LD	A,(FORFLG)	; Array name needed ?
   0B8D 3D            [ 4] 2212 	DEC	A
   0B8E CA 31 0C      [10] 2213 	JP	Z,ARLDSV	; Yes - Get array name
   0B91 F2 98 0B      [10] 2214 	JP	P,NSCFOR	; No array with "FOR" or "FN"
   0B94 7E            [ 7] 2215 	LD	A,(HL)		; Get byte again
q  0B95                    2216 	SUB	'('		; Subscripted variable?
   0B95 CA 0D 0C      [10] 2217 	JP	Z,SBSCPT	; Yes - Sort out subscript
                           2218 ;
   0B98 AF            [ 4] 2219 NSCFOR: XOR	A		; Simple variable
u  0B99 32 00 00      [13] 2220 	LD	(FORFLG),A	; Clear "FOR" flag
   0B9C E5            [11] 2221 	PUSH	HL		; Save code string address
   0B9D 50            [ 4] 2222 	LD	D,B		; DE = Variable name to find
   0B9E 59            [ 4] 2223 	LD	E,C
u  0B9F 2A 00 00      [16] 2224 	LD	HL,(FNRGNM)	; FN argument name
   0BA2 CD D8 03      [17] 2225 	CALL	CPDEHL		; Is it the FN argument?
u  0BA5 11 00 00      [10] 2226 	LD	DE,FNARG	; Point to argument value
   0BA8 CA 4A 12      [10] 2227 	JP	Z,POPHRT	; Yes - Return FN argument value
u  0BAB 2A 00 00      [16] 2228 	LD	HL,(VAREND)	; End of variables
   0BAE EB            [ 4] 2229 	EX	DE,HL		; Address of end of search
u  0BAF 2A 00 00      [16] 2230 	LD	HL,(PROGND)	; Start of variables address
   0BB2 CD D8 03      [17] 2231 FNDVAR: CALL	CPDEHL		; End of variable list table?
   0BB5 CA CB 0B      [10] 2232 	JP	Z,CFEVAL	; Yes - Called from EVAL?
   0BB8 79            [ 4] 2233 	LD	A,C		; Get second byte of name
   0BB9 96            [ 7] 2234 	SUB	(HL)		; Compare with name in list
   0BBA 23            [ 6] 2235 	INC	HL		; Move on to first byte
   0BBB C2 C0 0B      [10] 2236 	JP	NZ,FNTHR	; Different - Find another
   0BBE 78            [ 4] 2237 	LD	A,B		; Get first byte of name
   0BBF 96            [ 7] 2238 	SUB	(HL)		; Compare with name in list
   0BC0 23            [ 6] 2239 FNTHR:	INC	HL		; Move on to LSB of value
   0BC1 CA FF 0B      [10] 2240 	JP	Z,RETADR	; Found - Return address
   0BC4 23            [ 6] 2241 	INC	HL		; <- Skip
   0BC5 23            [ 6] 2242 	INC	HL		; <- over
   0BC6 23            [ 6] 2243 	INC	HL		; <- F.P.
   0BC7 23            [ 6] 2244 	INC	HL		; <- value
   0BC8 C3 B2 0B      [10] 2245 	JP	FNDVAR		; Keep looking
                           2246 ;
   0BCB E1            [10] 2247 CFEVAL: POP	HL		; Restore code string address
   0BCC E3            [19] 2248 	EX	(SP),HL		; Get return address
   0BCD D5            [11] 2249 	PUSH	DE		; Save address of variable
   0BCE 11 5B 0A      [10] 2250 	LD	DE,FRMEVL	; Return address in EVAL
   0BD1 CD D8 03      [17] 2251 	CALL	CPDEHL		; Called from EVAL ?
   0BD4 D1            [10] 2252 	POP	DE		; Restore address of variable
   0BD5 CA 02 0C      [10] 2253 	JP	Z,RETNUL	; Yes - Return null variable
   0BD8 E3            [19] 2254 	EX	(SP),HL		; Put back return
   0BD9 E5            [11] 2255 	PUSH	HL		; Save code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 42
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0BDA C5            [11] 2256 	PUSH	BC		; Save variable name
   0BDB 01 06 00      [10] 2257 	LD	BC,6		; 2 byte name plus 4 byte data
u  0BDE 2A 00 00      [16] 2258 	LD	HL,(ARREND)	; End of arrays
   0BE1 E5            [11] 2259 	PUSH	HL		; Save end of arrays
   0BE2 09            [11] 2260 	ADD	HL,BC		; Move up 6 bytes
   0BE3 C1            [10] 2261 	POP	BC		; Source address in BC
   0BE4 E5            [11] 2262 	PUSH	HL		; Save new end address
   0BE5 CD 05 01      [17] 2263 	CALL	MOVUP		; Move arrays up
   0BE8 E1            [10] 2264 	POP	HL		; Restore new end address
u  0BE9 22 00 00      [16] 2265 	LD	(ARREND),HL	; Set new end address
   0BEC 60            [ 4] 2266 	LD	H,B		; End of variables to HL
   0BED 69            [ 4] 2267 	LD	L,C
u  0BEE 22 00 00      [16] 2268 	LD	(VAREND),HL	; Set new end address
                           2269 ;
   0BF1 2B            [ 6] 2270 ZEROLP: DEC	HL		; Back through to zero variable
   0BF2 36 00         [10] 2271 	LD	(HL),0		; Zero byte in variable
   0BF4 CD D8 03      [17] 2272 	CALL	CPDEHL		; Done them all?
   0BF7 C2 F1 0B      [10] 2273 	JP	NZ,ZEROLP	; No - Keep on going
   0BFA D1            [10] 2274 	POP	DE		; Get variable name
   0BFB 73            [ 7] 2275 	LD	(HL),E		; Store second character
   0BFC 23            [ 6] 2276 	INC	HL
   0BFD 72            [ 7] 2277 	LD	(HL),D		; Store first character
   0BFE 23            [ 6] 2278 	INC	HL
   0BFF EB            [ 4] 2279 RETADR: EX	DE,HL		; Address of variable in DE
   0C00 E1            [10] 2280 	POP	HL		; Restore code string address
   0C01 C9            [10] 2281 	RET
                           2282 ;
u  0C02 32 00 00      [13] 2283 RETNUL: LD	(FPEXP),A	; Set result to zero
u  0C05 21 00 00      [10] 2284 	LD	HL,ZERBYT	; Also set a null string
u  0C08 22 00 00      [16] 2285 	LD	(FPREG),HL	; Save for EVAL
   0C0B E1            [10] 2286 	POP	HL		; Restore code string address
   0C0C C9            [10] 2287 	RET
                           2288 ;
   0C0D E5            [11] 2289 SBSCPT: PUSH	HL		; Save code string address
u  0C0E 2A 00 00      [16] 2290 	LD	HL,(LCRFLG)	; Locate/Create and Type
   0C11 E3            [19] 2291 	EX	(SP),HL		; Save and get code string
   0C12 57            [ 4] 2292 	LD	D,A		; Zero number of dimensions
   0C13 D5            [11] 2293 SCPTLP: PUSH	DE		; Save number of dimensions
   0C14 C5            [11] 2294 	PUSH	BC		; Save array name
   0C15 CD F5 05      [17] 2295 	CALL	FPSINT		; Get subscript (0-32767)
   0C18 C1            [10] 2296 	POP	BC		; Restore array name
   0C19 F1            [10] 2297 	POP	AF		; Get number of dimensions
   0C1A EB            [ 4] 2298 	EX	DE,HL
   0C1B E3            [19] 2299 	EX	(SP),HL		; Save subscript value
   0C1C E5            [11] 2300 	PUSH	HL		; Save LCRFLG and TYPE
   0C1D EB            [ 4] 2301 	EX	DE,HL
   0C1E 3C            [ 4] 2302 	INC	A		; Count dimensions
   0C1F 57            [ 4] 2303 	LD	D,A		; Save in D
   0C20 7E            [ 7] 2304 	LD	A,(HL)		; Get next byte in code string
q  0C21                    2305 	CP	','		; Comma (more to come)?
   0C21 CA 13 0C      [10] 2306 	JP	Z,SCPTLP	; Yes - More subscripts
   0C24 CD DE 03      [17] 2307 	CALL	CHKSYN		; Make sure ")" follows
                           2308 	DB	")"
u  0C27 22 00 00      [16] 2309 	LD	(NXTOPR),HL	; Save code string address
   0C2A E1            [10] 2310 	POP	HL		; Get LCRFLG and TYPE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 43
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  0C2B 22 00 00      [16] 2311 	LD	(LCRFLG),HL	; Restore Locate/create & type
   0C2E 1E 00         [ 7] 2312 	LD	E,0		; Flag not CSAVE* or CLOAD*
   0C30 D5            [11] 2313 	PUSH	DE		; Save number of dimensions (D)
                           2314 	DB	11H		; Skip "PUSH HL" and "PUSH AF'
                           2315 ;
   0C31 E5            [11] 2316 ARLDSV: PUSH	HL		; Save code string address
   0C32 F5            [11] 2317 	PUSH	AF		; A = 00 , Flags set = Z,N
u  0C33 2A 00 00      [16] 2318 	LD	HL,(VAREND)	; Start of arrays
                           2319 	DB	3EH		; Skip "ADD HL,DE"
   0C36 19            [11] 2320 FNDARY: ADD	HL,DE		; Move to next array start
   0C37 EB            [ 4] 2321 	EX	DE,HL
u  0C38 2A 00 00      [16] 2322 	LD	HL,(ARREND)	; End of arrays
   0C3B EB            [ 4] 2323 	EX	DE,HL		; Current array pointer
   0C3C CD D8 03      [17] 2324 	CALL	CPDEHL		; End of arrays found?
   0C3F CA 68 0C      [10] 2325 	JP	Z,CREARY	; Yes - Create array
   0C42 7E            [ 7] 2326 	LD	A,(HL)		; Get second byte of name
   0C43 B9            [ 4] 2327 	CP	C		; Compare with name given
   0C44 23            [ 6] 2328 	INC	HL		; Move on
   0C45 C2 4A 0C      [10] 2329 	JP	NZ,NXTARY	; Different - Find next array
   0C48 7E            [ 7] 2330 	LD	A,(HL)		; Get first byte of name
   0C49 B8            [ 4] 2331 	CP	B		; Compare with name given
   0C4A 23            [ 6] 2332 NXTARY: INC	HL		; Move on
   0C4B 5E            [ 7] 2333 	LD	E,(HL)		; Get LSB of next array address
   0C4C 23            [ 6] 2334 	INC	HL
   0C4D 56            [ 7] 2335 	LD	D,(HL)		; Get MSB of next array address
   0C4E 23            [ 6] 2336 	INC	HL
   0C4F C2 36 0C      [10] 2337 	JP	NZ,FNDARY	; Not found - Keep looking
u  0C52 3A 00 00      [13] 2338 	LD	A,(LCRFLG)	; Found Locate or Create it?
   0C55 B7            [ 4] 2339 	OR	A
   0C56 C2 3E 01      [10] 2340 	JP	NZ,DDERR	; Create - ?DD Error
   0C59 F1            [10] 2341 	POP	AF		; Locate - Get number of dim'ns
   0C5A 44            [ 4] 2342 	LD	B,H		; BC Points to array dim'ns
   0C5B 4D            [ 4] 2343 	LD	C,L
   0C5C CA 4A 12      [10] 2344 	JP	Z,POPHRT	; Jump if array load/save
   0C5F 96            [ 7] 2345 	SUB	(HL)		; Same number of dimensions?
   0C60 CA C6 0C      [10] 2346 	JP	Z,FINDEL	; Yes - Find element
u  0C63 1E 00         [ 7] 2347 BSERR:	LD	E,BS		; ?BS Error
   0C65 C3 46 01      [10] 2348 	JP	ERROR		; Output error
                           2349 ;
   0C68 11 04 00      [10] 2350 CREARY: LD	DE,4		; 4 Bytes per entry
   0C6B F1            [10] 2351 	POP	AF		; Array to save or 0 dim'ns?
   0C6C CA 14 06      [10] 2352 	JP	Z,FCERR		; Yes - ?FC Error
   0C6F 71            [ 7] 2353 	LD	(HL),C		; Save second byte of name
   0C70 23            [ 6] 2354 	INC	HL
   0C71 70            [ 7] 2355 	LD	(HL),B		; Save first byte of name
   0C72 23            [ 6] 2356 	INC	HL
   0C73 4F            [ 4] 2357 	LD	C,A		; Number of dimensions to C
   0C74 CD 16 01      [17] 2358 	CALL	CHKSTK		; Check if enough memory
   0C77 23            [ 6] 2359 	INC	HL		; Point to number of dimensions
   0C78 23            [ 6] 2360 	INC	HL
u  0C79 22 00 00      [16] 2361 	LD	(CUROPR),HL	; Save address of pointer
   0C7C 71            [ 7] 2362 	LD	(HL),C		; Set number of dimensions
   0C7D 23            [ 6] 2363 	INC	HL
u  0C7E 3A 00 00      [13] 2364 	LD	A,(LCRFLG)	; Locate of Create?
   0C81 17            [ 4] 2365 	RLA			; Carry set = Create
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 44
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0C82 79            [ 4] 2366 	LD	A,C		; Get number of dimensions
   0C83 01 0B 00      [10] 2367 CRARLP: LD	BC,10+1		; Default dimension size 10
   0C86 D2 8B 0C      [10] 2368 	JP	NC,DEFSIZ	; Locate - Set default size
   0C89 C1            [10] 2369 	POP	BC		; Get specified dimension size
   0C8A 03            [ 6] 2370 	INC	BC		; Include zero element
   0C8B 71            [ 7] 2371 DEFSIZ: LD	(HL),C		; Save LSB of dimension size
   0C8C 23            [ 6] 2372 	INC	HL
   0C8D 70            [ 7] 2373 	LD	(HL),B		; Save MSB of dimension size
   0C8E 23            [ 6] 2374 	INC	HL
   0C8F F5            [11] 2375 	PUSH	AF		; Save num' of dim'ns an status
   0C90 E5            [11] 2376 	PUSH	HL		; Save address of dim'n size
   0C91 CD EF 13      [17] 2377 	CALL	MLDEBC		; Multiply DE by BC to find
   0C94 EB            [ 4] 2378 	EX	DE,HL		; amount of mem needed (to DE)
   0C95 E1            [10] 2379 	POP	HL		; Restore address of dimension
   0C96 F1            [10] 2380 	POP	AF		; Restore number of dimensions
   0C97 3D            [ 4] 2381 	DEC	A		; Count them
   0C98 C2 83 0C      [10] 2382 	JP	NZ,CRARLP	; Do next dimension if more
   0C9B F5            [11] 2383 	PUSH	AF		; Save locate/create flag
   0C9C 42            [ 4] 2384 	LD	B,D		; MSB of memory needed
   0C9D 4B            [ 4] 2385 	LD	C,E		; LSB of memory needed
   0C9E EB            [ 4] 2386 	EX	DE,HL
   0C9F 19            [11] 2387 	ADD	HL,DE		; Add bytes to array start
   0CA0 DA 2D 01      [10] 2388 	JP	C,OMERR		; Too big - Error
   0CA3 CD 1E 01      [17] 2389 	CALL	ENFMEM		; See if enough memory
u  0CA6 22 00 00      [16] 2390 	LD	(ARREND),HL	; Save new end of array
                           2391 ;
   0CA9 2B            [ 6] 2392 ZERARY: DEC	HL		; Back through array data
   0CAA 36 00         [10] 2393 	LD	(HL),0		; Set array element to zero
   0CAC CD D8 03      [17] 2394 	CALL	CPDEHL		; All elements zeroed?
   0CAF C2 A9 0C      [10] 2395 	JP	NZ,ZERARY	; No - Keep on going
   0CB2 03            [ 6] 2396 	INC	BC		; Number of bytes + 1
   0CB3 57            [ 4] 2397 	LD	D,A		; A=0
u  0CB4 2A 00 00      [16] 2398 	LD	HL,(CUROPR)	; Get address of array
   0CB7 5E            [ 7] 2399 	LD	E,(HL)		; Number of dimensions
   0CB8 EB            [ 4] 2400 	EX	DE,HL		; To HL
   0CB9 29            [11] 2401 	ADD	HL,HL		; Two bytes per dimension size
   0CBA 09            [11] 2402 	ADD	HL,BC		; Add number of bytes
   0CBB EB            [ 4] 2403 	EX	DE,HL		; Bytes needed to DE
   0CBC 2B            [ 6] 2404 	DEC	HL
   0CBD 2B            [ 6] 2405 	DEC	HL
   0CBE 73            [ 7] 2406 	LD	(HL),E		; Save LSB of bytes needed
   0CBF 23            [ 6] 2407 	INC	HL
   0CC0 72            [ 7] 2408 	LD	(HL),D		; Save MSB of bytes needed
   0CC1 23            [ 6] 2409 	INC	HL
   0CC2 F1            [10] 2410 	POP	AF		; Locate / Create?
   0CC3 DA E9 0C      [10] 2411 	JP	C,ENDDIM	; A is 0 , End if create
   0CC6 47            [ 4] 2412 FINDEL: LD	B,A		; Find array element
   0CC7 4F            [ 4] 2413 	LD	C,A
   0CC8 7E            [ 7] 2414 	LD	A,(HL)		; Number of dimensions
   0CC9 23            [ 6] 2415 	INC	HL
                           2416 	DB	16H		; Skip "POP HL"
   0CCA E1            [10] 2417 FNDELP: POP	HL		; Address of next dim' size
   0CCB 5E            [ 7] 2418 	LD	E,(HL)		; Get LSB of dim'n size
   0CCC 23            [ 6] 2419 	INC	HL
   0CCD 56            [ 7] 2420 	LD	D,(HL)		; Get MSB of dim'n size
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 45
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0CCE 23            [ 6] 2421 	INC	HL
   0CCF E3            [19] 2422 	EX	(SP),HL		; Save address - Get index
   0CD0 F5            [11] 2423 	PUSH	AF		; Save number of dim'ns
   0CD1 CD D8 03      [17] 2424 	CALL	CPDEHL		; Dimension too large?
   0CD4 D2 63 0C      [10] 2425 	JP	NC,BSERR	; Yes - ?BS Error
   0CD7 E5            [11] 2426 	PUSH	HL		; Save index
   0CD8 CD EF 13      [17] 2427 	CALL	MLDEBC		; Multiply previous by size
   0CDB D1            [10] 2428 	POP	DE		; Index supplied to DE
   0CDC 19            [11] 2429 	ADD	HL,DE		; Add index to pointer
   0CDD F1            [10] 2430 	POP	AF		; Number of dimensions
   0CDE 3D            [ 4] 2431 	DEC	A		; Count them
   0CDF 44            [ 4] 2432 	LD	B,H		; MSB of pointer
   0CE0 4D            [ 4] 2433 	LD	C,L		; LSB of pointer
   0CE1 C2 CA 0C      [10] 2434 	JP	NZ,FNDELP	; More - Keep going
   0CE4 29            [11] 2435 	ADD	HL,HL		; 4 Bytes per element
   0CE5 29            [11] 2436 	ADD	HL,HL
   0CE6 C1            [10] 2437 	POP	BC		; Start of array
   0CE7 09            [11] 2438 	ADD	HL,BC		; Point to element
   0CE8 EB            [ 4] 2439 	EX	DE,HL		; Address of element to DE
u  0CE9 2A 00 00      [16] 2440 ENDDIM: LD	HL,(NXTOPR)	; Got code string address
   0CEC C9            [10] 2441 	RET
                           2442 ;
u  0CED 2A 00 00      [16] 2443 FRE:	LD	HL,(ARREND)	; Start of free memory
   0CF0 EB            [ 4] 2444 	EX	DE,HL		; To DE
   0CF1 21 00 00      [10] 2445 	LD	HL,0		; End of free memory
   0CF4 39            [11] 2446 	ADD	HL,SP		; Current stack value
u  0CF5 3A 00 00      [13] 2447 	LD	A,(TYPE)	; Dummy argument type
   0CF8 B7            [ 4] 2448 	OR	A
   0CF9 CA 09 0D      [10] 2449 	JP	Z,FRENUM	; Numeric - Free variable space
   0CFC CD 67 0F      [17] 2450 	CALL	GSTRCU		; Current string to pool
   0CFF CD 69 0E      [17] 2451 	CALL	GARBGE		; Garbage collection
u  0D02 2A 00 00      [16] 2452 	LD	HL,(STRSPC)	; Bottom of string space in use
   0D05 EB            [ 4] 2453 	EX	DE,HL		; To DE
u  0D06 2A 00 00      [16] 2454 	LD	HL,(STRBOT)	; Bottom of string space
   0D09 7D            [ 4] 2455 FRENUM: LD	A,L		; Get LSB of end
   0D0A 93            [ 4] 2456 	SUB	E		; Subtract LSB of beginning
   0D0B 4F            [ 4] 2457 	LD	C,A		; Save difference if C
   0D0C 7C            [ 4] 2458 	LD	A,H		; Get MSB of end
   0D0D 9A            [ 4] 2459 	SBC	A,D		; Subtract MSB of beginning
   0D0E 41            [ 4] 2460 ACPASS: LD	B,C		; Return integer AC
   0D0F 50            [ 4] 2461 ABPASS: LD	D,B		; Return integer AB
   0D10 1E 00         [ 7] 2462 	LD	E,0
u  0D12 21 00 00      [10] 2463 	LD	HL,TYPE		; Point to type
   0D15 73            [ 7] 2464 	LD	(HL),E		; Set type to numeric
q  0D16 06 50         [ 7] 2465 	LD	B,80H+16	; 16 bit integer
   0D18 C3 1E 13      [10] 2466 	JP	RETINT		; Return the integr
                           2467 ;
u  0D1B 3A 00 00      [13] 2468 POS:	LD	A,(CURPOS)	; Get cursor position
   0D1E 47            [ 4] 2469 PASSA:	LD	B,A		; Put A into AB
   0D1F AF            [ 4] 2470 	XOR	A		; Zero A
   0D20 C3 0F 0D      [10] 2471 	JP	ABPASS		; Return integer AB
                           2472 ;
   0D23 CD A3 0D      [17] 2473 DEF:	CALL	CHEKFN		; Get "FN" and name
   0D26 CD 95 0D      [17] 2474 	CALL	IDTEST		; Test for illegal direct
   0D29 01 E0 06      [10] 2475 	LD	BC,DATA		; To get next statement
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 46
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0D2C C5            [11] 2476 	PUSH	BC		; Save address for RETurn
   0D2D D5            [11] 2477 	PUSH	DE		; Save address of function ptr
   0D2E CD DE 03      [17] 2478 	CALL	CHKSYN		; Make sure "(" follows
                           2479 	DB	"("
   0D31 CD 54 0B      [17] 2480 	CALL	GETVAR		; Get argument variable name
   0D34 E5            [11] 2481 	PUSH	HL		; Save code string address
   0D35 EB            [ 4] 2482 	EX	DE,HL		; Argument address to HL
   0D36 2B            [ 6] 2483 	DEC	HL
   0D37 56            [ 7] 2484 	LD	D,(HL)		; Get first byte of arg name
   0D38 2B            [ 6] 2485 	DEC	HL
   0D39 5E            [ 7] 2486 	LD	E,(HL)		; Get second byte of arg name
   0D3A E1            [10] 2487 	POP	HL		; Restore code string address
   0D3B CD 7A 09      [17] 2488 	CALL	TSTNUM		; Make sure numeric argument
   0D3E CD DE 03      [17] 2489 	CALL	CHKSYN		; Make sure ")" follows
                           2490 	DB	")"
   0D41 CD DE 03      [17] 2491 	CALL	CHKSYN		; Make sure "=" follows
o  0D44                    2492 	DB	ZEQUAL		; "=" token
   0D44 44            [ 4] 2493 	LD	B,H		; Code string address to BC
   0D45 4D            [ 4] 2494 	LD	C,L
   0D46 E3            [19] 2495 	EX	(SP),HL		; Save code str , Get FN ptr
   0D47 71            [ 7] 2496 	LD	(HL),C		; Save LSB of FN code string
   0D48 23            [ 6] 2497 	INC	HL
   0D49 70            [ 7] 2498 	LD	(HL),B		; Save MSB of FN code string
   0D4A C3 E1 0D      [10] 2499 	JP	SVSTAD		; Save address and do function
                           2500 ;
   0D4D CD A3 0D      [17] 2501 DOFN:	CALL	CHEKFN		; Make sure FN follows
   0D50 D5            [11] 2502 	PUSH	DE		; Save function pointer address
   0D51 CD 40 0A      [17] 2503 	CALL	EVLPAR		; Evaluate expression in "()"
   0D54 CD 7A 09      [17] 2504 	CALL	TSTNUM		; Make sure numeric result
   0D57 E3            [19] 2505 	EX	(SP),HL		; Save code str , Get FN ptr
   0D58 5E            [ 7] 2506 	LD	E,(HL)		; Get LSB of FN code string
   0D59 23            [ 6] 2507 	INC	HL
   0D5A 56            [ 7] 2508 	LD	D,(HL)		; Get MSB of FN code string
   0D5B 23            [ 6] 2509 	INC	HL
   0D5C 7A            [ 4] 2510 	LD	A,D		; And function DEFined?
   0D5D B3            [ 4] 2511 	OR	E
   0D5E CA 40 01      [10] 2512 	JP	Z,UFERR		; No - ?UF Error
   0D61 7E            [ 7] 2513 	LD	A,(HL)		; Get LSB of argument address
   0D62 23            [ 6] 2514 	INC	HL
   0D63 66            [ 7] 2515 	LD	H,(HL)		; Get MSB of argument address
   0D64 6F            [ 4] 2516 	LD	L,A		; HL = Arg variable address
   0D65 E5            [11] 2517 	PUSH	HL		; Save it
u  0D66 2A 00 00      [16] 2518 	LD	HL,(FNRGNM)	; Get old argument name
   0D69 E3            [19] 2519 	EX	(SP),HL;	; Save old , Get new
u  0D6A 22 00 00      [16] 2520 	LD	(FNRGNM),HL	; Set new argument name
u  0D6D 2A 02 00      [16] 2521 	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
   0D70 E5            [11] 2522 	PUSH	HL		; Save it
u  0D71 2A 00 00      [16] 2523 	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
   0D74 E5            [11] 2524 	PUSH	HL		; Save it
u  0D75 21 00 00      [10] 2525 	LD	HL,FNARG	; HL = Value of argument
   0D78 D5            [11] 2526 	PUSH	DE		; Save FN code string address
   0D79 CD 5D 13      [17] 2527 	CALL	FPTHL		; Move FPREG to argument
   0D7C E1            [10] 2528 	POP	HL		; Get FN code string address
   0D7D CD 77 09      [17] 2529 	CALL	GETNUM		; Get value from function
   0D80 2B            [ 6] 2530 	DEC	HL		; DEC 'cos GETCHR INCs
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 47
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0D81 CD 5F 05      [17] 2531 	CALL	GETCHR		; Get next character
   0D84 C2 38 01      [10] 2532 	JP	NZ,SNERR	; Bad character in FN - Error
   0D87 E1            [10] 2533 	POP	HL		; Get MSB,EXP of old arg
u  0D88 22 00 00      [16] 2534 	LD	(FNARG),HL	; Restore it
   0D8B E1            [10] 2535 	POP	HL		; Get LSB,NLSB of old arg
u  0D8C 22 02 00      [16] 2536 	LD	(FNARG+2),HL	; Restore it
   0D8F E1            [10] 2537 	POP	HL		; Get name of old arg
u  0D90 22 00 00      [16] 2538 	LD	(FNRGNM),HL	; Restore it
   0D93 E1            [10] 2539 	POP	HL		; Restore code string address
   0D94 C9            [10] 2540 	RET
                           2541 ;
   0D95 E5            [11] 2542 IDTEST: PUSH	HL		; Save code string address
u  0D96 2A 00 00      [16] 2543 	LD	HL,(LINEAT)	; Get current line number
   0D99 23            [ 6] 2544 	INC	HL		; -1 means direct statement
   0D9A 7C            [ 4] 2545 	LD	A,H
   0D9B B5            [ 4] 2546 	OR	L
   0D9C E1            [10] 2547 	POP	HL		; Restore code string address
   0D9D C0            [11] 2548 	RET	NZ		; Return if in program
u  0D9E 1E 00         [ 7] 2549 	LD	E,ID		; ?ID Error
   0DA0 C3 46 01      [10] 2550 	JP	ERROR
                           2551 ;
   0DA3 CD DE 03      [17] 2552 CHEKFN: CALL	CHKSYN		; Make sure FN follows
o  0DA6                    2553 	DB	ZFN		; "FN" token
q  0DA6 3E 50         [ 7] 2554 	LD	A,80H
u  0DA8 32 00 00      [13] 2555 	LD	(FORFLG),A	; Flag FN name to find
   0DAB B6            [ 7] 2556 	OR	(HL)		; FN name has bit 7 set
   0DAC 47            [ 4] 2557 	LD	B,A		; in first byte of name
   0DAD CD 59 0B      [17] 2558 	CALL	GTFNAM		; Get FN name
   0DB0 C3 7A 09      [10] 2559 	JP	TSTNUM		; Make sure numeric function
                           2560 ;
   0DB3 CD 7A 09      [17] 2561 STR:	CALL	TSTNUM		; Make sure it's a number
   0DB6 CD 9C 14      [17] 2562 	CALL	NUMASC		; Turn number into text
   0DB9 CD E7 0D      [17] 2563 STR1:	CALL	CRTST		; Create string entry for it
   0DBC CD 67 0F      [17] 2564 	CALL	GSTRCU		; Current string to pool
   0DBF 01 C2 0F      [10] 2565 	LD	BC,TOPOOL	; Save in string pool
   0DC2 C5            [11] 2566 	PUSH	BC		; Save address on stack
                           2567 ;
   0DC3 7E            [ 7] 2568 SAVSTR: LD	A,(HL)		; Get string length
   0DC4 23            [ 6] 2569 	INC	HL
   0DC5 23            [ 6] 2570 	INC	HL
   0DC6 E5            [11] 2571 	PUSH	HL		; Save pointer to string
   0DC7 CD 40 0E      [17] 2572 	CALL	TESTR		; See if enough string space
   0DCA E1            [10] 2573 	POP	HL		; Restore pointer to string
   0DCB 4E            [ 7] 2574 	LD	C,(HL)		; Get LSB of address
   0DCC 23            [ 6] 2575 	INC	HL
   0DCD 46            [ 7] 2576 	LD	B,(HL)		; Get MSB of address
   0DCE CD DB 0D      [17] 2577 	CALL	CRTMST		; Create string entry
   0DD1 E5            [11] 2578 	PUSH	HL		; Save pointer to MSB of addr
   0DD2 6F            [ 4] 2579 	LD	L,A		; Length of string
   0DD3 CD 5A 0F      [17] 2580 	CALL	TOSTRA		; Move to string area
   0DD6 D1            [10] 2581 	POP	DE		; Restore pointer to MSB
   0DD7 C9            [10] 2582 	RET
                           2583 ;
   0DD8 CD 40 0E      [17] 2584 MKTMST: CALL	TESTR		; See if enough string space
u  0DDB 21 00 00      [10] 2585 CRTMST: LD	HL,TMPSTR	; Temporary string
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 48
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0DDE E5            [11] 2586 	PUSH	HL		; Save it
   0DDF 77            [ 7] 2587 	LD	(HL),A		; Save length of string
   0DE0 23            [ 6] 2588 	INC	HL
   0DE1 23            [ 6] 2589 SVSTAD: INC	HL
   0DE2 73            [ 7] 2590 	LD	(HL),E		; Save LSB of address
   0DE3 23            [ 6] 2591 	INC	HL
   0DE4 72            [ 7] 2592 	LD	(HL),D		; Save MSB of address
   0DE5 E1            [10] 2593 	POP	HL		; Restore pointer
   0DE6 C9            [10] 2594 	RET
                           2595 ;
   0DE7 2B            [ 6] 2596 CRTST:	DEC	HL		; DEC - INCed after
q  0DE8 06 22         [ 7] 2597 QTSTR:	LD	B,'"'		; Terminating quote
   0DEA 50            [ 4] 2598 	LD	D,B		; Quote to D
   0DEB E5            [11] 2599 DTSTR:	PUSH	HL		; Save start
   0DEC 0E FF         [ 7] 2600 	LD	C,-1		; Set counter to -1
   0DEE 23            [ 6] 2601 QTSTLP: INC	HL		; Move on
   0DEF 7E            [ 7] 2602 	LD	A,(HL)		; Get byte
   0DF0 0C            [ 4] 2603 	INC	C		; Count bytes
   0DF1 B7            [ 4] 2604 	OR	A		; End of line?
   0DF2 CA FD 0D      [10] 2605 	JP	Z,CRTSTE	; Yes - Create string entry
   0DF5 BA            [ 4] 2606 	CP	D		; Terminator D found?
   0DF6 CA FD 0D      [10] 2607 	JP	Z,CRTSTE	; Yes - Create string entry
   0DF9 B8            [ 4] 2608 	CP	B		; Terminator B found?
   0DFA C2 EE 0D      [10] 2609 	JP	NZ,QTSTLP	; No - Keep looking
q  0DFD                    2610 CRTSTE: CP	'"'		; End with '"'?
   0DFD CC 5F 05      [17] 2611 	CALL	Z,GETCHR	; Yes - Get next character
   0E00 E3            [19] 2612 	EX	(SP),HL		; Starting quote
   0E01 23            [ 6] 2613 	INC	HL		; First byte of string
   0E02 EB            [ 4] 2614 	EX	DE,HL		; To DE
   0E03 79            [ 4] 2615 	LD	A,C		; Get length
   0E04 CD DB 0D      [17] 2616 	CALL	CRTMST		; Create string entry
u  0E07 11 00 00      [10] 2617 TSTOPL: LD	DE,TMPSTR	; Temporary string
u  0E0A 2A 00 00      [16] 2618 	LD	HL,(TMSTPT)	; Temporary string pool pointer
u  0E0D 22 00 00      [16] 2619 	LD	(FPREG),HL	; Save address of string ptr
   0E10 3E 01         [ 7] 2620 	LD	A,1
u  0E12 32 00 00      [13] 2621 	LD	(TYPE),A	; Set type to string
   0E15 CD 60 13      [17] 2622 	CALL	DETHL4		; Move string to pool
   0E18 CD D8 03      [17] 2623 	CALL	CPDEHL		; Out of string pool?
u  0E1B 22 00 00      [16] 2624 	LD	(TMSTPT),HL	; Save new pointer
   0E1E E1            [10] 2625 	POP	HL		; Restore code string address
   0E1F 7E            [ 7] 2626 	LD	A,(HL)		; Get next code byte
   0E20 C0            [11] 2627 	RET	NZ		; Return if pool OK
u  0E21 1E 00         [ 7] 2628 	LD	E,ST		; ?ST Error
   0E23 C3 46 01      [10] 2629 	JP	ERROR		; String pool overflow
                           2630 ;
   0E26 23            [ 6] 2631 PRNUMS: INC	HL		; Skip leading space
   0E27 CD E7 0D      [17] 2632 PRS:	CALL	CRTST		; Create string entry for it
   0E2A CD 67 0F      [17] 2633 PRS1:	CALL	GSTRCU		; Current string to pool
   0E2D CD 54 13      [17] 2634 	CALL	LOADFP		; Move string block to BCDE
   0E30 1C            [ 4] 2635 	INC	E		; Length + 1
   0E31 1D            [ 4] 2636 PRSLP:	DEC	E		; Count characters
   0E32 C8            [11] 2637 	RET	Z		; End of string
   0E33 0A            [ 7] 2638 	LD	A,(BC)		; Get byte to output
   0E34 CD E9 03      [17] 2639 	CALL	OUTC		; Output character in A
u  0E37 FE 00         [ 7] 2640 	CP	CR		; Return?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 49
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0E39 CC EF 07      [17] 2641 	CALL	Z,DONULL	; Yes - Do nulls
   0E3C 03            [ 6] 2642 	INC	BC		; Next byte in string
   0E3D C3 31 0E      [10] 2643 	JP	PRSLP		; More characters to output
                           2644 ;
   0E40 B7            [ 4] 2645 TESTR:	OR	A		; Test if enough room
                           2646 	DB	0EH		; No garbage collection done
   0E41 F1            [10] 2647 GRBDON: POP	AF		; Garbage collection done
   0E42 F5            [11] 2648 	PUSH	AF		; Save status
u  0E43 2A 00 00      [16] 2649 	LD	HL,(STRSPC)	; Bottom of string space in use
   0E46 EB            [ 4] 2650 	EX	DE,HL		; To DE
u  0E47 2A 00 00      [16] 2651 	LD	HL,(STRBOT)	; Bottom of string area
   0E4A 2F            [ 4] 2652 	CPL			; Negate length (Top down)
   0E4B 4F            [ 4] 2653 	LD	C,A		; -Length to BC
   0E4C 06 FF         [ 7] 2654 	LD	B,-1		; BC = -ve length of string
   0E4E 09            [11] 2655 	ADD	HL,BC		; Add to bottom of space in use
   0E4F 23            [ 6] 2656 	INC	HL		; Plus one for 2's complement
   0E50 CD D8 03      [17] 2657 	CALL	CPDEHL		; Below string RAM area?
   0E53 DA 5D 0E      [10] 2658 	JP	C,TESTOS	; Tidy up if not done else err
u  0E56 22 00 00      [16] 2659 	LD	(STRBOT),HL	; Save new bottom of area
   0E59 23            [ 6] 2660 	INC	HL		; Point to first byte of string
   0E5A EB            [ 4] 2661 	EX	DE,HL		; Address to DE
   0E5B F1            [10] 2662 POPAF:	POP	AF		; Throw away status push
   0E5C C9            [10] 2663 	RET
                           2664 ;
   0E5D F1            [10] 2665 TESTOS: POP	AF		; Garbage collect been done?
u  0E5E 1E 00         [ 7] 2666 	LD	E,OS		; ?OS Error
   0E60 CA 46 01      [10] 2667 	JP	Z,ERROR		; Yes - Not enough string apace
   0E63 BF            [ 4] 2668 	CP	A		; Flag garbage collect done
   0E64 F5            [11] 2669 	PUSH	AF		; Save status
   0E65 01 41 0E      [10] 2670 	LD	BC,GRBDON	; Garbage collection done
   0E68 C5            [11] 2671 	PUSH	BC		; Save for RETurn
u  0E69 2A 00 00      [16] 2672 GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
u  0E6C 22 00 00      [16] 2673 GARBLP: LD	(STRBOT),HL	; Reset string pointer
   0E6F 21 00 00      [10] 2674 	LD	HL,0
   0E72 E5            [11] 2675 	PUSH	HL		; Flag no string found
u  0E73 2A 00 00      [16] 2676 	LD	HL,(STRSPC)	; Get bottom of string space
   0E76 E5            [11] 2677 	PUSH	HL		; Save bottom of string space
u  0E77 21 00 00      [10] 2678 	LD	HL,TMSTPL	; Temporary string pool
   0E7A EB            [ 4] 2679 GRBLP:	EX	DE,HL
u  0E7B 2A 00 00      [16] 2680 	LD	HL,(TMSTPT)	; Temporary string pool pointer
   0E7E EB            [ 4] 2681 	EX	DE,HL
   0E7F CD D8 03      [17] 2682 	CALL	CPDEHL		; Temporary string pool done?
   0E82 01 7A 0E      [10] 2683 	LD	BC,GRBLP	; Loop until string pool done
   0E85 C2 CE 0E      [10] 2684 	JP	NZ,STPOOL	; No - See if in string area
u  0E88 2A 00 00      [16] 2685 	LD	HL,(PROGND)	; Start of simple variables
   0E8B EB            [ 4] 2686 SMPVAR: EX	DE,HL
u  0E8C 2A 00 00      [16] 2687 	LD	HL,(VAREND)	; End of simple variables
   0E8F EB            [ 4] 2688 	EX	DE,HL
   0E90 CD D8 03      [17] 2689 	CALL	CPDEHL		; All simple strings done?
   0E93 CA A1 0E      [10] 2690 	JP	Z,ARRLP		; Yes - Do string arrays
   0E96 7E            [ 7] 2691 	LD	A,(HL)		; Get type of variable
   0E97 23            [ 6] 2692 	INC	HL
   0E98 23            [ 6] 2693 	INC	HL
   0E99 B7            [ 4] 2694 	OR	A		; "S" flag set if string
   0E9A CD CF 0E      [17] 2695 	CALL	STRADD		; See if string in string area
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 50
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0E9D C3 8B 0E      [10] 2696 	JP	SMPVAR		; Loop until simple ones done
                           2697 ;
   0EA0 C1            [10] 2698 GNXARY: POP	BC		; Scrap address of this array
   0EA1 EB            [ 4] 2699 ARRLP:	EX	DE,HL
u  0EA2 2A 00 00      [16] 2700 	LD	HL,(ARREND)	; End of string arrays
   0EA5 EB            [ 4] 2701 	EX	DE,HL
   0EA6 CD D8 03      [17] 2702 	CALL	CPDEHL		; All string arrays done?
   0EA9 CA F5 0E      [10] 2703 	JP	Z,SCNEND	; Yes - Move string if found
   0EAC CD 54 13      [17] 2704 	CALL	LOADFP		; Get array name to BCDE
   0EAF 7B            [ 4] 2705 	LD	A,E		; Get type of array	
   0EB0 E5            [11] 2706 	PUSH	HL		; Save address of num of dim'ns
   0EB1 09            [11] 2707 	ADD	HL,BC		; Start of next array
   0EB2 B7            [ 4] 2708 	OR	A		; Test type of array
   0EB3 F2 A0 0E      [10] 2709 	JP	P,GNXARY	; Numeric array - Ignore it
u  0EB6 22 00 00      [16] 2710 	LD	(CUROPR),HL	; Save address of next array
   0EB9 E1            [10] 2711 	POP	HL		; Get address of num of dim'ns
   0EBA 4E            [ 7] 2712 	LD	C,(HL)		; BC = Number of dimensions
   0EBB 06 00         [ 7] 2713 	LD	B,0
   0EBD 09            [11] 2714 	ADD	HL,BC		; Two bytes per dimension size
   0EBE 09            [11] 2715 	ADD	HL,BC
   0EBF 23            [ 6] 2716 	INC	HL		; Plus one for number of dim'ns
   0EC0 EB            [ 4] 2717 GRBARY: EX	DE,HL
u  0EC1 2A 00 00      [16] 2718 	LD	HL,(CUROPR)	; Get address of next array
   0EC4 EB            [ 4] 2719 	EX	DE,HL
   0EC5 CD D8 03      [17] 2720 	CALL	CPDEHL		; Is this array finished?
   0EC8 CA A1 0E      [10] 2721 	JP	Z,ARRLP		; Yes - Get next one
   0ECB 01 C0 0E      [10] 2722 	LD	BC,GRBARY	; Loop until array all done
   0ECE C5            [11] 2723 STPOOL: PUSH	BC		; Save return address
q  0ECF                    2724 	OR	80H		; Flag string type
   0ECF 7E            [ 7] 2725 STRADD: LD	A,(HL)		; Get string length
   0ED0 23            [ 6] 2726 	INC	HL
   0ED1 23            [ 6] 2727 	INC	HL
   0ED2 5E            [ 7] 2728 	LD	E,(HL)		; Get LSB of string address
   0ED3 23            [ 6] 2729 	INC	HL
   0ED4 56            [ 7] 2730 	LD	D,(HL)		; Get MSB of string address
   0ED5 23            [ 6] 2731 	INC	HL
   0ED6 F0            [11] 2732 	RET	P		; Not a string - Return
   0ED7 B7            [ 4] 2733 	OR	A		; Set flags on string length
   0ED8 C8            [11] 2734 	RET	Z		; Null string - Return
   0ED9 44            [ 4] 2735 	LD	B,H		; Save variable pointer
   0EDA 4D            [ 4] 2736 	LD	C,L
u  0EDB 2A 00 00      [16] 2737 	LD	HL,(STRBOT)	; Bottom of new area
   0EDE CD D8 03      [17] 2738 	CALL	CPDEHL		; String been done?
   0EE1 60            [ 4] 2739 	LD	H,B		; Restore variable pointer
   0EE2 69            [ 4] 2740 	LD	L,C
   0EE3 D8            [11] 2741 	RET	C		; String done - Ignore
   0EE4 E1            [10] 2742 	POP	HL		; Return address
   0EE5 E3            [19] 2743 	EX	(SP),HL		; Lowest available string area
   0EE6 CD D8 03      [17] 2744 	CALL	CPDEHL		; String within string area?
   0EE9 E3            [19] 2745 	EX	(SP),HL		; Lowest available string area
   0EEA E5            [11] 2746 	PUSH	HL		; Re-save return address
   0EEB 60            [ 4] 2747 	LD	H,B		; Restore variable pointer
   0EEC 69            [ 4] 2748 	LD	L,C
   0EED D0            [11] 2749 	RET	NC		; Outside string area - Ignore
   0EEE C1            [10] 2750 	POP	BC		; Get return , Throw 2 away
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 51
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0EEF F1            [10] 2751 	POP	AF		; 
   0EF0 F1            [10] 2752 	POP	AF		; 
   0EF1 E5            [11] 2753 	PUSH	HL		; Save variable pointer
   0EF2 D5            [11] 2754 	PUSH	DE		; Save address of current
   0EF3 C5            [11] 2755 	PUSH	BC		; Put back return address
   0EF4 C9            [10] 2756 	RET			; Go to it
                           2757 ;
   0EF5 D1            [10] 2758 SCNEND: POP	DE		; Addresses of strings
   0EF6 E1            [10] 2759 	POP	HL		; 
   0EF7 7D            [ 4] 2760 	LD	A,L		; HL = 0 if no more to do
   0EF8 B4            [ 4] 2761 	OR	H
   0EF9 C8            [11] 2762 	RET	Z		; No more to do - Return
   0EFA 2B            [ 6] 2763 	DEC	HL
   0EFB 46            [ 7] 2764 	LD	B,(HL)		; MSB of address of string
   0EFC 2B            [ 6] 2765 	DEC	HL
   0EFD 4E            [ 7] 2766 	LD	C,(HL)		; LSB of address of string
   0EFE E5            [11] 2767 	PUSH	HL		; Save variable address
   0EFF 2B            [ 6] 2768 	DEC	HL
   0F00 2B            [ 6] 2769 	DEC	HL
   0F01 6E            [ 7] 2770 	LD	L,(HL)		; HL = Length of string
   0F02 26 00         [ 7] 2771 	LD	H,0
   0F04 09            [11] 2772 	ADD	HL,BC		; Address of end of string+1
   0F05 50            [ 4] 2773 	LD	D,B		; String address to DE
   0F06 59            [ 4] 2774 	LD	E,C
   0F07 2B            [ 6] 2775 	DEC	HL		; Last byte in string
   0F08 44            [ 4] 2776 	LD	B,H		; Address to BC
   0F09 4D            [ 4] 2777 	LD	C,L
u  0F0A 2A 00 00      [16] 2778 	LD	HL,(STRBOT)	; Current bottom of string area
   0F0D CD 08 01      [17] 2779 	CALL	MOVSTR		; Move string to new address
   0F10 E1            [10] 2780 	POP	HL		; Restore variable address
   0F11 71            [ 7] 2781 	LD	(HL),C		; Save new LSB of address
   0F12 23            [ 6] 2782 	INC	HL
   0F13 70            [ 7] 2783 	LD	(HL),B		; Save new MSB of address
   0F14 69            [ 4] 2784 	LD	L,C		; Next string area+1 to HL
   0F15 60            [ 4] 2785 	LD	H,B
   0F16 2B            [ 6] 2786 	DEC	HL		; Next string area address
   0F17 C3 6C 0E      [10] 2787 	JP	GARBLP		; Look for more strings
                           2788 ;
   0F1A C5            [11] 2789 CONCAT: PUSH	BC		; Save prec' opr & code string
   0F1B E5            [11] 2790 	PUSH	HL		; 
u  0F1C 2A 00 00      [16] 2791 	LD	HL,(FPREG)	; Get first string
   0F1F E3            [19] 2792 	EX	(SP),HL		; Save first string
   0F20 CD FC 09      [17] 2793 	CALL	OPRND		; Get second string
   0F23 E3            [19] 2794 	EX	(SP),HL		; Restore first string
   0F24 CD 7A 09      [17] 2795 	CALL	TSTSTR		; Make sure it's a string
   0F27 7E            [ 7] 2796 	LD	A,(HL)		; Get length of second string
   0F28 E5            [11] 2797 	PUSH	HL		; Save first string
u  0F29 2A 00 00      [16] 2798 	LD	HL,(FPREG)	; Get second string
   0F2C E5            [11] 2799 	PUSH	HL		; Save second string
   0F2D 86            [ 7] 2800 	ADD	A,(HL)		; Add length of second string
u  0F2E 1E 00         [ 7] 2801 	LD	E,LS		; ?LS Error
   0F30 DA 46 01      [10] 2802 	JP	C,ERROR		; String too long - Error
   0F33 CD D8 0D      [17] 2803 	CALL	MKTMST		; Make temporary string
   0F36 D1            [10] 2804 	POP	DE		; Get second string to DE
   0F37 CD 6B 0F      [17] 2805 	CALL	GSTRDE		; Move to string pool if needed
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 52
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0F3A E3            [19] 2806 	EX	(SP),HL		; Get first string
   0F3B CD 6A 0F      [17] 2807 	CALL	GSTRHL		; Move to string pool if needed
   0F3E E5            [11] 2808 	PUSH	HL		; Save first string
u  0F3F 2A 02 00      [16] 2809 	LD	HL,(TMPSTR+2)	; Temporary string address
   0F42 EB            [ 4] 2810 	EX	DE,HL		; To DE
   0F43 CD 51 0F      [17] 2811 	CALL	SSTSA		; First string to string area
   0F46 CD 51 0F      [17] 2812 	CALL	SSTSA		; Second string to string area
   0F49 21 93 09      [10] 2813 	LD	HL,EVAL2	; Return to evaluation loop
   0F4C E3            [19] 2814 	EX	(SP),HL		; Save return,get code string
   0F4D E5            [11] 2815 	PUSH	HL		; Save code string address
   0F4E C3 07 0E      [10] 2816 	JP	TSTOPL		; To temporary string to pool
                           2817 ;
   0F51 E1            [10] 2818 SSTSA:	POP	HL		; Return address
   0F52 E3            [19] 2819 	EX	(SP),HL		; Get string block,save return
   0F53 7E            [ 7] 2820 	LD	A,(HL)		; Get length of string
   0F54 23            [ 6] 2821 	INC	HL
   0F55 23            [ 6] 2822 	INC	HL
   0F56 4E            [ 7] 2823 	LD	C,(HL)		; Get LSB of string address
   0F57 23            [ 6] 2824 	INC	HL
   0F58 46            [ 7] 2825 	LD	B,(HL)		; Get MSB of string address
   0F59 6F            [ 4] 2826 	LD	L,A		; Length to L
   0F5A 2C            [ 4] 2827 TOSTRA: INC	L		; INC - DECed after
   0F5B 2D            [ 4] 2828 TSALP:	DEC	L		; Count bytes moved
   0F5C C8            [11] 2829 	RET	Z		; End of string - Return
   0F5D 0A            [ 7] 2830 	LD	A,(BC)		; Get source
   0F5E 12            [ 7] 2831 	LD	(DE),A		; Save destination
   0F5F 03            [ 6] 2832 	INC	BC		; Next source
   0F60 13            [ 6] 2833 	INC	DE		; Next destination
   0F61 C3 5B 0F      [10] 2834 	JP	TSALP		; Loop until string moved
                           2835 ;
   0F64 CD 7A 09      [17] 2836 GETSTR: CALL	TSTSTR		; Make sure it's a string
u  0F67 2A 00 00      [16] 2837 GSTRCU: LD	HL,(FPREG)	; Get current string
   0F6A EB            [ 4] 2838 GSTRHL: EX	DE,HL		; Save DE
   0F6B CD 85 0F      [17] 2839 GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
   0F6E EB            [ 4] 2840 	EX	DE,HL		; Restore DE
   0F6F C0            [11] 2841 	RET	NZ		; No - Return
   0F70 D5            [11] 2842 	PUSH	DE		; Save string
   0F71 50            [ 4] 2843 	LD	D,B		; String block address to DE
   0F72 59            [ 4] 2844 	LD	E,C
   0F73 1B            [ 6] 2845 	DEC	DE		; Point to length
   0F74 4E            [ 7] 2846 	LD	C,(HL)		; Get string length
u  0F75 2A 00 00      [16] 2847 	LD	HL,(STRBOT)	; Current bottom of string area
   0F78 CD D8 03      [17] 2848 	CALL	CPDEHL		; Last one in string area?
   0F7B C2 83 0F      [10] 2849 	JP	NZ,POPHL	; No - Return
   0F7E 47            [ 4] 2850 	LD	B,A		; Clear B (A=0)
   0F7F 09            [11] 2851 	ADD	HL,BC		; Remove string from str' area
u  0F80 22 00 00      [16] 2852 	LD	(STRBOT),HL	; Save new bottom of str' area
   0F83 E1            [10] 2853 POPHL:	POP	HL		; Restore string
   0F84 C9            [10] 2854 	RET
                           2855 ;
u  0F85 2A 00 00      [16] 2856 BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
   0F88 2B            [ 6] 2857 	DEC	HL		; Back
   0F89 46            [ 7] 2858 	LD	B,(HL)		; Get MSB of address
   0F8A 2B            [ 6] 2859 	DEC	HL		; Back
   0F8B 4E            [ 7] 2860 	LD	C,(HL)		; Get LSB of address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 53
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0F8C 2B            [ 6] 2861 	DEC	HL		; Back
   0F8D 2B            [ 6] 2862 	DEC	HL		; Back
   0F8E CD D8 03      [17] 2863 	CALL	CPDEHL		; String last in string pool?
   0F91 C0            [11] 2864 	RET	NZ		; Yes - Leave it
u  0F92 22 00 00      [16] 2865 	LD	(TMSTPT),HL	; Save new string pool top
   0F95 C9            [10] 2866 	RET
                           2867 ;
   0F96 01 1E 0D      [10] 2868 LEN:	LD	BC,PASSA	; To return integer A
   0F99 C5            [11] 2869 	PUSH	BC		; Save address
   0F9A CD 64 0F      [17] 2870 GETLEN: CALL	GETSTR		; Get string and its length
   0F9D AF            [ 4] 2871 	XOR	A
   0F9E 57            [ 4] 2872 	LD	D,A		; Clear D
u  0F9F 32 00 00      [13] 2873 	LD	(TYPE),A	; Set type to numeric
   0FA2 7E            [ 7] 2874 	LD	A,(HL)		; Get length of string
   0FA3 B7            [ 4] 2875 	OR	A		; Set status flags
   0FA4 C9            [10] 2876 	RET
                           2877 ;
   0FA5 01 1E 0D      [10] 2878 ASC:	LD	BC,PASSA	; To return integer A
   0FA8 C5            [11] 2879 	PUSH	BC		; Save address
   0FA9 CD 9A 0F      [17] 2880 GTFLNM: CALL	GETLEN		; Get length of string
   0FAC CA 14 06      [10] 2881 	JP	Z,FCERR		; Null string - Error
   0FAF 23            [ 6] 2882 	INC	HL
   0FB0 23            [ 6] 2883 	INC	HL
   0FB1 5E            [ 7] 2884 	LD	E,(HL)		; Get LSB of address
   0FB2 23            [ 6] 2885 	INC	HL
   0FB3 56            [ 7] 2886 	LD	D,(HL)		; Get MSB of address
   0FB4 1A            [ 7] 2887 	LD	A,(DE)		; Get first byte of string
   0FB5 C9            [10] 2888 	RET
                           2889 ;
   0FB6 3E 01         [ 7] 2890 CHR:	LD	A,1		; One character string
   0FB8 CD D8 0D      [17] 2891 	CALL	MKTMST		; Make a temporary string
   0FBB CD A3 10      [17] 2892 	CALL	MAKINT		; Make it integer A
u  0FBE 2A 02 00      [16] 2893 	LD	HL,(TMPSTR+2)	; Get address of string
   0FC1 73            [ 7] 2894 	LD	(HL),E		; Save character
   0FC2 C1            [10] 2895 TOPOOL: POP	BC		; Clean up stack
   0FC3 C3 07 0E      [10] 2896 	JP	TSTOPL		; Temporary string to pool
                           2897 ;
   0FC6 CD 56 10      [17] 2898 LEFT:	CALL	LFRGNM		; Get number and ending ")"
   0FC9 AF            [ 4] 2899 	XOR	A		; Start at first byte in string
   0FCA E3            [19] 2900 RIGHT1: EX	(SP),HL		; Save code string,Get string
   0FCB 4F            [ 4] 2901 	LD	C,A		; Starting position in string
   0FCC E5            [11] 2902 MID1:	PUSH	HL		; Save string block address
   0FCD 7E            [ 7] 2903 	LD	A,(HL)		; Get length of string
   0FCE B8            [ 4] 2904 	CP	B		; Compare with number given
   0FCF DA D3 0F      [10] 2905 	JP	C,ALLFOL	; All following bytes required
   0FD2 78            [ 4] 2906 	LD	A,B		; Get new length
                           2907 	DB	11H		; Skip "LD C,0"
   0FD3 0E 00         [ 7] 2908 ALLFOL: LD	C,0		; First byte of string
   0FD5 C5            [11] 2909 	PUSH	BC		; Save position in string
   0FD6 CD 40 0E      [17] 2910 	CALL	TESTR		; See if enough string space
   0FD9 C1            [10] 2911 	POP	BC		; Get position in string
   0FDA E1            [10] 2912 	POP	HL		; Restore string block address
   0FDB E5            [11] 2913 	PUSH	HL		; And re-save it
   0FDC 23            [ 6] 2914 	INC	HL
   0FDD 23            [ 6] 2915 	INC	HL
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 54
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   0FDE 46            [ 7] 2916 	LD	B,(HL)		; Get LSB of address
   0FDF 23            [ 6] 2917 	INC	HL
   0FE0 66            [ 7] 2918 	LD	H,(HL)		; Get MSB of address
   0FE1 68            [ 4] 2919 	LD	L,B		; HL = address of string
   0FE2 06 00         [ 7] 2920 	LD	B,0		; BC = starting address
   0FE4 09            [11] 2921 	ADD	HL,BC		; Point to that byte
   0FE5 44            [ 4] 2922 	LD	B,H		; BC = source string
   0FE6 4D            [ 4] 2923 	LD	C,L
   0FE7 CD DB 0D      [17] 2924 	CALL	CRTMST		; Create a string entry
   0FEA 6F            [ 4] 2925 	LD	L,A		; Length of new string
   0FEB CD 5A 0F      [17] 2926 	CALL	TOSTRA		; Move string to string area
   0FEE D1            [10] 2927 	POP	DE		; Clear stack
   0FEF CD 6B 0F      [17] 2928 	CALL	GSTRDE		; Move to string pool if needed
   0FF2 C3 07 0E      [10] 2929 	JP	TSTOPL		; Temporary string to pool
                           2930 ;
   0FF5 CD 56 10      [17] 2931 RIGHT:	CALL	LFRGNM		; Get number and ending ")"
   0FF8 D1            [10] 2932 	POP	DE		; Get string length
   0FF9 D5            [11] 2933 	PUSH	DE		; And re-save
   0FFA 1A            [ 7] 2934 	LD	A,(DE)		; Get length
   0FFB 90            [ 4] 2935 	SUB	B		; Move back N bytes
   0FFC C3 CA 0F      [10] 2936 	JP	RIGHT1		; Go and get sub-string
                           2937 ;
   0FFF EB            [ 4] 2938 MID:	EX	DE,HL		; Get code string address
   1000 7E            [ 7] 2939 	LD	A,(HL)		; Get next byte ',' or ")"
   1001 CD 5A 10      [17] 2940 	CALL	MIDNUM		; Get number supplied
   1004 04            [ 4] 2941 	INC	B		; Is it character zero?
   1005 05            [ 4] 2942 	DEC	B
   1006 CA 14 06      [10] 2943 	JP	Z,FCERR		; Yes - Error
   1009 C5            [11] 2944 	PUSH	BC		; Save starting position
   100A 1E FF         [ 7] 2945 	LD	E,255		; All of string
q  100C                    2946 	CP	')'		; Any length given?
   100C CA 15 10      [10] 2947 	JP	Z,RSTSTR	; No - Rest of string
   100F CD DE 03      [17] 2948 	CALL	CHKSYN		; Make sure ',' follows
                           2949 	DB	','
   1012 CD A0 10      [17] 2950 	CALL	GETINT		; Get integer 0-255
   1015 CD DE 03      [17] 2951 RSTSTR: CALL	CHKSYN		; Make sure ")" follows
                           2952 	DB	")"
   1018 F1            [10] 2953 	POP	AF		; Restore starting position
   1019 E3            [19] 2954 	EX	(SP),HL		; Get string,8ave code string
   101A 01 CC 0F      [10] 2955 	LD	BC,MID1		; Continuation of MID$ routine
   101D C5            [11] 2956 	PUSH	BC		; Save for return
   101E 3D            [ 4] 2957 	DEC	A		; Starting position-1
   101F BE            [ 7] 2958 	CP	(HL)		; Compare with length
   1020 06 00         [ 7] 2959 	LD	B,0		; Zero bytes length
   1022 D0            [11] 2960 	RET	NC		; Null string if start past end
   1023 4F            [ 4] 2961 	LD	C,A		; Save starting position-1
   1024 7E            [ 7] 2962 	LD	A,(HL)		; Get length of string
   1025 91            [ 4] 2963 	SUB	C		; Subtract start
   1026 BB            [ 4] 2964 	CP	E		; Enough string for it?
   1027 47            [ 4] 2965 	LD	B,A		; Save maximum length available
   1028 D8            [11] 2966 	RET	C		; Truncate string if needed
   1029 43            [ 4] 2967 	LD	B,E		; Set specified length
   102A C9            [10] 2968 	RET			; Go and create string
                           2969 ;
   102B CD 9A 0F      [17] 2970 VAL:	CALL	GETLEN		; Get length of string
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 55
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   102E CA 3D 11      [10] 2971 	JP	Z,RESZER	; Result zero
   1031 5F            [ 4] 2972 	LD	E,A		; Save length
   1032 23            [ 6] 2973 	INC	HL
   1033 23            [ 6] 2974 	INC	HL
   1034 7E            [ 7] 2975 	LD	A,(HL)		; Get LSB of address
   1035 23            [ 6] 2976 	INC	HL
   1036 66            [ 7] 2977 	LD	H,(HL)		; Get MSB of address
   1037 6F            [ 4] 2978 	LD	L,A		; HL = String address
   1038 E5            [11] 2979 	PUSH	HL		; Save string address
   1039 19            [11] 2980 	ADD	HL,DE
   103A 46            [ 7] 2981 	LD	B,(HL)		; Get end of string+1 byte
   103B 72            [ 7] 2982 	LD	(HL),D		; Zero it to terminate
   103C E3            [19] 2983 	EX	(SP),HL		; Save string end,get start
   103D C5            [11] 2984 	PUSH	BC		; Save end+1 byte
   103E 7E            [ 7] 2985 	LD	A,(HL)		; Get starting byte
q  103F                    2986 	CP	'$'		; Hex number indicated? [function added]
   103F C2 47 10      [10] 2987 	JP	NZ,VAL1
u  1042 CD 00 00      [17] 2988 	CALL	HEXTFP		; Convert Hex to FPREG
   1045 18 0B         [12] 2989 	JR	VAL3
q  1047                    2990 VAL1:	CP	'%'		; Binary number indicated? [function added]
   1047 C2 4F 10      [10] 2991 	JP	NZ,VAL2
   104A CD F5 17      [17] 2992 	CALL	BINTFP		; Convert Bin to FPREG
   104D 18 03         [12] 2993 	JR	VAL3
   104F CD 0A 14      [17] 2994 VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
   1052 C1            [10] 2995 VAL3:	POP	BC		; Restore end+1 byte
   1053 E1            [10] 2996 	POP	HL		; Restore end+1 address
   1054 70            [ 7] 2997 	LD	(HL),B		; Put back original byte
   1055 C9            [10] 2998 	RET
                           2999 ;
   1056 EB            [ 4] 3000 LFRGNM: EX	DE,HL		; Code string address to HL
   1057 CD DE 03      [17] 3001 	CALL	CHKSYN		; Make sure ")" follows
                           3002 	DB	")"
   105A C1            [10] 3003 MIDNUM: POP	BC		; Get return address
   105B D1            [10] 3004 	POP	DE		; Get number supplied
   105C C5            [11] 3005 	PUSH	BC		; Re-save return address
   105D 43            [ 4] 3006 	LD	B,E		; Number to B
   105E C9            [10] 3007 	RET
                           3008 ;
   105F CD A3 10      [17] 3009 INP:	CALL	MAKINT		; Make it integer A
u  1062 32 00 00      [13] 3010 	LD	(INPORT),A	; Set input port
u  1065 CD 00 00      [17] 3011 	CALL	INPSUB		; Get input from port
   1068 C3 1E 0D      [10] 3012 	JP	PASSA		; Return integer A
                           3013 ;
   106B CD 8E 10      [17] 3014 POUT:	CALL	SETIO		; Set up port number
u  106E C3 00 00      [10] 3015 	JP	OUTSUB		; Output data and return
                           3016 ;
   1071 CD 8E 10      [17] 3017 WAIT:	CALL	SETIO		; Set up port number
   1074 F5            [11] 3018 	PUSH	AF		; Save AND mask
   1075 1E 00         [ 7] 3019 	LD	E,0		; Assume zero if none given
   1077 2B            [ 6] 3020 	DEC	HL		; DEC 'cos GETCHR INCs
   1078 CD 5F 05      [17] 3021 	CALL	GETCHR		; Get next character
   107B CA 84 10      [10] 3022 	JP	Z,NOXOR		; No XOR byte given
   107E CD DE 03      [17] 3023 	CALL	CHKSYN		; Make sure ',' follows
                           3024 	DB	','
   1081 CD A0 10      [17] 3025 	CALL	GETINT		; Get integer 0-255 to XOR with
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 56
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1084 C1            [10] 3026 NOXOR:	POP	BC		; Restore AND mask
u  1085 CD 00 00      [17] 3027 WAITLP: CALL	INPSUB		; Get input
   1088 AB            [ 4] 3028 	XOR	E		; Flip selected bits
   1089 A0            [ 4] 3029 	AND	B		; Result non-zero?
   108A CA 85 10      [10] 3030 	JP	Z,WAITLP	; No = keep waiting
   108D C9            [10] 3031 	RET
                           3032 ;
   108E CD A0 10      [17] 3033 SETIO:	CALL	GETINT		; Get integer 0-255
u  1091 32 00 00      [13] 3034 	LD	(INPORT),A	; Set input port
u  1094 32 00 00      [13] 3035 	LD	(OTPORT),A	; Set output port
   1097 CD DE 03      [17] 3036 	CALL	CHKSYN		; Make sure ',' follows
                           3037 	DB	','
   109A C3 A0 10      [10] 3038 	JP	GETINT		; Get integer 0-255 and return
                           3039 ;
   109D CD 5F 05      [17] 3040 FNDNUM: CALL	GETCHR		; Get next character
   10A0 CD 77 09      [17] 3041 GETINT: CALL	GETNUM		; Get a number from 0 to 255
   10A3 CD FB 05      [17] 3042 MAKINT: CALL	DEPINT		; Make sure value 0 - 255
   10A6 7A            [ 4] 3043 	LD	A,D		; Get MSB of number
   10A7 B7            [ 4] 3044 	OR	A		; Zero?
   10A8 C2 14 06      [10] 3045 	JP	NZ,FCERR	; No - Error
   10AB 2B            [ 6] 3046 	DEC	HL		; DEC 'cos GETCHR INCs
   10AC CD 5F 05      [17] 3047 	CALL	GETCHR		; Get next character
   10AF 7B            [ 4] 3048 	LD	A,E		; Get number to A
   10B0 C9            [10] 3049 	RET
                           3050 ;
   10B1 CD 01 06      [17] 3051 PEEK:	CALL	DEINT		; Get memory address
   10B4 1A            [ 7] 3052 	LD	A,(DE)		; Get byte in memory
   10B5 C3 1E 0D      [10] 3053 	JP	PASSA		; Return integer A
                           3054 ;
   10B8 CD 77 09      [17] 3055 POKE:	CALL	GETNUM		; Get memory address
   10BB CD 01 06      [17] 3056 	CALL	DEINT		; Get integer -32768 to 3276
   10BE D5            [11] 3057 	PUSH	DE		; Save memory address
   10BF CD DE 03      [17] 3058 	CALL	CHKSYN		; Make sure ',' follows
                           3059 	DB	','
   10C2 CD A0 10      [17] 3060 	CALL	GETINT		; Get integer 0-255
   10C5 D1            [10] 3061 	POP	DE		; Restore memory address
   10C6 12            [ 7] 3062 	LD	(DE),A		; Load it into memory
   10C7 C9            [10] 3063 	RET
                           3064 ;
   10C8 21 71 15      [10] 3065 ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
   10CB CD 54 13      [17] 3066 ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
   10CE C3 D9 10      [10] 3067 	JP	FPADD		; Add BCDE to FPREG
                           3068 ;
   10D1 CD 54 13      [17] 3069 SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
                           3070 	DB	21H		; Skip "POP BC" and "POP DE"
   10D4 C1            [10] 3071 PSUB:	POP	BC		; Get FP number from stack
   10D5 D1            [10] 3072 	POP	DE
   10D6 CD 30 13      [17] 3073 SUBCDE: CALL	INVSGN		; Negate FPREG
   10D9 78            [ 4] 3074 FPADD:	LD	A,B		; Get FP exponent
   10DA B7            [ 4] 3075 	OR	A		; Is number zero?
   10DB C8            [11] 3076 	RET	Z		; Yes - Nothing to add
u  10DC 3A 00 00      [13] 3077 	LD	A,(FPEXP)	; Get FPREG exponent
   10DF B7            [ 4] 3078 	OR	A		; Is this number zero?
   10E0 CA 46 13      [10] 3079 	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
   10E3 90            [ 4] 3080 	SUB	B		; BCDE number larger?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 57
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   10E4 D2 F3 10      [10] 3081 	JP	NC,NOSWAP	; No - Don't swap them
   10E7 2F            [ 4] 3082 	CPL			; Two's complement
   10E8 3C            [ 4] 3083 	INC	A		;	FP exponent
   10E9 EB            [ 4] 3084 	EX	DE,HL
   10EA CD 36 13      [17] 3085 	CALL	STAKFP		; Put FPREG on stack
   10ED EB            [ 4] 3086 	EX	DE,HL
   10EE CD 46 13      [17] 3087 	CALL	FPBCDE		; Move BCDE to FPREG
   10F1 C1            [10] 3088 	POP	BC		; Restore number from stack
   10F2 D1            [10] 3089 	POP	DE
   10F3 FE 19         [ 7] 3090 NOSWAP: CP	24+1		; Second number insignificant?
   10F5 D0            [11] 3091 	RET	NC		; Yes - First number is result
   10F6 F5            [11] 3092 	PUSH	AF		; Save number of bits to scale
   10F7 CD 6B 13      [17] 3093 	CALL	SIGNS		; Set MSBs & sign of result
   10FA 67            [ 4] 3094 	LD	H,A		; Save sign of result
   10FB F1            [10] 3095 	POP	AF		; Restore scaling factor
   10FC CD 9A 11      [17] 3096 	CALL	SCALE		; Scale BCDE to same exponent
   10FF B4            [ 4] 3097 	OR	H		; Result to be positive?
u  1100 21 00 00      [10] 3098 	LD	HL,FPREG	; Point to FPREG
   1103 F2 19 11      [10] 3099 	JP	P,MINCDE	; No - Subtract FPREG from CDE
   1106 CD 7A 11      [17] 3100 	CALL	PLUCDE		; Add FPREG to CDE
   1109 D2 5D 11      [10] 3101 	JP	NC,RONDUP	; No overflow - Round it up
   110C 23            [ 6] 3102 	INC	HL		; Point to exponent
   110D 34            [11] 3103 	INC	(HL)		; Increment it
   110E CA 42 01      [10] 3104 	JP	Z,OVERR		; Number overflowed - Error
   1111 2E 01         [ 7] 3105 	LD	L,1		; 1 bit to shift right
   1113 CD B0 11      [17] 3106 	CALL	SHRT1		; Shift result right
   1116 C3 5D 11      [10] 3107 	JP	RONDUP		; Round it up
                           3108 ;
   1119 AF            [ 4] 3109 MINCDE: XOR	A		; Clear A and carry
   111A 90            [ 4] 3110 	SUB	B		; Negate exponent
   111B 47            [ 4] 3111 	LD	B,A		; Re-save exponent
   111C 7E            [ 7] 3112 	LD	A,(HL)		; Get LSB of FPREG
   111D 9B            [ 4] 3113 	SBC	A, E		; Subtract LSB of BCDE
   111E 5F            [ 4] 3114 	LD	E,A		; Save LSB of BCDE
   111F 23            [ 6] 3115 	INC	HL
   1120 7E            [ 7] 3116 	LD	A,(HL)		; Get NMSB of FPREG
   1121 9A            [ 4] 3117 	SBC	A,D		; Subtract NMSB of BCDE
   1122 57            [ 4] 3118 	LD	D,A		; Save NMSB of BCDE
   1123 23            [ 6] 3119 	INC	HL
   1124 7E            [ 7] 3120 	LD	A,(HL)		; Get MSB of FPREG
   1125 99            [ 4] 3121 	SBC	A,C		; Subtract MSB of BCDE
   1126 4F            [ 4] 3122 	LD	C,A		; Save MSB of BCDE
   1127 DC 86 11      [17] 3123 CONPOS: CALL	C,COMPL		; Overflow - Make it positive
                           3124 ;
   112A 68            [ 4] 3125 BNORM:	LD	L,B		; L = Exponent
   112B 63            [ 4] 3126 	LD	H,E		; H = LSB
   112C AF            [ 4] 3127 	XOR	A
   112D 47            [ 4] 3128 BNRMLP: LD	B,A		; Save bit count
   112E 79            [ 4] 3129 	LD	A,C		; Get MSB
   112F B7            [ 4] 3130 	OR	A		; Is it zero?
   1130 C2 4A 11      [10] 3131 	JP	NZ,PNORM	; No - Do it bit at a time
   1133 4A            [ 4] 3132 	LD	C,D		; MSB = NMSB
   1134 54            [ 4] 3133 	LD	D,H		; NMSB= LSB
   1135 65            [ 4] 3134 	LD	H,L		; LSB = VLSB
   1136 6F            [ 4] 3135 	LD	L,A		; VLSB= 0
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 58
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1137 78            [ 4] 3136 	LD	A,B		; Get exponent
   1138 D6 08         [ 7] 3137 	SUB	8		; Count 8 bits
kq 113A                    3138 	CP	0E0H		; -24-8 Was number zero?
   113A C2 2D 11      [10] 3139 	JP	NZ,BNRMLP	; No - Keep normalising
   113D AF            [ 4] 3140 RESZER: XOR	A		; Result is zero
u  113E 32 00 00      [13] 3141 SAVEXP: LD	(FPEXP),A	; Save result as zero
   1141 C9            [10] 3142 	RET
                           3143 ;
   1142 05            [ 4] 3144 NORMAL: DEC	B		; Count bits
   1143 29            [11] 3145 	ADD	HL,HL		; Shift HL left
   1144 7A            [ 4] 3146 	LD	A,D		; Get NMSB
   1145 17            [ 4] 3147 	RLA			; Shift left with last bit
   1146 57            [ 4] 3148 	LD	D,A		; Save NMSB
   1147 79            [ 4] 3149 	LD	A,C		; Get MSB
   1148 8F            [ 4] 3150 	ADC	A,A		; Shift left with last bit
   1149 4F            [ 4] 3151 	LD	C,A		; Save MSB
   114A F2 42 11      [10] 3152 PNORM:	JP	P,NORMAL	; Not done - Keep going
   114D 78            [ 4] 3153 	LD	A,B		; Number of bits shifted
   114E 5C            [ 4] 3154 	LD	E,H		; Save HL in EB
   114F 45            [ 4] 3155 	LD	B,L
   1150 B7            [ 4] 3156 	OR	A		; Any shifting done?
   1151 CA 5D 11      [10] 3157 	JP	Z,RONDUP	; No - Round it up
u  1154 21 00 00      [10] 3158 	LD	HL,FPEXP	; Point to exponent
   1157 86            [ 7] 3159 	ADD	A,(HL)		; Add shifted bits
   1158 77            [ 7] 3160 	LD	(HL),A		; Re-save exponent
   1159 D2 3D 11      [10] 3161 	JP	NC,RESZER	; Underflow - Result is zero
   115C C8            [11] 3162 	RET	Z		; Result is zero
   115D 78            [ 4] 3163 RONDUP: LD	A,B		; Get VLSB of number
u  115E 21 00 00      [10] 3164 RONDB:	LD	HL,FPEXP	; Point to exponent
   1161 B7            [ 4] 3165 	OR	A		; Any rounding?
   1162 FC 6D 11      [17] 3166 	CALL	M,FPROND	; Yes - Round number up
   1165 46            [ 7] 3167 	LD	B,(HL)		; B = Exponent
   1166 23            [ 6] 3168 	INC	HL
   1167 7E            [ 7] 3169 	LD	A,(HL)		; Get sign of result
kq 1168                    3170 	AND	10000000B	; Only bit 7 needed
   1168 A9            [ 4] 3171 	XOR	C		; Set correct sign
   1169 4F            [ 4] 3172 	LD	C,A		; Save correct sign in number
   116A C3 46 13      [10] 3173 	JP	FPBCDE		; Move BCDE to FPREG
                           3174 ;
   116D 1C            [ 4] 3175 FPROND: INC	E		; Round LSB
   116E C0            [11] 3176 	RET	NZ		; Return if ok
   116F 14            [ 4] 3177 	INC	D		; Round NMSB
   1170 C0            [11] 3178 	RET	NZ		; Return if ok
   1171 0C            [ 4] 3179 	INC	C		; Round MSB
   1172 C0            [11] 3180 	RET	NZ		; Return if ok
q  1173 0E 50         [ 7] 3181 	LD	C,80H		; Set normal value
   1175 34            [11] 3182 	INC	(HL)		; Increment exponent
   1176 C0            [11] 3183 	RET	NZ		; Return if ok
   1177 C3 42 01      [10] 3184 	JP	OVERR		; Overflow error
                           3185 ;
   117A 7E            [ 7] 3186 PLUCDE: LD	A,(HL)		; Get LSB of FPREG
   117B 83            [ 4] 3187 	ADD	A,E		; Add LSB of BCDE
   117C 5F            [ 4] 3188 	LD	E,A		; Save LSB of BCDE
   117D 23            [ 6] 3189 	INC	HL
   117E 7E            [ 7] 3190 	LD	A,(HL)		; Get NMSB of FPREG
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 59
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   117F 8A            [ 4] 3191 	ADC	A,D		; Add NMSB of BCDE
   1180 57            [ 4] 3192 	LD	D,A		; Save NMSB of BCDE
   1181 23            [ 6] 3193 	INC	HL
   1182 7E            [ 7] 3194 	LD	A,(HL)		; Get MSB of FPREG
   1183 89            [ 4] 3195 	ADC	A,C		; Add MSB of BCDE
   1184 4F            [ 4] 3196 	LD	C,A		; Save MSB of BCDE
   1185 C9            [10] 3197 	RET
                           3198 ;
u  1186 21 00 00      [10] 3199 COMPL:	LD	HL,SGNRES	; Sign of result
   1189 7E            [ 7] 3200 	LD	A,(HL)		; Get sign of result
   118A 2F            [ 4] 3201 	CPL			; Negate it
   118B 77            [ 7] 3202 	LD	(HL),A		; Put it back
   118C AF            [ 4] 3203 	XOR	A
   118D 6F            [ 4] 3204 	LD	L,A		; Set L to zero
   118E 90            [ 4] 3205 	SUB	B		; Negate exponent,set carry
   118F 47            [ 4] 3206 	LD	B,A		; Re-save exponent
   1190 7D            [ 4] 3207 	LD	A,L		; Load zero
   1191 9B            [ 4] 3208 	SBC	A,E		; Negate LSB
   1192 5F            [ 4] 3209 	LD	E,A		; Re-save LSB
   1193 7D            [ 4] 3210 	LD	A,L		; Load zero
   1194 9A            [ 4] 3211 	SBC	A,D		; Negate NMSB
   1195 57            [ 4] 3212 	LD	D,A		; Re-save NMSB
   1196 7D            [ 4] 3213 	LD	A,L		; Load zero
   1197 99            [ 4] 3214 	SBC	A,C		; Negate MSB
   1198 4F            [ 4] 3215 	LD	C,A		; Re-save MSB
   1199 C9            [10] 3216 	RET
                           3217 ;
   119A 06 00         [ 7] 3218 SCALE:	LD	B,0		; Clear underflow
   119C D6 08         [ 7] 3219 SCALLP: SUB	8		; 8 bits (a whole byte)?
   119E DA A9 11      [10] 3220 	JP	C,SHRITE	; No - Shift right A bits
   11A1 43            [ 4] 3221 	LD	B,E		; <- Shift
   11A2 5A            [ 4] 3222 	LD	E,D		; <- right
   11A3 51            [ 4] 3223 	LD	D,C		; <- eight
   11A4 0E 00         [ 7] 3224 	LD	C,0		; <- bits
   11A6 C3 9C 11      [10] 3225 	JP	SCALLP		; More bits to shift
                           3226 ;
   11A9 C6 09         [ 7] 3227 SHRITE: ADD	A,8+1		; Adjust count
   11AB 6F            [ 4] 3228 	LD	L,A		; Save bits to shift
   11AC AF            [ 4] 3229 SHRLP:	XOR	A		; Flag for all done
   11AD 2D            [ 4] 3230 	DEC	L		; All shifting done?
   11AE C8            [11] 3231 	RET	Z		; Yes - Return
   11AF 79            [ 4] 3232 	LD	A,C		; Get MSB
   11B0 1F            [ 4] 3233 SHRT1:	RRA			; Shift it right
   11B1 4F            [ 4] 3234 	LD	C,A		; Re-save
   11B2 7A            [ 4] 3235 	LD	A,D		; Get NMSB
   11B3 1F            [ 4] 3236 	RRA			; Shift right with last bit
   11B4 57            [ 4] 3237 	LD	D,A		; Re-save it
   11B5 7B            [ 4] 3238 	LD	A,E		; Get LSB
   11B6 1F            [ 4] 3239 	RRA			; Shift right with last bit
   11B7 5F            [ 4] 3240 	LD	E,A		; Re-save it
   11B8 78            [ 4] 3241 	LD	A,B		; Get underflow
   11B9 1F            [ 4] 3242 	RRA			; Shift right with last bit
   11BA 47            [ 4] 3243 	LD	B,A		; Re-save underflow
   11BB C3 AC 11      [10] 3244 	JP	SHRLP		; More bits to do
                           3245 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 60
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



q  11BE                    3246 UNITY:	DB	 000H,000H,000H,081H	; 1.00000
                           3247 ;
q  11BE                    3248 LOGTAB: DB	3			; Table used by LOG
                           3249 	DB	0AAH,056H,019H,080H	; 0.59898
                           3250 	DB	0F1H,022H,076H,080H	; 0.96147
                           3251 	DB	045H,0AAH,038H,082H	; 2.88539
                           3252 ;
   11BE CD 08 13      [17] 3253 LOG:	CALL	TSTSGN		; Test sign of value
   11C1 B7            [ 4] 3254 	OR	A
   11C2 EA 14 06      [10] 3255 	JP	PE,FCERR	; ?FC Error if <= zero
u  11C5 21 00 00      [10] 3256 	LD	HL,FPEXP	; Point to exponent
   11C8 7E            [ 7] 3257 	LD	A,(HL)		; Get exponent
q  11C9 01 63 1F      [10] 3258 	LD	BC,8035H	; BCDE = SQR(1/2)
kq 11CC 11 04 00      [10] 3259 	LD	DE,04F3H
   11CF 90            [ 4] 3260 	SUB	B		; Scale value to be < 1
   11D0 F5            [11] 3261 	PUSH	AF		; Save scale factor
   11D1 70            [ 7] 3262 	LD	(HL),B		; Save new exponent
   11D2 D5            [11] 3263 	PUSH	DE		; Save SQR(1/2)
   11D3 C5            [11] 3264 	PUSH	BC
   11D4 CD D9 10      [17] 3265 	CALL	FPADD		; Add SQR(1/2) to value
   11D7 C1            [10] 3266 	POP	BC		; Restore SQR(1/2)
   11D8 D1            [10] 3267 	POP	DE
   11D9 04            [ 4] 3268 	INC	B		; Make it SQR(2)
   11DA CD 5F 12      [17] 3269 	CALL	DVBCDE		; Divide by SQR(2)
   11DD 21 BE 11      [10] 3270 	LD	HL,UNITY	; Point to 1.
   11E0 CD D1 10      [17] 3271 	CALL	SUBPHL		; Subtract FPREG from 1
   11E3 21 BE 11      [10] 3272 	LD	HL,LOGTAB	; Coefficient table
   11E6 CD 00 16      [17] 3273 	CALL	SUMSER		; Evaluate sum of series
q  11E9 01 90 1F      [10] 3274 	LD	BC,8080H	; BCDE = -0.5
q  11EC 11 00 00      [10] 3275 	LD	DE,0000H
   11EF CD D9 10      [17] 3276 	CALL	FPADD		; Subtract 0.5 from FPREG
   11F2 F1            [10] 3277 	POP	AF		; Restore scale factor
   11F3 CD 74 14      [17] 3278 	CALL	RSCALE		; Re-scale number
q  11F6 01 5F 1F      [10] 3279 MULLN2: LD	BC,8031H	; BCDE = Ln(2)
q  11F9 11 32 1C      [10] 3280 	LD	DE,7218H
                           3281 	DB	21H		; Skip "POP BC" and "POP DE"
                           3282 ;
   11FC C1            [10] 3283 MULT:	POP	BC		; Get number from stack
   11FD D1            [10] 3284 	POP	DE
   11FE CD 08 13      [17] 3285 FPMULT: CALL	TSTSGN		; Test sign of FPREG
   1201 C8            [11] 3286 	RET	Z		; Return zero if zero
   1202 2E 00         [ 7] 3287 	LD	L,0		; Flag add exponents
   1204 CD C6 12      [17] 3288 	CALL	ADDEXP		; Add exponents
   1207 79            [ 4] 3289 	LD	A,C		; Get MSB of multiplier
u  1208 32 00 00      [13] 3290 	LD	(MULVAL),A	; Save MSB of multiplier
   120B EB            [ 4] 3291 	EX	DE,HL
u  120C 22 01 00      [16] 3292 	LD	(MULVAL+1),HL	; Save rest of multiplier
   120F 01 00 00      [10] 3293 	LD	BC,0		; Partial product (BCDE) = zero
   1212 50            [ 4] 3294 	LD	D,B
   1213 58            [ 4] 3295 	LD	E,B
   1214 21 2A 11      [10] 3296 	LD	HL,BNORM	; Address of normalise
   1217 E5            [11] 3297 	PUSH	HL		; Save for return
   1218 21 20 12      [10] 3298 	LD	HL,MULT8	; Address of 8 bit multiply
   121B E5            [11] 3299 	PUSH	HL		; Save for NMSB,MSB
   121C E5            [11] 3300 	PUSH	HL		; 
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 61
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



u  121D 21 00 00      [10] 3301 	LD	HL,FPREG	; Point to number
   1220 7E            [ 7] 3302 MULT8:	LD	A,(HL)		; Get LSB of number
   1221 23            [ 6] 3303 	INC	HL		; Point to NMSB
   1222 B7            [ 4] 3304 	OR	A		; Test LSB
   1223 CA 4C 12      [10] 3305 	JP	Z,BYTSFT	; Zero - shift to next byte
   1226 E5            [11] 3306 	PUSH	HL		; Save address of number
   1227 2E 08         [ 7] 3307 	LD	L,8		; 8 bits to multiply by
   1229 1F            [ 4] 3308 MUL8LP: RRA			; Shift LSB right
   122A 67            [ 4] 3309 	LD	H,A		; Save LSB
   122B 79            [ 4] 3310 	LD	A,C		; Get MSB
   122C D2 3A 12      [10] 3311 	JP	NC,NOMADD	; Bit was zero - Don't add
   122F E5            [11] 3312 	PUSH	HL		; Save LSB and count
u  1230 2A 01 00      [16] 3313 	LD	HL,(MULVAL+1)	; Get LSB and NMSB
   1233 19            [11] 3314 	ADD	HL,DE		; Add NMSB and LSB
   1234 EB            [ 4] 3315 	EX	DE,HL		; Leave sum in DE
   1235 E1            [10] 3316 	POP	HL		; Restore MSB and count
u  1236 3A 00 00      [13] 3317 	LD	A,(MULVAL)	; Get MSB of multiplier
   1239 89            [ 4] 3318 	ADC	A,C		; Add MSB
   123A 1F            [ 4] 3319 NOMADD: RRA			; Shift MSB right
   123B 4F            [ 4] 3320 	LD	C,A		; Re-save MSB
   123C 7A            [ 4] 3321 	LD	A,D		; Get NMSB
   123D 1F            [ 4] 3322 	RRA			; Shift NMSB right
   123E 57            [ 4] 3323 	LD	D,A		; Re-save NMSB
   123F 7B            [ 4] 3324 	LD	A,E		; Get LSB
   1240 1F            [ 4] 3325 	RRA			; Shift LSB right
   1241 5F            [ 4] 3326 	LD	E,A		; Re-save LSB
   1242 78            [ 4] 3327 	LD	A,B		; Get VLSB
   1243 1F            [ 4] 3328 	RRA			; Shift VLSB right
   1244 47            [ 4] 3329 	LD	B,A		; Re-save VLSB
   1245 2D            [ 4] 3330 	DEC	L		; Count bits multiplied
   1246 7C            [ 4] 3331 	LD	A,H		; Get LSB of multiplier
   1247 C2 29 12      [10] 3332 	JP	NZ,MUL8LP	; More - Do it
   124A E1            [10] 3333 POPHRT: POP	HL		; Restore address of number
   124B C9            [10] 3334 	RET
                           3335 ;
   124C 43            [ 4] 3336 BYTSFT: LD	B,E		; Shift partial product left
   124D 5A            [ 4] 3337 	LD	E,D
   124E 51            [ 4] 3338 	LD	D,C
   124F 4F            [ 4] 3339 	LD	C,A
   1250 C9            [10] 3340 	RET
                           3341 ;
   1251 CD 36 13      [17] 3342 DIV10:	CALL	STAKFP		; Save FPREG on stack
q  1254 01 E4 20      [10] 3343 	LD	BC,8420H	; BCDE = 10.
q  1257 11 00 00      [10] 3344 	LD	DE,0000H
   125A CD 46 13      [17] 3345 	CALL	FPBCDE		; Move 10 to FPREG
                           3346 ;
   125D C1            [10] 3347 DIV:	POP	BC		; Get number from stack
   125E D1            [10] 3348 	POP	DE
   125F CD 08 13      [17] 3349 DVBCDE: CALL	TSTSGN		; Test sign of FPREG
   1262 CA 3A 01      [10] 3350 	JP	Z,DZERR		; Error if division by zero
   1265 2E FF         [ 7] 3351 	LD	L,-1		; Flag subtract exponents
   1267 CD C6 12      [17] 3352 	CALL	ADDEXP		; Subtract exponents
   126A 34            [11] 3353 	INC	(HL)		; Add 2 to exponent to adjust
   126B 34            [11] 3354 	INC	(HL)
   126C 2B            [ 6] 3355 	DEC	HL		; Point to MSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 62
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   126D 7E            [ 7] 3356 	LD	A,(HL)		; Get MSB of dividend
u  126E 32 00 00      [13] 3357 	LD	(DIV3),A	; Save for subtraction
   1271 2B            [ 6] 3358 	DEC	HL
   1272 7E            [ 7] 3359 	LD	A,(HL)		; Get NMSB of dividend
u  1273 32 00 00      [13] 3360 	LD	(DIV2),A	; Save for subtraction
   1276 2B            [ 6] 3361 	DEC	HL
   1277 7E            [ 7] 3362 	LD	A,(HL)		; Get MSB of dividend
u  1278 32 00 00      [13] 3363 	LD	(DIV1),A	; Save for subtraction
   127B 41            [ 4] 3364 	LD	B,C		; Get MSB
   127C EB            [ 4] 3365 	EX	DE,HL		; NMSB,LSB to HL
   127D AF            [ 4] 3366 	XOR	A
   127E 4F            [ 4] 3367 	LD	C,A		; Clear MSB of quotient
   127F 57            [ 4] 3368 	LD	D,A		; Clear NMSB of quotient
   1280 5F            [ 4] 3369 	LD	E,A		; Clear LSB of quotient
u  1281 32 00 00      [13] 3370 	LD	(DIV4),A	; Clear overflow count
   1284 E5            [11] 3371 DIVLP:	PUSH	HL		; Save divisor
   1285 C5            [11] 3372 	PUSH	BC
   1286 7D            [ 4] 3373 	LD	A,L		; Get LSB of number
u  1287 CD 00 00      [17] 3374 	CALL	DIVSUP		; Subt' divisor from dividend
   128A DE 00         [ 7] 3375 	SBC	A,0		; Count for overflows
   128C 3F            [ 4] 3376 	CCF
   128D D2 96 12      [10] 3377 	JP	NC,RESDIV	; Restore divisor if borrow
u  1290 32 00 00      [13] 3378 	LD	(DIV4),A	; Re-save overflow count
   1293 F1            [10] 3379 	POP	AF		; Scrap divisor
   1294 F1            [10] 3380 	POP	AF
   1295 37            [ 4] 3381 	SCF			; Set carry to
                           3382 	DB	0D2H		; Skip "POP BC" and "POP HL"
                           3383 ;
   1296 C1            [10] 3384 RESDIV: POP	BC		; Restore divisor
   1297 E1            [10] 3385 	POP	HL
   1298 79            [ 4] 3386 	LD	A,C		; Get MSB of quotient
   1299 3C            [ 4] 3387 	INC	A
   129A 3D            [ 4] 3388 	DEC	A
   129B 1F            [ 4] 3389 	RRA			; Bit 0 to bit 7
   129C FA 5E 11      [10] 3390 	JP	M,RONDB		; Done - Normalise result
   129F 17            [ 4] 3391 	RLA			; Restore carry
   12A0 7B            [ 4] 3392 	LD	A,E		; Get LSB of quotient
   12A1 17            [ 4] 3393 	RLA			; Double it
   12A2 5F            [ 4] 3394 	LD	E,A		; Put it back
   12A3 7A            [ 4] 3395 	LD	A,D		; Get NMSB of quotient
   12A4 17            [ 4] 3396 	RLA			; Double it
   12A5 57            [ 4] 3397 	LD	D,A		; Put it back
   12A6 79            [ 4] 3398 	LD	A,C		; Get MSB of quotient
   12A7 17            [ 4] 3399 	RLA			; Double it
   12A8 4F            [ 4] 3400 	LD	C,A		; Put it back
   12A9 29            [11] 3401 	ADD	HL,HL		; Double NMSB,LSB of divisor
   12AA 78            [ 4] 3402 	LD	A,B		; Get MSB of divisor
   12AB 17            [ 4] 3403 	RLA			; Double it
   12AC 47            [ 4] 3404 	LD	B,A		; Put it back
u  12AD 3A 00 00      [13] 3405 	LD	A,(DIV4)	; Get VLSB of quotient
   12B0 17            [ 4] 3406 	RLA			; Double it
u  12B1 32 00 00      [13] 3407 	LD	(DIV4),A	; Put it back
   12B4 79            [ 4] 3408 	LD	A,C		; Get MSB of quotient
   12B5 B2            [ 4] 3409 	OR	D		; Merge NMSB
   12B6 B3            [ 4] 3410 	OR	E		; Merge LSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 63
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   12B7 C2 84 12      [10] 3411 	JP	NZ,DIVLP	; Not done - Keep dividing
   12BA E5            [11] 3412 	PUSH	HL		; Save divisor
u  12BB 21 00 00      [10] 3413 	LD	HL,FPEXP	; Point to exponent
   12BE 35            [11] 3414 	DEC	(HL)		; Divide by 2
   12BF E1            [10] 3415 	POP	HL		; Restore divisor
   12C0 C2 84 12      [10] 3416 	JP	NZ,DIVLP	; Ok - Keep going
   12C3 C3 42 01      [10] 3417 	JP	OVERR		; Overflow error
                           3418 ;
   12C6 78            [ 4] 3419 ADDEXP: LD	A,B		; Get exponent of dividend
   12C7 B7            [ 4] 3420 	OR	A		; Test it
   12C8 CA EA 12      [10] 3421 	JP	Z,OVTST3	; Zero - Result zero
   12CB 7D            [ 4] 3422 	LD	A,L		; Get add/subtract flag
u  12CC 21 00 00      [10] 3423 	LD	HL,FPEXP	; Point to exponent
   12CF AE            [ 7] 3424 	XOR	(HL)		; Add or subtract it
   12D0 80            [ 4] 3425 	ADD	A,B		; Add the other exponent
   12D1 47            [ 4] 3426 	LD	B,A		; Save new exponent
   12D2 1F            [ 4] 3427 	RRA			; Test exponent for overflow
   12D3 A8            [ 4] 3428 	XOR	B
   12D4 78            [ 4] 3429 	LD	A,B		; Get exponent
   12D5 F2 E9 12      [10] 3430 	JP	P,OVTST2	; Positive - Test for overflow
q  12D8 C6 50         [ 7] 3431 	ADD	A,80H		; Add excess 128
   12DA 77            [ 7] 3432 	LD	(HL),A		; Save new exponent
   12DB CA 4A 12      [10] 3433 	JP	Z,POPHRT	; Zero - Result zero
   12DE CD 6B 13      [17] 3434 	CALL	SIGNS		; Set MSBs and sign of result
   12E1 77            [ 7] 3435 	LD	(HL),A		; Save new exponent
   12E2 2B            [ 6] 3436 	DEC	HL		; Point to MSB
   12E3 C9            [10] 3437 	RET
                           3438 ;
   12E4 CD 08 13      [17] 3439 OVTST1: CALL	TSTSGN		; Test sign of FPREG
   12E7 2F            [ 4] 3440 	CPL			; Invert sign
   12E8 E1            [10] 3441 	POP	HL		; Clean up stack
   12E9 B7            [ 4] 3442 OVTST2: OR	A		; Test if new exponent zero
   12EA E1            [10] 3443 OVTST3: POP	HL		; Clear off return address
   12EB F2 3D 11      [10] 3444 	JP	P,RESZER	; Result zero
   12EE C3 42 01      [10] 3445 	JP	OVERR		; Overflow error
                           3446 ;
   12F1 CD 51 13      [17] 3447 MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
   12F4 78            [ 4] 3448 	LD	A,B		; Get exponent
   12F5 B7            [ 4] 3449 	OR	A		; Is it zero?
   12F6 C8            [11] 3450 	RET	Z		; Yes - Result is zero
   12F7 C6 02         [ 7] 3451 	ADD	A,2		; Multiply by 4
   12F9 DA 42 01      [10] 3452 	JP	C,OVERR		; Overflow - ?OV Error
   12FC 47            [ 4] 3453 	LD	B,A		; Re-save exponent
   12FD CD D9 10      [17] 3454 	CALL	FPADD		; Add BCDE to FPREG (Times 5)
u  1300 21 00 00      [10] 3455 	LD	HL,FPEXP	; Point to exponent
   1303 34            [11] 3456 	INC	(HL)		; Double number (Times 10)
   1304 C0            [11] 3457 	RET	NZ		; Ok - Return
   1305 C3 42 01      [10] 3458 	JP	OVERR		; Overflow error
                           3459 ;
u  1308 3A 00 00      [13] 3460 TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
   130B B7            [ 4] 3461 	OR	A
   130C C8            [11] 3462 	RET	Z		; RETurn if number is zero
u  130D 3A 02 00      [13] 3463 	LD	A,(FPREG+2)	; Get MSB of FPREG
                           3464 	DB	0FEH		; Test sign
   1310 2F            [ 4] 3465 RETREL: CPL			; Invert sign
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 64
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1311 17            [ 4] 3466 	RLA			; Sign bit to carry
   1312 9F            [ 4] 3467 FLGDIF: SBC	A,A		; Carry to all bits of A
   1313 C0            [11] 3468 	RET	NZ		; Return -1 if negative
   1314 3C            [ 4] 3469 	INC	A		; Bump to +1
   1315 C9            [10] 3470 	RET			; Positive - Return +1
                           3471 ;
   1316 CD 08 13      [17] 3472 SGN:	CALL	TSTSGN		; Test sign of FPREG
q  1319 06 50         [ 7] 3473 FLGREL: LD	B,80H+8		; 8 bit integer in exponent
   131B 11 00 00      [10] 3474 	LD	DE,0		; Zero NMSB and LSB
u  131E 21 00 00      [10] 3475 RETINT: LD	HL,FPEXP	; Point to exponent
   1321 4F            [ 4] 3476 	LD	C,A		; CDE = MSB,NMSB and LSB
   1322 70            [ 7] 3477 	LD	(HL),B		; Save exponent
   1323 06 00         [ 7] 3478 	LD	B,0		; CDE = integer to normalise
   1325 23            [ 6] 3479 	INC	HL		; Point to sign of result
q  1326 36 50         [10] 3480 	LD	(HL),80H	; Set sign of result
   1328 17            [ 4] 3481 	RLA			; Carry = sign of integer
   1329 C3 27 11      [10] 3482 	JP	CONPOS		; Set sign of result
                           3483 ;
   132C CD 08 13      [17] 3484 ABS:	CALL	TSTSGN		; Test sign of FPREG
   132F F0            [11] 3485 	RET	P		; Return if positive
u  1330 21 02 00      [10] 3486 INVSGN: LD	HL,FPREG+2	; Point to MSB
   1333 7E            [ 7] 3487 	LD	A,(HL)		; Get sign of mantissa
q  1334                    3488 	XOR	80H		; Invert sign of mantissa
   1334 77            [ 7] 3489 	LD	(HL),A		; Re-save sign of mantissa
   1335 C9            [10] 3490 	RET
                           3491 ;
   1336 EB            [ 4] 3492 STAKFP: EX	DE,HL		; Save code string address
u  1337 2A 00 00      [16] 3493 	LD	HL,(FPREG)	; LSB,NLSB of FPREG
   133A E3            [19] 3494 	EX	(SP),HL		; Stack them,get return
   133B E5            [11] 3495 	PUSH	HL		; Re-save return
u  133C 2A 02 00      [16] 3496 	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
   133F E3            [19] 3497 	EX	(SP),HL		; Stack them,get return
   1340 E5            [11] 3498 	PUSH	HL		; Re-save return
   1341 EB            [ 4] 3499 	EX	DE,HL		; Restore code string address
   1342 C9            [10] 3500 	RET
                           3501 ;
   1343 CD 54 13      [17] 3502 PHLTFP: CALL	LOADFP		; Number at HL to BCDE
   1346 EB            [ 4] 3503 FPBCDE: EX	DE,HL		; Save code string address
u  1347 22 00 00      [16] 3504 	LD	(FPREG),HL	; Save LSB,NLSB of number
   134A 60            [ 4] 3505 	LD	H,B		; Exponent of number
   134B 69            [ 4] 3506 	LD	L,C		; MSB of number
u  134C 22 02 00      [16] 3507 	LD	(FPREG+2),HL	; Save MSB and exponent
   134F EB            [ 4] 3508 	EX	DE,HL		; Restore code string address
   1350 C9            [10] 3509 	RET
                           3510 ;
u  1351 21 00 00      [10] 3511 BCDEFP: LD	HL,FPREG	; Point to FPREG
   1354 5E            [ 7] 3512 LOADFP: LD	E,(HL)		; Get LSB of number
   1355 23            [ 6] 3513 	INC	HL
   1356 56            [ 7] 3514 	LD	D,(HL)		; Get NMSB of number
   1357 23            [ 6] 3515 	INC	HL
   1358 4E            [ 7] 3516 	LD	C,(HL)		; Get MSB of number
   1359 23            [ 6] 3517 	INC	HL
   135A 46            [ 7] 3518 	LD	B,(HL)		; Get exponent of number
   135B 23            [ 6] 3519 INCHL:	INC	HL		; Used for conditional "INC HL"
   135C C9            [10] 3520 	RET
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 65
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                           3521 ;
u  135D 11 00 00      [10] 3522 FPTHL:	LD	DE,FPREG	; Point to FPREG
   1360 06 04         [ 7] 3523 DETHL4: LD	B,4		; 4 bytes to move
   1362 1A            [ 7] 3524 DETHLB: LD	A,(DE)		; Get source
   1363 77            [ 7] 3525 	LD	(HL),A		; Save destination
   1364 13            [ 6] 3526 	INC	DE		; Next source
   1365 23            [ 6] 3527 	INC	HL		; Next destination
   1366 05            [ 4] 3528 	DEC	B		; Count bytes
   1367 C2 62 13      [10] 3529 	JP	NZ,DETHLB	; Loop if more
   136A C9            [10] 3530 	RET
                           3531 ;
u  136B 21 02 00      [10] 3532 SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
   136E 7E            [ 7] 3533 	LD	A,(HL)		; Get MSB
   136F 07            [ 4] 3534 	RLCA			; Old sign to carry
   1370 37            [ 4] 3535 	SCF			; Set MSBit
   1371 1F            [ 4] 3536 	RRA			; Set MSBit of MSB
   1372 77            [ 7] 3537 	LD	(HL),A		; Save new MSB
   1373 3F            [ 4] 3538 	CCF			; Complement sign
   1374 1F            [ 4] 3539 	RRA			; Old sign to carry
   1375 23            [ 6] 3540 	INC	HL
   1376 23            [ 6] 3541 	INC	HL
   1377 77            [ 7] 3542 	LD	(HL),A		; Set sign of result
   1378 79            [ 4] 3543 	LD	A,C		; Get MSB
   1379 07            [ 4] 3544 	RLCA			; Old sign to carry
   137A 37            [ 4] 3545 	SCF			; Set MSBit
   137B 1F            [ 4] 3546 	RRA			; Set MSBit of MSB
   137C 4F            [ 4] 3547 	LD	C,A		; Save MSB
   137D 1F            [ 4] 3548 	RRA
   137E AE            [ 7] 3549 	XOR	(HL)		; New sign of result
   137F C9            [10] 3550 	RET
                           3551 ;
   1380 78            [ 4] 3552 CMPNUM: LD	A,B		; Get exponent of number
   1381 B7            [ 4] 3553 	OR	A
   1382 CA 08 13      [10] 3554 	JP	Z,TSTSGN	; Zero - Test sign of FPREG
   1385 21 10 13      [10] 3555 	LD	HL,RETREL	; Return relation routine
   1388 E5            [11] 3556 	PUSH	HL		; Save for return
   1389 CD 08 13      [17] 3557 	CALL	TSTSGN		; Test sign of FPREG
   138C 79            [ 4] 3558 	LD	A,C		; Get MSB of number
   138D C8            [11] 3559 	RET	Z		; FPREG zero - Number's MSB
u  138E 21 02 00      [10] 3560 	LD	HL,FPREG+2	; MSB of FPREG
   1391 AE            [ 7] 3561 	XOR	(HL)		; Combine signs
   1392 79            [ 4] 3562 	LD	A,C		; Get MSB of number
   1393 F8            [11] 3563 	RET	M		; Exit if signs different
   1394 CD 9A 13      [17] 3564 	CALL	CMPFP		; Compare FP numbers
   1397 1F            [ 4] 3565 	RRA			; Get carry to sign
   1398 A9            [ 4] 3566 	XOR	C		; Combine with MSB of number
   1399 C9            [10] 3567 	RET
                           3568 ;
   139A 23            [ 6] 3569 CMPFP:	INC	HL		; Point to exponent
   139B 78            [ 4] 3570 	LD	A,B		; Get exponent
   139C BE            [ 7] 3571 	CP	(HL)		; Compare exponents
   139D C0            [11] 3572 	RET	NZ		; Different
   139E 2B            [ 6] 3573 	DEC	HL		; Point to MBS
   139F 79            [ 4] 3574 	LD	A,C		; Get MSB
   13A0 BE            [ 7] 3575 	CP	(HL)		; Compare MSBs
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 66
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   13A1 C0            [11] 3576 	RET	NZ		; Different
   13A2 2B            [ 6] 3577 	DEC	HL		; Point to NMSB
   13A3 7A            [ 4] 3578 	LD	A,D		; Get NMSB
   13A4 BE            [ 7] 3579 	CP	(HL)		; Compare NMSBs
   13A5 C0            [11] 3580 	RET	NZ		; Different
   13A6 2B            [ 6] 3581 	DEC	HL		; Point to LSB
   13A7 7B            [ 4] 3582 	LD	A,E		; Get LSB
   13A8 96            [ 7] 3583 	SUB	(HL)		; Compare LSBs
   13A9 C0            [11] 3584 	RET	NZ		; Different
   13AA E1            [10] 3585 	POP	HL		; Drop RETurn
   13AB E1            [10] 3586 	POP	HL		; Drop another RETurn
   13AC C9            [10] 3587 	RET
                           3588 ;
   13AD 47            [ 4] 3589 FPINT:	LD	B,A		; <- Move
   13AE 4F            [ 4] 3590 	LD	C,A		; <- exponent
   13AF 57            [ 4] 3591 	LD	D,A		; <- to all
   13B0 5F            [ 4] 3592 	LD	E,A		; <- bits
   13B1 B7            [ 4] 3593 	OR	A		; Test exponent
   13B2 C8            [11] 3594 	RET	Z		; Zero - Return zero
   13B3 E5            [11] 3595 	PUSH	HL		; Save pointer to number
   13B4 CD 51 13      [17] 3596 	CALL	BCDEFP		; Move FPREG to BCDE
   13B7 CD 6B 13      [17] 3597 	CALL	SIGNS		; Set MSBs & sign of result
   13BA AE            [ 7] 3598 	XOR	(HL)		; Combine with sign of FPREG
   13BB 67            [ 4] 3599 	LD	H,A		; Save combined signs
   13BC FC D1 13      [17] 3600 	CALL	M,DCBCDE	; Negative - Decrement BCDE
q  13BF 3E 50         [ 7] 3601 	LD	A,80H+24	; 24 bits
   13C1 90            [ 4] 3602 	SUB	B		; Bits to shift
   13C2 CD 9A 11      [17] 3603 	CALL	SCALE		; Shift BCDE
   13C5 7C            [ 4] 3604 	LD	A,H		; Get combined sign
   13C6 17            [ 4] 3605 	RLA			; Sign to carry
   13C7 DC 6D 11      [17] 3606 	CALL	C,FPROND	; Negative - Round number up
   13CA 06 00         [ 7] 3607 	LD	B,0		; Zero exponent
   13CC DC 86 11      [17] 3608 	CALL	C,COMPL		; If negative make positive
   13CF E1            [10] 3609 	POP	HL		; Restore pointer to number
   13D0 C9            [10] 3610 	RET
                           3611 ;
   13D1 1B            [ 6] 3612 DCBCDE: DEC	DE		; Decrement BCDE
   13D2 7A            [ 4] 3613 	LD	A,D		; Test LSBs
   13D3 A3            [ 4] 3614 	AND	E
   13D4 3C            [ 4] 3615 	INC	A
   13D5 C0            [11] 3616 	RET	NZ		; Exit if LSBs not FFFF
   13D6 0B            [ 6] 3617 	DEC	BC		; Decrement MSBs
   13D7 C9            [10] 3618 	RET
                           3619 ;
u  13D8 21 00 00      [10] 3620 INT:	LD	HL,FPEXP	; Point to exponent
   13DB 7E            [ 7] 3621 	LD	A,(HL)		; Get exponent
q  13DC                    3622 	CP	80H+24		; Integer accuracy only?
u  13DC 3A 00 00      [13] 3623 	LD	A,(FPREG)	; Get LSB
   13DF D0            [11] 3624 	RET	NC		; Yes - Already integer
   13E0 7E            [ 7] 3625 	LD	A,(HL)		; Get exponent
   13E1 CD AD 13      [17] 3626 	CALL	FPINT		; F.P to integer
q  13E4 36 50         [10] 3627 	LD	(HL),80H+24	; Save 24 bit integer
   13E6 7B            [ 4] 3628 	LD	A,E		; Get LSB of number
   13E7 F5            [11] 3629 	PUSH	AF		; Save LSB
   13E8 79            [ 4] 3630 	LD	A,C		; Get MSB of number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 67
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   13E9 17            [ 4] 3631 	RLA			; Sign to carry
   13EA CD 27 11      [17] 3632 	CALL	CONPOS		; Set sign of result
   13ED F1            [10] 3633 	POP	AF		; Restore LSB of number
   13EE C9            [10] 3634 	RET
                           3635 ;
   13EF 21 00 00      [10] 3636 MLDEBC: LD	HL,0		; Clear partial product
   13F2 78            [ 4] 3637 	LD	A,B		; Test multiplier
   13F3 B1            [ 4] 3638 	OR	C
   13F4 C8            [11] 3639 	RET	Z		; Return zero if zero
   13F5 3E 10         [ 7] 3640 	LD	A,16		; 16 bits
   13F7 29            [11] 3641 MLDBLP: ADD	HL,HL		; Shift P.P left
   13F8 DA 63 0C      [10] 3642 	JP	C,BSERR		; ?BS Error if overflow
   13FB EB            [ 4] 3643 	EX	DE,HL
   13FC 29            [11] 3644 	ADD	HL,HL		; Shift multiplier left
   13FD EB            [ 4] 3645 	EX	DE,HL
   13FE D2 05 14      [10] 3646 	JP	NC,NOMLAD	; Bit was zero - No add
   1401 09            [11] 3647 	ADD	HL,BC		; Add multiplicand
   1402 DA 63 0C      [10] 3648 	JP	C,BSERR		; ?BS Error if overflow
   1405 3D            [ 4] 3649 NOMLAD: DEC	A		; Count bits
   1406 C2 F7 13      [10] 3650 	JP	NZ,MLDBLP	; More
   1409 C9            [10] 3651 	RET
                           3652 ;
q  140A                    3653 ASCTFP: CP	'-'		; Negative?
   140A F5            [11] 3654 	PUSH	AF		; Save it and flags
   140B CA 12 14      [10] 3655 	JP	Z,CNVNUM	; Yes - Convert number
q  140E                    3656 	CP	'+'		; Positive?
   140E CA 12 14      [10] 3657 	JP	Z,CNVNUM	; Yes - Convert number
   1411 2B            [ 6] 3658 	DEC	HL		; DEC 'cos GETCHR INCs
   1412 CD 3D 11      [17] 3659 CNVNUM: CALL	RESZER		; Set result to zero
   1415 47            [ 4] 3660 	LD	B,A		; Digits after point counter
   1416 57            [ 4] 3661 	LD	D,A		; Sign of exponent
   1417 5F            [ 4] 3662 	LD	E,A		; Exponent of ten
   1418 2F            [ 4] 3663 	CPL
   1419 4F            [ 4] 3664 	LD	C,A		; Before or after point flag
   141A CD 5F 05      [17] 3665 MANLP:	CALL	GETCHR		; Get next character
   141D DA 5F 14      [10] 3666 	JP	C,ADDIG		; Digit - Add to number
q  1420                    3667 	CP	'.'
   1420 CA 3A 14      [10] 3668 	JP	Z,DPOINT	; '.' - Flag point
q  1423                    3669 	CP	'E'
   1423 C2 3E 14      [10] 3670 	JP	NZ,CONEXP	; Not 'E' - Scale number
   1426 CD 5F 05      [17] 3671 	CALL	GETCHR		; Get next character
   1429 CD A0 0A      [17] 3672 	CALL	SGNEXP		; Get sign of exponent
   142C CD 5F 05      [17] 3673 EXPLP:	CALL	GETCHR		; Get next character
   142F DA 7F 14      [10] 3674 	JP	C,EDIGIT	; Digit - Add to exponent
   1432 14            [ 4] 3675 	INC	D		; Is sign negative?
   1433 C2 3E 14      [10] 3676 	JP	NZ,CONEXP	; No - Scale number
   1436 AF            [ 4] 3677 	XOR	A
   1437 93            [ 4] 3678 	SUB	E		; Negate exponent
   1438 5F            [ 4] 3679 	LD	E,A		; And re-save it
   1439 0C            [ 4] 3680 	INC	C		; Flag end of number
   143A 0C            [ 4] 3681 DPOINT: INC	C		; Flag point passed
   143B CA 1A 14      [10] 3682 	JP	Z,MANLP		; Zero - Get another digit
   143E E5            [11] 3683 CONEXP: PUSH	HL		; Save code string address
   143F 7B            [ 4] 3684 	LD	A,E		; Get exponent
   1440 90            [ 4] 3685 	SUB	B		; Subtract digits after point
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 68
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1441 F4 57 14      [17] 3686 SCALMI: CALL	P,SCALPL	; Positive - Multiply number
   1444 F2 4D 14      [10] 3687 	JP	P,ENDCON	; Positive - All done
   1447 F5            [11] 3688 	PUSH	AF		; Save number of times to /10
   1448 CD 51 12      [17] 3689 	CALL	DIV10		; Divide by 10
   144B F1            [10] 3690 	POP	AF		; Restore count
   144C 3C            [ 4] 3691 	INC	A		; Count divides
                           3692 ;
   144D C2 41 14      [10] 3693 ENDCON: JP	NZ,SCALMI	; More to do
   1450 D1            [10] 3694 	POP	DE		; Restore code string address
   1451 F1            [10] 3695 	POP	AF		; Restore sign of number
   1452 CC 30 13      [17] 3696 	CALL	Z,INVSGN	; Negative - Negate number
   1455 EB            [ 4] 3697 	EX	DE,HL		; Code string address to HL
   1456 C9            [10] 3698 	RET
                           3699 ;
   1457 C8            [11] 3700 SCALPL: RET	Z		; Exit if no scaling needed
   1458 F5            [11] 3701 MULTEN: PUSH	AF		; Save count
   1459 CD F1 12      [17] 3702 	CALL	MLSP10		; Multiply number by 10
   145C F1            [10] 3703 	POP	AF		; Restore count
   145D 3D            [ 4] 3704 	DEC	A		; Count multiplies
   145E C9            [10] 3705 	RET
                           3706 ;
   145F D5            [11] 3707 ADDIG:	PUSH	DE		; Save sign of exponent
   1460 57            [ 4] 3708 	LD	D,A		; Save digit
   1461 78            [ 4] 3709 	LD	A,B		; Get digits after point
   1462 89            [ 4] 3710 	ADC	A,C		; Add one if after point
   1463 47            [ 4] 3711 	LD	B,A		; Re-save counter
   1464 C5            [11] 3712 	PUSH	BC		; Save point flags
   1465 E5            [11] 3713 	PUSH	HL		; Save code string address
   1466 D5            [11] 3714 	PUSH	DE		; Save digit
   1467 CD F1 12      [17] 3715 	CALL	MLSP10		; Multiply number by 10
   146A F1            [10] 3716 	POP	AF		; Restore digit
q  146B                    3717 	SUB	'0'		; Make it absolute
   146B CD 74 14      [17] 3718 	CALL	RSCALE		; Re-scale number
   146E E1            [10] 3719 	POP	HL		; Restore code string address
   146F C1            [10] 3720 	POP	BC		; Restore point flags
   1470 D1            [10] 3721 	POP	DE		; Restore sign of exponent
   1471 C3 1A 14      [10] 3722 	JP	MANLP		; Get another digit
                           3723 ;
   1474 CD 36 13      [17] 3724 RSCALE: CALL	STAKFP		; Put number on stack
   1477 CD 19 13      [17] 3725 	CALL	FLGREL		; Digit to add to FPREG
   147A C1            [10] 3726 PADD:	POP	BC		; Restore number
   147B D1            [10] 3727 	POP	DE
   147C C3 D9 10      [10] 3728 	JP	FPADD		; Add BCDE to FPREG and return
                           3729 ;
   147F 7B            [ 4] 3730 EDIGIT: LD	A,E		; Get digit
   1480 07            [ 4] 3731 	RLCA			; Times 2
   1481 07            [ 4] 3732 	RLCA			; Times 4
   1482 83            [ 4] 3733 	ADD	A,E		; Times 5
   1483 07            [ 4] 3734 	RLCA			; Times 10
   1484 86            [ 7] 3735 	ADD	A,(HL)		; Add next digit
q  1485                    3736 	SUB	'0'		; Make it absolute
   1485 5F            [ 4] 3737 	LD	E,A		; Save new digit
   1486 C3 2C 14      [10] 3738 	JP	EXPLP		; Look for another digit
                           3739 ;
   1489 E5            [11] 3740 LINEIN: PUSH	HL		; Save code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 69
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   148A 21 E2 00      [10] 3741 	LD	HL,INMSG	; Output " in "
   148D CD 27 0E      [17] 3742 	CALL	PRS		; Output string at HL
   1490 E1            [10] 3743 	POP	HL		; Restore code string address
   1491 EB            [ 4] 3744 PRNTHL: EX	DE,HL		; Code string address to DE
   1492 AF            [ 4] 3745 	XOR	A
q  1493 06 50         [ 7] 3746 	LD	B,80H+24	; 24 bits
   1495 CD 1E 13      [17] 3747 	CALL	RETINT		; Return the integer
   1498 21 26 0E      [10] 3748 	LD	HL,PRNUMS	; Print number string
   149B E5            [11] 3749 	PUSH	HL		; Save for return
u  149C 21 00 00      [10] 3750 NUMASC: LD	HL,PBUFF	; Convert number to ASCII
   149F E5            [11] 3751 	PUSH	HL		; Save for return
   14A0 CD 08 13      [17] 3752 	CALL	TSTSGN		; Test sign of FPREG
q  14A3 36 20         [10] 3753 	LD	(HL),' '	; Space at start
   14A5 F2 AA 14      [10] 3754 	JP	P,SPCFST	; Positive - Space to start
q  14A8 36 2D         [10] 3755 	LD	(HL),'-'	; '-' sign at start
   14AA 23            [ 6] 3756 SPCFST: INC	HL		; First byte of number
q  14AB 36 30         [10] 3757 	LD	(HL),'0'	; '0' if zero
   14AD CA 5C 15      [10] 3758 	JP	Z,JSTZER	; Return '0' if zero
   14B0 E5            [11] 3759 	PUSH	HL		; Save buffer address
   14B1 FC 30 13      [17] 3760 	CALL	M,INVSGN	; Negate FPREG if negative
   14B4 AF            [ 4] 3761 	XOR	A		; Zero A
   14B5 F5            [11] 3762 	PUSH	AF		; Save it
   14B6 CD 62 15      [17] 3763 	CALL	RNGTST		; Test number is in range
q  14B9 01 B7 23      [10] 3764 SIXDIG: LD	BC,9143H	; BCDE - 99999.9
kq 14BC 11 04 00      [10] 3765 	LD	DE,4FF8H
   14BF CD 80 13      [17] 3766 	CALL	CMPNUM		; Compare numbers
   14C2 B7            [ 4] 3767 	OR	A
   14C3 E2 D7 14      [10] 3768 	JP	PO,INRNG	; > 99999.9 - Sort it out
   14C6 F1            [10] 3769 	POP	AF		; Restore count
   14C7 CD 58 14      [17] 3770 	CALL	MULTEN		; Multiply by ten
   14CA F5            [11] 3771 	PUSH	AF		; Re-save count
   14CB C3 B9 14      [10] 3772 	JP	SIXDIG		; Test it again
                           3773 ;
   14CE CD 51 12      [17] 3774 GTSIXD: CALL	DIV10		; Divide by 10
   14D1 F1            [10] 3775 	POP	AF		; Get count
   14D2 3C            [ 4] 3776 	INC	A		; Count divides
   14D3 F5            [11] 3777 	PUSH	AF		; Re-save count
   14D4 CD 62 15      [17] 3778 	CALL	RNGTST		; Test number is in range
   14D7 CD C8 10      [17] 3779 INRNG:	CALL	ROUND		; Add 0.5 to FPREG
   14DA 3C            [ 4] 3780 	INC	A
   14DB CD AD 13      [17] 3781 	CALL	FPINT		; F.P to integer
   14DE CD 46 13      [17] 3782 	CALL	FPBCDE		; Move BCDE to FPREG
q  14E1 01 32 01      [10] 3783 	LD	BC,0306H	; 1E+06 to 1E-03 range
   14E4 F1            [10] 3784 	POP	AF		; Restore count
   14E5 81            [ 4] 3785 	ADD	A,C		; 6 digits before point
   14E6 3C            [ 4] 3786 	INC	A		; Add one
   14E7 FA F3 14      [10] 3787 	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
   14EA FE 08         [ 7] 3788 	CP	6+1+1		; More than 999999 ?
   14EC D2 F3 14      [10] 3789 	JP	NC,MAKNUM	; Yes - Do it in 'E' form
   14EF 3C            [ 4] 3790 	INC	A		; Adjust for exponent
   14F0 47            [ 4] 3791 	LD	B,A		; Exponent of number
   14F1 3E 02         [ 7] 3792 	LD	A,2		; Make it zero after
                           3793 ;
   14F3 3D            [ 4] 3794 MAKNUM: DEC	A		; Adjust for digits to do
   14F4 3D            [ 4] 3795 	DEC	A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 70
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   14F5 E1            [10] 3796 	POP	HL		; Restore buffer address
   14F6 F5            [11] 3797 	PUSH	AF		; Save count
   14F7 11 71 15      [10] 3798 	LD	DE,POWERS	; Powers of ten
   14FA 05            [ 4] 3799 	DEC	B		; Count digits before point
   14FB C2 04 15      [10] 3800 	JP	NZ,DIGTXT	; Not zero - Do number
q  14FE 36 2E         [10] 3801 	LD	(HL),'.'	; Save point
   1500 23            [ 6] 3802 	INC	HL		; Move on
q  1501 36 30         [10] 3803 	LD	(HL),'0'	; Save zero
   1503 23            [ 6] 3804 	INC	HL		; Move on
   1504 05            [ 4] 3805 DIGTXT: DEC	B		; Count digits before point
q  1505 36 2E         [10] 3806 	LD	(HL),'.'	; Save point in case
   1507 CC 5B 13      [17] 3807 	CALL	Z,INCHL		; Last digit - move on
   150A C5            [11] 3808 	PUSH	BC		; Save digits before point
   150B E5            [11] 3809 	PUSH	HL		; Save buffer address
   150C D5            [11] 3810 	PUSH	DE		; Save powers of ten
   150D CD 51 13      [17] 3811 	CALL	BCDEFP		; Move FPREG to BCDE
   1510 E1            [10] 3812 	POP	HL		; Powers of ten table
q  1511 06 30         [ 7] 3813 	LD	B, '0'-1	; ASCII '0' - 1
   1513 04            [ 4] 3814 TRYAGN: INC	B		; Count subtractions
   1514 7B            [ 4] 3815 	LD	A,E		; Get LSB
   1515 96            [ 7] 3816 	SUB	(HL)		; Subtract LSB
   1516 5F            [ 4] 3817 	LD	E,A		; Save LSB
   1517 23            [ 6] 3818 	INC	HL
   1518 7A            [ 4] 3819 	LD	A,D		; Get NMSB
   1519 9E            [ 7] 3820 	SBC	A,(HL)		; Subtract NMSB
   151A 57            [ 4] 3821 	LD	D,A		; Save NMSB
   151B 23            [ 6] 3822 	INC	HL
   151C 79            [ 4] 3823 	LD	A,C		; Get MSB
   151D 9E            [ 7] 3824 	SBC	A,(HL)		; Subtract MSB
   151E 4F            [ 4] 3825 	LD	C,A		; Save MSB
   151F 2B            [ 6] 3826 	DEC	HL		; Point back to start
   1520 2B            [ 6] 3827 	DEC	HL
   1521 D2 13 15      [10] 3828 	JP	NC,TRYAGN	; No overflow - Try again
   1524 CD 7A 11      [17] 3829 	CALL	PLUCDE		; Restore number
   1527 23            [ 6] 3830 	INC	HL		; Start of next number
   1528 CD 46 13      [17] 3831 	CALL	FPBCDE		; Move BCDE to FPREG
   152B EB            [ 4] 3832 	EX	DE,HL		; Save point in table
   152C E1            [10] 3833 	POP	HL		; Restore buffer address
   152D 70            [ 7] 3834 	LD	(HL),B		; Save digit in buffer
   152E 23            [ 6] 3835 	INC	HL		; And move on
   152F C1            [10] 3836 	POP	BC		; Restore digit count
   1530 0D            [ 4] 3837 	DEC	C		; Count digits
   1531 C2 04 15      [10] 3838 	JP	NZ,DIGTXT	; More - Do them
   1534 05            [ 4] 3839 	DEC	B		; Any decimal part?
   1535 CA 40 15      [10] 3840 	JP	Z,DOEBIT	; No - Do 'E' bit
   1538 2B            [ 6] 3841 SUPTLZ: DEC	HL		; Move back through buffer
   1539 7E            [ 7] 3842 	LD	A,(HL)		; Get character
q  153A                    3843 	CP	'0'		; '0' character?
   153A CA 38 15      [10] 3844 	JP	Z,SUPTLZ	; Yes - Look back for more
q  153D                    3845 	CP	'.'		; A decimal point?
   153D C4 5B 13      [17] 3846 	CALL	NZ,INCHL	; Move back over digit
                           3847 ;
   1540 F1            [10] 3848 DOEBIT: POP	AF		; Get 'E' flag
   1541 CA 5F 15      [10] 3849 	JP	Z,NOENED	; No 'E' needed - End buffer
q  1544 36 45         [10] 3850 	LD	(HL),'E'	; Put 'E' in buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 71
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1546 23            [ 6] 3851 	INC	HL		; And move on
q  1547 36 2B         [10] 3852 	LD	(HL),'+'	; Put '+' in buffer
   1549 F2 50 15      [10] 3853 	JP	P,OUTEXP	; Positive - Output exponent
q  154C 36 2D         [10] 3854 	LD	(HL),'-'	; Put '-' in buffer
   154E 2F            [ 4] 3855 	CPL			; Negate exponent
   154F 3C            [ 4] 3856 	INC	A
q  1550 06 30         [ 7] 3857 OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
   1552 04            [ 4] 3858 EXPTEN: INC	B		; Count subtractions
   1553 D6 0A         [ 7] 3859 	SUB	10		; Tens digit
   1555 D2 52 15      [10] 3860 	JP	NC,EXPTEN	; More to do
q  1558 C6 30         [ 7] 3861 	ADD	A,'0'+10	; Restore and make ASCII
   155A 23            [ 6] 3862 	INC	HL		; Move on
   155B 70            [ 7] 3863 	LD	(HL),B		; Save MSB of exponent
   155C 23            [ 6] 3864 JSTZER: INC	HL		;
   155D 77            [ 7] 3865 	LD	(HL),A		; Save LSB of exponent
   155E 23            [ 6] 3866 	INC	HL
   155F 71            [ 7] 3867 NOENED: LD	(HL),C		; Mark end of buffer
   1560 E1            [10] 3868 	POP	HL		; Restore code string address
   1561 C9            [10] 3869 	RET
                           3870 ;
q  1562 01 02 25      [10] 3871 RNGTST: LD	BC,9474H	; BCDE = 999999.
kq 1565 11 17 00      [10] 3872 	LD	DE,23F7H
   1568 CD 80 13      [17] 3873 	CALL	CMPNUM		; Compare numbers
   156B B7            [ 4] 3874 	OR	A
   156C E1            [10] 3875 	POP	HL		; Return address to HL
   156D E2 CE 14      [10] 3876 	JP	PO,GTSIXD	; Too big - Divide by ten
   1570 E9            [ 4] 3877 	JP	(HL)		; Otherwise return to caller
                           3878 ;
q  1571                    3879 HALF:	DB	00H,00H,00H,80H	; 0.5
                           3880 ;
q  1571                    3881 POWERS: DB	0A0H,086H,001H	; 100000
                           3882 	DB	010H,027H,000H	; 10000
                           3883 	DB	0E8H,003H,000H	; 1000
                           3884 	DB	064H,000H,000H	; 100
                           3885 	DB	00AH,000H,000H	; 10
                           3886 	DB	001H,000H,000H	; 1
                           3887 ;
   1571 21 30 13      [10] 3888 NEGAFT: LD	HL,INVSGN	; Negate result
   1574 E3            [19] 3889 	EX	(SP),HL		; To be done after caller
   1575 E9            [ 4] 3890 	JP	(HL)		; Return to caller
                           3891 ;
   1576 CD 36 13      [17] 3892 SQR:	CALL	STAKFP		; Put value on stack
   1579 21 71 15      [10] 3893 	LD	HL,HALF		; Set power to 1/2
   157C CD 43 13      [17] 3894 	CALL	PHLTFP		; Move 1/2 to FPREG
                           3895 ;
   157F C1            [10] 3896 POWER:	POP	BC		; Get base
   1580 D1            [10] 3897 	POP	DE
   1581 CD 08 13      [17] 3898 	CALL	TSTSGN		; Test sign of power
   1584 78            [ 4] 3899 	LD	A,B		; Get exponent of base
   1585 CA C2 15      [10] 3900 	JP	Z,EXP		; Make result 1 if zero
   1588 F2 8F 15      [10] 3901 	JP	P,POWER1	; Positive base - Ok
   158B B7            [ 4] 3902 	OR	A		; Zero to negative power?
   158C CA 3A 01      [10] 3903 	JP	Z,DZERR		; Yes - ?/0 Error
   158F B7            [ 4] 3904 POWER1: OR	A		; Base zero?
   1590 CA 3E 11      [10] 3905 	JP	Z,SAVEXP	; Yes - Return zero
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 72
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1593 D5            [11] 3906 	PUSH	DE		; Save base
   1594 C5            [11] 3907 	PUSH	BC
   1595 79            [ 4] 3908 	LD	A,C		; Get MSB of base
kq 1596                    3909 	OR	01111111B	; Get sign status
   1596 CD 51 13      [17] 3910 	CALL	BCDEFP		; Move power to BCDE
   1599 F2 AA 15      [10] 3911 	JP	P,POWER2	; Positive base - Ok
   159C D5            [11] 3912 	PUSH	DE		; Save power
   159D C5            [11] 3913 	PUSH	BC
   159E CD D8 13      [17] 3914 	CALL	INT		; Get integer of power
   15A1 C1            [10] 3915 	POP	BC		; Restore power
   15A2 D1            [10] 3916 	POP	DE
   15A3 F5            [11] 3917 	PUSH	AF		; MSB of base
   15A4 CD 80 13      [17] 3918 	CALL	CMPNUM		; Power an integer?
   15A7 E1            [10] 3919 	POP	HL		; Restore MSB of base
   15A8 7C            [ 4] 3920 	LD	A,H		; but don't affect flags
   15A9 1F            [ 4] 3921 	RRA			; Exponent odd or even?
   15AA E1            [10] 3922 POWER2: POP	HL		; Restore MSB and exponent
u  15AB 22 02 00      [16] 3923 	LD	(FPREG+2),HL	; Save base in FPREG
   15AE E1            [10] 3924 	POP	HL		; LSBs of base
u  15AF 22 00 00      [16] 3925 	LD	(FPREG),HL	; Save in FPREG
   15B2 DC 71 15      [17] 3926 	CALL	C,NEGAFT	; Odd power - Negate result
   15B5 CC 30 13      [17] 3927 	CALL	Z,INVSGN	; Negative base - Negate it
   15B8 D5            [11] 3928 	PUSH	DE		; Save power
   15B9 C5            [11] 3929 	PUSH	BC
   15BA CD BE 11      [17] 3930 	CALL	LOG		; Get LOG of base
   15BD C1            [10] 3931 	POP	BC		; Restore power
   15BE D1            [10] 3932 	POP	DE
   15BF CD FE 11      [17] 3933 	CALL	FPMULT		; Multiply LOG by power
                           3934 ;
   15C2 CD 36 13      [17] 3935 EXP:	CALL	STAKFP		; Put value on stack
q  15C5 01 CA 1F      [10] 3936 	LD	BC,08138H	; BCDE = 1/Ln(2)
kq 15C8 11 00 00      [10] 3937 	LD	DE,0AA3BH
   15CB CD FE 11      [17] 3938 	CALL	FPMULT		; Multiply value by 1/LN(2)
u  15CE 3A 00 00      [13] 3939 	LD	A,(FPEXP)	; Get exponent
q  15D1                    3940 	CP	80H+8		; Is it in range?
   15D1 D2 E4 12      [10] 3941 	JP	NC,OVTST1	; No - Test for overflow
   15D4 CD D8 13      [17] 3942 	CALL	INT		; Get INT of FPREG
q  15D7 C6 50         [ 7] 3943 	ADD	A,80H		; For excess 128
   15D9 C6 02         [ 7] 3944 	ADD	A,2		; Exponent > 126?
   15DB DA E4 12      [10] 3945 	JP	C,OVTST1	; Yes - Test for overflow
   15DE F5            [11] 3946 	PUSH	AF		; Save scaling factor
   15DF 21 BE 11      [10] 3947 	LD	HL,UNITY	; Point to 1.
   15E2 CD CB 10      [17] 3948 	CALL	ADDPHL		; Add 1 to FPREG
   15E5 CD F6 11      [17] 3949 	CALL	MULLN2		; Multiply by LN(2)
   15E8 F1            [10] 3950 	POP	AF		; Restore scaling factor
   15E9 C1            [10] 3951 	POP	BC		; Restore exponent
   15EA D1            [10] 3952 	POP	DE
   15EB F5            [11] 3953 	PUSH	AF		; Save scaling factor
   15EC CD D6 10      [17] 3954 	CALL	SUBCDE		; Subtract exponent from FPREG
   15EF CD 30 13      [17] 3955 	CALL	INVSGN		; Negate result
   15F2 21 00 16      [10] 3956 	LD	HL,EXPTAB	; Coefficient table
   15F5 CD 0F 16      [17] 3957 	CALL	SMSER1		; Sum the series
   15F8 11 00 00      [10] 3958 	LD	DE,0		; Zero LSBs
   15FB C1            [10] 3959 	POP	BC		; Scaling factor
   15FC 4A            [ 4] 3960 	LD	C,D		; Zero MSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 73
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   15FD C3 FE 11      [10] 3961 	JP	FPMULT		; Scale result to correct value
                           3962 ;
q  1600                    3963 EXPTAB: DB	8			; Table used by EXP
                           3964 	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
                           3965 	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
                           3966 	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
                           3967 	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
                           3968 	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
                           3969 	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
                           3970 	DB	000H,000H,080H,081H	; -1/1! (-1/1)
                           3971 	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
                           3972 ;
   1600 CD 36 13      [17] 3973 SUMSER: CALL	STAKFP		; Put FPREG on stack
   1603 11 FC 11      [10] 3974 	LD	DE,MULT		; Multiply by "X"
   1606 D5            [11] 3975 	PUSH	DE		; To be done after
   1607 E5            [11] 3976 	PUSH	HL		; Save address of table
   1608 CD 51 13      [17] 3977 	CALL	BCDEFP		; Move FPREG to BCDE
   160B CD FE 11      [17] 3978 	CALL	FPMULT		; Square the value
   160E E1            [10] 3979 	POP	HL		; Restore address of table
   160F CD 36 13      [17] 3980 SMSER1: CALL	STAKFP		; Put value on stack
   1612 7E            [ 7] 3981 	LD	A,(HL)		; Get number of coefficients
   1613 23            [ 6] 3982 	INC	HL		; Point to start of table
   1614 CD 43 13      [17] 3983 	CALL	PHLTFP		; Move coefficient to FPREG
                           3984 	DB	06H		; Skip "POP AF"
   1617 F1            [10] 3985 SUMLP:	POP	AF		; Restore count
   1618 C1            [10] 3986 	POP	BC		; Restore number
   1619 D1            [10] 3987 	POP	DE
   161A 3D            [ 4] 3988 	DEC	A		; Cont coefficients
   161B C8            [11] 3989 	RET	Z		; All done
   161C D5            [11] 3990 	PUSH	DE		; Save number
   161D C5            [11] 3991 	PUSH	BC
   161E F5            [11] 3992 	PUSH	AF		; Save count
   161F E5            [11] 3993 	PUSH	HL		; Save address in table
   1620 CD FE 11      [17] 3994 	CALL	FPMULT		; Multiply FPREG by BCDE
   1623 E1            [10] 3995 	POP	HL		; Restore address in table
   1624 CD 54 13      [17] 3996 	CALL	LOADFP		; Number at HL to BCDE
   1627 E5            [11] 3997 	PUSH	HL		; Save address in table
   1628 CD D9 10      [17] 3998 	CALL	FPADD		; Add coefficient to FPREG
   162B E1            [10] 3999 	POP	HL		; Restore address in table
   162C C3 17 16      [10] 4000 	JP	SUMLP		; More coefficients
                           4001 ;
   162F CD 08 13      [17] 4002 RND:	CALL	TSTSGN		; Test sign of FPREG
u  1632 21 02 00      [10] 4003 	LD	HL,SEED+2	; Random number seed
   1635 FA 8A 16      [10] 4004 	JP	M,RESEED	; Negative - Re-seed
u  1638 21 00 00      [10] 4005 	LD	HL,LSTRND	; Last random number
   163B CD 43 13      [17] 4006 	CALL	PHLTFP		; Move last RND to FPREG
u  163E 21 02 00      [10] 4007 	LD	HL,SEED+2	; Random number seed
   1641 C8            [11] 4008 	RET	Z		; Return if RND(0)
   1642 86            [ 7] 4009 	ADD	A,(HL)		; Add (SEED)+2)
kq 1643                    4010 	AND	00000111B	; 0 to 7
   1643 06 00         [ 7] 4011 	LD	B,0
   1645 77            [ 7] 4012 	LD	(HL),A		; Re-save seed
   1646 23            [ 6] 4013 	INC	HL		; Move to coefficient table
   1647 87            [ 4] 4014 	ADD	A,A		; 4 bytes
   1648 87            [ 4] 4015 	ADD	A,A		; per entry
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 74
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1649 4F            [ 4] 4016 	LD	C,A		; BC = Offset into table
   164A 09            [11] 4017 	ADD	HL,BC		; Point to coefficient
   164B CD 54 13      [17] 4018 	CALL	LOADFP		; Coefficient to BCDE
   164E CD FE 11      [17] 4019 	CALL	FPMULT	;	; Multiply FPREG by coefficient
u  1651 3A 01 00      [13] 4020 	LD	A,(SEED+1)	; Get (SEED+1)
   1654 3C            [ 4] 4021 	INC	A		; Add 1
kq 1655                    4022 	AND	00000011B	; 0 to 3
   1655 06 00         [ 7] 4023 	LD	B,0
   1657 FE 01         [ 7] 4024 	CP	1		; Is it zero?
   1659 88            [ 4] 4025 	ADC	A,B		; Yes - Make it 1
u  165A 32 01 00      [13] 4026 	LD	(SEED+1),A	; Re-save seed
   165D 21 8E 16      [10] 4027 	LD	HL,RNDTAB-4	; Addition table
   1660 87            [ 4] 4028 	ADD	A,A		; 4 bytes
   1661 87            [ 4] 4029 	ADD	A,A		; per entry
   1662 4F            [ 4] 4030 	LD	C,A		; BC = Offset into table
   1663 09            [11] 4031 	ADD	HL,BC		; Point to value
   1664 CD CB 10      [17] 4032 	CALL	ADDPHL		; Add value to FPREG
   1667 CD 51 13      [17] 4033 RND1:	CALL	BCDEFP		; Move FPREG to BCDE
   166A 7B            [ 4] 4034 	LD	A,E		; Get LSB
   166B 59            [ 4] 4035 	LD	E,C		; LSB = MSB
kq 166C                    4036 	XOR	01001111B	; Fiddle around
   166C 4F            [ 4] 4037 	LD	C,A		; New MSB
q  166D 36 50         [10] 4038 	LD	(HL),80H	; Set exponent
   166F 2B            [ 6] 4039 	DEC	HL		; Point to MSB
   1670 46            [ 7] 4040 	LD	B,(HL)		; Get MSB
q  1671 36 50         [10] 4041 	LD	(HL),80H	; Make value -0.5
u  1673 21 00 00      [10] 4042 	LD	HL,SEED		; Random number seed
   1676 34            [11] 4043 	INC	(HL)		; Count seed
   1677 7E            [ 7] 4044 	LD	A,(HL)		; Get seed
   1678 D6 AB         [ 7] 4045 	SUB	171		; Do it modulo 171
   167A C2 81 16      [10] 4046 	JP	NZ,RND2		; Non-zero - Ok
   167D 77            [ 7] 4047 	LD	(HL),A		; Zero seed
   167E 0C            [ 4] 4048 	INC	C		; Fillde about
   167F 15            [ 4] 4049 	DEC	D		; with the
   1680 1C            [ 4] 4050 	INC	E		; number
   1681 CD 2A 11      [17] 4051 RND2:	CALL	BNORM		; Normalise number
u  1684 21 00 00      [10] 4052 	LD	HL,LSTRND	; Save random number
   1687 C3 5D 13      [10] 4053 	JP	FPTHL		; Move FPREG to last and return
                           4054 ;
   168A 77            [ 7] 4055 RESEED: LD	(HL),A		; Re-seed random numbers
   168B 2B            [ 6] 4056 	DEC	HL
   168C 77            [ 7] 4057 	LD	(HL),A
   168D 2B            [ 6] 4058 	DEC	HL
   168E 77            [ 7] 4059 	LD	(HL),A
   168F C3 67 16      [10] 4060 	JP	RND1		; Return RND seed
                           4061 ;
q  1692                    4062 RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
                           4063 	DB	099H,0E9H,092H,069H
                           4064 	DB	010H,0D1H,075H,068H
                           4065 ;
   1692 21 DC 16      [10] 4066 COS:	LD	HL,HALFPI	; Point to PI/2
   1695 CD CB 10      [17] 4067 	CALL	ADDPHL		; Add it to PPREG
   1698 CD 36 13      [17] 4068 SIN:	CALL	STAKFP		; Put angle on stack
q  169B 01 9D 20      [10] 4069 	LD	BC,8349H	; BCDE = 2 PI
kq 169E 11 00 00      [10] 4070 	LD	DE,0FDBH
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 75
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   16A1 CD 46 13      [17] 4071 	CALL	FPBCDE		; Move 2 PI to FPREG
   16A4 C1            [10] 4072 	POP	BC		; Restore angle
   16A5 D1            [10] 4073 	POP	DE
   16A6 CD 5F 12      [17] 4074 	CALL	DVBCDE		; Divide angle by 2 PI
   16A9 CD 36 13      [17] 4075 	CALL	STAKFP		; Put it on stack
   16AC CD D8 13      [17] 4076 	CALL	INT		; Get INT of result
   16AF C1            [10] 4077 	POP	BC		; Restore number
   16B0 D1            [10] 4078 	POP	DE
   16B1 CD D6 10      [17] 4079 	CALL	SUBCDE		; Make it 0 <= value < 1
   16B4 21 DC 16      [10] 4080 	LD	HL,QUARTR	; Point to 0.25
   16B7 CD D1 10      [17] 4081 	CALL	SUBPHL		; Subtract value from 0.25
   16BA CD 08 13      [17] 4082 	CALL	TSTSGN		; Test sign of value
   16BD 37            [ 4] 4083 	SCF			; Flag positive
   16BE F2 C8 16      [10] 4084 	JP	P,SIN1		; Positive - Ok
   16C1 CD C8 10      [17] 4085 	CALL	ROUND		; Add 0.5 to value
   16C4 CD 08 13      [17] 4086 	CALL	TSTSGN		; Test sign of value
   16C7 B7            [ 4] 4087 	OR	A		; Flag negative
   16C8 F5            [11] 4088 SIN1:	PUSH	AF		; Save sign
   16C9 F4 30 13      [17] 4089 	CALL	P,INVSGN	; Negate value if positive
   16CC 21 DC 16      [10] 4090 	LD	HL,QUARTR	; Point to 0.25
   16CF CD CB 10      [17] 4091 	CALL	ADDPHL		; Add 0.25 to value
   16D2 F1            [10] 4092 	POP	AF		; Restore sign
   16D3 D4 30 13      [17] 4093 	CALL	NC,INVSGN	; Negative - Make positive
   16D6 21 DC 16      [10] 4094 	LD	HL,SINTAB	; Coefficient table
   16D9 C3 00 16      [10] 4095 	JP	SUMSER		; Evaluate sum of series
                           4096 ;
q  16DC                    4097 HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
                           4098 ;
q  16DC                    4099 QUARTR: DB	000H,000H,000H,07FH	; 0.25
                           4100 ;
q  16DC                    4101 SINTAB: DB	5			; Table used by SIN
                           4102 	DB	0BAH,0D7H,01EH,086H	; 39.711
                           4103 	DB	064H,026H,099H,087H	;-76.575
                           4104 	DB	058H,034H,023H,087H	; 81.602
                           4105 	DB	0E0H,05DH,0A5H,086H	;-41.342
                           4106 	DB	0DAH,00FH,049H,083H	; 6.2832
                           4107 ;
   16DC CD 36 13      [17] 4108 TAN:	CALL	STAKFP		; Put angle on stack
   16DF CD 98 16      [17] 4109 	CALL	SIN		; Get SIN of angle
   16E2 C1            [10] 4110 	POP	BC		; Restore angle
   16E3 E1            [10] 4111 	POP	HL
   16E4 CD 36 13      [17] 4112 	CALL	STAKFP		; Save SIN of angle
   16E7 EB            [ 4] 4113 	EX	DE,HL		; BCDE = Angle
   16E8 CD 46 13      [17] 4114 	CALL	FPBCDE		; Angle to FPREG
   16EB CD 92 16      [17] 4115 	CALL	COS		; Get COS of angle
   16EE C3 5D 12      [10] 4116 	JP	DIV		; TAN = SIN / COS
                           4117 ;
   16F1 CD 08 13      [17] 4118 ATN:	CALL	TSTSGN		; Test sign of value
   16F4 FC 71 15      [17] 4119 	CALL	M,NEGAFT	; Negate result after if -ve
   16F7 FC 30 13      [17] 4120 	CALL	M,INVSGN	; Negate value if -ve
u  16FA 3A 00 00      [13] 4121 	LD	A,(FPEXP)	; Get exponent
q  16FD                    4122 	CP	81H		; Number less than 1?
   16FD DA 0C 17      [10] 4123 	JP	C,ATN1		; Yes - Get arc tangnt
q  1700 01 A4 1F      [10] 4124 	LD	BC,8100H	; BCDE = 1
   1703 51            [ 4] 4125 	LD	D,C
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 76
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1704 59            [ 4] 4126 	LD	E,C
   1705 CD 5F 12      [17] 4127 	CALL	DVBCDE		; Get reciprocal of number
   1708 21 D1 10      [10] 4128 	LD	HL,SUBPHL	; Sub angle from PI/2
   170B E5            [11] 4129 	PUSH	HL		; Save for angle > 1
   170C 21 16 17      [10] 4130 ATN1:	LD	HL,ATNTAB	; Coefficient table
   170F CD 00 16      [17] 4131 	CALL	SUMSER		; Evaluate sum of series
   1712 21 DC 16      [10] 4132 	LD	HL,HALFPI	; PI/2 - angle in case > 1
   1715 C9            [10] 4133 	RET			; Number > 1 - Sub from PI/2
                           4134 ;
q  1716                    4135 ATNTAB: DB	9			; Table used by ATN
                           4136 	DB	04AH,0D7H,03BH,078H	; 1/17
                           4137 	DB	002H,06EH,084H,07BH	;-1/15
                           4138 	DB	0FEH,0C1H,02FH,07CH	; 1/13
                           4139 	DB	074H,031H,09AH,07DH	;-1/11
                           4140 	DB	084H,03DH,05AH,07DH	; 1/9
                           4141 	DB	0C8H,07FH,091H,07EH	;-1/7
                           4142 	DB	0E4H,0BBH,04CH,07EH	; 1/5
                           4143 	DB	06CH,0AAH,0AAH,07FH	;-1/3
                           4144 	DB	000H,000H,000H,081H	; 1/1
                           4145 ;
                           4146 
   1716 C9            [10] 4147 ARET:	RET			; A RETurn instruction
                           4148 ;
aq 1717 C7            [11] 4149 GETINP: RST	10H		;input a character
   1718 C9            [10] 4150 	RET
                           4151 ;
   1719                    4152 CLS: 
u  1719 3E 00         [ 7] 4153 	LD	A,CS		; ASCII Clear screen
   171B C3 20 18      [10] 4154 	JP	MONOUT		; Output character
                           4155 ;
   171E CD A0 10      [17] 4156 WIDTH:	CALL	GETINT		; Get integer 0-255
   1721 7B            [ 4] 4157 	LD	A,E		; Width to A
u  1722 32 00 00      [13] 4158 	LD	(LWIDTH),A	; Set width
   1725 C9            [10] 4159 	RET
                           4160 ;
   1726 CD 77 09      [17] 4161 LINES:	CALL	GETNUM		; Get a number
   1729 CD 01 06      [17] 4162 	CALL	DEINT		; Get integer -32768 to 32767
u  172C ED 53 00 00   [20] 4163 	LD	(LINESC),DE	; Set lines counter
u  1730 ED 53 00 00   [20] 4164 	LD	(LINESN),DE	; Set lines number
   1734 C9            [10] 4165 	RET
                           4166 ;
   1735 CD 01 06      [17] 4167 DEEK:	CALL	DEINT		; Get integer -32768 to 32767
   1738 D5            [11] 4168 	PUSH	DE		; Save number
   1739 E1            [10] 4169 	POP	HL		; Number to HL
   173A 46            [ 7] 4170 	LD	B,(HL)		; Get LSB of contents
   173B 23            [ 6] 4171 	INC	HL
   173C 7E            [ 7] 4172 	LD	A,(HL)		; Get MSB of contents
   173D C3 0F 0D      [10] 4173 	JP	ABPASS		; Return integer AB
                           4174 ;
   1740 CD 77 09      [17] 4175 DOKE:	CALL	GETNUM		; Get a number
   1743 CD 01 06      [17] 4176 	CALL	DEINT		; Get integer -32768 to 32767
   1746 D5            [11] 4177 	PUSH	DE		; Save address
   1747 CD DE 03      [17] 4178 	CALL	CHKSYN		; Make sure ',' follows
                           4179 	DB	','
   174A CD 77 09      [17] 4180 	CALL	GETNUM		; Get a number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 77
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   174D CD 01 06      [17] 4181 	CALL	DEINT		; Get integer -32768 to 32767
   1750 E3            [19] 4182 	EX	(SP),HL		; Save value,get address
   1751 73            [ 7] 4183 	LD	(HL),E		; Save LSB of value
   1752 23            [ 6] 4184 	INC	HL
   1753 72            [ 7] 4185 	LD	(HL),D		; Save MSB of value
   1754 E1            [10] 4186 	POP	HL		; Restore code string address
   1755 C9            [10] 4187 	RET
                           4188 ;
                           4189 
                           4190 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                           4191 ;
   1756 CD 7A 09      [17] 4192 HEX: 	CALL	TSTNUM		; Verify it's a number
   1759 CD 01 06      [17] 4193 	CALL	DEINT		; Get integer -32768 to 32767
   175C C5            [11] 4194 	PUSH	BC		; Save contents of BC
u  175D 21 00 00      [10] 4195 	LD	HL,PBUFF
   1760 7A            [ 4] 4196 	LD	A,D		; Get high order into A
   1761 FE 00         [ 7] 4197 	CP	0
   1763 28 0A         [12] 4198 	JR	Z,HEX2		; Skip output if both high digits are zero
u  1765 CD 00 00      [17] 4199 	CALL	BYT2ASC		; Convert D to ASCII
   1768 78            [ 4] 4200 	LD	A,B
q  1769                    4201 	CP	'0'
   1769 28 02         [12] 4202 	JR	Z,HEX1		; Don't store high digit if zero
   176B 70            [ 7] 4203 	LD	(HL),B		; Store it to PBUFF
   176C 23            [ 6] 4204 	INC	HL		; Next location
   176D 71            [ 7] 4205 HEX1:	LD	(HL),C		; Store C to PBUFF+1
   176E 23            [ 6] 4206 	INC	HL		; Next location
   176F 7B            [ 4] 4207 HEX2:	LD	A,E		; Get lower byte
u  1770 CD 00 00      [17] 4208 	CALL	BYT2ASC		; Convert E to ASCII
   1773 7A            [ 4] 4209 	LD	A,D
   1774 FE 00         [ 7] 4210 	CP	0
   1776 20 03         [12] 4211 	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
   1778 78            [ 4] 4212 	LD	A,B
q  1779                    4213 	CP	'0'		; If high digit of lower byte is zero then don't print
   1779 28 02         [12] 4214 	JR	Z,HEX4
   177B 70            [ 7] 4215 HEX3:	LD	(HL),B		; to PBUFF+2
   177C 23            [ 6] 4216 	INC	HL		; Next location
   177D 71            [ 7] 4217 HEX4:	LD	(HL),C		; to PBUFF+3
   177E 23            [ 6] 4218 	INC	HL		; PBUFF+4 to zero
   177F AF            [ 4] 4219 	XOR	A		; Terminating character
   1780 77            [ 7] 4220 	LD	(HL),A		; Store zero to terminate
   1781 23            [ 6] 4221 	INC	HL		; Make sure PBUFF is terminated
   1782 77            [ 7] 4222 	LD	(HL),A		; Store the double zero there
   1783 C1            [10] 4223 	POP	BC		; Get BC back
u  1784 21 00 00      [10] 4224 	LD	HL,PBUFF	; Reset to start of PBUFF
   1787 C3 B9 0D      [10] 4225 	JP	STR1		; Convert the PBUFF to a string and return it
                           4226 ;
o  178A                    4227 BYT2ASC	LD	B,A		; Save original value
kq 178A                    4228 	AND	0FH		; Strip off upper nybble
kq 178A                    4229 	CP	0AH		; 0-9?
u  178A 38 00         [12] 4230 	JR	C,ADD30		; If A-F, add 7 more
q  178C C6 07         [ 7] 4231 	ADD	A,07H		; Bring value up to ASCII A-F
o  178E                    4232 ADD30	ADD	A,30H		; And make ASCII
   178E 4F            [ 4] 4233 	LD	C,A		; Save converted char to C
   178F 78            [ 4] 4234 	LD	A,B		; Retrieve original value
   1790 0F            [ 4] 4235 	RRCA			; and Rotate it right
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 78
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1791 0F            [ 4] 4236 	RRCA
   1792 0F            [ 4] 4237 	RRCA
   1793 0F            [ 4] 4238 	RRCA
kq 1794                    4239 	AND	0FH		; Mask off upper nybble
kq 1794                    4240 	CP	0AH		; 0-9? < A hex?
u  1794 38 00         [12] 4241 	JR	C,ADD301	; Skip Add 7
q  1796 C6 07         [ 7] 4242 	ADD	A,07H		; Bring it up to ASCII A-F
o  1798                    4243 ADD301	ADD	A,30H		; And make it full ASCII
   1798 47            [ 4] 4244 	LD	B,A		; Store high order byte
   1799 C9            [10] 4245 	RET	
                           4246 ;
                           4247 ; Convert "&Hnnnn" to FPREG
                           4248 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                           4249 ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
o  179A                    4250 HEXTFP	EX	DE,HL		; Move code string pointer to DE
q  179A 21 00 00      [10] 4251 	LD	HL,0000H	; Zero out the value
u  179D CD 00 00      [17] 4252 	CALL	GETHEX		; Check the number for valid hex
   17A0 DA C0 17      [10] 4253 	JP	C,HXERR		; First value wasn't hex, HX error
u  17A3 18 00         [12] 4254 	JR	HEXLP1		; Convert first character
o  17A5                    4255 HEXLP	CALL	GETHEX		; Get second and addtional characters
u  17A5 38 00         [12] 4256 	JR	C,HEXIT		; Exit if not a hex character
o  17A7                    4257 HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
   17A7 29            [11] 4258 	ADD	HL,HL
   17A8 29            [11] 4259 	ADD	HL,HL
   17A9 29            [11] 4260 	ADD	HL,HL
   17AA B5            [ 4] 4261 	OR	L		; Add in D0-D3 into L
   17AB 6F            [ 4] 4262 	LD	L,A		; Save new value
u  17AC 18 00         [12] 4263 	JR	HEXLP		; And continue until all hex characters are in
                           4264 ;
o  17AE                    4265 GETHEX	INC	DE		; Next location
   17AE 1A            [ 7] 4266 	LD	A,(DE)		; Load character at pointer
q  17AF                    4267 	CP	' '
u  17AF CA 00 00      [10] 4268 	JP	Z,GETHEX	; Skip spaces
q  17B2                    4269 	SUB	30H		; Get absolute value
   17B2 D8            [11] 4270 	RET	C		; < "0", error
kq 17B3                    4271 	CP	0AH
u  17B3 38 00         [12] 4272 	JR	C,NOSUB7	; Is already in the range 0-9
q  17B5                    4273 	SUB	07H		; Reduce to A-F
kq 17B5                    4274 	CP	0AH		; Value should be $0A-$0F at this point
   17B5 D8            [11] 4275 	RET	C		; CY set if was :		; < = > ? @
o  17B6                    4276 NOSUB7	CP	10H		; > Greater than "F"?
   17B6 3F            [ 4] 4277 	CCF
   17B7 C9            [10] 4278 	RET			; CY set if it wasn't valid hex
                           4279 	
o  17B8                    4280 HEXIT	EX	DE,HL		; Value into DE, Code string into HL
   17B8 7A            [ 4] 4281 	LD	A,D		; Load DE into AC
   17B9 4B            [ 4] 4282 	LD	C,E		; For prep to 
   17BA E5            [11] 4283 	PUSH	HL
   17BB CD 0E 0D      [17] 4284 	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
   17BE E1            [10] 4285 	POP	HL
   17BF C9            [10] 4286 	RET
                           4287 ;
u  17C0 1E 00         [ 7] 4288 HXERR:	LD	E,HX		; ?HEX Error
   17C2 C3 46 01      [10] 4289 	JP	ERROR
                           4290 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 79
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



                           4291 ; BIN$(NN) Convert integer to a 1-16 char binary string
   17C5 CD 7A 09      [17] 4292 BIN:	CALL	TSTNUM		; Verify it's a number
   17C8 CD 01 06      [17] 4293 	CALL	DEINT		; Get integer -32768 to 32767
   17CB C5            [11] 4294 BIN2:	PUSH	BC		; Save contents of BC
u  17CC 21 00 00      [10] 4295 	LD	HL,PBUFF
   17CF 06 11         [ 7] 4296 	LD	B,17		; One higher than max char count
   17D1                    4297 ZEROSUP:			; Suppress leading zeros
   17D1 05            [ 4] 4298 	DEC	B		; Max 16 chars
   17D2 78            [ 4] 4299 	LD	A,B
q  17D3                    4300 	CP	01H
   17D3 28 08         [12] 4301 	JR	Z,BITOUT	; Always output at least one character
   17D5 CB 13         [ 8] 4302 	RL	E
   17D7 CB 12         [ 8] 4303 	RL	D
   17D9 30 F6         [12] 4304 	JR	NC,ZEROSUP
   17DB 18 04         [12] 4305 	JR	BITOUT2
   17DD                    4306 BITOUT:	
   17DD CB 13         [ 8] 4307 	RL	E
   17DF CB 12         [ 8] 4308 	RL	D		; Top bit now in carry
   17E1                    4309 BITOUT2:
q  17E1 3E 30         [ 7] 4310 	LD	A,'0'		; Char for '0'
   17E3 CE 00         [ 7] 4311 	ADC	A,0		; If carry set then '0' --> '1'
   17E5 77            [ 7] 4312 	LD	(HL),A
   17E6 23            [ 6] 4313 	INC	HL
   17E7 05            [ 4] 4314 	DEC	B
   17E8 20 F3         [12] 4315 	JR	NZ,BITOUT
   17EA AF            [ 4] 4316 	XOR	A		; Terminating character
   17EB 77            [ 7] 4317 	LD	(HL),A		; Store zero to terminate
   17EC 23            [ 6] 4318 	INC	HL		; Make sure PBUFF is terminated
   17ED 77            [ 7] 4319 	LD	(HL),A		; Store the double zero there
   17EE C1            [10] 4320 	POP	BC
u  17EF 21 00 00      [10] 4321 	LD	HL,PBUFF
   17F2 C3 B9 0D      [10] 4322 	JP	STR1
                           4323 ;
                           4324 ; Convert "&Bnnnn" to FPREG
                           4325 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
   17F5 EB            [ 4] 4326 BINTFP: EX	DE,HL		; Move code string pointer to DE
q  17F6 21 00 00      [10] 4327 	LD	HL,0000H	; Zero out the value
   17F9 CD 10 18      [17] 4328 	CALL	CHKBIN		; Check the number for valid bin
   17FC DA 18 18      [10] 4329 	JP	C,BINERR	; First value wasn't bin, HX error
q  17FF                    4330 BINIT:	SUB	'0'
   17FF 29            [11] 4331 	ADD	HL,HL		; Rotate HL left
   1800 B5            [ 4] 4332 	OR	L
   1801 6F            [ 4] 4333 	LD	L,A
   1802 CD 10 18      [17] 4334 	CALL	CHKBIN		; Get second and addtional characters
   1805 30 F8         [12] 4335 	JR	NC,BINIT	; Process if a bin character
   1807 EB            [ 4] 4336 	EX	DE,HL		; Value into DE, Code string into HL
   1808 7A            [ 4] 4337 	LD	A,D		; Load DE into AC
   1809 4B            [ 4] 4338 	LD	C,E		; For prep to 
   180A E5            [11] 4339 	PUSH	HL
   180B CD 0E 0D      [17] 4340 	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
   180E E1            [10] 4341 	POP	HL
   180F C9            [10] 4342 	RET
                           4343 ;
                           4344 ; Char is in A, NC if char is 0 or 1
   1810 13            [ 6] 4345 CHKBIN: INC	DE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 80
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025



   1811 1A            [ 7] 4346 	LD	A,(DE)
q  1812                    4347 	CP	' '
   1812 CA 10 18      [10] 4348 	JP	Z,CHKBIN	; Skip spaces
q  1815                    4349 	CP	'0'		; Set C if < '0'
   1815 D8            [11] 4350 	RET	C
q  1816                    4351 	CP	'2'
   1816 3F            [ 4] 4352 	CCF			; Set C if > '1'
   1817 C9            [10] 4353 	RET
                           4354 ;
u  1818 1E 00         [ 7] 4355 BINERR: LD	E,BN		; ?BIN Error
   181A C3 46 01      [10] 4356 	JP	ERROR
                           4357 ;
   181D C3 3C 00      [10] 4358 JJUMP1: JP	CSTART		; Go and initialise
                           4359 ;
q  1820 C3 08 00      [10] 4360 MONOUT: JP	0008H		; output a char
                           4361 ;
q  1823 C3 00 00      [10] 4362 MONITR: JP	0000H		; Restart (Normally Monitor Start)
                           4363 ;
   1826 3E 00         [ 7] 4364 INITST: LD	A,0		; Clear break flag
u  1828 32 00 00      [13] 4365 	LD	(BRKFLG),A
   182B C3 43 00      [10] 4366 	JP	INIT
                           4367 ;
   182E F5            [11] 4368 TSTBIT: PUSH	AF		; Save bit mask
   182F A0            [ 4] 4369 	AND	B		; Get common bits
   1830 C1            [10] 4370 	POP	BC		; Restore bit mask
   1831 B8            [ 4] 4371 	CP	B		; Same bit set?
   1832 3E 00         [ 7] 4372 	LD	A,0		; Return 0 in A
   1834 C9            [10] 4373 	RET
                           4374 ;
   1835 CD E9 03      [17] 4375 OUTNCR: CALL	OUTC		; Output character in A
   1838 C3 E5 07      [10] 4376 	JP	PRCRLF		; Output CRLF
                           4377 ;
                           4378 	END
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 81
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Symbol Table

    .__.$$$.       =   2710 L   |     .__.ABS.       =   0000 G
    .__.CPU.       =   0000 L   |     .__.H$L.       =   0000 L
  0 ABPASS             0D0F R   |   0 ABS                132C R
  0 ACCSUM             05E4 R   |   0 ACPASS             0D0E R
    ADD30              **** X   |     ADD301             **** X
  0 ADDEXP             12C6 R   |   0 ADDIG              145F R
  0 ADDPHL             10CB R   |   0 ALLFOL             0FD3 R
  0 ANTVLU             08B2 R   |   0 ARET               1716 R
  0 ARLDSV             0C31 R   |     ARREND             **** X
  0 ARRLP              0EA1 R   |   0 ASC                0FA5 R
  0 ASCTFP             140A R   |   0 ASPCS              082F R
  0 ATN                16F1 R   |   0 ATN1               170C R
  0 ATNTAB             1716 R   |   0 ATOH               0619 R
  0 BADINP             0841 R   |   0 BAKSTK             00E2 R
  0 BAKTMP             0F85 R   |     BASTXT             **** X
  0 BCDEFP             1351 R   |   0 BFREE              00BC R
  0 BIN                17C5 R   |   0 BIN2               17CB R
  0 BINERR             1818 R   |   0 BINIT              17FF R
  0 BINTFP             17F5 R   |   0 BITOUT             17DD R
  0 BITOUT2            17E1 R   |     BKSP               **** X
    BN                 **** X   |   0 BNORM              112A R
  0 BNRMLP             112D R   |     BRK                **** X
    BRKFLG             **** X   |     BRKLIN             **** X
  0 BRKMSG             00E2 R   |   0 BRKRET             00AD R
    BS                 **** X   |   0 BSERR              0C63 R
    BUFFER             **** X   |     BYT2ASC            **** X
  0 BYTSFT             124C R   |   0 CFEVAL             0BCB R
  0 CHARTY             0B7D R   |   0 CHEKFN             0DA3 R
  0 CHKBIN             1810 R   |   0 CHKLTR             05F1 R
  0 CHKSTK             0116 R   |     CHKSUM             **** X
  0 CHKSYN             03DE R   |   0 CHKTYP             097B R
  0 CHR                0FB6 R   |   0 CLEAR              063C R
  0 CLOTST             0411 R   |   0 CLREG              0263 R
  0 CLRPTR             023E R   |   0 CLS                1719 R
  0 CMPFP              139A R   |   0 CMPLG1             0AE5 R
  0 CMPLOG             0AE5 R   |   0 CMPNUM             1380 R
  0 CMPRES             0B27 R   |   0 CMPSTR             0B0F R
    CN                 **** X   |   0 CNVNUM             1412 R
  0 COLD               0033 R   |     COMMAN             **** X
  0 COMPL              1186 R   |   0 CONCAT             0F1A R
  0 CONEXP             143E R   |   0 CONPOS             1127 R
  0 CONT               05C9 R   |     CONTAD             **** X
  0 CONVAR             0A58 R   |   0 COPY               004B R
  0 COS                1692 R   |   0 COUNT              047D R
  0 CPDEHL             03D8 R   |   0 CPYLIT             031B R
    CR                 **** X   |   0 CRARLP             0C83 R
  0 CREARY             0C68 R   |   0 CRESTR             0733 R
  0 CRNCLP             0296 R   |   0 CRTMST             0DDB R
  0 CRTST              0DE7 R   |   0 CRTSTE             0DFD R
  0 CRUNCH             028D R   |     CS                 **** X
  0 CSTART             003C R   |     CTLOFG             **** X
    CTRLC              **** X   |     CTRLG              **** X
    CTRLO              **** X   |     CTRLQ              **** X
    CTRLR              **** X   |     CTRLS              **** X
    CTRLU              **** X   |     CUROPR             **** X
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 82
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Symbol Table

    CURPOS             **** X   |   0 DATA               06E0 R
    DATFLG             **** X   |     DATLIN             **** X
  0 DATSNR             0132 R   |   0 DCBCDE             13D1 R
  0 DDERR              013E R   |   0 DEEK               1735 R
  0 DEF                0D23 R   |   0 DEFSIZ             0C8B R
  0 DEINT              0601 R   |     DEL                **** X
  0 DELCHR             034A R   |   0 DEPINT             05FB R
  0 DETHL4             1360 R   |   0 DETHLB             1362 R
  0 DIGTXT             1504 R   |   0 DIM                0B50 R
  0 DIMRET             0B48 R   |   0 DINPOS             040B R
  0 DIV                125D R   |     DIV1               **** X
  0 DIV10              1251 R   |     DIV2               **** X
    DIV3               **** X   |     DIV4               **** X
  0 DIVLP              1284 R   |     DIVSUP             **** X
  0 DOAGN              027C R   |   0 DOCOM              0801 R
  0 DODEL              032B R   |   0 DOEBIT             1540 R
  0 DOFN               0D4D R   |   0 DOKE               1740 R
  0 DONULL             07EF R   |   0 DOSPC              082A R
  0 DOTAB              0818 R   |   0 DPOINT             143A R
  0 DTSTR              0DEB R   |   0 DVBCDE             125F R
    DZ                 **** X   |   0 DZERR              013A R
  0 ECHDEL             033E R   |   0 EDIGIT             147F R
  0 ENDBUF             0322 R   |   0 ENDCON             144D R
  0 ENDDIM             0CE9 R   |   0 ENDINP             07E0 R
  0 ENDNAM             0B71 R   |   0 ENDPRG             05A5 R
  0 ENFMEM             011E R   |   0 ERRIN              0166 R
    ERRLIN             **** X   |   0 ERRMSG             00E2 R
  0 ERROR              0146 R   |   0 ERRORS             00BC R
    ESC                **** X   |   0 EVAL               0987 R
  0 EVAL1              098A R   |   0 EVAL2              0993 R
  0 EVAL3              0996 R   |   0 EVLPAR             0A40 R
  0 EVNOT              0B31 R   |   0 EXCUTE             053F R
  0 EXP                15C2 R   |   0 EXPLP              142C R
  0 EXPTAB             1600 R   |   0 EXPTEN             1552 R
  0 EXTIG              090A R   |   0 FANDT              0923 R
    FC                 **** X   |   0 FCERR              0614 R
  0 FDTLP              090A R   |   0 FINDEL             0CC6 R
  0 FLGDIF             1312 R   |   0 FLGREL             1319 R
    FNARG              **** X   |   0 FNCTAB             00BC R
  0 FNDARY             0C36 R   |   0 FNDELP             0CCA R
  0 FNDEND             0211 R   |   0 FNDNUM             109D R
  0 FNDTOK             045E R   |   0 FNDVAR             0BB2 R
  0 FNDWRD             02B8 R   |   0 FNOFST             0A69 R
    FNRGNM             **** X   |   0 FNTHR              0BC0 R
  0 FNVAL              0A8F R   |   0 FOPRND             09BD R
  0 FOR                04A9 R   |     FORFLG             **** X
  0 FORFND             04D9 R   |   0 FORSLP             04BD R
  0 FPADD              10D9 R   |   0 FPBCDE             1346 R
    FPEXP              **** X   |   0 FPINT              13AD R
  0 FPMULT             11FE R   |     FPREG              **** X
  0 FPROND             116D R   |   0 FPSINT             05F5 R
  0 FPTHL              135D R   |   0 FRE                0CED R
  0 FRENUM             0D09 R   |   0 FRMEVL             0A5B R
  0 GARBGE             0E69 R   |   0 GARBLP             0E6C R
  0 GETCHR             055F R   |   0 GETCMD             0189 R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 83
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Symbol Table

    GETHEX             **** X   |   0 GETINP             1717 R
  0 GETINT             10A0 R   |   0 GETLEN             0F9A R
  0 GETLIN             035B R   |   0 GETLN              061A R
  0 GETNUM             0977 R   |   0 GETNXT             02CD R
  0 GETSTR             0F64 R   |   0 GETVAR             0B54 R
  0 GNXARY             0EA0 R   |   0 GOFUNC             0A97 R
  0 GOSUB              068D R   |   0 GOTO               069E R
  0 GRBARY             0EC0 R   |   0 GRBDON             0E41 R
  0 GRBLP              0E7A R   |   0 GSTRCU             0F67 R
  0 GSTRDE             0F6B R   |   0 GSTRHL             0F6A R
  0 GTFLNM             0FA9 R   |   0 GTFNAM             0B59 R
  0 GTLNLP             061D R   |   0 GTSIXD             14CE R
  0 GTVLUS             088C R   |   0 HALF               1571 R
  0 HALFPI             16DC R   |   0 HEX                1756 R
  0 HEX1               176D R   |   0 HEX2               176F R
  0 HEX3               177B R   |   0 HEX4               177D R
    HEXIT              **** X   |     HEXLP              **** X
    HEXLP1             **** X   |     HEXTFP             **** X
    HX                 **** X   |   0 HXERR              17C0 R
    ID                 **** X   |   0 IDTEST             0D95 R
  0 IF                 0766 R   |   0 IFGO               0773 R
  0 IFJMP              0546 R   |   0 INCHL              135B R
  0 INCLEN             0407 R   |   0 INDFND             00FC R
  0 INEWLN             01D9 R   |   0 INIT               0043 R
  0 INITAB             00BC R   |   0 INITBE             00E2 R
  0 INITST             1826 R   |   0 INMSG              00E2 R
  0 INP                105F R   |   0 INPBIN             08DA R
  0 INPBRK             05A4 R   |     INPORT             **** X
    INPSUB             **** X   |   0 INPUT              0852 R
  0 INRNG              14D7 R   |   0 INT                13D8 R
  0 INTVAR             024D R   |   0 INVSGN             1330 R
  0 ITMSEP             08CB R   |   0 JJUMP1             181D R
  0 JSTZER             155C R   |   0 KBHIT              001D R
  0 KILFOR             0969 R   |   0 KILIN              0355 R
    LCRFLG             **** X   |   0 LEFT               0FC6 R
  0 LEN                0F96 R   |   0 LET                06F3 R
  0 LETNUM             0744 R   |   0 LETSTR             070D R
    LF                 **** X   |   0 LFRGNM             1056 R
    LINEAT             **** X   |   0 LINEIN             1489 R
  0 LINES              1726 R   |     LINESC             **** X
    LINESN             **** X   |   0 LINFND             01C2 R
  0 LIST               0420 R   |   0 LISTLP             042C R
  0 LOADFP             1354 R   |   0 LOG                11BE R
  0 LOGTAB             11BE R   |   0 LOKFOR             00E6 R
    LOOPST             **** X   |     LS                 **** X
    LSTBIN             **** X   |   0 LSTLP2             044C R
  0 LSTLP3             044F R   |     LSTRAM             **** X
    LSTRND             **** X   |   0 LTSTND             08E5 R
    LWIDTH             **** X   |   0 MAKINT             10A3 R
  0 MAKNUM             14F3 R   |   0 MANLP              141A R
  0 MATCH              02F9 R   |   0 MEMMSG             00BC R
  0 MID                0FFF R   |   0 MID1               0FCC R
  0 MIDNUM             105A R   |   0 MINCDE             1119 R
  0 MINUS              0A47 R   |   0 MKTMST             0DD8 R
  0 MLDBLP             13F7 R   |   0 MLDEBC             13EF R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 84
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Symbol Table

  0 MLOOP              0063 R   |   0 MLSP10             12F1 R
    MO                 **** X   |   0 MONITR             1823 R
  0 MONOUT             1820 R   |   0 MORDT              08EF R
  0 MORINP             0364 R   |   0 MOVBUF             01F8 R
  0 MOVDIR             0301 R   |   0 MOVLP              010B R
  0 MOVSTR             0108 R   |   0 MOVUP              0105 R
  0 MRPRNT             0785 R   |   0 MSIZE              0060 R
  0 MUL8LP             1229 R   |   0 MULLN2             11F6 R
  0 MULT               11FC R   |   0 MULT8              1220 R
  0 MULTEN             1458 R   |     MULVAL             **** X
  0 MVSTPT             073B R   |   0 NEDMOR             0889 R
  0 NEGAFT             1571 R   |   0 NEMEM              00B3 R
  0 NEW                023D R   |   0 NEXITM             083A R
  0 NEXT               092E R   |   0 NEXT1              0931 R
    NF                 **** X   |   0 NFERR              013C R
  0 NOCHNG             02F1 R   |   0 NOENED             155F R
  0 NOLIN              05B8 R   |   0 NOMADD             123A R
  0 NOMLAD             1405 R   |   0 NOPMPT             0868 R
  0 NORMAL             1142 R   |   0 NOSPC              02EC R
    NOSUB7             **** X   |   0 NOSWAP             10F3 R
  0 NOTAMP             0A21 R   |   0 NOTSTR             0B8A R
  0 NOXOR              1084 R   |   0 NSCFOR             0B98 R
    NULFLG             **** X   |   0 NULL               05DC R
  0 NULLP              07F6 R   |     NULLS              **** X
  0 NUMASC             149C R   |   0 NXTARY             0C4A R
  0 NXTBYT             02DB R   |   0 NXTCHR             0312 R
    NXTDAT             **** X   |   0 NXTDTA             06DF R
  0 NXTITM             0881 R   |     NXTOPR             **** X
  0 NXTSTL             06E4 R   |   0 NXTSTT             06E7 R
    OD                 **** X   |   0 OKMSG              00E2 R
    OM                 **** X   |   0 OMERR              012D R
  0 ON                 074B R   |   0 ONGO               0759 R
  0 ONGOLP             075A R   |   0 ONJMP              0547 R
  0 OPNPAR             0984 R   |   0 OPRND              09FC R
    OS                 **** X   |   0 OTKLN              0352 R
    OTPORT             **** X   |   0 OUTC               03E9 R
  0 OUTEXP             1550 R   |   0 OUTIT              03CA R
  0 OUTNBS             03D0 R   |   0 OUTNCR             1835 R
    OUTSUB             **** X   |   0 OUTWRD             0468 R
    OV                 **** X   |   0 OVERR              0142 R
  0 OVTST1             12E4 R   |   0 OVTST2             12E9 R
  0 OVTST3             12EA R   |   0 PADD               147A R
  0 PAND               0AAC R   |   0 PASSA              0D1E R
    PBUFF              **** X   |   0 PEEK               10B1 R
  0 PEND               05A0 R   |   0 PHLTFP             1343 R
  0 PLUCDE             117A R   |   0 PNORM              114A R
  0 POKE               10B8 R   |   0 POPAF              0E5B R
  0 POPHL              0F83 R   |   0 POPHRT             124A R
  0 POPNOK             017B R   |   0 POR                0AAC R
  0 POR1               0ACE R   |   0 POS                0D1B R
  0 POSINT             05F8 R   |   0 POUT               106B R
  0 POWER              157F R   |   0 POWER1             158F R
  0 POWER2             15AA R   |   0 POWERS             1571 R
  0 PRCRLF             07E5 R   |   0 PRINT              0789 R
  0 PRITAB             00BC R   |   0 PRNTHL             1491 R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 85
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Symbol Table

  0 PRNTLP             078C R   |   0 PRNTNB             07CD R
  0 PRNTOK             017C R   |   0 PRNTST             07D1 R
  0 PRNUMS             0E26 R   |   0 PROCES             037D R
    PROGND             **** X   |     PROGST             **** X
  0 PROMPT             0280 R   |   0 PRS                0E27 R
  0 PRS1               0E2A R   |   0 PRSLP              0E31 R
  0 PSUB               10D4 R   |   0 PTRLP              0205 R
  0 PUTBUF             03B8 R   |   0 PUTCTL             03BB R
  0 PUTFID             051D R   |   0 QTSTLP             0DEE R
  0 QTSTR              0DE8 R   |   0 QUARTR             16DC R
    RD                 **** X   |   0 READ               087D R
    READFG             **** X   |   0 REDO               0841 R
  0 REM                06E0 R   |   0 RESDIV             1296 R
  0 RESEED             168A R   |   0 RESTNL             057E R
  0 RESTOR             0569 R   |   0 RESZER             113D R
  0 RETADR             0BFF R   |   0 RETINT             131E R
  0 RETLIN             06DB R   |   0 RETNAD             02FD R
  0 RETNUL             0C02 R   |   0 RETNUM             0A53 R
  0 RETREL             1310 R   |   0 RETURN             06BC R
    RG                 **** X   |   0 RIGHT              0FF5 R
  0 RIGHT1             0FCA R   |     RINPUT             **** X
  0 RLTLP              09A1 R   |   0 RND                162F R
  0 RND1               1667 R   |   0 RND2               1681 R
  0 RNDTAB             1692 R   |   0 RNGTST             1562 R
  0 RONDB              115E R   |   0 RONDUP             115D R
  0 ROUND              10C8 R   |   0 RSCALE             1474 R
  0 RSLNBK             04A0 R   |   0 RSTSTR             1015 R
  0 RUN                0681 R   |   0 RUNCNT             0521 R
  0 RUNFST             0249 R   |   0 RUNLIN             069D R
  0 RXA                0010 R   |   0 SAVEXP             113E R
  0 SAVSTP             0514 R   |   0 SAVSTR             0DC3 R
  0 SBSCPT             0C0D R   |   0 SCALE              119A R
  0 SCALLP             119C R   |   0 SCALMI             1441 R
  0 SCALPL             1457 R   |   0 SCNEND             0EF5 R
  0 SCPTLP             0C13 R   |   0 SEARCH             02CB R
    SEED               **** X   |   0 SETIO              108E R
  0 SETLIN             0474 R   |   0 SETLIT             030B R
  0 SETPTR             0200 R   |   0 SETTOP             0072 R
  0 SFTPRG             01CA R   |   0 SGN                1316 R
  0 SGNEXP             0AA0 R   |     SGNRES             **** X
  0 SHRITE             11A9 R   |   0 SHRLP              11AC R
  0 SHRT1              11B0 R   |   0 SIGNON             00BC R
  0 SIGNS              136B R   |   0 SIN                1698 R
  0 SIN1               16C8 R   |   0 SINIT              0030 R
  0 SINTAB             16DC R   |   0 SIXDIG             14B9 R
  0 SMPVAR             0E8B R   |   0 SMSER1             160F R
    SN                 **** X   |   0 SNERR              0138 R
  0 SPCFST             14AA R   |   0 SPCLP              0833 R
  0 SQR                1576 R   |   0 SRCHLN             021D R
  0 SRCHLP             0220 R   |   0 SSTSA              0F51 R
    ST                 **** X   |     STACK              **** X
  0 STAKFP             1336 R   |   0 STALL              0592 R
  0 STARTB             0039 R   |   0 STKTHS             09E5 R
    STLOOK             **** X   |   0 STOP               059F R
  0 STORED             065E R   |   0 STPOOL             0ECE R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 86
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Symbol Table

  0 STR                0DB3 R   |   0 STR1               0DB9 R
  0 STRADD             0ECF R   |     STRBOT             **** X
  0 STRENT             08CE R   |     STRSPC             **** X
  0 STTLIN             07D8 R   |   0 SUBCDE             10D6 R
  0 SUBPHL             10D1 R   |   0 SUMLP              1617 R
  0 SUMSER             1600 R   |   0 SUPTLZ             1538 R
  0 SVNAM2             0B70 R   |   0 SVSTAD             0DE1 R
  0 TAN                16DC R   |   0 TESTOS             0E5D R
  0 TESTR              0E40 R   |     TM                 **** X
  0 TMERR              0144 R   |     TMPSTR             **** X
    TMSTPL             **** X   |     TMSTPT             **** X
  0 TOPOOL             0FC2 R   |   0 TOSTRA             0F5A R
  0 TRYAGN             1513 R   |   0 TSALP              0F5B R
    TSTACK             **** X   |   0 TSTBIT             182E R
  0 TSTBRK             0584 R   |   0 TSTNUM             097A R
  0 TSTOPL             0E07 R   |   0 TSTRED             0AD3 R
  0 TSTREM             030E R   |   0 TSTSGN             1308 R
  0 TSTSTR             097A R   |   0 TTYLIN             035B R
  0 TXA                0023 R   |   0 TXAST1             0024 R
    TYPE               **** X   |     UARTCR             **** X
    UARTDR             **** X   |     UF                 **** X
  0 UFERR              0140 R   |     UL                 **** X
  0 ULERR              06B7 R   |   0 UNITY              11BE R
  0 UPDATA             057F R   |   0 VAL                102B R
  0 VAL1               1047 R   |   0 VAL2               104F R
  0 VAL3               1052 R   |     VAREND             **** X
  0 WAIT               1071 R   |   0 WAITLP             1085 R
  0 WARM               0036 R   |   0 WARMST             00AA R
  0 WIDTH              171E R   |   0 WORDS              00BC R
  0 WORDTB             00BC R   |     WRKSPC             **** X
  0 XXXXX              00B9 R   |     ZDATA              **** X
    ZEND               **** X   |     ZEQUAL             **** X
  0 ZERARY             0CA9 R   |     ZERBYT             **** X
  0 ZEROLP             0BF1 R   |   0 ZEROSUP            17D1 R
    ZFN                **** X   |     ZFOR               **** X
    ZGOSUB             **** X   |     ZGOTO              **** X
    ZGTR               **** X   |     ZLEFT              **** X
    ZLTH               **** X   |     ZMINUS             **** X
    ZNEW               **** X   |     ZNOT               **** X
  0 ZONELP             080F R   |     ZOR                **** X
    ZPLUS              **** X   |     ZPRINT             **** X
    ZREM               **** X   |     ZSGN               **** X
    ZSPC               **** X   |     ZSTEP              **** X
    ZTAB               **** X

ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 87
Hexadecimal [16-Bits]                                 Wed Feb 26 00:05:59 2025

Area Table

[_CSEG]
   0 _CODE            size 183B   flags C180
[_DSEG]
   1 _DATA            size    0   flags C0C0

