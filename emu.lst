ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 1
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



                              1 	.area TEST (ABS)
                              2 ;	EMUBASIC based on GRANT's BASIC
                              3 ;	TARGET: EMUZ80
                              4 ;	ASSEMBLER: ARCPIT XZ80.EXE
                              5 ;
                              6 ;	START UP ROUTINE
                              7 ;	VERSION 1.0, 2022/02/15
                              8 ;	WRITTEN by TETSUYA SUZUKI
                              9 ;
                             10 ;	MEMORY ASIGN
                     0000    11 ROMTOP	.equ	0x0000
                     8000    12 RAMTOP	.equ	0x8000
                     1000    13 RAMSIZ	.equ	0x1000
                     80ED    14 TSTACK	.equ	0x80ED
                             15 ;
                             16 ;	UART REGISTER ADDRESS
                     E000    17 UARTDR	.equ	0x0E000	; UART DATA REGISTOR
                     E001    18 UARTCR	.equ	0x0E001	; UART CONTROL REGISTOR
                             19 ;
                             20 ;	RESET (RST 0x00)
   0000                      21 	.org	ROMTOP
   0000 F3            [ 4]   22 	DI
   0001 31 ED 80      [10]   23 	LD	SP,TSTACK
   0004 C3 41 00      [10]   24 	JP	SINIT
                             25 ;
                             26 ;	PUT 1CHAR (RST 0x08)
   0008                      27 	.org	ROMTOP+0x08
   0008 C3 34 00      [10]   28 	JP	TXA
                             29 ;
                             30 ;	GET 1CHAR (RST 0x10)
   0010                      31 	.org	ROMTOP+0x10
   0010 C3 1B 00      [10]   32 	JP	RXA
                             33 ;
                             34 ;	KBHIT (RST 0x18)
   0018                      35 	.org	ROMTOP+0x18
   0018 C3 2E 00      [10]   36 	JP	KBHIT
                             37 ;
                             38 ;	UART -> A
   001B 3A 01 E0      [13]   39 RXA:	LD	A,(UARTCR)
   001E CB 47         [ 8]   40 	BIT	0,A
   0020 28 F9         [12]   41 	JR	Z,RXA
   0022 3A 00 E0      [13]   42 	LD	A,(UARTDR)
   0025 FE 61         [ 7]   43 	CP	'a
   0027 D8            [11]   44 	RET	C
   0028 FE 7B         [ 7]   45 	CP	'z+1
   002A D0            [11]   46 	RET	NC
   002B E6 DF         [ 7]   47 	AND	0x0DF
   002D C9            [10]   48 	RET
                             49 ;
                             50 ;	CHECK RECEIVE STATUS
   002E 3A 01 E0      [13]   51 KBHIT:	LD	A,(UARTCR)
   0031 CB 47         [ 8]   52 	BIT	0,A
   0033 C9            [10]   53 	RET
                             54 ;
                             55 ;	A -> UART
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 2
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0034 F5            [11]   56 TXA:	PUSH	AF
   0035 3A 01 E0      [13]   57 TXAST1:	LD	A,(UARTCR)
   0038 CB 4F         [ 8]   58 	BIT	1,A
   003A 28 F9         [12]   59 	JR	Z,TXAST1
   003C F1            [10]   60 	POP	AF
   003D 32 00 E0      [13]   61 	LD	(UARTDR),A
   0040 C9            [10]   62 	RET
                             63 ;
                             64 ;
                             65 ;	SYSTEM INITIALIZE
   0041                      66 SINIT:
   0041 C3 44 00      [10]   67 	JP	COLD
                             68 ;
                             69 ;==================================================================================
                             70 ; The updates to the original BASIC within this file are copyright Grant Searle
                             71 ;
                             72 ; You have permission to use this for NON COMMERCIAL USE ONLY
                             73 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                             74 ;
                             75 ; http://searle.hostei.com/grant/index.html
                             76 ;
                             77 ; eMail: home.micros01@btinternet.com
                             78 ;
                             79 ; If the above don't work, please perform an Internet search to see if I have
                             80 ; updated the web page hosting service.
                             81 ;
                             82 ;==================================================================================
                             83 ;
                             84 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                             85 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                             86 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                             87 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                             88 ; the original ROM code (checksum 0xA934). PA
                             89 ;
                             90 ; GENERAL EQUATES
                             91 ;
                     0003    92 CTRLC	.equ	0x03		; Control "C"
                     0007    93 CTRLG	.equ	0x07		; Control "G"
                     0008    94 BKSP	.equ	0x08		; Back space
                     000A    95 LF	.equ	0x0A		; Line feed
                     000C    96 CS	.equ	0x0C		; Clear screen
                     000D    97 CR	.equ	0x0D		; Carriage return
                     000F    98 CTRLO	.equ	0x0F		; Control "O"
                     0011    99 CTRLQ	.equ	0x11		; Control "Q"
                     0012   100 CTRLR	.equ	0x12		; Control "R"
                     0013   101 CTRLS	.equ	0x13		; Control "S"
                     0015   102 CTRLU	.equ	0x15		; Control "U"
                     001B   103 ESC	.equ	0x1B		; Escape
                     007F   104 DEL	.equ	0x7F		; Delete
                            105 ;
                            106 ; BASIC WORK SPACE LOCATIONS
                            107 ;
                     8045   108 WRKSPC	.equ	0x8045		; BASIC Work space
                     8048   109 USR	.equ	WRKSPC+0x3	; "USR (x)" jump
                     804B   110 OUTSUB	.equ	WRKSPC+0x6	; "OUT p,n"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 3
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



                     804C   111 OTPORT	.equ	WRKSPC+0x7	; Port (p)
                     804E   112 DIVSUP	.equ	WRKSPC+0x9	; Division support routine
                     804F   113 DIV1	.equ	WRKSPC+0x0A	; <- Values
                     8053   114 DIV2	.equ	WRKSPC+0x0E	; <- to
                     8057   115 DIV3	.equ	WRKSPC+0x12	; <- be
                     805A   116 DIV4	.equ	WRKSPC+0x15	; <- inserted
                     805C   117 SEED	.equ	WRKSPC+0x17	; Random number seed
                     807F   118 LSTRND	.equ	WRKSPC+0x3A	; Last random number
                     8083   119 INPSUB	.equ	WRKSPC+0x3E	; #INP (x)" Routine
                     8084   120 INPORT	.equ	WRKSPC+0x3F	; PORT (x)
                     8086   121 NULLS	.equ	WRKSPC+0x41	; Number of nulls
                     8087   122 LWIDTH	.equ	WRKSPC+0x42	; Terminal width
                     8088   123 COMMAN	.equ	WRKSPC+0x43	; Width for commas
                     8089   124 NULFLG	.equ	WRKSPC+0x44	; Null after input byte flag
                     808A   125 CTLOFG	.equ	WRKSPC+0x45	; Control "O" flag
                     808B   126 LINESC	.equ	WRKSPC+0x46	; Lines counter
                     808D   127 LINESN	.equ	WRKSPC+0x48	; Lines number
                     808F   128 CHKSUM	.equ	WRKSPC+0x4A	; Array load/save check sum
                     8091   129 NMIFLG	.equ	WRKSPC+0x4C	; Flag for NMI break routine
                     8092   130 BRKFLG	.equ	WRKSPC+0x4D	; Break flag
                     8093   131 RINPUT	.equ	WRKSPC+0x4E	; Input reflection
                     8096   132 POINT	.equ	WRKSPC+0x51	; "POINT" reflection (unused)
                     8099   133 PSET	.equ	WRKSPC+0x54	; "SET"	reflection
                     809C   134 RESET	.equ	WRKSPC+0x57	; "RESET" reflection
                     809F   135 STRSPC	.equ	WRKSPC+0x5A	; Bottom of string space
                     80A1   136 LINEAT	.equ	WRKSPC+0x5C	; Current line number
                     80A3   137 BASTXT	.equ	WRKSPC+0x5E	; Pointer to start of program
                     80A6   138 BUFFER	.equ	WRKSPC+0x61	; Input buffer
                     80AB   139 STACK	.equ	WRKSPC+0x66	; Initial stack
                     80F0   140 CURPOS	.equ	WRKSPC+0x0AB	; Character position on line
                     80F1   141 LCRFLG	.equ	WRKSPC+0x0AC	; Locate/Create flag
                     80F2   142 TYPE	.equ	WRKSPC+0x0AD	; Data type flag
                     80F3   143 DATFLG	.equ	WRKSPC+0x0AE	; Literal statement flag
                     80F4   144 LSTRAM	.equ	WRKSPC+0x0AF	; Last available RAM
                     80F6   145 TMSTPT	.equ	WRKSPC+0x0B1	; Temporary string pointer
                     80F8   146 TMSTPL	.equ	WRKSPC+0x0B3	; Temporary string pool
                     8104   147 TMPSTR	.equ	WRKSPC+0x0BF	; Temporary string
                     8108   148 STRBOT	.equ	WRKSPC+0x0C3	; Bottom of string space
                     810A   149 CUROPR	.equ	WRKSPC+0x0C5	; Current operator in EVAL
                     810C   150 LOOPST	.equ	WRKSPC+0x0C7	; First statement of loop
                     810E   151 DATLIN	.equ	WRKSPC+0x0C9	; Line of current DATA item
                     8110   152 FORFLG	.equ	WRKSPC+0x0CB	; "FOR" loop flag
                     8111   153 LSTBIN	.equ	WRKSPC+0x0CC	; Last byte entered
                     8112   154 READFG	.equ	WRKSPC+0x0CD	; Read/Input flag
                     8113   155 BRKLIN	.equ	WRKSPC+0x0CE	; Line of break
                     8115   156 NXTOPR	.equ	WRKSPC+0x0D0	; Next operator in EVAL
                     8117   157 ERRLIN	.equ	WRKSPC+0x0D2	; Line of error
                     8119   158 CONTAD	.equ	WRKSPC+0x0D4	; Where to CONTinue
                     811B   159 PROGND	.equ	WRKSPC+0x0D6	; End of program
                     811D   160 VAREND	.equ	WRKSPC+0x0D8	; End of variables
                     811F   161 ARREND	.equ	WRKSPC+0x0DA	; End of arrays
                     8121   162 NXTDAT	.equ	WRKSPC+0x0DC	; Next data item
                     8123   163 FNRGNM	.equ	WRKSPC+0x0DE	; Name of FN argument
                     8125   164 FNARG	.equ	WRKSPC+0x0E0	; FN argument value
                     8129   165 FPREG	.equ	WRKSPC+0x0E4	; Floating point register
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 4
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



                     812C   166 FPEXP	.equ	FPREG+3		; Floating point exponent
                     812D   167 SGNRES	.equ	WRKSPC+0x0E8	; Sign of result
                     812E   168 PBUFF	.equ	WRKSPC+0x0E9	; Number print buffer
                     813B   169 MULVAL	.equ	WRKSPC+0x0F6	; Multiplier
                     813E   170 PROGST	.equ	WRKSPC+0x0F9	; Start of program text area
                     81A2   171 STLOOK	.equ	WRKSPC+0x15D	; Start of memory test
                            172 ;
                            173 ; BASIC ERROR CODE VALUES
                            174 ;
                     0000   175 NF	.equ	0x00		; NEXT without FOR
                     0002   176 SN	.equ	0x02		; Syntax error
                     0004   177 RG	.equ	0x04		; RETURN without GOSUB
                     0006   178 OD	.equ	0x06		; Out of DATA
                     0008   179 FC	.equ	0x08		; Function call error
                     000A   180 OV	.equ	0x0A		; Overflow
                     000C   181 OM	.equ	0x0C		; Out of memory
                     000E   182 UL	.equ	0x0E		; Undefined line number
                     0010   183 BS	.equ	0x10		; Bad subscript
                     0012   184 RD	.equ	0x12		; Re-DIMensioned array
                     0014   185 DZ	.equ	0x14		; Division by zero (/0)
                     0016   186 ID	.equ	0x16		; Illegal direct
                     0018   187 TM	.equ	0x18		; Type miss-match
                     001A   188 OS	.equ	0x1A		; Out of string space
                     001C   189 LS	.equ	0x1C		; String too long
                     001E   190 ST	.equ	0x1E		; String formula too complex
                     0020   191 CN	.equ	0x20		; Can't CONTinue
                     0022   192 UF	.equ	0x22		; UnDEFined FN function
                     0024   193 MO	.equ	0x24		; Missing operand
                     0026   194 HX	.equ	0x26		; HEX error
                     0028   195 BN	.equ	0x28		; BIN error
                            196 ;
   0044 C3 4A 00      [10]  197 COLD:	JP	STARTB		; Jump for cold start
   0047 C3 BF 00      [10]  198 WARM:	JP	WARMST		; Jump for warm start
   004A C3 51 00      [10]  199 STARTB: JP	CSTART		; Jump to initialise
                            200 ;
   004D F4 08               201 	.dw	DEINT		; Get integer -32768 to 32767
   004F 6A 10               202 	.dw	ABPASS		; Return integer in AB
                            203 ;
   0051 21 45 80      [10]  204 CSTART: LD	HL,WRKSPC	; Start of workspace RAM
   0054 F9            [ 6]  205 	LD	SP,HL		; Set up a temporary stack
   0055 C3 6D 1C      [10]  206 	JP	INITST		; Go to initialise
                            207 ;
   0058 11 29 03      [10]  208 INIT:	LD	DE,INITAB	; Initialise workspace
   005B 06 63         [ 7]  209 	LD	B,INITBE-INITAB+3; Bytes to copy
   005D 21 45 80      [10]  210 	LD	HL,WRKSPC	; Into workspace RAM
   0060 1A            [ 7]  211 COPY:	LD	A,(DE)		; Get source
   0061 77            [ 7]  212 	LD	(HL),A		; To destination
   0062 23            [ 6]  213 	INC	HL		; Next destination
   0063 13            [ 6]  214 	INC	DE		; Next source
   0064 05            [ 4]  215 	DEC	B		; Count bytes
   0065 C2 60 00      [10]  216 	JP	NZ,COPY		; More to move
   0068 F9            [ 6]  217 	LD	SP,HL		; Temporary stack
   0069 CD 2A 05      [17]  218 	CALL	CLREG		; Clear registers and stack
   006C CD EA 0A      [17]  219 	CALL	PRCRLF		; Output CRLF
   006F 32 EF 80      [13]  220 	LD	(BUFFER+72+1),A	; Mark end of buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 5
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0072 32 3E 81      [13]  221 	LD	(PROGST),A	; Initialise program area
   0075 21 A2 81      [10]  222 MSIZE:	LD	HL,STLOOK	; Point to start of RAM
   0078 23            [ 6]  223 MLOOP:	INC	HL		; Next byte
   0079 7C            [ 4]  224 	LD	A,H		; Above address FFFF ?
   007A B5            [ 4]  225 	OR	L
   007B CA 87 00      [10]  226 	JP	Z,SETTOP	; Yes - 64K RAM
   007E 7E            [ 7]  227 	LD	A,(HL)		; Get contents
   007F 47            [ 4]  228 	LD	B,A		; Save it
   0080 2F            [ 4]  229 	CPL			; Flip all bits
   0081 77            [ 7]  230 	LD	(HL),A		; Put it back
   0082 BE            [ 7]  231 	CP	(HL)		; RAM there if same
   0083 70            [ 7]  232 	LD	(HL),B		; Restore old contents
   0084 CA 78 00      [10]  233 	JP	Z,MLOOP		; If RAM - test next byte
                            234 ;
   0087 2B            [ 6]  235 SETTOP: DEC	HL		; Back one byte
   0088 11 A1 81      [10]  236 	LD	DE,STLOOK-1	; See if enough RAM
   008B CD BA 06      [17]  237 	CALL	CPDEHL		; Compare DE with HL
   008E DA C8 00      [10]  238 	JP	C,NEMEM		; If not enough RAM
   0091 11 CE FF      [10]  239 	LD	DE,0-50		; 50 Bytes string space
   0094 22 F4 80      [16]  240 	LD	(LSTRAM),HL	; Save last available RAM
   0097 19            [11]  241 	ADD	HL,DE		; Allocate string space
   0098 22 9F 80      [16]  242 	LD	(STRSPC),HL	; Save string space
   009B CD 05 05      [17]  243 	CALL	CLRPTR		; Clear program area
   009E 2A 9F 80      [16]  244 	LD	HL,(STRSPC)	; Get end of memory
   00A1 11 EF FF      [10]  245 	LD	DE,0-17		; Offset for free bytes
   00A4 19            [11]  246 	ADD	HL,DE		; Adjust HL
   00A5 11 3E 81      [10]  247 	LD	DE,PROGST	; Start of program text
   00A8 7D            [ 4]  248 	LD	A,L		; Get LSB
   00A9 93            [ 4]  249 	SUB	E		; Adjust it
   00AA 6F            [ 4]  250 	LD	L,A		; Re-save
   00AB 7C            [ 4]  251 	LD	A,H		; Get MSB
   00AC 9A            [ 4]  252 	SBC	A,D		; Adjust it
   00AD 67            [ 4]  253 	LD	H,A		; Re-save
   00AE E5            [11]  254 	PUSH	HL		; Save bytes free
   00AF 21 E0 00      [10]  255 	LD	HL,SIGNON	; Sign-on message
   00B2 CD 88 11      [17]  256 	CALL	PRS		; Output string
   00B5 E1            [10]  257 	POP	HL		; Get bytes free back
   00B6 CD 29 18      [17]  258 	CALL	PRNTHL		; Output amount of free memory
   00B9 21 D1 00      [10]  259 	LD	HL,BFREE	; " Bytes free" message
   00BC CD 88 11      [17]  260 	CALL	PRS		; Output string
                            261 ;
   00BF 31 AB 80      [10]  262 WARMST: LD	SP,STACK	; Temporary stack
   00C2 CD 2A 05      [17]  263 BRKRET: CALL	CLREG		; Clear registers and stack
   00C5 C3 43 04      [10]  264 	JP	PRNTOK		; Go to get command line
                            265 ;
   00C8 21 17 01      [10]  266 NEMEM:	LD	HL,MEMMSG	; Memory size not enough
   00CB CD 88 11      [17]  267 	CALL	PRS		; Print it
   00CE C3 CE 00      [10]  268 XXXXX:	JP	XXXXX		; Stop
                            269 ;
   00D1 20 42 79 74 65 73   270 BFREE:	.ascii	" Bytes free"
        20 66 72 65 65
   00DC 0D 0A 00 00         271 	.db CR,LF,0,0
                            272 ;
   00E0 5A 38 30 20 42 41   273 SIGNON: .ascii	"Z80 BASIC Ver 4.7b"
        53 49 43 20 56 65
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 6
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



        72 20 34 2E 37 62
   00F2 0D 0A               274 	.db CR,LF
   00F4 43 6F 70 79 72 69   275 	.ascii	"Copyright "
        67 68 74 20
   00FE 28                  276 	.db 40
   00FF 43                  277 	.ascii "C"
   0100 29                  278 	.db 41
   0101 20 31 39 37 38 20   279 	.ascii	" 1978 by Microsoft"
        62 79 20 4D 69 63
        72 6F 73 6F 66 74
   0113 0D 0A 00 00         280 	.db CR,LF,0,0
                            281 ;
   0117 4D 65 6D 6F 72 79   282 MEMMSG: .ascii	"Memory size not enough"
        20 73 69 7A 65 20
        6E 6F 74 20 65 6E
        6F 75 67 68
   012D 0D 0A               283 	.db CR,LF
   012F 54 68 65 20 73 79   284 	.ascii	"The system is stopped."
        73 74 65 6D 20 69
        73 20 73 74 6F 70
        70 65 64 2E
   0145 0D 0A 00 00         285 	.db CR,LF,0,0
                            286 ;
                            287 ; FUNCTION ADDRESS TABLE
                            288 ;
   0149 9E 16               289 FNCTAB: .dw	SGN
   014B 62 17               290 	.dw	INT
   014D B4 16               291 	.dw	ABS
   014F 48 80               292 	.dw	USR
   0151 48 10               293 	.dw	FRE
   0153 CD 13               294 	.dw	INP
   0155 76 10               295 	.dw	POS
   0157 28 19               296 	.dw	SQR
   0159 05 1A               297 	.dw	RND
   015B 43 15               298 	.dw	LOG
   015D 74 19               299 	.dw	EXP
   015F 74 1A               300 	.dw	COS
   0161 7A 1A               301 	.dw	SIN
   0163 DB 1A               302 	.dw	TAN
   0165 F0 1A               303 	.dw	ATN
   0167 21 14               304 	.dw	PEEK
   0169 5B 1B               305 	.dw	DEEK
   016B 96 80               306 	.dw	POINT
   016D FA 12               307 	.dw	LEN
   016F 12 11               308 	.dw	STR
   0171 94 13               309 	.dw	VAL
   0173 09 13               310 	.dw	ASC
   0175 1A 13               311 	.dw	CHR
   0177 7D 1B               312 	.dw	HEX
   0179 02 1C               313 	.dw	BIN
   017B 2A 13               314 	.dw	LEFT
   017D 5A 13               315 	.dw	RIGHT
   017F 64 13               316 	.dw	MID
                            317 ;
                            318 ; RESERVED WORD LIST
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 7
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



                            319 ;
   0181 C5                  320 WORDS:	.db	0x0C5
   0182 4E 44               321 	.ascii "ND"
   0184 C6                  322 	.db	0x0C6
   0185 4F 52               323 	.ascii "OR"
   0187 CE                  324 	.db	0x0CE
   0188 45 58 54            325 	.ascii "EXT"
   018B C4                  326 	.db	0x0C4
   018C 41 54 41            327 	.ascii "ATA"
   018F C9                  328 	.db	0x0C9
   0190 4E 50 55 54         329 	.ascii "NPUT"
   0194 C4                  330 	.db	0x0C4
   0195 49 4D               331 	.ascii "IM"
   0197 D2                  332 	.db	0x0D2
   0198 45 41 44            333 	.ascii "EAD"
   019B CC                  334 	.db	0x0CC
   019C 45 54               335 	.ascii "ET"
   019E C7                  336 	.db	0x0C7
   019F 4F 54 4F            337 	.ascii "OTO"
   01A2 D2                  338 	.db	0x0D2
   01A3 55 4E               339 	.ascii "UN"
   01A5 C9                  340 	.db	0x0C9
   01A6 46                  341 	.ascii "F"
   01A7 D2                  342 	.db	0x0D2
   01A8 45 53 54 4F 52 45   343 	.ascii "ESTORE"
   01AE C7                  344 	.db	0x0C7
   01AF 4F 53 55 42         345 	.ascii "OSUB"
   01B3 D2                  346 	.db	0x0D2
   01B4 45 54 55 52 4E      347 	.ascii "ETURN"
   01B9 D2                  348 	.db	0x0D2
   01BA 45 4D               349 	.ascii "EM"
   01BC D3                  350 	.db	0x0D3
   01BD 54 4F 50            351 	.ascii "TOP"
   01C0 CF                  352 	.db	0x0CF
   01C1 55 54               353 	.ascii "UT"
   01C3 CF                  354 	.db	0x0CF
   01C4 4E                  355 	.ascii "N"
   01C5 CE                  356 	.db	0x0CE
   01C6 55 4C 4C            357 	.ascii "ULL"
   01C9 D7                  358 	.db	0x0D7
   01CA 41 49 54            359 	.ascii "AIT"
   01CD C4                  360 	.db	0x0C4
   01CE 45 46               361 	.ascii "EF"
   01D0 D0                  362 	.db	0x0D0
   01D1 4F 4B 45            363 	.ascii "OKE"
   01D4 C4                  364 	.db	0x0C4
   01D5 4F 4B 45            365 	.ascii "OKE"
   01D8 D3                  366 	.db	0x0D3
   01D9 43 52 45 45 4E      367 	.ascii "CREEN"
   01DE CC                  368 	.db	0x0CC
   01DF 49 4E 45 53         369 	.ascii "INES"
   01E3 C3                  370 	.db	0x0C3
   01E4 4C 53               371 	.ascii "LS"
   01E6 D7                  372 	.db	0x0D7
   01E7 49 44 54 48         373 	.ascii "IDTH"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 8
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   01EB CD                  374 	.db	0x0CD
   01EC 4F 4E 49 54 4F 52   375 	.ascii "ONITOR"
   01F2 D3                  376 	.db	0x0D3
   01F3 45 54               377 	.ascii "ET"
   01F5 D2                  378 	.db	0x0D2
   01F6 45 53 45 54         379 	.ascii "ESET"
   01FA D0                  380 	.db	0x0D0
   01FB 52 49 4E 54         381 	.ascii "RINT"
   01FF C3                  382 	.db	0x0C3
   0200 4F 4E 54            383 	.ascii "ONT"
   0203 CC                  384 	.db	0x0CC
   0204 49 53 54            385 	.ascii "IST"
   0207 C3                  386 	.db	0x0C3
   0208 4C 45 41 52         387 	.ascii "LEAR"
   020C C3                  388 	.db	0x0C3
   020D 4C 4F 41 44         389 	.ascii "LOAD"
   0211 C3                  390 	.db	0x0C3
   0212 53 41 56 45         391 	.ascii "SAVE"
   0216 CE                  392 	.db	0x0CE
   0217 45 57               393 	.ascii "EW"
                            394 ;
   0219 D4                  395 	.db	0x0D4
   021A 41 42 28            396 	.ascii "AB("
   021D D4                  397 	.db	0x0D4
   021E 4F                  398 	.ascii "O"
   021F C6                  399 	.db	0x0C6
   0220 4E                  400 	.ascii "N"
   0221 D3                  401 	.db	0x0D3
   0222 50 43 28            402 	.ascii "PC("
   0225 D4                  403 	.db	0x0D4
   0226 48 45 4E            404 	.ascii "HEN"
   0229 CE                  405 	.db	0x0CE
   022A 4F 54               406 	.ascii "OT"
   022C D3                  407 	.db	0x0D3
   022D 54 45 50            408 	.ascii "TEP"
                            409 ;
   0230 AB                  410 	.db	0x0AB
   0231 AD                  411 	.db	0x0AD
   0232 AA                  412 	.db	0x0AA
   0233 AF                  413 	.db	0x0AF
   0234 DE                  414 	.db	0x0DE
   0235 C1                  415 	.db	0x0C1
   0236 4E 44               416 	.ascii "ND"
   0238 CF                  417 	.db	0x0CF
   0239 52                  418 	.ascii "R"
   023A BE                  419 	.db	0x0BE
   023B BD                  420 	.db	0x0BD
   023C BC                  421 	.db	0x0BC
                            422 ;
   023D D3                  423 	.db	0x0D3
   023E 47 4E               424 	.ascii "GN"
   0240 C9                  425 	.db	0x0C9
   0241 4E 54               426 	.ascii "NT"
   0243 C1                  427 	.db	0x0C1
   0244 42 53               428 	.ascii "BS"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 9
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0246 D5                  429 	.db	0x0D5
   0247 53 52               430 	.ascii "SR"
   0249 C6                  431 	.db	0x0C6
   024A 52 45               432 	.ascii "RE"
   024C C9                  433 	.db	0x0C9
   024D 4E 50               434 	.ascii "NP"
   024F D0                  435 	.db	0x0D0
   0250 4F 53               436 	.ascii "OS"
   0252 D3                  437 	.db	0x0D3
   0253 51 52               438 	.ascii "QR"
   0255 D2                  439 	.db	0x0D2
   0256 4E 44               440 	.ascii "ND"
   0258 CC                  441 	.db	0x0CC
   0259 4F 47               442 	.ascii "OG"
   025B C5                  443 	.db	0x0C5
   025C 58 50               444 	.ascii "XP"
   025E C3                  445 	.db	0x0C3
   025F 4F 53               446 	.ascii "OS"
   0261 D3                  447 	.db	0x0D3
   0262 49 4E               448 	.ascii "IN"
   0264 D4                  449 	.db	0x0D4
   0265 41 4E               450 	.ascii "AN"
   0267 C1                  451 	.db	0x0C1
   0268 54 4E               452 	.ascii "TN"
   026A D0                  453 	.db	0x0D0
   026B 45 45 4B            454 	.ascii "EEK"
   026E C4                  455 	.db	0x0C4
   026F 45 45 4B            456 	.ascii "EEK"
   0272 D0                  457 	.db	0x0D0
   0273 4F 49 4E 54         458 	.ascii "OINT"
   0277 CC                  459 	.db	0x0CC
   0278 45 4E               460 	.ascii "EN"
   027A D3                  461 	.db	0x0D3
   027B 54 52 24            462 	.ascii "TR$"
   027E D6                  463 	.db	0x0D6
   027F 41 4C               464 	.ascii "AL"
   0281 C1                  465 	.db	0x0C1
   0282 53 43               466 	.ascii "SC"
   0284 C3                  467 	.db	0x0C3
   0285 48 52 24            468 	.ascii "HR$"
   0288 C8                  469 	.db	0x0C8
   0289 45 58 24            470 	.ascii "EX$"
   028C C2                  471 	.db	0x0C2
   028D 49 4E 24            472 	.ascii "IN$"
   0290 CC                  473 	.db	0x0CC
   0291 45 46 54 24         474 	.ascii "EFT$"
   0295 D2                  475 	.db	0x0D2
   0296 49 47 48 54 24      476 	.ascii "IGHT$"
   029B CD                  477 	.db	0x0CD
   029C 49 44 24            478 	.ascii "ID$"
   029F 80                  479 	.db	0x80		; End of list marker
                            480 ;
                            481 ; KEYWORD ADDRESS TABLE
                            482 ;
   02A0 8E 08               483 WORDTB: .dw	PEND
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 10
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   02A2 8D 07               484 	.dw	FOR
   02A4 64 0C               485 	.dw	NEXT
   02A6 D9 09               486 	.dw	DATA
   02A8 6B 0B               487 	.dw	INPUT
   02AA A0 0E               488 	.dw	DIM
   02AC 9A 0B               489 	.dw	READ
   02AE F0 09               490 	.dw	LET
   02B0 96 09               491 	.dw	GOTO
   02B2 79 09               492 	.dw	RUN
   02B4 68 0A               493 	.dw	IF
   02B6 56 08               494 	.dw	RESTOR
   02B8 85 09               495 	.dw	GOSUB
   02BA B4 09               496 	.dw	RETURN
   02BC DB 09               497 	.dw	REM
   02BE 8C 08               498 	.dw	STOP
   02C0 D9 13               499 	.dw	POUT
   02C2 4A 0A               500 	.dw	ON
   02C4 CB 08               501 	.dw	NULL
   02C6 DF 13               502 	.dw	WAIT
   02C8 7E 10               503 	.dw	DEF
   02CA 28 14               504 	.dw	POKE
   02CC 66 1B               505 	.dw	DOKE
   02CE DB 09               506 	.dw	REM
   02D0 4C 1B               507 	.dw	LINES
   02D2 3F 1B               508 	.dw	CLS
   02D4 44 1B               509 	.dw	WIDTH
   02D6 6A 1C               510 	.dw	MONITR
   02D8 99 80               511 	.dw	PSET
   02DA 9C 80               512 	.dw	RESET
   02DC 8C 0A               513 	.dw	PRINT
   02DE B8 08               514 	.dw	CONT
   02E0 04 07               515 	.dw	LIST
   02E2 33 09               516 	.dw	CLEAR
   02E4 DB 09               517 	.dw	REM
   02E6 DB 09               518 	.dw	REM
   02E8 04 05               519 	.dw	NEW
                            520 ;
                            521 ; RESERVED WORD TOKEN VALUES
                            522 ;
                     0080   523 ZEND	.equ	0x080		; END
                     0081   524 ZFOR	.equ	0x081		; FOR
                     0083   525 ZDATA	.equ	0x083		; DATA
                     0088   526 ZGOTO	.equ	0x088		; GOTO
                     008C   527 ZGOSUB	.equ	0x08C		; GOSUB
                     008E   528 ZREM	.equ	0x08E		; REM
                     009E   529 ZPRINT	.equ	0x09E		; PRINT
                     00A4   530 ZNEW	.equ	0x0A4		; NEW
                            531 ;
                     00A5   532 ZTAB	.equ	0x0A5		; TAB
                     00A6   533 ZTO	.equ	0x0A6		; TO
                     00A7   534 ZFN	.equ	0x0A7		; FN
                     00A8   535 ZSPC	.equ	0x0A8		; SPC
                     00A9   536 ZTHEN	.equ	0x0A9		; THEN
                     00AA   537 ZNOT	.equ	0x0AA		; NOT
                     00AB   538 ZSTEP	.equ	0x0AB		; STEP
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 11
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



                            539 ;
                     00AC   540 ZPLUS	.equ	0x0AC		; +
                     00AD   541 ZMINUS	.equ	0x0AD		; -
                     00AE   542 ZTIMES	.equ	0x0AE		; *
                     00AF   543 ZDIV	.equ	0x0AF		; /
                     00B2   544 ZOR	.equ	0x0B2		; OR
                     00B3   545 ZGTR	.equ	0x0B3		; >
                     00B4   546 ZEQUAL	.equ	0x0B4		; M
                     00B5   547 ZLTH	.equ	0x0B5		; <
                     00B6   548 ZSGN	.equ	0x0B6		; SGN
                     00C7   549 ZPOINT	.equ	0x0C7		; POINT
                     00CF   550 ZLEFT	.equ	0x0CD +2		; LEFT$
                            551 ;
                            552 ; ARITHMETIC PRECEDENCE TABLE
                            553 ;
   02EA 79                  554 PRITAB: .db	0x79		; Precedence value
   02EB 10 18               555 	.dw	PADD		; FPREG = <last> + FPREG
                            556 ;
   02ED 79                  557 	.db	0x79		; Precedence value
   02EE 46 14               558 	.dw	PSUB		; FPREG = <last> - FPREG
                            559 ;
   02F0 7C                  560 	.db	0x7C		; Precedence value
   02F1 82 15               561 	.dw	MULT		; PPREG = <last> * FPREG
                            562 ;
   02F3 7C                  563 	.db	0x7C		; Precedence value
   02F4 E3 15               564 	.dw	DIV		; FPREG = <last> / FPREG
                            565 ;
   02F6 7F                  566 	.db	0x7F		; Precedence value
   02F7 31 19               567 	.dw	POWER		; FPREG = <last> ^ FPREG
                            568 ;
   02F9 50                  569 	.db	0x50		; Precedence value
   02FA F9 0D               570 	.dw	PAND		; FPREG = <last> AND FPREG
                            571 ;
   02FC 46                  572 	.db	0x46		; Precedence value
   02FD F8 0D               573 	.dw	POR		; FPREG = <last> OR FPREG
                            574 ;
                            575 ; BASIC ERROR CODE LIST
                            576 ;
   02FF 4E 46               577 ERRORS: .ascii	"NF"		; NEXT without FOR
   0301 53 4E               578 	.ascii	"SN"		; Syntax error
   0303 52 47               579 	.ascii	"RG"		; RETURN without GOSUB
   0305 4F 44               580 	.ascii	"OD"		; Out of DATA
   0307 46 43               581 	.ascii	"FC"		; Illegal function call
   0309 4F 56               582 	.ascii	"OV"		; Overflow error
   030B 4F 4D               583 	.ascii	"OM"		; Out of memory
   030D 55 4C               584 	.ascii	"UL"		; Undefined line
   030F 42 53               585 	.ascii	"BS"		; Bad subscript
   0311 44 44               586 	.ascii	"DD"		; Re-DIMensioned array
   0313 2F 30               587 	.ascii	"/0"		; Division by zero
   0315 49 44               588 	.ascii	"ID"		; Illegal direct
   0317 54 4D               589 	.ascii	"TM"		; Type mis-match
   0319 4F 53               590 	.ascii	"OS"		; Out of string space
   031B 4C 53               591 	.ascii	"LS"		; String too long
   031D 53 54               592 	.ascii	"ST"		; String formula too complex
   031F 43 4E               593 	.ascii	"CN"		; Can't CONTinue
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 12
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0321 55 46               594 	.ascii	"UF"		; Undefined FN function
   0323 4D 4F               595 	.ascii	"MO"		; Missing operand
   0325 48 58               596 	.ascii	"HX"		; HEX error
   0327 42 4E               597 	.ascii	"BN"		; BIN error
                            598 ;
                            599 ; INITIALISATION TABLE -------------------------------------------------------
                            600 ;
   0329 C3 BF 00      [10]  601 INITAB: JP	WARMST		; Warm start jump
   032C C3 09 09      [10]  602 	JP	FCERR		; "USR (X)" jump (Set to Error)
   032F D3 00         [11]  603 	OUT	(0),A		; "OUT p,n" skeleton
   0331 C9            [10]  604 	RET
   0332 D6 00         [ 7]  605 	SUB	0		; Division support routine
   0334 6F            [ 4]  606 	LD	L,A
   0335 7C            [ 4]  607 	LD	A,H
   0336 DE 00         [ 7]  608 	SBC	A,0
   0338 67            [ 4]  609 	LD	H,A
   0339 78            [ 4]  610 	LD	A,B
   033A DE 00         [ 7]  611 	SBC	A,0
   033C 47            [ 4]  612 	LD	B,A
   033D 3E 00         [ 7]  613 	LD	A,0
   033F C9            [10]  614 	RET
   0340 00 00 00            615 	.db	0,0,0			; Random number seed table used by RND
   0343 35 4A CA 99         616 	.db	0x035,0x04A,0x0CA,0x099	;-2.65145E+07
   0347 39 1C 76 98         617 	.db	0x039,0x01C,0x076,0x098	; 1.61291E+07
   034B 22 95 B3 98         618 	.db	0x022,0x095,0x0B3,0x098	;-1.17691E+07
   034F 0A DD 47 98         619 	.db	0x00A,0x0DD,0x047,0x098	; 1.30983E+07
   0353 53 D1 99 99         620 	.db	0x053,0x0D1,0x099,0x099	;-2-01612E+07
   0357 0A 1A 9F 98         621 	.db	0x00A,0x01A,0x09F,0x098	;-1.04269E+07
   035B 65 BC CD 98         622 	.db	0x065,0x0BC,0x0CD,0x098	;-1.34831E+07
   035F D6 77 3E 98         623 	.db	0x0D6,0x077,0x03E,0x098	; 1.24825E+07
   0363 52 C7 4F 80         624 	.db	0x052,0x0C7,0x04F,0x080	; Last random number
   0367 DB 00         [11]  625 	IN	A,(0)		; INP (x) skeleton
   0369 C9            [10]  626 	RET
   036A 01                  627 	.db	1		; POS (x) number (1)
   036B FF                  628 	.db	255		; Terminal width (255 = no auto CRLF)
   036C 1C                  629 	.db	28		; Width for commas (3 columns)
   036D 00                  630 	.db	0		; No nulls after input bytes
   036E 00                  631 	.db	0		; Output enabled (^O off)
   036F 14 00               632 	.dw	20		; Initial lines counter
   0371 14 00               633 	.dw	20		; Initial lines number
   0373 00 00               634 	.dw	0		; Array load/save check sum
   0375 00                  635 	.db	0		; Break not by NMI
   0376 00                  636 	.db	0		; Break flag
   0377 C3 37 06      [10]  637 	JP	TTYLIN		; Input reflection (set to TTY)
   037A C3 00 00      [10]  638 	JP	0x0000		; POINT reflection unused
   037D C3 00 00      [10]  639 	JP	0x0000		; SET reflection
   0380 C3 00 00      [10]  640 	JP	0x0000			; RESET reflection
   0383 A2 81               641 	.dw	STLOOK		; Temp string space
   0385 FE FF               642 	.dw	-2		; Current line number (cold)
   0387 3F 81               643 	.dw	PROGST+1	; Start of program text
   0389                     644 INITBE:			 
                            645 ;
                            646 ; END OF INITIALISATION TABLE ---------------------------------------------------
                            647 ;
   0389 20 45 72 72 6F 72   648 ERRMSG: .ascii	" Error"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 13
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   038F 00                  649 	.db 0
   0390 20 69 6E 20         650 INMSG:	.ascii	" in "
   0394 00                  651 	.db 0
                     0394   652 ZERBYT	.equ	.-1		; A zero byte
   0395 4F 6B               653 OKMSG:	.ascii	"Ok"
   0397 0D 0A 00 00         654 	.db CR,LF,0,0
   039B 42 72 65 61 6B      655 BRKMSG: .ascii	"Break"
   03A0 00                  656 	.db 0
                            657 ;
   03A1 21 04 00      [10]  658 BAKSTK: LD	HL,4		; Look for "FOR" block with
   03A4 39            [11]  659 	ADD	HL,SP		; same index as specified
   03A5 7E            [ 7]  660 LOKFOR: LD	A,(HL)		; Get block ID
   03A6 23            [ 6]  661 	INC	HL		; Point to index address
   03A7 FE 81         [ 7]  662 	CP	ZFOR		; Is it a "FOR" token
   03A9 C0            [11]  663 	RET	NZ		; No - exit
   03AA 4E            [ 7]  664 	LD	C,(HL)		; BC = Address of "FOR" index
   03AB 23            [ 6]  665 	INC	HL
   03AC 46            [ 7]  666 	LD	B,(HL)
   03AD 23            [ 6]  667 	INC	HL		; Point to sign of STEP
   03AE E5            [11]  668 	PUSH	HL		; Save pointer to sign
   03AF 69            [ 4]  669 	LD	L,C		; HL = address of "FOR" index
   03B0 60            [ 4]  670 	LD	H,B
   03B1 7A            [ 4]  671 	LD	A,D		; See if an index was specified
   03B2 B3            [ 4]  672 	OR	E		; DE = 0 if no index specified
   03B3 EB            [ 4]  673 	EX	DE,HL		; Specified index into HL
   03B4 CA BB 03      [10]  674 	JP	Z,INDFND	; Skip if no index given
   03B7 EB            [ 4]  675 	EX	DE,HL		; Index back into DE
   03B8 CD BA 06      [17]  676 	CALL	CPDEHL		; Compare index with one given
   03BB 01 0D 00      [10]  677 INDFND: LD	BC,16-3		; Offset to next block
   03BE E1            [10]  678 	POP	HL		; Restore pointer to sign
   03BF C8            [11]  679 	RET	Z		; Return if block found
   03C0 09            [11]  680 	ADD	HL,BC		; Point to next block
   03C1 C3 A5 03      [10]  681 	JP	LOKFOR		; Keep on looking
                            682 ;
   03C4 CD DE 03      [17]  683 MOVUP:	CALL	ENFMEM		; See if enough memory
   03C7 C5            [11]  684 MOVSTR: PUSH	BC		; Save end of source
   03C8 E3            [19]  685 	EX	(SP),HL		; Swap source and dest" end
   03C9 C1            [10]  686 	POP	BC		; Get end of destination
   03CA CD BA 06      [17]  687 MOVLP:	CALL	CPDEHL		; See if list moved
   03CD 7E            [ 7]  688 	LD	A,(HL)		; Get byte
   03CE 02            [ 7]  689 	LD	(BC),A		; Move it
   03CF C8            [11]  690 	RET	Z		; Exit if all done
   03D0 0B            [ 6]  691 	DEC	BC		; Next byte to move to
   03D1 2B            [ 6]  692 	DEC	HL		; Next byte to move
   03D2 C3 CA 03      [10]  693 	JP	MOVLP		; Loop until all bytes moved
                            694 ;
   03D5 E5            [11]  695 CHKSTK: PUSH	HL		; Save code string address
   03D6 2A 1F 81      [16]  696 	LD	HL,(ARREND)	; Lowest free memory
   03D9 06 00         [ 7]  697 	LD	B,0		; BC = Number of levels to test
   03DB 09            [11]  698 	ADD	HL,BC		; 2 Bytes for each level
   03DC 09            [11]  699 	ADD	HL,BC
   03DD 3E                  700 	.db	0x3E		; Skip "PUSH HL"
   03DE E5            [11]  701 ENFMEM: PUSH	HL		; Save code string address
   03DF 3E D0         [ 7]  702 	LD	A,0x0D0		; LOW -48; 48 Bytes minimum RAM
   03E1 95            [ 4]  703 	SUB	L
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 14
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   03E2 6F            [ 4]  704 	LD	L,A
   03E3 3E FF         [ 7]  705 	LD	A,0x0FF		; HIGH (-48); 48 Bytes minimum RAM
   03E5 9C            [ 4]  706 	SBC	A,H
   03E6 DA ED 03      [10]  707 	JP	C,OMERR		; Not enough - ?OM Error
   03E9 67            [ 4]  708 	LD	H,A
   03EA 39            [11]  709 	ADD	HL,SP		; Test if stack is overflowed
   03EB E1            [10]  710 	POP	HL		; Restore code string address
   03EC D8            [11]  711 	RET	C		; Return if enough mmory
   03ED 1E 0C         [ 7]  712 OMERR:	LD	E,OM		; ?OM Error
   03EF C3 0C 04      [10]  713 	JP	ERROR
                            714 ;
   03F2 2A 0E 81      [16]  715 DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
   03F5 22 A1 80      [16]  716 	LD	(LINEAT),HL	; Save as current line
   03F8 1E 02         [ 7]  717 SNERR:	LD	E,SN		; ?SN Error
   03FA 01                  718 	.db	0x01		; Skip "LD E,DZ"
   03FB 1E 14         [ 7]  719 DZERR:	LD	E,DZ		; ?/0 Error
   03FD 01                  720 	.db	0x01		; Skip "LD E,NF"
   03FE 1E 00         [ 7]  721 NFERR:	LD	E,NF		; ?NF Error
   0400 01                  722 	.db	0x01		; Skip "LD E,RD"
   0401 1E 12         [ 7]  723 DDERR:	LD	E,RD		; ?DD Error
   0403 01                  724 	.db	0x01		; Skip "LD E,UF"
   0404 1E 22         [ 7]  725 UFERR:	LD	E,UF		; ?UF Error
   0406 01                  726 	.db	0x01		; Skip "LD E,OV
   0407 1E 0A         [ 7]  727 OVERR:	LD	E,OV		; ?OV Error
   0409 01                  728 	.db	0x01		; Skip "LD E,TM"
   040A 1E 18         [ 7]  729 TMERR:	LD	E,TM		; ?TM Error
                            730 ;
   040C CD 2A 05      [17]  731 ERROR:	CALL	CLREG		; Clear registers and stack
   040F 32 8A 80      [13]  732 	LD	(CTLOFG),A	; Enable output (A is 0)
   0412 CD DD 0A      [17]  733 	CALL	STTLIN		; Start new line
   0415 21 FF 02      [10]  734 	LD	HL,ERRORS	; Point to error codes
   0418 57            [ 4]  735 	LD	D,A		; D = 0 (A is 0)
   0419 3E 3F         [ 7]  736 	LD	A,'?
   041B CD CB 06      [17]  737 	CALL	OUTC		; Output '?
   041E 19            [11]  738 	ADD	HL,DE		; Offset to correct error code
   041F 7E            [ 7]  739 	LD	A,(HL)		; First character
   0420 CD CB 06      [17]  740 	CALL	OUTC		; Output it
   0423 CD 46 08      [17]  741 	CALL	GETCHR		; Get next character
   0426 CD CB 06      [17]  742 	CALL	OUTC		; Output it
   0429 21 89 03      [10]  743 	LD	HL,ERRMSG	; "Error" message
   042C CD 88 11      [17]  744 ERRIN:	CALL	PRS		; Output message
   042F 2A A1 80      [16]  745 	LD	HL,(LINEAT)	; Get line of error
   0432 11 FE FF      [10]  746 	LD	DE,-2		; Cold start error if -2
   0435 CD BA 06      [17]  747 	CALL	CPDEHL		; See if cold start error
   0438 CA 51 00      [10]  748 	JP	Z,CSTART	; Cold start error - Restart
   043B 7C            [ 4]  749 	LD	A,H		; Was it a direct error?
   043C A5            [ 4]  750 	AND	L		; Line = -1 if direct error
   043D 3C            [ 4]  751 	INC	A
   043E C4 21 18      [17]  752 	CALL	NZ,LINEIN	; No - output line of error
   0441 3E                  753 	.db	0x3E		; Skip "POP BC"
   0442 C1            [10]  754 POPNOK: POP	BC		; Drop address in input buffer
                            755 ;
   0443 AF            [ 4]  756 PRNTOK: XOR	A		; Output "Ok" and get command
   0444 32 8A 80      [13]  757 	LD	(CTLOFG),A	; Enable output
   0447 CD DD 0A      [17]  758 	CALL	STTLIN		; Start new line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 15
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   044A 21 95 03      [10]  759 	LD	HL,OKMSG	; "Ok" message
   044D CD 88 11      [17]  760 	CALL	PRS		; Output "Ok"
   0450 21 FF FF      [10]  761 GETCMD: LD	HL,-1		; Flag direct mode
   0453 22 A1 80      [16]  762 	LD	(LINEAT),HL	; Save as current line
   0456 CD 37 06      [17]  763 	CALL	GETLIN		; Get an input line
   0459 DA 50 04      [10]  764 	JP	C,GETCMD	; Get line again if break
   045C CD 46 08      [17]  765 	CALL	GETCHR		; Get first character
   045F 3C            [ 4]  766 	INC	A		; Test if end of line
   0460 3D            [ 4]  767 	DEC	A		; Without affecting Carry
   0461 CA 50 04      [10]  768 	JP	Z,GETCMD	; Nothing entered - Get another
   0464 F5            [11]  769 	PUSH	AF		; Save Carry status
   0465 CD 0E 09      [17]  770 	CALL	ATOH		; Get line number into DE
   0468 D5            [11]  771 	PUSH	DE		; Save line number
   0469 CD 54 05      [17]  772 	CALL	CRUN0xC		; Tokenise rest of line
   046C 47            [ 4]  773 	LD	B,A		; Length of tokenised line
   046D D1            [10]  774 	POP	DE		; Restore line number
   046E F1            [10]  775 	POP	AF		; Restore Carry
   046F D2 26 08      [10]  776 	JP	NC,EXCUTE	; No line number - Direct mode
   0472 D5            [11]  777 	PUSH	DE		; Save line number
   0473 C5            [11]  778 	PUSH	BC		; Save length of tokenised line
   0474 AF            [ 4]  779 	XOR	A
   0475 32 11 81      [13]  780 	LD	(LSTBIN),A	; Clear last byte input
   0478 CD 46 08      [17]  781 	CALL	GETCHR		; Get next character
   047B B7            [ 4]  782 	OR	A		; Set flags
   047C F5            [11]  783 	PUSH	AF		; And save them
   047D CD E4 04      [17]  784 	CALL	SRCHLN		; Search for line number in DE
   0480 DA 89 04      [10]  785 	JP	C,LINFND	; Jump if line found
   0483 F1            [10]  786 	POP	AF		; Get status
   0484 F5            [11]  787 	PUSH	AF		; And re-save
   0485 CA AF 09      [10]  788 	JP	Z,ULERR	; Nothing after number - Error
   0488 B7            [ 4]  789 	OR	A		; Clear Carry
   0489 C5            [11]  790 LINFND: PUSH	BC		; Save address of line in prog
   048A D2 A0 04      [10]  791 	JP	NC,INEWLN	; Line not found - Insert new
   048D EB            [ 4]  792 	EX	DE,HL		; Next line address in DE
   048E 2A 1B 81      [16]  793 	LD	HL,(PROGND)	; End of program
   0491 1A            [ 7]  794 SFTPRG: LD	A,(DE)		; Shift rest of program down
   0492 02            [ 7]  795 	LD	(BC),A
   0493 03            [ 6]  796 	INC	BC		; Next destination
   0494 13            [ 6]  797 	INC	DE		; Next source
   0495 CD BA 06      [17]  798 	CALL	CPDEHL		; All done?
   0498 C2 91 04      [10]  799 	JP	NZ,SFTPRG	; More to do
   049B 60            [ 4]  800 	LD	H,B		; HL - New end of program
   049C 69            [ 4]  801 	LD	L,C
   049D 22 1B 81      [16]  802 	LD	(PROGND),HL	; Update end of program
                            803 ;
   04A0 D1            [10]  804 INEWLN: POP	DE		; Get address of line,
   04A1 F1            [10]  805 	POP	AF		; Get status
   04A2 CA C7 04      [10]  806 	JP	Z,SETPTR	; No text - Set up pointers
   04A5 2A 1B 81      [16]  807 	LD	HL,(PROGND)	; Get end of program
   04A8 E3            [19]  808 	EX	(SP),HL		; Get length of input line
   04A9 C1            [10]  809 	POP	BC		; End of program to BC
   04AA 09            [11]  810 	ADD	HL,BC		; Find new end
   04AB E5            [11]  811 	PUSH	HL		; Save new end
   04AC CD C4 03      [17]  812 	CALL	MOVUP		; Make space for line
   04AF E1            [10]  813 	POP	HL		; Restore new end
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 16
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   04B0 22 1B 81      [16]  814 	LD	(PROGND),HL	; Update end of program pointer
   04B3 EB            [ 4]  815 	EX	DE,HL		; Get line to move up in HL
   04B4 74            [ 7]  816 	LD	(HL),H		; Save MSB
   04B5 D1            [10]  817 	POP	DE		; Get new line number
   04B6 23            [ 6]  818 	INC	HL		; Skip pointer
   04B7 23            [ 6]  819 	INC	HL
   04B8 73            [ 7]  820 	LD	(HL),E		; Save LSB of line number
   04B9 23            [ 6]  821 	INC	HL
   04BA 72            [ 7]  822 	LD	(HL),D		; Save MSB of line number
   04BB 23            [ 6]  823 	INC	HL		; To first byte in line
   04BC 11 A6 80      [10]  824 	LD	DE,BUFFER	; Copy buffer to program
   04BF 1A            [ 7]  825 MOVBUF: LD	A,(DE)		; Get source
   04C0 77            [ 7]  826 	LD	(HL),A		; Save destinations
   04C1 23            [ 6]  827 	INC	HL		; Next source
   04C2 13            [ 6]  828 	INC	DE		; Next destination
   04C3 B7            [ 4]  829 	OR	A		; Done?
   04C4 C2 BF 04      [10]  830 	JP	NZ,MOVBUF	; No - Repeat
   04C7 CD 10 05      [17]  831 SETPTR: CALL	RUNFST		; Set line pointers
   04CA 23            [ 6]  832 	INC	HL		; To LSB of pointer
   04CB EB            [ 4]  833 	EX	DE,HL		; Address to DE
   04CC 62            [ 4]  834 PTRLP:	LD	H,D		; Address to HL
   04CD 6B            [ 4]  835 	LD	L,E
   04CE 7E            [ 7]  836 	LD	A,(HL)		; Get LSB of pointer
   04CF 23            [ 6]  837 	INC	HL		; To MSB of pointer
   04D0 B6            [ 7]  838 	OR	(HL)		; Compare with MSB pointer
   04D1 CA 50 04      [10]  839 	JP	Z,GETCMD	; Get command line if end
   04D4 23            [ 6]  840 	INC	HL		; To LSB of line number
   04D5 23            [ 6]  841 	INC	HL		; Skip line number
   04D6 23            [ 6]  842 	INC	HL		; Point to first byte in line
   04D7 AF            [ 4]  843 	XOR	A		; Looking for 00 byte
   04D8 BE            [ 7]  844 FNDEND: CP	(HL)		; Found end of line?
   04D9 23            [ 6]  845 	INC	HL		; Move to next byte
   04DA C2 D8 04      [10]  846 	JP	NZ,FNDEND	; No - Keep looking
   04DD EB            [ 4]  847 	EX	DE,HL		; Next line address to HL
   04DE 73            [ 7]  848 	LD	(HL),E		; Save LSB of pointer
   04DF 23            [ 6]  849 	INC	HL
   04E0 72            [ 7]  850 	LD	(HL),D		; Save MSB of pointer
   04E1 C3 CC 04      [10]  851 	JP	PTRLP		; Do next line
                            852 ;
   04E4 2A A3 80      [16]  853 SRCHLN: LD	HL,(BASTXT)	; Start of program text
   04E7 44            [ 4]  854 SRCHLP: LD	B,H		; BC = Address to look at
   04E8 4D            [ 4]  855 	LD	C,L
   04E9 7E            [ 7]  856 	LD	A,(HL)		; Get address of next line
   04EA 23            [ 6]  857 	INC	HL
   04EB B6            [ 7]  858 	OR	(HL)		; End of program found?
   04EC 2B            [ 6]  859 	DEC	HL
   04ED C8            [11]  860 	RET	Z		; Yes - Line not found
   04EE 23            [ 6]  861 	INC	HL
   04EF 23            [ 6]  862 	INC	HL
   04F0 7E            [ 7]  863 	LD	A,(HL)		; Get LSB of line number
   04F1 23            [ 6]  864 	INC	HL
   04F2 66            [ 7]  865 	LD	H,(HL)		; Get MSB of line number
   04F3 6F            [ 4]  866 	LD	L,A
   04F4 CD BA 06      [17]  867 	CALL	CPDEHL		; Compare with line in DE
   04F7 60            [ 4]  868 	LD	H,B		; HL = Start of this line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 17
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   04F8 69            [ 4]  869 	LD	L,C
   04F9 7E            [ 7]  870 	LD	A,(HL)		; Get LSB of next line address
   04FA 23            [ 6]  871 	INC	HL
   04FB 66            [ 7]  872 	LD	H,(HL)		; Get MSB of next line address
   04FC 6F            [ 4]  873 	LD	L,A		; Next line to HL
   04FD 3F            [ 4]  874 	CCF
   04FE C8            [11]  875 	RET	Z		; Lines found - Exit
   04FF 3F            [ 4]  876 	CCF
   0500 D0            [11]  877 	RET	NC		; Line not found,at line after
   0501 C3 E7 04      [10]  878 	JP	SRCHLP		; Keep looking
                            879 ;
   0504 C0            [11]  880 NEW:	RET	NZ		; Return if any more on line
   0505 2A A3 80      [16]  881 CLRPTR: LD	HL,(BASTXT)	; Point to start of program
   0508 AF            [ 4]  882 	XOR	A		; Set program area to empty
   0509 77            [ 7]  883 	LD	(HL),A		; Save LSB = 00
   050A 23            [ 6]  884 	INC	HL
   050B 77            [ 7]  885 	LD	(HL),A		; Save MSB = 00
   050C 23            [ 6]  886 	INC	HL
   050D 22 1B 81      [16]  887 	LD	(PROGND),HL	; Set program end
                            888 ;
   0510 2A A3 80      [16]  889 RUNFST: LD	HL,(BASTXT)	; Clear all variables
   0513 2B            [ 6]  890 	DEC	HL
                            891 ;
   0514 22 13 81      [16]  892 INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
   0517 2A F4 80      [16]  893 	LD	HL,(LSTRAM)	; Get end of RAM
   051A 22 08 81      [16]  894 	LD	(STRBOT),HL	; Clear string space
   051D AF            [ 4]  895 	XOR	A
   051E CD 56 08      [17]  896 	CALL	RESTOR		; Reset DATA pointers
   0521 2A 1B 81      [16]  897 	LD	HL,(PROGND)	; Get end of program
   0524 22 1D 81      [16]  898 	LD	(VAREND),HL	; Clear variables
   0527 22 1F 81      [16]  899 	LD	(ARREND),HL	; Clear arrays
                            900 ;
   052A C1            [10]  901 CLREG:	POP	BC		; Save return address
   052B 2A 9F 80      [16]  902 	LD	HL,(STRSPC)	; Get end of working RAN
   052E F9            [ 6]  903 	LD	SP,HL		; Set stack
   052F 21 F8 80      [10]  904 	LD	HL,TMSTPL	; Temporary string pool
   0532 22 F6 80      [16]  905 	LD	(TMSTPT),HL	; Reset temporary string ptr
   0535 AF            [ 4]  906 	XOR	A		; A = 00
   0536 6F            [ 4]  907 	LD	L,A		; HL = 0000
   0537 67            [ 4]  908 	LD	H,A
   0538 22 19 81      [16]  909 	LD	(CONTAD),HL	; No CONTinue
   053B 32 10 81      [13]  910 	LD	(FORFLG),A	; Clear FOR flag
   053E 22 23 81      [16]  911 	LD	(FNRGNM),HL	; Clear FN argument
   0541 E5            [11]  912 	PUSH	HL		; HL = 0000
   0542 C5            [11]  913 	PUSH	BC		; Put back return
   0543 2A 13 81      [16]  914 DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
   0546 C9            [10]  915 	RET			; Return to execution driver
                            916 ;
   0547 3E 3F         [ 7]  917 PROMPT: LD	A,'?		; '?
   0549 CD CB 06      [17]  918 	CALL	OUTC		; Output character
   054C 3E 20         [ 7]  919 	LD	A,' 		; Space
   054E CD CB 06      [17]  920 	CALL	OUTC		; Output character
   0551 C3 93 80      [10]  921 	JP	RINPUT		; Get input line
                            922 ;
   0554 AF            [ 4]  923 CRUN0xC: XOR	A		; Tokenise line @ HL to BUFFER
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 18
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0555 32 F3 80      [13]  924 	LD	(DATFLG),A	; Reset literal flag
   0558 0E 05         [ 7]  925 	LD	C,2+3		; 2 byte number and 3 nulls
   055A 11 A6 80      [10]  926 	LD	DE,BUFFER	; Start of input buffer
   055D 7E            [ 7]  927 CRNCLP: LD	A,(HL)		; Get byte
   055E FE 20         [ 7]  928 	CP	' 		; Is it a space?
   0560 CA D6 05      [10]  929 	JP	Z,MOVDIR	; Yes - Copy direct
   0563 47            [ 4]  930 	LD	B,A		; Save character
   0564 FE 22         [ 7]  931 	CP	'"		; Is it a quote?
   0566 CA F6 05      [10]  932 	JP	Z,CPYLIT	; Yes - Copy literal string
   0569 B7            [ 4]  933 	OR	A		; Is it end of buffer?
   056A CA FD 05      [10]  934 	JP	Z,ENDBUF	; Yes - End buffer
   056D 3A F3 80      [13]  935 	LD	A,(DATFLG)	; Get data type
   0570 B7            [ 4]  936 	OR	A		; Literal?
   0571 7E            [ 7]  937 	LD	A,(HL)		; Get byte to copy
   0572 C2 D6 05      [10]  938 	JP	NZ,MOVDIR	; Literal - Copy direct
   0575 FE 3F         [ 7]  939 	CP	'?		; Is it '? short for PRINT
   0577 3E 9E         [ 7]  940 	LD	A,ZPRINT	; "PRINT" token
   0579 CA D6 05      [10]  941 	JP	Z,MOVDIR	; Yes - replace it
   057C 7E            [ 7]  942 	LD	A,(HL)		; Get byte again
   057D FE 30         [ 7]  943 	CP	'0		; Is it less than '0
   057F DA 87 05      [10]  944 	JP	C,FNDWRD	; Yes - Look for reserved words
   0582 FE 3C         [ 7]  945 	CP	60		; ";"+1; Is it "0123456789:;" ?
   0584 DA D6 05      [10]  946 	JP	C,MOVDIR	; Yes - copy it direct
   0587 D5            [11]  947 FNDWRD: PUSH	DE		; Look for reserved words
   0588 11 80 01      [10]  948 	LD	DE,WORDS-1	; Point to table
   058B C5            [11]  949 	PUSH	BC		; Save count
   058C 01 D2 05      [10]  950 	LD	BC,RETNAD	; Where to return to
   058F C5            [11]  951 	PUSH	BC		; Save return address
   0590 06 7F         [ 7]  952 	LD	B,ZEND-1	; First token value -1
   0592 7E            [ 7]  953 	LD	A,(HL)		; Get byte
   0593 FE 61         [ 7]  954 	CP	'a		; Less than 'a ?
   0595 DA 9E 05      [10]  955 	JP	C,SEAR0xC	; Yes - search for words
   0598 FE 7B         [ 7]  956 	CP	'z+1		; Greater than 'z ?
   059A D2 9E 05      [10]  957 	JP	NC,SEAR0xC	; Yes - search for words
kq 059D                     958 	AND	01011111B	; Force upper case
   059D 77            [ 7]  959 	LD	(HL),A		; Replace byte
   059E 4E            [ 7]  960 SEAR0xC: LD	C,(HL)		; Search for a word
   059F EB            [ 4]  961 	EX	DE,HL
   05A0 23            [ 6]  962 GETNXT: INC	HL		; Get next reserved word
   05A1 B6            [ 7]  963 	OR	(HL)		; Start of word?
   05A2 F2 A0 05      [10]  964 	JP	P,GETNXT	; No - move on
   05A5 04            [ 4]  965 	INC	B		; Increment token value
   05A6 7E            [ 7]  966 	LD	A, (HL)		; Get byte from table
kq 05A7                     967 	AND	01111111B	; Strip bit 7
   05A7 C8            [11]  968 	RET	Z		; Return if end of list
   05A8 B9            [ 4]  969 	CP	C		; Same character as in buffer?
   05A9 C2 A0 05      [10]  970 	JP	NZ,GETNXT	; No - get next word
   05AC EB            [ 4]  971 	EX	DE,HL
   05AD E5            [11]  972 	PUSH	HL		; Save start of word
                            973 ;
   05AE 13            [ 6]  974 NXTBYT: INC	DE		; Look through rest of word
   05AF 1A            [ 7]  975 	LD	A,(DE)		; Get byte from table
   05B0 B7            [ 4]  976 	OR	A		; End of word ?
   05B1 FA CE 05      [10]  977 	JP	M,MAT0xC		; Yes - Match found
   05B4 4F            [ 4]  978 	LD	C,A		; Save it
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 19
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   05B5 78            [ 4]  979 	LD	A,B		; Get token value
   05B6 FE 88         [ 7]  980 	CP	ZGOTO		; Is it "GOTO" token ?
   05B8 C2 BF 05      [10]  981 	JP	NZ,NOSPC	; No - Don't allow spaces
   05BB CD 46 08      [17]  982 	CALL	GETCHR		; Get next character
   05BE 2B            [ 6]  983 	DEC	HL		; Cancel increment from GETCHR
   05BF 23            [ 6]  984 NOSPC:	INC	HL		; Next byte
   05C0 7E            [ 7]  985 	LD	A,(HL)		; Get byte
   05C1 FE 61         [ 7]  986 	CP	'a		; Less than 'a ?
   05C3 DA C6 05      [10]  987 	JP	C,NOCHNG	; Yes - don't change
kq 05C6                     988 	AND	01011111B	; Make upper case
   05C6 B9            [ 4]  989 NOCHNG: CP	C		; Same as in buffer ?
   05C7 CA AE 05      [10]  990 	JP	Z,NXTBYT	; Yes - keep testing
   05CA E1            [10]  991 	POP	HL		; Get back start of word
   05CB C3 9E 05      [10]  992 	JP	SEAR0xC		; Look at next word
                            993 ;
   05CE 48            [ 4]  994 MAT0xC:	LD	C,B		; Word found - Save token value
   05CF F1            [10]  995 	POP	AF		; Throw away return
   05D0 EB            [ 4]  996 	EX	DE,HL
   05D1 C9            [10]  997 	RET			; Return to "RETNAD"
   05D2 EB            [ 4]  998 RETNAD: EX	DE,HL		; Get address in string
   05D3 79            [ 4]  999 	LD	A,C		; Get token value
   05D4 C1            [10] 1000 	POP	BC		; Restore buffer length
   05D5 D1            [10] 1001 	POP	DE		; Get destination address
   05D6 23            [ 6] 1002 MOVDIR: INC	HL		; Next source in buffer
   05D7 12            [ 7] 1003 	LD	(DE),A		; Put byte in buffer
   05D8 13            [ 6] 1004 	INC	DE		; Move up buffer
   05D9 0C            [ 4] 1005 	INC	C		; Increment length of buffer
   05DA D6 3A         [ 7] 1006 	SUB	':		; End of statement?
   05DC CA E4 05      [10] 1007 	JP	Z,SETLIT	; Jump if multi-statement line
   05DF FE 49         [ 7] 1008 	CP	ZDATA-0x3A	; Is it DATA statement ?
   05E1 C2 E7 05      [10] 1009 	JP	NZ,TSTREM	; No - see if REM
   05E4 32 F3 80      [13] 1010 SETLIT: LD	(DATFLG),A	; Set literal flag
   05E7 D6 54         [ 7] 1011 TSTREM: SUB	ZREM-0x3A	; Is it REM?
   05E9 C2 5D 05      [10] 1012 	JP	NZ,CRNCLP	; No - Leave flag
   05EC 47            [ 4] 1013 	LD	B,A		; Copy rest of buffer
   05ED 7E            [ 7] 1014 NXTCHR: LD	A,(HL)		; Get byte
   05EE B7            [ 4] 1015 	OR	A		; End of line ?
   05EF CA FD 05      [10] 1016 	JP	Z,ENDBUF	; Yes - Terminate buffer
   05F2 B8            [ 4] 1017 	CP	B		; End of statement ?
   05F3 CA D6 05      [10] 1018 	JP	Z,MOVDIR	; Yes - Get next one
   05F6 23            [ 6] 1019 CPYLIT: INC	HL		; Move up source string
   05F7 12            [ 7] 1020 	LD	(DE),A		; Save in destination
   05F8 0C            [ 4] 1021 	INC	C		; Increment length
   05F9 13            [ 6] 1022 	INC	DE		; Move up destination
   05FA C3 ED 05      [10] 1023 	JP	NXTCHR		; Repeat
                           1024 ;
   05FD 21 A5 80      [10] 1025 ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
   0600 12            [ 7] 1026 	LD	(DE),A		; Mark end of buffer (A = 00)
   0601 13            [ 6] 1027 	INC	DE
   0602 12            [ 7] 1028 	LD	(DE),A		; A = 00
   0603 13            [ 6] 1029 	INC	DE
   0604 12            [ 7] 1030 	LD	(DE),A		; A = 00
   0605 C9            [10] 1031 	RET
                           1032 ;
   0606 3A 89 80      [13] 1033 DODEL:	LD	A,(NULFLG)	; Get null flag status
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 20
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0609 B7            [ 4] 1034 	OR	A		; Is it zero?
   060A 3E 00         [ 7] 1035 	LD	A,0		; Zero A - Leave flags
   060C 32 89 80      [13] 1036 	LD	(NULFLG),A	; Zero null flag
   060F C2 1A 06      [10] 1037 	JP	NZ,ECHDEL	; Set - Echo it
   0612 05            [ 4] 1038 	DEC	B		; Decrement length
   0613 CA 37 06      [10] 1039 	JP	Z,GETLIN	; Get line again if empty
   0616 CD CB 06      [17] 1040 	CALL	OUTC		; Output null character
   0619 3E                 1041 	.db	0x3E		; Skip "DEC B"
   061A 05            [ 4] 1042 ECHDEL: DEC	B		; Count bytes in buffer
   061B 2B            [ 6] 1043 	DEC	HL		; Back space buffer
   061C CA 2E 06      [10] 1044 	JP	Z,OTKLN		; No buffer - Try again
   061F 7E            [ 7] 1045 	LD	A,(HL)		; Get deleted byte
   0620 CD CB 06      [17] 1046 	CALL	OUTC		; Echo it
   0623 C3 40 06      [10] 1047 	JP	MORINP		; Get more input
                           1048 ;
   0626 05            [ 4] 1049 DELCHR: DEC	B		; Count bytes in buffer
   0627 2B            [ 6] 1050 	DEC	HL		; Back space buffer
   0628 CD CB 06      [17] 1051 	CALL	OUTC		; Output character in A
   062B C2 40 06      [10] 1052 	JP	NZ,MORINP	; Not end - Get more
   062E CD CB 06      [17] 1053 OTKLN:	CALL	OUTC		; Output character in A
   0631 CD EA 0A      [17] 1054 KILIN:	CALL	PRCRLF		; Output CRLF
   0634 C3 37 06      [10] 1055 	JP	TTYLIN		; Get line again
                           1056 ;
   0637                    1057 GETLIN:
   0637 21 A6 80      [10] 1058 TTYLIN: LD	HL,BUFFER	; Get a line by character
   063A 06 01         [ 7] 1059 	LD	B,1		; Set buffer as empty
   063C AF            [ 4] 1060 	XOR	A
   063D 32 89 80      [13] 1061 	LD	(NULFLG),A	; Clear null flag
   0640 CD F5 06      [17] 1062 MORINP: CALL	CLOTST		; Get character and test ^O
   0643 4F            [ 4] 1063 	LD	C,A		; Save character in C
   0644 FE 7F         [ 7] 1064 	CP	DEL		; Delete character?
   0646 CA 06 06      [10] 1065 	JP	Z,DODEL	; Yes - Process it
   0649 3A 89 80      [13] 1066 	LD	A,(NULFLG)	; Get null flag
   064C B7            [ 4] 1067 	OR	A		; Test null flag status
   064D CA 59 06      [10] 1068 	JP	Z,PROCES	; Reset - Process character
   0650 3E 00         [ 7] 1069 	LD	A,0		; Set a null
   0652 CD CB 06      [17] 1070 	CALL	OUTC		; Output null
   0655 AF            [ 4] 1071 	XOR	A		; Clear A
   0656 32 89 80      [13] 1072 	LD	(NULFLG),A	; Reset null flag
   0659 79            [ 4] 1073 PROCES: LD	A,C		; Get character
   065A FE 07         [ 7] 1074 	CP	CTRLG		; Bell?
   065C CA 9D 06      [10] 1075 	JP	Z,PUTCTL	; Yes - Save it
   065F FE 03         [ 7] 1076 	CP	CTRLC		; Is it control "C"?
   0661 CC EA 0A      [17] 1077 	CALL	Z,PRCRLF	; Yes - Output CRLF
   0664 37            [ 4] 1078 	SCF			; Flag break
   0665 C8            [11] 1079 	RET	Z		; Return if control "C"
   0666 FE 0D         [ 7] 1080 	CP	CR		; Is it enter?
   0668 CA E5 0A      [10] 1081 	JP	Z,ENDINP	; Yes - Terminate input
   066B FE 15         [ 7] 1082 	CP	CTRLU		; Is it control "U"?
   066D CA 31 06      [10] 1083 	JP	Z,KILIN		; Yes - Get another line
   0670 FE 40         [ 7] 1084 	CP	'@		; Is it "kill line"?
   0672 CA 2E 06      [10] 1085 	JP	Z,OTKLN		; Yes - Kill line
   0675 FE 5F         [ 7] 1086 	CP	'_		; Is it delete?
   0677 CA 26 06      [10] 1087 	JP	Z,DELCHR	; Yes - Delete character
   067A FE 08         [ 7] 1088 	CP	BKSP		; Is it backspace?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 21
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   067C CA 26 06      [10] 1089 	JP	Z,DELCHR	; Yes - Delete character
   067F FE 12         [ 7] 1090 	CP	CTRLR		; Is it control "R"?
   0681 C2 98 06      [10] 1091 	JP	NZ,PUTBUF	; No - Put in buffer
   0684 C5            [11] 1092 	PUSH	BC		; Save buffer length
   0685 D5            [11] 1093 	PUSH	DE		; Save DE
   0686 E5            [11] 1094 	PUSH	HL		; Save buffer address
   0687 36 00         [10] 1095 	LD	(HL),0		; Mark end of buffer
   0689 CD 7C 1C      [17] 1096 	CALL	OUTNCR		; Output and do CRLF
   068C 21 A6 80      [10] 1097 	LD	HL,BUFFER	; Point to buffer start
   068F CD 88 11      [17] 1098 	CALL	PRS		; Output buffer
   0692 E1            [10] 1099 	POP	HL		; Restore buffer address
   0693 D1            [10] 1100 	POP	DE		; Restore DE
   0694 C1            [10] 1101 	POP	BC		; Restore buffer length
   0695 C3 40 06      [10] 1102 	JP	MORINP		; Get another character
                           1103 ;
   0698 FE 20         [ 7] 1104 PUTBUF: CP	' 		; Is it a control code?
   069A DA 40 06      [10] 1105 	JP	C,MORINP	; Yes - Ignore
   069D 78            [ 4] 1106 PUTCTL: LD	A,B		; Get number of bytes in buffer
   069E FE 49         [ 7] 1107 	CP	72+1		; Test for line overflow
   06A0 3E 07         [ 7] 1108 	LD	A,CTRLG		; Set a bell
   06A2 D2 B2 06      [10] 1109 	JP	NC,OUTNBS	; Ring bell if buffer full
   06A5 79            [ 4] 1110 	LD	A,C		; Get character
   06A6 71            [ 7] 1111 	LD	(HL),C		; Save in buffer
   06A7 32 11 81      [13] 1112 	LD	(LSTBIN),A	; Save last input byte
   06AA 23            [ 6] 1113 	INC	HL		; Move up buffer
   06AB 04            [ 4] 1114 	INC	B		; Increment length
   06AC CD CB 06      [17] 1115 OUTIT:	CALL	OUTC		; Output the character entered
   06AF C3 40 06      [10] 1116 	JP	MORINP		; Get another character
                           1117 ;
   06B2 CD CB 06      [17] 1118 OUTNBS: CALL	OUTC		; Output bell and back over it
   06B5 3E 08         [ 7] 1119 	LD	A,BKSP		; Set back space
   06B7 C3 AC 06      [10] 1120 	JP	OUTIT		; Output it and get more
                           1121 ;
   06BA 7C            [ 4] 1122 CPDEHL: LD	A,H		; Get H
   06BB 92            [ 4] 1123 	SUB	D		; Compare with D
   06BC C0            [11] 1124 	RET	NZ		; Different - Exit
   06BD 7D            [ 4] 1125 	LD	A,L		; Get L
   06BE 93            [ 4] 1126 	SUB	E		; Compare with E
   06BF C9            [10] 1127 	RET			; Return status
                           1128 ;
   06C0 7E            [ 7] 1129 CHKSYN: LD	A,(HL)		; Check syntax of character
   06C1 E3            [19] 1130 	EX	(SP),HL		; Address of test byte
   06C2 BE            [ 7] 1131 	CP	(HL)		; Same as in code string?
   06C3 23            [ 6] 1132 	INC	HL		; Return address
   06C4 E3            [19] 1133 	EX	(SP),HL		; Put it back
   06C5 CA 46 08      [10] 1134 	JP	Z,GETCHR	; Yes - Get next character
   06C8 C3 F8 03      [10] 1135 	JP	SNERR		; Different - ?SN Error
                           1136 ;
   06CB F5            [11] 1137 OUTC:	PUSH	AF		; Save character
   06CC 3A 8A 80      [13] 1138 	LD	A,(CTLOFG)	; Get control "O" flag
   06CF B7            [ 4] 1139 	OR	A		; Is it set?
   06D0 C2 BD 11      [10] 1140 	JP	NZ,POPAF	; Yes - don't output
   06D3 F1            [10] 1141 	POP	AF		; Restore character
   06D4 C5            [11] 1142 	PUSH	BC		; Save buffer length
   06D5 F5            [11] 1143 	PUSH	AF		; Save character
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 22
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   06D6 FE 20         [ 7] 1144 	CP	' 		; Is it a control code?
   06D8 DA EF 06      [10] 1145 	JP	C,DINPOS	; Yes - Don't INC POS(X)
   06DB 3A 87 80      [13] 1146 	LD	A,(LWIDTH)	; Get line width
   06DE 47            [ 4] 1147 	LD	B,A		; To B
   06DF 3A F0 80      [13] 1148 	LD	A,(CURPOS)	; Get cursor position
   06E2 04            [ 4] 1149 	INC	B		; Width 255?
   06E3 CA EB 06      [10] 1150 	JP	Z,INCLEN	; Yes - No width limit
   06E6 05            [ 4] 1151 	DEC	B		; Restore width
   06E7 B8            [ 4] 1152 	CP	B		; At end of line?
   06E8 CC EA 0A      [17] 1153 	CALL	Z,PRCRLF	; Yes - output CRLF
   06EB 3C            [ 4] 1154 INCLEN: INC	A		; Move on one character
   06EC 32 F0 80      [13] 1155 	LD	(CURPOS),A	; Save new position
   06EF F1            [10] 1156 DINPOS: POP	AF		; Restore character
   06F0 C1            [10] 1157 	POP	BC		; Restore buffer length
   06F1 CD 67 1C      [17] 1158 	CALL	MONOUT		; Send it
   06F4 C9            [10] 1159 	RET
                           1160 ;
   06F5 CD 3D 1B      [17] 1161 CLOTST: CALL	GETINP		; Get input character
kq 06F8                    1162 	AND	01111111B	; Strip bit 7
   06F8 FE 0F         [ 7] 1163 	CP	CTRLO		; Is it control "O"?
   06FA C0            [11] 1164 	RET	NZ		; No don't flip flag
   06FB 3A 8A 80      [13] 1165 	LD	A,(CTLOFG)	; Get flag
   06FE 2F            [ 4] 1166 	CPL			; Flip it
   06FF 32 8A 80      [13] 1167 	LD	(CTLOFG),A	; Put it back
   0702 AF            [ 4] 1168 	XOR	A		; Null character
   0703 C9            [10] 1169 	RET
                           1170 ;
   0704 CD 0E 09      [17] 1171 LIST:	CALL	ATOH		; ASCII number to DE
   0707 C0            [11] 1172 	RET	NZ		; Return if anything extra
   0708 C1            [10] 1173 	POP	BC		; Rubbish - Not needed
   0709 CD E4 04      [17] 1174 	CALL	SRCHLN		; Search for line number in DE
   070C C5            [11] 1175 	PUSH	BC		; Save address of line
   070D CD 58 07      [17] 1176 	CALL	SETLIN		; Set up lines counter
   0710 E1            [10] 1177 LISTLP: POP	HL		; Restore address of line
   0711 4E            [ 7] 1178 	LD	C,(HL)		; Get LSB of next line
   0712 23            [ 6] 1179 	INC	HL
   0713 46            [ 7] 1180 	LD	B,(HL)		; Get MSB of next line
   0714 23            [ 6] 1181 	INC	HL
   0715 78            [ 4] 1182 	LD	A,B		; BC = 0 (End of program)?
   0716 B1            [ 4] 1183 	OR	C
   0717 CA 43 04      [10] 1184 	JP	Z,PRNTOK	; Yes - Go to command mode
   071A CD 61 07      [17] 1185 	CALL	COUNT		; Count lines
   071D CD 71 08      [17] 1186 	CALL	TSTBRK		; Test for break key
   0720 C5            [11] 1187 	PUSH	BC		; Save address of next line
   0721 CD EA 0A      [17] 1188 	CALL	PRCRLF		; Output CRLF
   0724 5E            [ 7] 1189 	LD	E,(HL)		; Get LSB of line number
   0725 23            [ 6] 1190 	INC	HL
   0726 56            [ 7] 1191 	LD	D,(HL)		; Get MSB of line number
   0727 23            [ 6] 1192 	INC	HL
   0728 E5            [11] 1193 	PUSH	HL		; Save address of line start
   0729 EB            [ 4] 1194 	EX	DE,HL		; Line number to HL
   072A CD 29 18      [17] 1195 	CALL	PRNTHL		; Output line number in decimal
   072D 3E 20         [ 7] 1196 	LD	A,' 		; Space after line number
   072F E1            [10] 1197 	POP	HL		; Restore start of line address
   0730 CD CB 06      [17] 1198 LSTLP2: CALL	OUTC		; Output character in A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 23
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0733 7E            [ 7] 1199 LSTLP3: LD	A,(HL)		; Get next byte in line
   0734 B7            [ 4] 1200 	OR	A		; End of line?
   0735 23            [ 6] 1201 	INC	HL		; To next byte in line
   0736 CA 10 07      [10] 1202 	JP	Z,LISTLP	; Yes - get next line
   0739 F2 30 07      [10] 1203 	JP	P,LSTLP2	; No token - output it
   073C D6 7F         [ 7] 1204 	SUB	ZEND-1		; Find and output word
   073E 4F            [ 4] 1205 	LD	C,A		; Token offset+1 to C
   073F 11 81 01      [10] 1206 	LD	DE,WORDS	; Reserved word list
   0742 1A            [ 7] 1207 FNDTOK: LD	A,(DE)		; Get character in list
   0743 13            [ 6] 1208 	INC	DE		; Move on to next
   0744 B7            [ 4] 1209 	OR	A		; Is it start of word?
   0745 F2 42 07      [10] 1210 	JP	P,FNDTOK	; No - Keep looking for word
   0748 0D            [ 4] 1211 	DEC	C		; Count words
   0749 C2 42 07      [10] 1212 	JP	NZ,FNDTOK	; Not there - keep looking
kq 074C                    1213 OUTWRD: AND	01111111B	; Strip bit 7
   074C CD CB 06      [17] 1214 	CALL	OUTC		; Output first character
   074F 1A            [ 7] 1215 	LD	A,(DE)		; Get next character
   0750 13            [ 6] 1216 	INC	DE		; Move on to next
   0751 B7            [ 4] 1217 	OR	A		; Is it end of word?
   0752 F2 4C 07      [10] 1218 	JP	P,OUTWRD	; No - output the rest
   0755 C3 33 07      [10] 1219 	JP	LSTLP3		; Next byte in line
                           1220 ;
   0758 E5            [11] 1221 SETLIN: PUSH	HL		; Set up LINES counter
   0759 2A 8D 80      [16] 1222 	LD	HL,(LINESN)	; Get LINES number
   075C 22 8B 80      [16] 1223 	LD	(LINESC),HL	; Save in LINES counter
   075F E1            [10] 1224 	POP	HL
   0760 C9            [10] 1225 	RET
                           1226 ;
   0761 E5            [11] 1227 COUNT:	PUSH	HL		; Save code string address
   0762 D5            [11] 1228 	PUSH	DE
   0763 2A 8B 80      [16] 1229 	LD	HL,(LINESC)	; Get LINES counter
   0766 11 FF FF      [10] 1230 	LD	DE,-1
   0769 ED 5A         [15] 1231 	ADC	HL,DE		; Decrement
   076B 22 8B 80      [16] 1232 	LD	(LINESC),HL	; Put it back
   076E D1            [10] 1233 	POP	DE
   076F E1            [10] 1234 	POP	HL		; Restore code string address
   0770 F0            [11] 1235 	RET	P		; Return if more lines to go
   0771 E5            [11] 1236 	PUSH	HL		; Save code string address
   0772 2A 8D 80      [16] 1237 	LD	HL,(LINESN)	; Get LINES number
   0775 22 8B 80      [16] 1238 	LD	(LINESC),HL	; Reset LINES counter
   0778 CD 3D 1B      [17] 1239 	CALL	GETINP		; Get input character
   077B FE 03         [ 7] 1240 	CP	CTRLC		; Is it control "C"?
   077D CA 84 07      [10] 1241 	JP	Z,RSLNBK	; Yes - Reset LINES and break
   0780 E1            [10] 1242 	POP	HL		; Restore code string address
   0781 C3 61 07      [10] 1243 	JP	COUNT		; Keep on counting
                           1244 ;
   0784 2A 8D 80      [16] 1245 RSLNBK: LD	HL,(LINESN)	; Get LINES number
   0787 22 8B 80      [16] 1246 	LD	(LINESC),HL	; Reset LINES counter
   078A C3 C2 00      [10] 1247 	JP	BRKRET		; Go and output "Break"
                           1248 ;
   078D 3E 64         [ 7] 1249 FOR:	LD	A,0x64		; Flag "FOR" assignment
   078F 32 10 81      [13] 1250 	LD	(FORFLG),A	; Save "FOR" flag
   0792 CD F0 09      [17] 1251 	CALL	LET		; Set up initial index
   0795 C1            [10] 1252 	POP	BC		; Drop RETurn address
   0796 E5            [11] 1253 	PUSH	HL		; Save code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 24
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0797 CD D9 09      [17] 1254 	CALL	DATA		; Get next statement address
   079A 22 0C 81      [16] 1255 	LD	(LOOPST),HL	; Save it for start of loop
   079D 21 02 00      [10] 1256 	LD	HL,2		; Offset for "FOR" block
   07A0 39            [11] 1257 	ADD	HL,SP		; Point to it
   07A1 CD A5 03      [17] 1258 FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
   07A4 D1            [10] 1259 	POP	DE		; Get code string address
   07A5 C2 BD 07      [10] 1260 	JP	NZ,FORFND	; No nesting found
   07A8 09            [11] 1261 	ADD	HL,BC		; Move into "FOR" block
   07A9 D5            [11] 1262 	PUSH	DE		; Save code string address
   07AA 2B            [ 6] 1263 	DEC	HL
   07AB 56            [ 7] 1264 	LD	D,(HL)		; Get MSB of loop statement
   07AC 2B            [ 6] 1265 	DEC	HL
   07AD 5E            [ 7] 1266 	LD	E,(HL)		; Get LSB of loop statement
   07AE 23            [ 6] 1267 	INC	HL
   07AF 23            [ 6] 1268 	INC	HL
   07B0 E5            [11] 1269 	PUSH	HL		; Save block address
   07B1 2A 0C 81      [16] 1270 	LD	HL,(LOOPST)	; Get address of loop statement
   07B4 CD BA 06      [17] 1271 	CALL	CPDEHL		; Compare the FOR loops
   07B7 E1            [10] 1272 	POP	HL		; Restore block address
   07B8 C2 A1 07      [10] 1273 	JP	NZ,FORSLP	; Different FORs - Find another
   07BB D1            [10] 1274 	POP	DE		; Restore code string address
   07BC F9            [ 6] 1275 	LD	SP,HL		; Remove all nested loops
                           1276 ;
   07BD EB            [ 4] 1277 FORFND: EX	DE,HL		; Code string address to HL
   07BE 0E 08         [ 7] 1278 	LD	C,8
   07C0 CD D5 03      [17] 1279 	CALL	CHKSTK		; Check for 8 levels of stack
   07C3 E5            [11] 1280 	PUSH	HL		; Save code string address
   07C4 2A 0C 81      [16] 1281 	LD	HL,(LOOPST)	; Get first statement of loop
   07C7 E3            [19] 1282 	EX	(SP),HL		; Save and restore code string
   07C8 E5            [11] 1283 	PUSH	HL		; Re-save code string address
   07C9 2A A1 80      [16] 1284 	LD	HL,(LINEAT)	; Get current line number
   07CC E3            [19] 1285 	EX	(SP),HL		; Save and restore code string
   07CD CD B2 0C      [17] 1286 	CALL	TSTNUM		; Make sure it's a number
   07D0 CD C0 06      [17] 1287 	CALL	CHKSYN		; Make sure "TO" is next
   07D3 A6                 1288 	.db	ZTO		; "TO" token
   07D4 CD AF 0C      [17] 1289 	CALL	GETNUM		; Get "TO" expression value
   07D7 E5            [11] 1290 	PUSH	HL		; Save code string address
   07D8 CD DB 16      [17] 1291 	CALL	BCDEFP		; Move "TO" value to BCDE
   07DB E1            [10] 1292 	POP	HL		; Restore code string address
   07DC C5            [11] 1293 	PUSH	BC		; Save "TO" value in block
   07DD D5            [11] 1294 	PUSH	DE
   07DE 01 00 81      [10] 1295 	LD	BC,0x8100	; BCDE - 1 (default STEP)
   07E1 51            [ 4] 1296 	LD	D,C		; C=0
   07E2 5A            [ 4] 1297 	LD	E,D		; D=0
   07E3 7E            [ 7] 1298 	LD	A,(HL)		; Get next byte in code string
   07E4 FE AB         [ 7] 1299 	CP	ZSTEP		; See if "STEP" is stated
   07E6 3E 01         [ 7] 1300 	LD	A,1		; Sign of step = 1
   07E8 C2 F9 07      [10] 1301 	JP	NZ,SAVSTP	; No STEP given - Default to 1
   07EB CD 46 08      [17] 1302 	CALL	GETCHR		; Jump over "STEP" token
   07EE CD AF 0C      [17] 1303 	CALL	GETNUM		; Get step value
   07F1 E5            [11] 1304 	PUSH	HL		; Save code string address
   07F2 CD DB 16      [17] 1305 	CALL	BCDEFP		; Move STEP to BCDE
   07F5 CD 8F 16      [17] 1306 	CALL	TSTSGN		; Test sign of FPREG
   07F8 E1            [10] 1307 	POP	HL		; Restore code string address
   07F9 C5            [11] 1308 SAVSTP: PUSH	BC		; Save the STEP value in block
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 25
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   07FA D5            [11] 1309 	PUSH	DE
   07FB F5            [11] 1310 	PUSH	AF		; Save sign of STEP
   07FC 33            [ 6] 1311 	INC	SP		; Don't save flags
   07FD E5            [11] 1312 	PUSH	HL		; Save code string address
   07FE 2A 13 81      [16] 1313 	LD	HL,(BRKLIN)	; Get address of index variable
   0801 E3            [19] 1314 	EX	(SP),HL		; Save and restore code string
   0802 06 81         [ 7] 1315 PUTFID: LD	B,ZFOR		; "FOR" block marker
   0804 C5            [11] 1316 	PUSH	BC		; Save it
   0805 33            [ 6] 1317 	INC	SP		; Don't save C
                           1318 ;
   0806 CD 71 08      [17] 1319 RUNCNT: CALL	TSTBRK		; Execution driver - Test break
   0809 22 13 81      [16] 1320 	LD	(BRKLIN),HL	; Save code address for break
   080C 7E            [ 7] 1321 	LD	A,(HL)		; Get next byte in code string
   080D FE 3A         [ 7] 1322 	CP	':		; Multi statement line?
   080F CA 26 08      [10] 1323 	JP	Z,EXCUTE	; Yes - Execute it
   0812 B7            [ 4] 1324 	OR	A		; End of line?
   0813 C2 F8 03      [10] 1325 	JP	NZ,SNERR	; No - Syntax error
   0816 23            [ 6] 1326 	INC	HL		; Point to address of next line
   0817 7E            [ 7] 1327 	LD	A,(HL)		; Get LSB of line pointer
   0818 23            [ 6] 1328 	INC	HL
   0819 B6            [ 7] 1329 	OR	(HL)		; Is it zero (End of prog)?
   081A CA 94 08      [10] 1330 	JP	Z,ENDPRG	; Yes - Terminate execution
   081D 23            [ 6] 1331 	INC	HL		; Point to line number
   081E 5E            [ 7] 1332 	LD	E,(HL)		; Get LSB of line number
   081F 23            [ 6] 1333 	INC	HL
   0820 56            [ 7] 1334 	LD	D,(HL)		; Get MSB of line number
   0821 EB            [ 4] 1335 	EX	DE,HL		; Line number to HL
   0822 22 A1 80      [16] 1336 	LD	(LINEAT),HL	; Save as current line number
   0825 EB            [ 4] 1337 	EX	DE,HL		; Line number back to DE
   0826 CD 46 08      [17] 1338 EXCUTE: CALL	GETCHR		; Get key word
   0829 11 06 08      [10] 1339 	LD	DE,RUNCNT	; Where to RETurn to
   082C D5            [11] 1340 	PUSH	DE		; Save for RETurn
   082D C8            [11] 1341 IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
   082E D6 80         [ 7] 1342 ONJMP:	SUB	ZEND		; Is it a token?
   0830 DA F0 09      [10] 1343 	JP	C,LET		; No - try to assign it
   0833 FE 25         [ 7] 1344 	CP	ZNEW+1-ZEND	; END to NEW ?
   0835 D2 F8 03      [10] 1345 	JP	NC,SNERR	; Not a key word - ?SN Error
   0838 07            [ 4] 1346 	RLCA			; Double it
   0839 4F            [ 4] 1347 	LD	C,A		; BC = Offset into table
   083A 06 00         [ 7] 1348 	LD	B,0
   083C EB            [ 4] 1349 	EX	DE,HL		; Save code string address
   083D 21 A0 02      [10] 1350 	LD	HL,WORDTB	; Keyword address table
   0840 09            [11] 1351 	ADD	HL,BC		; Point to routine address
   0841 4E            [ 7] 1352 	LD	C,(HL)		; Get LSB of routine address
   0842 23            [ 6] 1353 	INC	HL
   0843 46            [ 7] 1354 	LD	B,(HL)		; Get MSB of routine address
   0844 C5            [11] 1355 	PUSH	BC		; Save routine address
   0845 EB            [ 4] 1356 	EX	DE,HL		; Restore code string address
                           1357 ;
   0846 23            [ 6] 1358 GETCHR: INC	HL		; Point to next character
   0847 7E            [ 7] 1359 	LD	A,(HL)		; Get next code string byte
   0848 FE 3A         [ 7] 1360 	CP	':		; Z if ':
   084A D0            [11] 1361 	RET	NC		; NC if > "9"
   084B FE 20         [ 7] 1362 	CP	' 
   084D CA 46 08      [10] 1363 	JP	Z,GETCHR	; Skip over spaces
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 26
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0850 FE 30         [ 7] 1364 	CP	'0
   0852 3F            [ 4] 1365 	CCF			; NC if < '0
   0853 3C            [ 4] 1366 	INC	A		; Test for zero - Leave carry
   0854 3D            [ 4] 1367 	DEC	A		; Z if Null
   0855 C9            [10] 1368 	RET
                           1369 ;
   0856 EB            [ 4] 1370 RESTOR: EX	DE,HL		; Save code string address
   0857 2A A3 80      [16] 1371 	LD	HL,(BASTXT)	; Point to start of program
   085A CA 6B 08      [10] 1372 	JP	Z,RESTNL	; Just RESTORE - reset pointer
   085D EB            [ 4] 1373 	EX	DE,HL		; Restore code string address
   085E CD 0E 09      [17] 1374 	CALL	ATOH		; Get line number to DE
   0861 E5            [11] 1375 	PUSH	HL		; Save code string address
   0862 CD E4 04      [17] 1376 	CALL	SRCHLN		; Search for line number in DE
   0865 60            [ 4] 1377 	LD	H,B		; HL = Address of line
   0866 69            [ 4] 1378 	LD	L,C
   0867 D1            [10] 1379 	POP	DE		; Restore code string address
   0868 D2 AF 09      [10] 1380 	JP	NC,ULERR	; ?UL Error if not found
   086B 2B            [ 6] 1381 RESTNL: DEC	HL		; Byte before DATA statement
   086C 22 21 81      [16] 1382 UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
   086F EB            [ 4] 1383 	EX	DE,HL		; Restore code string address
   0870 C9            [10] 1384 	RET
                           1385 ;
                           1386 
   0871 DF            [11] 1387 TSTBRK: RST	0x18		; Check input status
   0872 C8            [11] 1388 	RET	Z		; No key, go back
   0873 D7            [11] 1389 	RST	0x10		; Get the key into A
   0874 FE 1B         [ 7] 1390 	CP	ESC		; Escape key?
u  0876 28 00         [12] 1391 	JR	Z,BRK		; Yes, break
   0878 FE 03         [ 7] 1392 	CP	CTRLC		; <Ctrl-C>
u  087A 28 00         [12] 1393 	JR	Z,BRK		; Yes, break
   087C FE 13         [ 7] 1394 	CP	CTRLS		; Stop scrolling?
   087E C0            [11] 1395 	RET	NZ		; Other key, ignore
                           1396 ;
                           1397 
   087F D7            [11] 1398 STALL:	RST	0x10		; Wait for key
   0880 FE 11         [ 7] 1399 	CP	CTRLQ		; Resume scrolling?
   0882 C8            [11] 1400 	RET	Z		; Release the chokehold
   0883 FE 03         [ 7] 1401 	CP	CTRLC		; Second break?
   0885 28 05         [12] 1402 	JR	Z,STOP		; Break during hold exits prog
   0887 18 F6         [12] 1403 	JR	STALL		; Loop until <Ctrl-Q> or <brk>
                           1404 ;
o  0889                    1405 BRK	LD	A,0x0FF		; Set BRKFLG
   0889 32 92 80      [13] 1406 	LD	(BRKFLG),A	; Store it
                           1407 ;
                           1408 
   088C C0            [11] 1409 STOP:	RET	NZ		; Exit if anything else
   088D F6                 1410 	.db	0x0F6		; Flag "STOP"
   088E C0            [11] 1411 PEND:	RET	NZ		; Exit if anything else
   088F 22 13 81      [16] 1412 	LD	(BRKLIN),HL	; Save point of break
   0892 21                 1413 	.db	0x21		; Skip "OR 11111111B"
kq 0893                    1414 INPBRK: OR	11111111B	; Flag "Break" wanted
   0893 C1            [10] 1415 	POP	BC		; Return not needed and more
   0894 2A A1 80      [16] 1416 ENDPRG: LD	HL,(LINEAT)	; Get current line number
   0897 F5            [11] 1417 	PUSH	AF		; Save STOP / END status
   0898 7D            [ 4] 1418 	LD	A,L		; Is it direct break?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 27
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0899 A4            [ 4] 1419 	AND	H
   089A 3C            [ 4] 1420 	INC	A		; Line is -1 if direct break
   089B CA A7 08      [10] 1421 	JP	Z,NOLIN		; Yes - No line number
   089E 22 17 81      [16] 1422 	LD	(ERRLIN),HL	; Save line of break
   08A1 2A 13 81      [16] 1423 	LD	HL,(BRKLIN)	; Get point of break
   08A4 22 19 81      [16] 1424 	LD	(CONTAD),HL	; Save point to CONTinue
   08A7 AF            [ 4] 1425 NOLIN:	XOR	A
   08A8 32 8A 80      [13] 1426 	LD	(CTLOFG),A	; Enable output
   08AB CD DD 0A      [17] 1427 	CALL	STTLIN		; Start a new line
   08AE F1            [10] 1428 	POP	AF		; Restore STOP / END status
   08AF 21 9B 03      [10] 1429 	LD	HL,BRKMSG	; "Break" message
   08B2 C2 2C 04      [10] 1430 	JP	NZ,ERRIN	; "in line" wanted?
   08B5 C3 43 04      [10] 1431 	JP	PRNTOK		; Go to command mode
                           1432 ;
   08B8 2A 19 81      [16] 1433 CONT:	LD	HL,(CONTAD)	; Get CONTinue address
   08BB 7C            [ 4] 1434 	LD	A,H		; Is it zero?
   08BC B5            [ 4] 1435 	OR	L
   08BD 1E 20         [ 7] 1436 	LD	E,CN		; ?CN Error
   08BF CA 0C 04      [10] 1437 	JP	Z,ERROR		; Yes - output "?CN Error"
   08C2 EB            [ 4] 1438 	EX	DE,HL		; Save code string address
   08C3 2A 17 81      [16] 1439 	LD	HL,(ERRLIN)	; Get line of last break
   08C6 22 A1 80      [16] 1440 	LD	(LINEAT),HL	; Set up current line number
   08C9 EB            [ 4] 1441 	EX	DE,HL		; Restore code string address
   08CA C9            [10] 1442 	RET			; CONTinue where left off
                           1443 ;
   08CB CD 10 14      [17] 1444 NULL:	CALL	GETINT		; Get integer 0-255
   08CE C0            [11] 1445 	RET	NZ		; Return if bad value
   08CF 32 86 80      [13] 1446 	LD	(NULLS),A	; Set nulls number
   08D2 C9            [10] 1447 	RET
                           1448 ;
                           1449 
   08D3 E5            [11] 1450 ACCSUM: PUSH	HL		; Save address in array
   08D4 2A 8F 80      [16] 1451 	LD	HL,(CHKSUM)	; Get check sum
   08D7 06 00         [ 7] 1452 	LD	B,0		; BC - Value of byte
   08D9 4F            [ 4] 1453 	LD	C,A
   08DA 09            [11] 1454 	ADD	HL,BC		; Add byte to check sum
   08DB 22 8F 80      [16] 1455 	LD	(CHKSUM),HL	; Re-save check sum
   08DE E1            [10] 1456 	POP	HL		; Restore address in array
   08DF C9            [10] 1457 	RET
                           1458 ;
   08E0 7E            [ 7] 1459 CHKLTR: LD	A,(HL)		; Get byte
   08E1 FE 41         [ 7] 1460 	CP	'A		; < 'a ?
   08E3 D8            [11] 1461 	RET	C		; Carry set if not letter
   08E4 FE 5B         [ 7] 1462 	CP	'Z+1		; > 'z ?
   08E6 3F            [ 4] 1463 	CCF
   08E7 C9            [10] 1464 	RET			; Carry set if not letter
                           1465 ;
   08E8 CD 46 08      [17] 1466 FPSINT: CALL	GETCHR		; Get next character
   08EB CD AF 0C      [17] 1467 POSINT: CALL	GETNUM		; Get integer 0 to 32767
   08EE CD 8F 16      [17] 1468 DEPINT: CALL	TSTSGN		; Test sign of FPREG
   08F1 FA 09 09      [10] 1469 	JP	M,FCERR		; Negative - ?FC Error
   08F4 3A 2C 81      [13] 1470 DEINT:	LD	A,(FPEXP)	; Get integer value to DE
   08F7 FE 90         [ 7] 1471 	CP	0x80+16		; Exponent in range (16 bits)?
   08F9 DA 37 17      [10] 1472 	JP	C,FPINT		; Yes - convert it
   08FC 01 80 90      [10] 1473 	LD	BC,0x9080	; BCDE = -32768
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 28
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   08FF 11 00 00      [10] 1474 	LD	DE,0000
   0902 E5            [11] 1475 	PUSH	HL		; Save code string address
   0903 CD 0A 17      [17] 1476 	CALL	CMPNUM		; Compare FPREG with BCDE
   0906 E1            [10] 1477 	POP	HL		; Restore code string address
   0907 51            [ 4] 1478 	LD	D,C		; MSB to D
   0908 C8            [11] 1479 	RET	Z		; Return if in range
   0909 1E 08         [ 7] 1480 FCERR:	LD	E,FC		; ?FC Error
   090B C3 0C 04      [10] 1481 	JP	ERROR		; Output error-
                           1482 ;
   090E 2B            [ 6] 1483 ATOH:	DEC	HL		; ASCII number to DE binary
   090F 11 00 00      [10] 1484 GETLN:	LD	DE,0		; Get number to DE
   0912 CD 46 08      [17] 1485 GTLNLP: CALL	GETCHR		; Get next character
   0915 D0            [11] 1486 	RET	NC		; Exit if not a digit
   0916 E5            [11] 1487 	PUSH	HL		; Save code string address
   0917 F5            [11] 1488 	PUSH	AF		; Save digit
   0918 21 98 19      [10] 1489 	LD	HL,65529/10	; Largest number 65529
   091B CD BA 06      [17] 1490 	CALL	CPDEHL		; Number in range?
   091E DA F8 03      [10] 1491 	JP	C,SNERR		; No - ?SN Error
   0921 62            [ 4] 1492 	LD	H,D		; HL = Number
   0922 6B            [ 4] 1493 	LD	L,E
   0923 19            [11] 1494 	ADD	HL,DE		; Times 2
   0924 29            [11] 1495 	ADD	HL,HL		; Times 4
   0925 19            [11] 1496 	ADD	HL,DE		; Times 5
   0926 29            [11] 1497 	ADD	HL,HL		; Times 10
   0927 F1            [10] 1498 	POP	AF		; Restore digit
   0928 D6 30         [ 7] 1499 	SUB	'0		; Make it 0 to 9
   092A 5F            [ 4] 1500 	LD	E,A		; DE = Value of digit
   092B 16 00         [ 7] 1501 	LD	D,0
   092D 19            [11] 1502 	ADD	HL,DE		; Add to number
   092E EB            [ 4] 1503 	EX	DE,HL		; Number to DE
   092F E1            [10] 1504 	POP	HL		; Restore code string address
   0930 C3 12 09      [10] 1505 	JP	GTLNLP		; Go to next character
                           1506 ;
   0933 CA 14 05      [10] 1507 CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
   0936 CD EB 08      [17] 1508 	CALL	POSINT		; Get integer 0 to 32767 to DE
   0939 2B            [ 6] 1509 	DEC	HL		; Cancel increment
   093A CD 46 08      [17] 1510 	CALL	GETCHR		; Get next character
   093D E5            [11] 1511 	PUSH	HL		; Save code string address
   093E 2A F4 80      [16] 1512 	LD	HL,(LSTRAM)	; Get end of RAM
   0941 CA 56 09      [10] 1513 	JP	Z,STORED	; No value given - Use stored
   0944 E1            [10] 1514 	POP	HL		; Restore code string address
   0945 CD C0 06      [17] 1515 	CALL	CHKSYN		; Check for comma
   0948 2C                 1516 	.db	',
   0949 D5            [11] 1517 	PUSH	DE		; Save number
   094A CD EB 08      [17] 1518 	CALL	POSINT		; Get integer 0 to 32767
   094D 2B            [ 6] 1519 	DEC	HL		; Cancel increment
   094E CD 46 08      [17] 1520 	CALL	GETCHR		; Get next character
   0951 C2 F8 03      [10] 1521 	JP	NZ,SNERR	; ?SN Error if more on line
   0954 E3            [19] 1522 	EX	(SP),HL		; Save code string address
   0955 EB            [ 4] 1523 	EX	DE,HL		; Number to DE
   0956 7D            [ 4] 1524 STORED: LD	A,L		; Get LSB of new RAM top
   0957 93            [ 4] 1525 	SUB	E		; Subtract LSB of string space
   0958 5F            [ 4] 1526 	LD	E,A		; Save LSB
   0959 7C            [ 4] 1527 	LD	A,H		; Get MSB of new RAM top
   095A 9A            [ 4] 1528 	SBC	A,D		; Subtract MSB of string space
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 29
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   095B 57            [ 4] 1529 	LD	D,A		; Save MSB
   095C DA ED 03      [10] 1530 	JP	C,OMERR		; ?OM Error if not enough mem
   095F E5            [11] 1531 	PUSH	HL		; Save RAM top
   0960 2A 1B 81      [16] 1532 	LD	HL,(PROGND)	; Get program end
   0963 01 28 00      [10] 1533 	LD	BC,40		; 40 Bytes minimum working RAM
   0966 09            [11] 1534 	ADD	HL,BC		; Get lowest address
   0967 CD BA 06      [17] 1535 	CALL	CPDEHL		; Enough memory?
   096A D2 ED 03      [10] 1536 	JP	NC,OMERR	; No - ?OM Error
   096D EB            [ 4] 1537 	EX	DE,HL		; RAM top to HL
   096E 22 9F 80      [16] 1538 	LD	(STRSPC),HL	; Set new string space
   0971 E1            [10] 1539 	POP	HL		; End of memory to use
   0972 22 F4 80      [16] 1540 	LD	(LSTRAM),HL	; Set new top of RAM
   0975 E1            [10] 1541 	POP	HL		; Restore code string address
   0976 C3 14 05      [10] 1542 	JP	INTVAR		; Initialise variables
                           1543 ;
   0979 CA 10 05      [10] 1544 RUN:	JP	Z,RUNFST	; RUN from start if just RUN
   097C CD 14 05      [17] 1545 	CALL	INTVAR		; Initialise variables
   097F 01 06 08      [10] 1546 	LD	BC,RUNCNT	; Execution driver loop
   0982 C3 95 09      [10] 1547 	JP	RUNLIN		; RUN from line number
                           1548 ;
   0985 0E 03         [ 7] 1549 GOSUB:	LD	C,3		; 3 Levels of stack needed
   0987 CD D5 03      [17] 1550 	CALL	CHKSTK		; Check for 3 levels of stack
   098A C1            [10] 1551 	POP	BC		; Get return address
   098B E5            [11] 1552 	PUSH	HL		; Save code string for RETURN
   098C E5            [11] 1553 	PUSH	HL		; And for GOSUB routine
   098D 2A A1 80      [16] 1554 	LD	HL,(LINEAT)	; Get current line
   0990 E3            [19] 1555 	EX	(SP),HL		; Into stack - Code string out
   0991 3E 8C         [ 7] 1556 	LD	A,ZGOSUB	; "GOSUB" token
   0993 F5            [11] 1557 	PUSH	AF		; Save token
   0994 33            [ 6] 1558 	INC	SP		; Don't save flags
                           1559 ;
   0995 C5            [11] 1560 RUNLIN: PUSH	BC		; Save return address
   0996 CD 0E 09      [17] 1561 GOTO:	CALL	ATOH		; ASCII number to DE binary
   0999 CD DB 09      [17] 1562 	CALL	REM		; Get end of line
   099C E5            [11] 1563 	PUSH	HL		; Save end of line
   099D 2A A1 80      [16] 1564 	LD	HL,(LINEAT)	; Get current line
   09A0 CD BA 06      [17] 1565 	CALL	CPDEHL		; Line after current?
   09A3 E1            [10] 1566 	POP	HL		; Restore end of line
   09A4 23            [ 6] 1567 	INC	HL		; Start of next line
   09A5 DC E7 04      [17] 1568 	CALL	C,SRCHLP	; Line is after current line
   09A8 D4 E4 04      [17] 1569 	CALL	NC,SRCHLN	; Line is before current line
   09AB 60            [ 4] 1570 	LD	H,B		; Set up code string address
   09AC 69            [ 4] 1571 	LD	L,C
   09AD 2B            [ 6] 1572 	DEC	HL		; Incremented after
   09AE D8            [11] 1573 	RET	C		; Line found
   09AF 1E 0E         [ 7] 1574 ULERR:	LD	E,UL		; ?UL Error
   09B1 C3 0C 04      [10] 1575 	JP	ERROR		; Output error message
                           1576 ;
   09B4 C0            [11] 1577 RETURN: RET	NZ		; Return if not just RETURN
   09B5 16 FF         [ 7] 1578 	LD	D,-1		; Flag "GOSUB" search
   09B7 CD A1 03      [17] 1579 	CALL	BAKSTK		; Look "GOSUB" block
   09BA F9            [ 6] 1580 	LD	SP,HL		; Kill all FORs in subroutine
   09BB FE 8C         [ 7] 1581 	CP	ZGOSUB		; Test for "GOSUB" token
   09BD 1E 04         [ 7] 1582 	LD	E,RG		; ?RG Error
   09BF C2 0C 04      [10] 1583 	JP	NZ,ERROR	; Error if no "GOSUB" found
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 30
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   09C2 E1            [10] 1584 	POP	HL		; Get RETURN line number
   09C3 22 A1 80      [16] 1585 	LD	(LINEAT),HL	; Save as current
   09C6 23            [ 6] 1586 	INC	HL		; Was it from direct statement?
   09C7 7C            [ 4] 1587 	LD	A,H
   09C8 B5            [ 4] 1588 	OR	L		; Return to line
   09C9 C2 D3 09      [10] 1589 	JP	NZ,RETLIN	; No - Return to line
   09CC 3A 11 81      [13] 1590 	LD	A,(LSTBIN)	; Any INPUT in subroutine?
   09CF B7            [ 4] 1591 	OR	A		; If so buffer is corrupted
   09D0 C2 42 04      [10] 1592 	JP	NZ,POPNOK	; Yes - Go to command mode
   09D3 21 06 08      [10] 1593 RETLIN: LD	HL,RUNCNT	; Execution driver loop
   09D6 E3            [19] 1594 	EX	(SP),HL		; Into stack - Code string out
   09D7 3E                 1595 	.db	0x3E		; Skip "POP HL"
   09D8 E1            [10] 1596 NXTDTA: POP	HL		; Restore code string address
                           1597 ;
   09D9 01 3A              1598 DATA:	.db	0x01,0x3A		; ': End of statement
   09DB 0E 00         [ 7] 1599 REM:	LD	C,0		; 00	End of statement
   09DD 06 00         [ 7] 1600 	LD	B,0
   09DF 79            [ 4] 1601 NXTSTL: LD	A,C		; Statement and byte
   09E0 48            [ 4] 1602 	LD	C,B
   09E1 47            [ 4] 1603 	LD	B,A		; Statement end byte
   09E2 7E            [ 7] 1604 NXTSTT: LD	A,(HL)		; Get byte
   09E3 B7            [ 4] 1605 	OR	A		; End of line?
   09E4 C8            [11] 1606 	RET	Z		; Yes - Exit
   09E5 B8            [ 4] 1607 	CP	B		; End of statement?
   09E6 C8            [11] 1608 	RET	Z		; Yes - Exit
   09E7 23            [ 6] 1609 	INC	HL		; Next byte
   09E8 FE 22         [ 7] 1610 	CP	'"		; Literal string?
   09EA CA DF 09      [10] 1611 	JP	Z,NXTSTL	; Yes - Look for another '"
   09ED C3 E2 09      [10] 1612 	JP	NXTSTT		; Keep looking
                           1613 ;
   09F0 CD A5 0E      [17] 1614 LET:	CALL	GETVAR		; Get variable name
   09F3 CD C0 06      [17] 1615 	CALL	CHKSYN		; Make sure "=" follows
   09F6 B4                 1616 	.db	ZEQUAL		; "=" token
   09F7 D5            [11] 1617 	PUSH	DE		; Save address of variable
   09F8 3A F2 80      [13] 1618 	LD	A,(TYPE)	; Get data type
   09FB F5            [11] 1619 	PUSH	AF		; Save type
   09FC CD C1 0C      [17] 1620 	CALL	EVAL		; Evaluate expression
   09FF F1            [10] 1621 	POP	AF		; Restore type
   0A00 E3            [19] 1622 	EX	(SP),HL		; Save code - Get var addr
   0A01 22 13 81      [16] 1623 	LD	(BRKLIN),HL	; Save address of variable
   0A04 1F            [ 4] 1624 	RRA			; Adjust type
   0A05 CD B4 0C      [17] 1625 	CALL	CHKTYP		; Check types are the same
   0A08 CA 43 0A      [10] 1626 	JP	Z,LETNUM	; Numeric - Move value
   0A0B E5            [11] 1627 LETSTR: PUSH	HL		; Save address of string var
   0A0C 2A 29 81      [16] 1628 	LD	HL,(FPREG)	; Pointer to string entry
   0A0F E5            [11] 1629 	PUSH	HL		; Save it on stack
   0A10 23            [ 6] 1630 	INC	HL		; Skip over length
   0A11 23            [ 6] 1631 	INC	HL
   0A12 5E            [ 7] 1632 	LD	E,(HL)		; LSB of string address
   0A13 23            [ 6] 1633 	INC	HL
   0A14 56            [ 7] 1634 	LD	D,(HL)		; MSB of string address
   0A15 2A A3 80      [16] 1635 	LD	HL,(BASTXT)	; Point to start of program
   0A18 CD BA 06      [17] 1636 	CALL	CPDEHL		; Is string before program?
   0A1B D2 32 0A      [10] 1637 	JP	NC,CRESTR	; Yes - Create string entry
   0A1E 2A 9F 80      [16] 1638 	LD	HL,(STRSPC)	; Point to string space
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 31
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0A21 CD BA 06      [17] 1639 	CALL	CPDEHL		; Is string literal in program?
   0A24 D1            [10] 1640 	POP	DE		; Restore address of string
   0A25 D2 3A 0A      [10] 1641 	JP	NC,MVSTPT	; Yes - Set up pointer
   0A28 21 04 81      [10] 1642 	LD	HL,TMPSTR	; Temporary string pool
   0A2B CD BA 06      [17] 1643 	CALL	CPDEHL		; Is string in temporary pool?
   0A2E D2 3A 0A      [10] 1644 	JP	NC,MVSTPT	; No - Set up pointer
   0A31 3E                 1645 	.db	0x3E		; Skip "POP DE"
   0A32 D1            [10] 1646 CRESTR: POP	DE		; Restore address of string
   0A33 CD E9 12      [17] 1647 	CALL	BAKTMP		; Back to last tmp-str entry
   0A36 EB            [ 4] 1648 	EX	DE,HL		; Address of string entry
   0A37 CD 22 11      [17] 1649 	CALL	SAVSTR		; Save string in string area
   0A3A CD E9 12      [17] 1650 MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
   0A3D E1            [10] 1651 	POP	HL		; Get string pointer
   0A3E CD EA 16      [17] 1652 	CALL	DETHL4		; Move string pointer to var
   0A41 E1            [10] 1653 	POP	HL		; Restore code string address
   0A42 C9            [10] 1654 	RET
                           1655 ;
   0A43 E5            [11] 1656 LETNUM: PUSH	HL		; Save address of variable
   0A44 CD E7 16      [17] 1657 	CALL	FPTHL		; Move value to variable
   0A47 D1            [10] 1658 	POP	DE		; Restore address of variable
   0A48 E1            [10] 1659 	POP	HL		; Restore code string address
   0A49 C9            [10] 1660 	RET
                           1661 ;
   0A4A CD 10 14      [17] 1662 ON:	CALL	GETINT		; Get integer 0-255
   0A4D 7E            [ 7] 1663 	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
   0A4E 47            [ 4] 1664 	LD	B,A		; Save in B
   0A4F FE 8C         [ 7] 1665 	CP	ZGOSUB		; "GOSUB" token?
   0A51 CA 59 0A      [10] 1666 	JP	Z,ONGO		; Yes - Find line number
   0A54 CD C0 06      [17] 1667 	CALL	CHKSYN		; Make sure it's "GOTO"
   0A57 88                 1668 	.db	ZGOTO		; "GOTO" token
   0A58 2B            [ 6] 1669 	DEC	HL		; Cancel increment
   0A59 4B            [ 4] 1670 ONGO:	LD	C,E		; Integer of branch value
   0A5A 0D            [ 4] 1671 ONGOLP: DEC	C		; Count branches
   0A5B 78            [ 4] 1672 	LD	A,B		; Get "GOTO" or "GOSUB" token
   0A5C CA 2E 08      [10] 1673 	JP	Z,ONJMP		; Go to that line if right one
   0A5F CD 0F 09      [17] 1674 	CALL	GETLN		; Get line number to DE
   0A62 FE 2C         [ 7] 1675 	CP	',		; Another line number?
   0A64 C0            [11] 1676 	RET	NZ		; No - Drop through
   0A65 C3 5A 0A      [10] 1677 	JP	ONGOLP		; Yes - loop
                           1678 ;
   0A68 CD C1 0C      [17] 1679 IF:	CALL	EVAL		; Evaluate expression
   0A6B 7E            [ 7] 1680 	LD	A,(HL)		; Get token
   0A6C FE 88         [ 7] 1681 	CP	ZGOTO		; "GOTO" token?
   0A6E CA 76 0A      [10] 1682 	JP	Z,IFGO		; Yes - Get line
   0A71 CD C0 06      [17] 1683 	CALL	CHKSYN		; Make sure it's "THEN"
   0A74 A9                 1684 	.db	ZTHEN		; "THEN" token
   0A75 2B            [ 6] 1685 	DEC	HL		; Cancel increment
   0A76 CD B2 0C      [17] 1686 IFGO:	CALL	TSTNUM		; Make sure it's numeric
   0A79 CD 8F 16      [17] 1687 	CALL	TSTSGN		; Test state of expression
   0A7C CA DB 09      [10] 1688 	JP	Z,REM		; False - Drop through
   0A7F CD 46 08      [17] 1689 	CALL	GETCHR		; Get next character
   0A82 DA 96 09      [10] 1690 	JP	C,GOTO		; Number - GOTO that line
   0A85 C3 2D 08      [10] 1691 	JP	IFJMP		; Otherwise do statement
                           1692 ;
   0A88 2B            [ 6] 1693 MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 32
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0A89 CD 46 08      [17] 1694 	CALL	GETCHR		; Get next character
   0A8C CA EA 0A      [10] 1695 PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
   0A8F C8            [11] 1696 PRNTLP: RET	Z		; End of list - Exit
   0A90 FE A5         [ 7] 1697 	CP	ZTAB		; "TAB(" token?
   0A92 CA 1D 0B      [10] 1698 	JP	Z,DOTAB		; Yes - Do TAB routine
   0A95 FE A8         [ 7] 1699 	CP	ZSPC		; "SPC(" token?
   0A97 CA 1D 0B      [10] 1700 	JP	Z,DOTAB		; Yes - Do SPC routine
   0A9A E5            [11] 1701 	PUSH	HL		; Save code string address
   0A9B FE 2C         [ 7] 1702 	CP	',		; Comma?
   0A9D CA 06 0B      [10] 1703 	JP	Z,DOCOM		; Yes - Move to next zone
   0AA0 FE 3B         [ 7] 1704 	CP	59;";"		; Semi-colon?
   0AA2 CA 40 0B      [10] 1705 	JP	Z,NEXITM	; Do semi-colon routine
   0AA5 C1            [10] 1706 	POP	BC		; Code string address to BC
   0AA6 CD C1 0C      [17] 1707 	CALL	EVAL		; Evaluate expression
   0AA9 E5            [11] 1708 	PUSH	HL		; Save code string address
   0AAA 3A F2 80      [13] 1709 	LD	A,(TYPE)	; Get variable type
   0AAD B7            [ 4] 1710 	OR	A		; Is it a string variable?
   0AAE C2 D6 0A      [10] 1711 	JP	NZ,PRNTST	; Yes - Output string contents
   0AB1 CD 34 18      [17] 1712 	CALL	NUMASC		; Convert number to text
   0AB4 CD 46 11      [17] 1713 	CALL	CRTST		; Create temporary string
   0AB7 36 20         [10] 1714 	LD	(HL),' 	; Followed by a space
   0AB9 2A 29 81      [16] 1715 	LD	HL,(FPREG)	; Get length of output
   0ABC 34            [11] 1716 	INC	(HL)		; Plus 1 for the space
   0ABD 2A 29 81      [16] 1717 	LD	HL,(FPREG)	; < Not needed >
   0AC0 3A 87 80      [13] 1718 	LD	A,(LWIDTH)	; Get width of line
   0AC3 47            [ 4] 1719 	LD	B,A		; To B
   0AC4 04            [ 4] 1720 	INC	B		; Width 255 (No limit)?
   0AC5 CA D2 0A      [10] 1721 	JP	Z,PRNTNB	; Yes - Output number string
   0AC8 04            [ 4] 1722 	INC	B		; Adjust it
   0AC9 3A F0 80      [13] 1723 	LD	A,(CURPOS)	; Get cursor position
   0ACC 86            [ 7] 1724 	ADD	A,(HL)		; Add length of string
   0ACD 3D            [ 4] 1725 	DEC	A		; Adjust it
   0ACE B8            [ 4] 1726 	CP	B		; Will output fit on this line?
   0ACF D4 EA 0A      [17] 1727 	CALL	NC,PRCRLF	; No - CRLF first
   0AD2 CD 8B 11      [17] 1728 PRNTNB: CALL	PRS1		; Output string at (HL)
   0AD5 AF            [ 4] 1729 	XOR	A		; Skip CALL by setting 'z flag
   0AD6 C4 8B 11      [17] 1730 PRNTST: CALL	NZ,PRS1		; Output string at (HL)
   0AD9 E1            [10] 1731 	POP	HL		; Restore code string address
   0ADA C3 88 0A      [10] 1732 	JP	MRPRNT		; See if more to PRINT
                           1733 ;
   0ADD 3A F0 80      [13] 1734 STTLIN: LD	A,(CURPOS)	; Make sure on new line
   0AE0 B7            [ 4] 1735 	OR	A		; Already at start?
   0AE1 C8            [11] 1736 	RET	Z		; Yes - Do nothing
   0AE2 C3 EA 0A      [10] 1737 	JP	PRCRLF		; Start a new line
                           1738 ;
   0AE5 36 00         [10] 1739 ENDINP: LD	(HL),0		; Mark end of buffer
   0AE7 21 A5 80      [10] 1740 	LD	HL,BUFFER-1	; Point to buffer
   0AEA 3E 0D         [ 7] 1741 PRCRLF: LD	A,CR		; Load a CR
   0AEC CD CB 06      [17] 1742 	CALL	OUTC		; Output character
   0AEF 3E 0A         [ 7] 1743 	LD	A,LF		; Load a LF
   0AF1 CD CB 06      [17] 1744 	CALL	OUTC		; Output character
   0AF4 AF            [ 4] 1745 DONULL: XOR	A		; Set to position 0
   0AF5 32 F0 80      [13] 1746 	LD	(CURPOS),A	; Store it
   0AF8 3A 86 80      [13] 1747 	LD	A,(NULLS)	; Get number of nulls
   0AFB 3D            [ 4] 1748 NULLP:	DEC	A		; Count them
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 33
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0AFC C8            [11] 1749 	RET	Z		; Return if done
   0AFD F5            [11] 1750 	PUSH	AF		; Save count
   0AFE AF            [ 4] 1751 	XOR	A		; Load a null
   0AFF CD CB 06      [17] 1752 	CALL	OUTC		; Output it
   0B02 F1            [10] 1753 	POP	AF		; Restore count
   0B03 C3 FB 0A      [10] 1754 	JP	NULLP		; Keep counting
                           1755 ;
   0B06 3A 88 80      [13] 1756 DOCOM:	LD	A,(COMMAN)	; Get comma width
   0B09 47            [ 4] 1757 	LD	B,A		; Save in B
   0B0A 3A F0 80      [13] 1758 	LD	A,(CURPOS)	; Get current position
   0B0D B8            [ 4] 1759 	CP	B		; Within the limit?
   0B0E D4 EA 0A      [17] 1760 	CALL	NC,PRCRLF	; No - output CRLF
   0B11 D2 40 0B      [10] 1761 	JP	NC,NEXITM	; Get next item
   0B14 D6 0E         [ 7] 1762 ZONELP: SUB	14		; Next zone of 14 characters
   0B16 D2 14 0B      [10] 1763 	JP	NC,ZONELP	; Repeat if more zones
   0B19 2F            [ 4] 1764 	CPL			; Number of spaces to output
   0B1A C3 35 0B      [10] 1765 	JP	ASPCS		; Output them
                           1766 ;
   0B1D F5            [11] 1767 DOTAB:	PUSH	AF		; Save token
   0B1E CD 0D 14      [17] 1768 	CALL	FNDNUM		; Evaluate expression
   0B21 CD C0 06      [17] 1769 	CALL	CHKSYN		; Make sure ")" follows
   0B24 29                 1770 	.ascii	")"
   0B25 2B            [ 6] 1771 	DEC	HL		; Back space on to ")"
   0B26 F1            [10] 1772 	POP	AF		; Restore token
   0B27 D6 A8         [ 7] 1773 	SUB	ZSPC		; Was it "SPC(" ?
   0B29 E5            [11] 1774 	PUSH	HL		; Save code string address
   0B2A CA 30 0B      [10] 1775 	JP	Z,DOSPC	; Yes - Do 'E spaces
   0B2D 3A F0 80      [13] 1776 	LD	A,(CURPOS)	; Get current position
   0B30 2F            [ 4] 1777 DOSPC:	CPL			; Number of spaces to print to
   0B31 83            [ 4] 1778 	ADD	A,E		; Total number to print
   0B32 D2 40 0B      [10] 1779 	JP	NC,NEXITM	; TAB < Current POS(X)
   0B35 3C            [ 4] 1780 ASPCS:	INC	A		; Output A spaces
   0B36 47            [ 4] 1781 	LD	B,A		; Save number to print
   0B37 3E 20         [ 7] 1782 	LD	A,' 		; Space
   0B39 CD CB 06      [17] 1783 SPCLP:	CALL	OUTC		; Output character in A
   0B3C 05            [ 4] 1784 	DEC	B		; Count them
   0B3D C2 39 0B      [10] 1785 	JP	NZ,SPCLP	; Repeat if more
   0B40 E1            [10] 1786 NEXITM: POP	HL		; Restore code string address
   0B41 CD 46 08      [17] 1787 	CALL	GETCHR		; Get next character
   0B44 C3 8F 0A      [10] 1788 	JP	PRNTLP		; More to print
                           1789 ;
   0B47 3F 52 65 64 6F 20  1790 REDO:	.ascii	"?Redo from start"
        66 72 6F 6D 20 73
        74 61 72 74
   0B57 0D 0A 00           1791 	.db CR,LF,0
                           1792 ;
   0B5A 3A 12 81      [13] 1793 BADINP: LD	A,(READFG)	; READ or INPUT?
   0B5D B7            [ 4] 1794 	OR	A
   0B5E C2 F2 03      [10] 1795 	JP	NZ,DATSNR	; READ - ?SN Error
   0B61 C1            [10] 1796 	POP	BC		; Throw away code string addr
   0B62 21 47 0B      [10] 1797 	LD	HL,REDO		; "Redo from start" message
   0B65 CD 88 11      [17] 1798 	CALL	PRS		; Output string
   0B68 C3 43 05      [10] 1799 	JP	DOAGN		; Do last INPUT again
                           1800 ;
   0B6B CD F3 10      [17] 1801 INPUT:	CALL	IDTEST		; Test for illegal direct
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 34
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0B6E 7E            [ 7] 1802 	LD	A,(HL)		; Get character after "INPUT"
   0B6F FE 22         [ 7] 1803 	CP	'"		; Is there a prompt string?
   0B71 3E 00         [ 7] 1804 	LD	A,0		; Clear A and leave flags
   0B73 32 8A 80      [13] 1805 	LD	(CTLOFG),A	; Enable output
   0B76 C2 85 0B      [10] 1806 	JP	NZ,NOPMPT	; No prompt - get input
   0B79 CD 47 11      [17] 1807 	CALL	QTSTR		; Get string terminated by '"
   0B7C CD C0 06      [17] 1808 	CALL	CHKSYN		; Check for '; after prompt
   0B7F 3B                 1809 	.db	';
   0B80 E5            [11] 1810 	PUSH	HL		; Save code string address
   0B81 CD 8B 11      [17] 1811 	CALL	PRS1		; Output prompt string
   0B84 3E                 1812 	.db	0x3E		; Skip "PUSH HL"
   0B85 E5            [11] 1813 NOPMPT: PUSH	HL		; Save code string address
   0B86 CD 47 05      [17] 1814 	CALL	PROMPT		; Get input with "? " prompt
   0B89 C1            [10] 1815 	POP	BC		; Restore code string address
   0B8A DA 93 08      [10] 1816 	JP	C,INPBRK	; Break pressed - Exit
   0B8D 23            [ 6] 1817 	INC	HL		; Next byte
   0B8E 7E            [ 7] 1818 	LD	A,(HL)		; Get it
   0B8F B7            [ 4] 1819 	OR	A		; End of line?
   0B90 2B            [ 6] 1820 	DEC	HL		; Back again
   0B91 C5            [11] 1821 	PUSH	BC		; Re-save code string address
   0B92 CA D8 09      [10] 1822 	JP	Z,NXTDTA	; Yes - Find next DATA stmt
   0B95 36 2C         [10] 1823 	LD	(HL),',	; Store comma as separator
   0B97 C3 9F 0B      [10] 1824 	JP	NXTITM		; Get next item
                           1825 ;
   0B9A E5            [11] 1826 READ:	PUSH	HL		; Save code string address
   0B9B 2A 21 81      [16] 1827 	LD	HL,(NXTDAT)	; Next DATA statement
   0B9E F6                 1828 	.db	0x0F6		; Flag "READ"
   0B9F AF            [ 4] 1829 NXTITM: XOR	A		; Flag "INPUT"
   0BA0 32 12 81      [13] 1830 	LD	(READFG),A	; Save "READ"/"INPUT" flag
   0BA3 E3            [19] 1831 	EX	(SP),HL		; Get code str' , Save pointer
   0BA4 C3 AB 0B      [10] 1832 	JP	GTVLUS		; Get values
                           1833 ;
   0BA7 CD C0 06      [17] 1834 NEDMOR: CALL	CHKSYN		; Check for comma between items
   0BAA 2C                 1835 	.db	',
   0BAB CD A5 0E      [17] 1836 GTVLUS: CALL	GETVAR		; Get variable name
   0BAE E3            [19] 1837 	EX	(SP),HL		; Save code str" , Get pointer
   0BAF D5            [11] 1838 	PUSH	DE		; Save variable address
   0BB0 7E            [ 7] 1839 	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
   0BB1 FE 2C         [ 7] 1840 	CP	',		; Comma?
   0BB3 CA D3 0B      [10] 1841 	JP	Z,ANTVLU	; Yes - Get another value
   0BB6 3A 12 81      [13] 1842 	LD	A,(READFG)	; Is it READ?
   0BB9 B7            [ 4] 1843 	OR	A
   0BBA C2 40 0C      [10] 1844 	JP	NZ,FDTLP	; Yes - Find next DATA stmt
   0BBD 3E 3F         [ 7] 1845 	LD	A,'?		; More INPUT needed
   0BBF CD CB 06      [17] 1846 	CALL	OUTC		; Output character
   0BC2 CD 47 05      [17] 1847 	CALL	PROMPT		; Get INPUT with prompt
   0BC5 D1            [10] 1848 	POP	DE		; Variable address
   0BC6 C1            [10] 1849 	POP	BC		; Code string address
   0BC7 DA 93 08      [10] 1850 	JP	C,INPBRK	; Break pressed
   0BCA 23            [ 6] 1851 	INC	HL		; Point to next DATA byte
   0BCB 7E            [ 7] 1852 	LD	A,(HL)		; Get byte
   0BCC B7            [ 4] 1853 	OR	A		; Is it zero (No input) ?
   0BCD 2B            [ 6] 1854 	DEC	HL		; Back space INPUT pointer
   0BCE C5            [11] 1855 	PUSH	BC		; Save code string address
   0BCF CA D8 09      [10] 1856 	JP	Z,NXTDTA	; Find end of buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 35
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0BD2 D5            [11] 1857 	PUSH	DE		; Save variable address
   0BD3 3A F2 80      [13] 1858 ANTVLU: LD	A,(TYPE)	; Check data type
   0BD6 B7            [ 4] 1859 	OR	A		; Is it numeric?
   0BD7 CA FD 0B      [10] 1860 	JP	Z,INPBIN	; Yes - Convert to binary
   0BDA CD 46 08      [17] 1861 	CALL	GETCHR		; Get next character
   0BDD 57            [ 4] 1862 	LD	D,A		; Save input character
   0BDE 47            [ 4] 1863 	LD	B,A		; Again
   0BDF FE 22         [ 7] 1864 	CP	'"		; Start of literal sting?
   0BE1 CA F1 0B      [10] 1865 	JP	Z,STRENT	; Yes - Create string entry
   0BE4 3A 12 81      [13] 1866 	LD	A,(READFG)	; "READ" or "INPUT" ?
   0BE7 B7            [ 4] 1867 	OR	A
   0BE8 57            [ 4] 1868 	LD	D,A		; Save 00 if "INPUT"
   0BE9 CA EE 0B      [10] 1869 	JP	Z,ITMSEP	; "INPUT" - End with 00
   0BEC 16 3A         [ 7] 1870 	LD	D,':		; "DATA" - End with 00 or ':
   0BEE 06 2C         [ 7] 1871 ITMSEP: LD	B,',		; Item separator
   0BF0 2B            [ 6] 1872 	DEC	HL		; Back space for DTSTR
   0BF1 CD 4A 11      [17] 1873 STRENT: CALL	DTSTR		; Get string terminated by D
   0BF4 EB            [ 4] 1874 	EX	DE,HL		; String address to DE
   0BF5 21 08 0C      [10] 1875 	LD	HL,LTSTND	; Where to go after LETSTR
   0BF8 E3            [19] 1876 	EX	(SP),HL		; Save HL , get input pointer
   0BF9 D5            [11] 1877 	PUSH	DE		; Save address of string
   0BFA C3 0B 0A      [10] 1878 	JP	LETSTR		; Assign string to variable
                           1879 ;
   0BFD CD 46 08      [17] 1880 INPBIN: CALL	GETCHR		; Get next character
   0C00 CD 96 17      [17] 1881 	CALL	ASCTFP		; Convert ASCII to FP number
   0C03 E3            [19] 1882 	EX	(SP),HL		; Save input ptr, Get var addr
   0C04 CD E7 16      [17] 1883 	CALL	FPTHL		; Move FPREG to variable
   0C07 E1            [10] 1884 	POP	HL		; Restore input pointer
   0C08 2B            [ 6] 1885 LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
   0C09 CD 46 08      [17] 1886 	CALL	GETCHR		; Get next character
   0C0C CA 14 0C      [10] 1887 	JP	Z,MORDT		; End of line - More needed?
   0C0F FE 2C         [ 7] 1888 	CP	',		; Another value?
   0C11 C2 5A 0B      [10] 1889 	JP	NZ,BADINP	; No - Bad input
   0C14 E3            [19] 1890 MORDT:	EX	(SP),HL		; Get code string address
   0C15 2B            [ 6] 1891 	DEC	HL		; DEC 'cos GETCHR INCs
   0C16 CD 46 08      [17] 1892 	CALL	GETCHR		; Get next character
   0C19 C2 A7 0B      [10] 1893 	JP	NZ,NEDMOR	; More needed - Get it
   0C1C D1            [10] 1894 	POP	DE		; Restore DATA pointer
   0C1D 3A 12 81      [13] 1895 	LD	A,(READFG)	; "READ" or "INPUT" ?
   0C20 B7            [ 4] 1896 	OR	A
   0C21 EB            [ 4] 1897 	EX	DE,HL		; DATA pointer to HL
   0C22 C2 6C 08      [10] 1898 	JP	NZ,UPDATA	; Update DATA pointer if "READ"
   0C25 D5            [11] 1899 	PUSH	DE		; Save code string address
   0C26 B6            [ 7] 1900 	OR	(HL)		; More input given?
   0C27 21 2F 0C      [10] 1901 	LD	HL,EXTIG	; "?Extra ignored" message
   0C2A C4 88 11      [17] 1902 	CALL	NZ,PRS		; Output string if extra given
   0C2D E1            [10] 1903 	POP	HL		; Restore code string address
   0C2E C9            [10] 1904 	RET
                           1905 ;
   0C2F 3F 45 78 74 72 61  1906 EXTIG:	.ascii	"?Extra ignored"
        20 69 67 6E 6F 72
        65 64
   0C3D 0D 0A 00           1907 	.db CR,LF,0
                           1908 ;
   0C40 CD D9 09      [17] 1909 FDTLP:	CALL	DATA		; Get next statement
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 36
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0C43 B7            [ 4] 1910 	OR	A		; End of line?
   0C44 C2 59 0C      [10] 1911 	JP	NZ,FANDT	; No - See if DATA statement
   0C47 23            [ 6] 1912 	INC	HL
   0C48 7E            [ 7] 1913 	LD	A,(HL)		; End of program?
   0C49 23            [ 6] 1914 	INC	HL
   0C4A B6            [ 7] 1915 	OR	(HL)		; 00 00 Ends program
   0C4B 1E 06         [ 7] 1916 	LD	E,OD		; ?OD Error
   0C4D CA 0C 04      [10] 1917 	JP	Z,ERROR		; Yes - Out of DATA
   0C50 23            [ 6] 1918 	INC	HL
   0C51 5E            [ 7] 1919 	LD	E,(HL)		; LSB of line number
   0C52 23            [ 6] 1920 	INC	HL
   0C53 56            [ 7] 1921 	LD	D,(HL)		; MSB of line number
   0C54 EB            [ 4] 1922 	EX	DE,HL
   0C55 22 0E 81      [16] 1923 	LD	(DATLIN),HL	; Set line of current DATA item
   0C58 EB            [ 4] 1924 	EX	DE,HL
   0C59 CD 46 08      [17] 1925 FANDT:	CALL	GETCHR		; Get next character
   0C5C FE 83         [ 7] 1926 	CP	ZDATA		; "DATA" token
   0C5E C2 40 0C      [10] 1927 	JP	NZ,FDTLP	; No "DATA" - Keep looking
   0C61 C3 D3 0B      [10] 1928 	JP	ANTVLU		; Found - Convert input
                           1929 ;
   0C64 11 00 00      [10] 1930 NEXT:	LD	DE,0		; In case no index given
   0C67 C4 A5 0E      [17] 1931 NEXT1:	CALL	NZ,GETVAR	; Get index address
   0C6A 22 13 81      [16] 1932 	LD	(BRKLIN),HL	; Save code string address
   0C6D CD A1 03      [17] 1933 	CALL	BAKSTK		; Look for "FOR" block
   0C70 C2 FE 03      [10] 1934 	JP	NZ,NFERR	; No "FOR" - ?NF Error
   0C73 F9            [ 6] 1935 	LD	SP,HL		; Clear nested loops
   0C74 D5            [11] 1936 	PUSH	DE		; Save index address
   0C75 7E            [ 7] 1937 	LD	A,(HL)		; Get sign of STEP
   0C76 23            [ 6] 1938 	INC	HL
   0C77 F5            [11] 1939 	PUSH	AF		; Save sign of STEP
   0C78 D5            [11] 1940 	PUSH	DE		; Save index address
   0C79 CD CD 16      [17] 1941 	CALL	PHLTFP		; Move index value to FPREG
   0C7C E3            [19] 1942 	EX	(SP),HL		; Save address of TO value
   0C7D E5            [11] 1943 	PUSH	HL		; Save address of index
   0C7E CD 3C 14      [17] 1944 	CALL	ADDPHL		; Add STEP to index value
   0C81 E1            [10] 1945 	POP	HL		; Restore address of index
   0C82 CD E7 16      [17] 1946 	CALL	FPTHL		; Move value to index variable
   0C85 E1            [10] 1947 	POP	HL		; Restore address of TO value
   0C86 CD DE 16      [17] 1948 	CALL	LOADFP		; Move TO value to BCDE
   0C89 E5            [11] 1949 	PUSH	HL		; Save address of line of FOR
   0C8A CD 0A 17      [17] 1950 	CALL	CMPNUM		; Compare index with TO value
   0C8D E1            [10] 1951 	POP	HL		; Restore address of line num
   0C8E C1            [10] 1952 	POP	BC		; Address of sign of STEP
   0C8F 90            [ 4] 1953 	SUB	B		; Compare with expected sign
   0C90 CD DE 16      [17] 1954 	CALL	LOADFP		; BC = Loop stmt,DE = Line num
   0C93 CA 9F 0C      [10] 1955 	JP	Z,KILFOR	; Loop finished - Terminate it
   0C96 EB            [ 4] 1956 	EX	DE,HL		; Loop statement line number
   0C97 22 A1 80      [16] 1957 	LD	(LINEAT),HL	; Set loop line number
   0C9A 69            [ 4] 1958 	LD	L,C		; Set code string to loop
   0C9B 60            [ 4] 1959 	LD	H,B
   0C9C C3 02 08      [10] 1960 	JP	PUTFID		; Put back "FOR" and continue
                           1961 ;
   0C9F F9            [ 6] 1962 KILFOR: LD	SP,HL		; Remove "FOR" block
   0CA0 2A 13 81      [16] 1963 	LD	HL,(BRKLIN)	; Code string after "NEXT"
   0CA3 7E            [ 7] 1964 	LD	A,(HL)		; Get next byte in code string
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 37
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0CA4 FE 2C         [ 7] 1965 	CP	',		; More NEXTs ?
   0CA6 C2 06 08      [10] 1966 	JP	NZ,RUNCNT	; No - Do next statement
   0CA9 CD 46 08      [17] 1967 	CALL	GETCHR		; Position to index name
   0CAC CD 67 0C      [17] 1968 	CALL	NEXT1		; Re-enter NEXT routine
                           1969 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1970 ;
   0CAF CD C1 0C      [17] 1971 GETNUM: CALL	EVAL		; Get a numeric expression
   0CB2 F6                 1972 TSTNUM: .db	0x0F6		; Clear carry (numeric)
   0CB3 37            [ 4] 1973 TSTSTR: SCF			; Set carry (string)
   0CB4 3A F2 80      [13] 1974 CHKTYP: LD	A,(TYPE)	; Check types match
   0CB7 8F            [ 4] 1975 	ADC	A,A		; Expected + actual
   0CB8 B7            [ 4] 1976 	OR	A		; Clear carry , set parity
   0CB9 E8            [11] 1977 	RET	PE		; Even parity - Types match
   0CBA C3 0A 04      [10] 1978 	JP	TMERR		; Different types - Error
                           1979 ;
   0CBD CD C0 06      [17] 1980 OPNPAR: CALL	CHKSYN		; Make sure "(" follows
   0CC0 28                 1981 	.ascii	"("
   0CC1 2B            [ 6] 1982 EVAL:	DEC	HL		; Evaluate expression & save
   0CC2 16 00         [ 7] 1983 	LD	D,0		; Precedence value
   0CC4 D5            [11] 1984 EVAL1:	PUSH	DE		; Save precedence
   0CC5 0E 01         [ 7] 1985 	LD	C,1
   0CC7 CD D5 03      [17] 1986 	CALL	CHKSTK		; Check for 1 level of stack
   0CCA CD 38 0D      [17] 1987 	CALL	OPRND		; Get next expression value
   0CCD 22 15 81      [16] 1988 EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
   0CD0 2A 15 81      [16] 1989 EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
   0CD3 C1            [10] 1990 	POP	BC		; Precedence value and operator
   0CD4 78            [ 4] 1991 	LD	A,B		; Get precedence value
   0CD5 FE 78         [ 7] 1992 	CP	0x78		; "AND" or "OR" ?
   0CD7 D4 B2 0C      [17] 1993 	CALL	NC,TSTNUM	; No - Make sure it's a number
   0CDA 7E            [ 7] 1994 	LD	A,(HL)		; Get next operator / function
   0CDB 16 00         [ 7] 1995 	LD	D,0		; Clear Last relation
   0CDD D6 B3         [ 7] 1996 RLTLP:	SUB	ZGTR		; ">" Token
   0CDF DA F9 0C      [10] 1997 	JP	C,FOPRND	; + - * / ^ AND OR - Test it
   0CE2 FE 03         [ 7] 1998 	CP	ZLTH+1-ZGTR	; < = >
   0CE4 D2 F9 0C      [10] 1999 	JP	NC,FOPRND	; Function - Call it
   0CE7 FE 01         [ 7] 2000 	CP	ZEQUAL-ZGTR	; "="
   0CE9 17            [ 4] 2001 	RLA			; <- Test for legal
   0CEA AA            [ 4] 2002 	XOR	D		; <- combinations of < = >
   0CEB BA            [ 4] 2003 	CP	D		; <- by combining last token
   0CEC 57            [ 4] 2004 	LD	D,A		; <- with current one
   0CED DA F8 03      [10] 2005 	JP	C,SNERR		; Error if "<<' ==" or ">>"
   0CF0 22 0A 81      [16] 2006 	LD	(CUROPR),HL	; Save address of current token
   0CF3 CD 46 08      [17] 2007 	CALL	GETCHR		; Get next character
   0CF6 C3 DD 0C      [10] 2008 	JP	RLTLP		; Treat the two as one
                           2009 ;
   0CF9 7A            [ 4] 2010 FOPRND: LD	A,D		; < = > found ?
   0CFA B7            [ 4] 2011 	OR	A
   0CFB C2 20 0E      [10] 2012 	JP	NZ,TSTRED	; Yes - Test for reduction
   0CFE 7E            [ 7] 2013 	LD	A,(HL)		; Get operator token
   0CFF 22 0A 81      [16] 2014 	LD	(CUROPR),HL	; Save operator address
   0D02 D6 AC         [ 7] 2015 	SUB	ZPLUS		; Operator or function?
   0D04 D8            [11] 2016 	RET	C		; Neither - Exit
   0D05 FE 07         [ 7] 2017 	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
   0D07 D0            [11] 2018 	RET	NC		; No - Exit
   0D08 5F            [ 4] 2019 	LD	E,A		; Coded operator
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 38
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0D09 3A F2 80      [13] 2020 	LD	A,(TYPE)	; Get data type
   0D0C 3D            [ 4] 2021 	DEC	A		; FF = numeric , 00 = string
   0D0D B3            [ 4] 2022 	OR	E		; Combine with coded operator
   0D0E 7B            [ 4] 2023 	LD	A,E		; Get coded operator
   0D0F CA 7E 12      [10] 2024 	JP	Z,CONCAT	; String concatenation
   0D12 07            [ 4] 2025 	RLCA			; Times 2
   0D13 83            [ 4] 2026 	ADD	A,E		; Times 3
   0D14 5F            [ 4] 2027 	LD	E,A		; To DE (D is 0)
   0D15 21 EA 02      [10] 2028 	LD	HL,PRITAB	; Precedence table
   0D18 19            [11] 2029 	ADD	HL,DE		; To the operator concerned
   0D19 78            [ 4] 2030 	LD	A,B		; Last operator precedence
   0D1A 56            [ 7] 2031 	LD	D,(HL)		; Get evaluation precedence
   0D1B BA            [ 4] 2032 	CP	D		; Compare with eval precedence
   0D1C D0            [11] 2033 	RET	NC		; Exit if higher precedence
   0D1D 23            [ 6] 2034 	INC	HL		; Point to routine address
   0D1E CD B2 0C      [17] 2035 	CALL	TSTNUM		; Make sure it's a number
                           2036 ;
   0D21 C5            [11] 2037 STKTHS: PUSH	BC		; Save last precedence & token
   0D22 01 D0 0C      [10] 2038 	LD	BC,EVAL3	; Where to go on prec' break
   0D25 C5            [11] 2039 	PUSH	BC		; Save on stack for return
   0D26 43            [ 4] 2040 	LD	B,E		; Save operator
   0D27 4A            [ 4] 2041 	LD	C,D		; Save precedence
   0D28 CD C0 16      [17] 2042 	CALL	STAKFP		; Move value to stack
   0D2B 58            [ 4] 2043 	LD	E,B		; Restore operator
   0D2C 51            [ 4] 2044 	LD	D,C		; Restore precedence
   0D2D 4E            [ 7] 2045 	LD	C,(HL)		; Get LSB of routine address
   0D2E 23            [ 6] 2046 	INC	HL
   0D2F 46            [ 7] 2047 	LD	B,(HL)		; Get MSB of routine address
   0D30 23            [ 6] 2048 	INC	HL
   0D31 C5            [11] 2049 	PUSH	BC		; Save routine address
   0D32 2A 0A 81      [16] 2050 	LD	HL,(CUROPR)	; Address of current operator
   0D35 C3 C4 0C      [10] 2051 	JP	EVAL1		; Loop until prec' break
                           2052 ;
   0D38 AF            [ 4] 2053 OPRND:	XOR	A		; Get operand routine
   0D39 32 F2 80      [13] 2054 	LD	(TYPE),A	; Set numeric expected
   0D3C CD 46 08      [17] 2055 	CALL	GETCHR		; Get next character
   0D3F 1E 24         [ 7] 2056 	LD	E,MO		; ?MO Error
   0D41 CA 0C 04      [10] 2057 	JP	Z,ERROR		; No operand - Error
   0D44 DA 96 17      [10] 2058 	JP	C,ASCTFP	; Number - Get value
   0D47 CD E0 08      [17] 2059 	CALL	CHKLTR		; See if a letter
   0D4A D2 9F 0D      [10] 2060 	JP	NC,CONVAR	; Letter - Find variable
   0D4D FE 26         [ 7] 2061 	CP	'&		; &H = HEX, &B = BINARY
   0D4F 20 12         [12] 2062 	JR	NZ, NOTAMP
   0D51 CD 46 08      [17] 2063 	CALL	GETCHR		; Get next character
   0D54 FE 48         [ 7] 2064 	CP	'H		; Hex number indicated? [function added]
u  0D56 CA 00 00      [10] 2065 	JP	Z,HEXTFP	; Convert Hex to FPREG
   0D59 FE 42         [ 7] 2066 	CP	'B		; Binary number indicated? [function added]
   0D5B CA 34 1C      [10] 2067 	JP	Z,BINTFP	; Convert Bin to FPREG
   0D5E 1E 02         [ 7] 2068 	LD	E,SN		; If neither then a ?SN Error
   0D60 CA 0C 04      [10] 2069 	JP	Z,ERROR
   0D63 FE AC         [ 7] 2070 NOTAMP: CP	ZPLUS		; '+ Token ?
   0D65 CA 38 0D      [10] 2071 	JP	Z,OPRND		; Yes - Look for operand
   0D68 FE 2E         [ 7] 2072 	CP	'.		; '. ?
   0D6A CA 96 17      [10] 2073 	JP	Z,ASCTFP	; Yes - Create FP number
   0D6D FE AD         [ 7] 2074 	CP	ZMINUS		; '- Token ?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 39
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0D6F CA 8E 0D      [10] 2075 	JP	Z,MINUS		; Yes - Do minus
   0D72 FE 22         [ 7] 2076 	CP	'"		; Literal string ?
   0D74 CA 47 11      [10] 2077 	JP	Z,QTSTR		; Get string terminated by '"
   0D77 FE AA         [ 7] 2078 	CP	ZNOT		; "NOT" Token ?
   0D79 CA 80 0E      [10] 2079 	JP	Z,EVNOT		; Yes - Eval NOT expression
   0D7C FE A7         [ 7] 2080 	CP	ZFN		; "FN" Token ?
   0D7E CA AB 10      [10] 2081 	JP	Z,DOFN		; Yes - Do FN routine
   0D81 D6 B6         [ 7] 2082 	SUB	ZSGN		; Is it a function?
   0D83 D2 B0 0D      [10] 2083 	JP	NC,FNOFST	; Yes - Evaluate function
   0D86 CD BD 0C      [17] 2084 EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
   0D89 CD C0 06      [17] 2085 	CALL	CHKSYN		; Make sure ")" follows
   0D8C 29                 2086 	.ascii	")"
   0D8D C9            [10] 2087 	RET
                           2088 ;
   0D8E 16 7D         [ 7] 2089 MINUS:	LD	D,0x7D		; '- precedence
   0D90 CD C4 0C      [17] 2090 	CALL	EVAL1		; Evaluate until prec' break
   0D93 2A 15 81      [16] 2091 	LD	HL,(NXTOPR)	; Get next operator address
   0D96 E5            [11] 2092 	PUSH	HL		; Save next operator address
   0D97 CD B8 16      [17] 2093 	CALL	INVSGN		; Negate value
   0D9A CD B2 0C      [17] 2094 RETNUM: CALL	TSTNUM		; Make sure it's a number
   0D9D E1            [10] 2095 	POP	HL		; Restore next operator address
   0D9E C9            [10] 2096 	RET
                           2097 ;
   0D9F CD A5 0E      [17] 2098 CONVAR: CALL	GETVAR		; Get variable address to DE
   0DA2 E5            [11] 2099 FRMEVL: PUSH	HL		; Save code string address
   0DA3 EB            [ 4] 2100 	EX	DE,HL		; Variable address to HL
   0DA4 22 29 81      [16] 2101 	LD	(FPREG),HL	; Save address of variable
   0DA7 3A F2 80      [13] 2102 	LD	A,(TYPE)	; Get type
   0DAA B7            [ 4] 2103 	OR	A		; Numeric?
   0DAB CC CD 16      [17] 2104 	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
   0DAE E1            [10] 2105 	POP	HL		; Restore code string address
   0DAF C9            [10] 2106 	RET
                           2107 ;
   0DB0 06 00         [ 7] 2108 FNOFST: LD	B,0		; Get address of function
   0DB2 07            [ 4] 2109 	RLCA			; Double function offset
   0DB3 4F            [ 4] 2110 	LD	C,A		; BC = Offset in function table
   0DB4 C5            [11] 2111 	PUSH	BC		; Save adjusted token value
   0DB5 CD 46 08      [17] 2112 	CALL	GETCHR		; Get next character
   0DB8 79            [ 4] 2113 	LD	A,C		; Get adjusted token value
   0DB9 FE 31         [ 7] 2114 	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
   0DBB DA D7 0D      [10] 2115 	JP	C,FNVAL		; No - Do function
   0DBE CD BD 0C      [17] 2116 	CALL	OPNPAR		; Evaluate expression	(X,...
   0DC1 CD C0 06      [17] 2117 	CALL	CHKSYN		; Make sure ', follows
   0DC4 2C                 2118 	.db	',
   0DC5 CD B3 0C      [17] 2119 	CALL	TSTSTR		; Make sure it's a string
   0DC8 EB            [ 4] 2120 	EX	DE,HL		; Save code string address
   0DC9 2A 29 81      [16] 2121 	LD	HL,(FPREG)	; Get address of string
   0DCC E3            [19] 2122 	EX	(SP),HL		; Save address of string
   0DCD E5            [11] 2123 	PUSH	HL		; Save adjusted token value
   0DCE EB            [ 4] 2124 	EX	DE,HL		; Restore code string address
   0DCF CD 10 14      [17] 2125 	CALL	GETINT		; Get integer 0-255
   0DD2 EB            [ 4] 2126 	EX	DE,HL		; Save code string address
   0DD3 E3            [19] 2127 	EX	(SP),HL		; Save integer,HL = adj' token
   0DD4 C3 DF 0D      [10] 2128 	JP	GOFUNC		; Jump to string function
                           2129 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 40
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0DD7 CD 86 0D      [17] 2130 FNVAL:	CALL	EVLPAR		; Evaluate expression
   0DDA E3            [19] 2131 	EX	(SP),HL		; HL = Adjusted token value
   0DDB 11 9A 0D      [10] 2132 	LD	DE,RETNUM	; Return number from function
   0DDE D5            [11] 2133 	PUSH	DE		; Save on stack
   0DDF 01 49 01      [10] 2134 GOFUNC: LD	BC,FNCTAB	; Function routine addresses
   0DE2 09            [11] 2135 	ADD	HL,BC		; Point to right address
   0DE3 4E            [ 7] 2136 	LD	C,(HL)		; Get LSB of address
   0DE4 23            [ 6] 2137 	INC	HL		;
   0DE5 66            [ 7] 2138 	LD	H,(HL)		; Get MSB of address
   0DE6 69            [ 4] 2139 	LD	L,C		; Address to HL
   0DE7 E9            [ 4] 2140 	JP	(HL)		; Jump to function
                           2141 ;
   0DE8 15            [ 4] 2142 SGNEXP: DEC	D		; Dee to flag negative exponent
   0DE9 FE AD         [ 7] 2143 	CP	ZMINUS		; '- token ?
   0DEB C8            [11] 2144 	RET	Z		; Yes - Return
   0DEC FE 2D         [ 7] 2145 	CP	'-		; '- ASCII ?
   0DEE C8            [11] 2146 	RET	Z		; Yes - Return
   0DEF 14            [ 4] 2147 	INC	D		; Inc to flag positive exponent
   0DF0 FE 2B         [ 7] 2148 	CP	'+		; '+ ASCII ?
   0DF2 C8            [11] 2149 	RET	Z		; Yes - Return
   0DF3 FE AC         [ 7] 2150 	CP	ZPLUS		; '+ token ?
   0DF5 C8            [11] 2151 	RET	Z		; Yes - Return
   0DF6 2B            [ 6] 2152 	DEC	HL		; DEC 'cos GETCHR INCs
   0DF7 C9            [10] 2153 	RET			; Return "NZ"
                           2154 ;
   0DF8 F6                 2155 POR:	.db	0x0F6		; Flag "OR"
   0DF9 AF            [ 4] 2156 PAND:	XOR	A		; Flag "AND"
   0DFA F5            [11] 2157 	PUSH	AF		; Save "AND" / "OR" flag
   0DFB CD B2 0C      [17] 2158 	CALL	TSTNUM		; Make sure it's a number
   0DFE CD F4 08      [17] 2159 	CALL	DEINT		; Get integer -32768 to 32767
   0E01 F1            [10] 2160 	POP	AF		; Restore "AND" / "OR" flag
   0E02 EB            [ 4] 2161 	EX	DE,HL		; <- Get last
   0E03 C1            [10] 2162 	POP	BC		; <- value
   0E04 E3            [19] 2163 	EX	(SP),HL		; <- from
   0E05 EB            [ 4] 2164 	EX	DE,HL		; <- stack
   0E06 CD D0 16      [17] 2165 	CALL	FPBCDE		; Move last value to FPREG
   0E09 F5            [11] 2166 	PUSH	AF		; Save "AND" / "OR" flag
   0E0A CD F4 08      [17] 2167 	CALL	DEINT		; Get integer -32768 to 32767
   0E0D F1            [10] 2168 	POP	AF		; Restore "AND" / "OR" flag
   0E0E C1            [10] 2169 	POP	BC		; Get value
   0E0F 79            [ 4] 2170 	LD	A,C		; Get LSB
   0E10 21 69 10      [10] 2171 	LD	HL,ACPASS	; Address of save AC as current
   0E13 C2 1B 0E      [10] 2172 	JP	NZ,POR1		; Jump if OR
   0E16 A3            [ 4] 2173 	AND	E		; "AND" LSBs
   0E17 4F            [ 4] 2174 	LD	C,A		; Save LSB
   0E18 78            [ 4] 2175 	LD	A,B		; Get MBS
   0E19 A2            [ 4] 2176 	AND	D		; "AND" MSBs
   0E1A E9            [ 4] 2177 	JP	(HL)		; Save AC as current (ACPASS)
                           2178 ;
   0E1B B3            [ 4] 2179 POR1:	OR	E		; "OR" LSBs
   0E1C 4F            [ 4] 2180 	LD	C,A		; Save LSB
   0E1D 78            [ 4] 2181 	LD	A,B		; Get MSB
   0E1E B2            [ 4] 2182 	OR	D		; "OR" MSBs
   0E1F E9            [ 4] 2183 	JP	(HL)		; Save AC as current (ACPASS)
                           2184 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 41
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0E20 21 32 0E      [10] 2185 TSTRED: LD	HL,CMPLOG	; Logical compare routine
   0E23 3A F2 80      [13] 2186 	LD	A,(TYPE)	; Get data type
   0E26 1F            [ 4] 2187 	RRA			; Carry set = string
   0E27 7A            [ 4] 2188 	LD	A,D		; Get last precedence value
   0E28 17            [ 4] 2189 	RLA			; Times 2 plus carry
   0E29 5F            [ 4] 2190 	LD	E,A		; To E
   0E2A 16 64         [ 7] 2191 	LD	D,0x64		; Relational precedence
   0E2C 78            [ 4] 2192 	LD	A,B		; Get current precedence
   0E2D BA            [ 4] 2193 	CP	D		; Compare with last
   0E2E D0            [11] 2194 	RET	NC		; Eval if last was rel' or log'
   0E2F C3 21 0D      [10] 2195 	JP	STKTHS		; Stack this one and get next
                           2196 ;
   0E32 34 0E              2197 CMPLOG: .dw	CMPLG1		; Compare two values / strings
   0E34 79            [ 4] 2198 CMPLG1: LD	A,C		; Get data type
   0E35 B7            [ 4] 2199 	OR	A
   0E36 1F            [ 4] 2200 	RRA
   0E37 C1            [10] 2201 	POP	BC		; Get last expression to BCDE
   0E38 D1            [10] 2202 	POP	DE
   0E39 F5            [11] 2203 	PUSH	AF		; Save status
   0E3A CD B4 0C      [17] 2204 	CALL	CHKTYP		; Check that types match
   0E3D 21 76 0E      [10] 2205 	LD	HL,CMPRES	; Result to comparison
   0E40 E5            [11] 2206 	PUSH	HL		; Save for RETurn
   0E41 CA 0A 17      [10] 2207 	JP	Z,CMPNUM	; Compare values if numeric
   0E44 AF            [ 4] 2208 	XOR	A		; Compare two strings
   0E45 32 F2 80      [13] 2209 	LD	(TYPE),A	; Set type to numeric
   0E48 D5            [11] 2210 	PUSH	DE		; Save string name
   0E49 CD CB 12      [17] 2211 	CALL	GSTRCU		; Get current string
   0E4C 7E            [ 7] 2212 	LD	A,(HL)		; Get length of string
   0E4D 23            [ 6] 2213 	INC	HL
   0E4E 23            [ 6] 2214 	INC	HL
   0E4F 4E            [ 7] 2215 	LD	C,(HL)		; Get LSB of address
   0E50 23            [ 6] 2216 	INC	HL
   0E51 46            [ 7] 2217 	LD	B,(HL)		; Get MSB of address
   0E52 D1            [10] 2218 	POP	DE		; Restore string name
   0E53 C5            [11] 2219 	PUSH	BC		; Save address of string
   0E54 F5            [11] 2220 	PUSH	AF		; Save length of string
   0E55 CD CF 12      [17] 2221 	CALL	GSTRDE		; Get second string
   0E58 CD DE 16      [17] 2222 	CALL	LOADFP		; Get address of second string
   0E5B F1            [10] 2223 	POP	AF		; Restore length of string 1
   0E5C 57            [ 4] 2224 	LD	D,A		; Length to D
   0E5D E1            [10] 2225 	POP	HL		; Restore address of string 1
   0E5E 7B            [ 4] 2226 CMPSTR: LD	A,E		; Bytes of string 2 to do
   0E5F B2            [ 4] 2227 	OR	D		; Bytes of string 1 to do
   0E60 C8            [11] 2228 	RET	Z		; Exit if all bytes compared
   0E61 7A            [ 4] 2229 	LD	A,D		; Get bytes of string 1 to do
   0E62 D6 01         [ 7] 2230 	SUB	1
   0E64 D8            [11] 2231 	RET	C		; Exit if end of string 1
   0E65 AF            [ 4] 2232 	XOR	A
   0E66 BB            [ 4] 2233 	CP	E		; Bytes of string 2 to do
   0E67 3C            [ 4] 2234 	INC	A
   0E68 D0            [11] 2235 	RET	NC		; Exit if end of string 2
   0E69 15            [ 4] 2236 	DEC	D		; Count bytes in string 1
   0E6A 1D            [ 4] 2237 	DEC	E		; Count bytes in string 2
   0E6B 0A            [ 7] 2238 	LD	A,(BC)		; Byte in string 2
   0E6C BE            [ 7] 2239 	CP	(HL)		; Compare to byte in string 1
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 42
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0E6D 23            [ 6] 2240 	INC	HL		; Move up string 1
   0E6E 03            [ 6] 2241 	INC	BC		; Move up string 2
   0E6F CA 5E 0E      [10] 2242 	JP	Z,CMPSTR	; Same - Try next bytes
   0E72 3F            [ 4] 2243 	CCF			; Flag difference (">" or "<")
   0E73 C3 9A 16      [10] 2244 	JP	FLGDIF		; "<" gives -1 , ">" gives +1
                           2245 ;
   0E76 3C            [ 4] 2246 CMPRES: INC	A		; Increment current value
   0E77 8F            [ 4] 2247 	ADC	A,A		; Double plus carry
   0E78 C1            [10] 2248 	POP	BC		; Get other value
   0E79 A0            [ 4] 2249 	AND	B		; Combine them
   0E7A C6 FF         [ 7] 2250 	ADD	A,-1		; Carry set if different
   0E7C 9F            [ 4] 2251 	SBC	A,A		; 00 - Equal , FF - Different
   0E7D C3 A1 16      [10] 2252 	JP	FLGREL		; Set current value & continue
                           2253 ;
   0E80 16 5A         [ 7] 2254 EVNOT:	LD	D,0x5A		; Precedence value for "NOT"
   0E82 CD C4 0C      [17] 2255 	CALL	EVAL1		; Eval until precedence break
   0E85 CD B2 0C      [17] 2256 	CALL	TSTNUM		; Make sure it's a number
   0E88 CD F4 08      [17] 2257 	CALL	DEINT		; Get integer -32768 - 32767
   0E8B 7B            [ 4] 2258 	LD	A,E		; Get LSB
   0E8C 2F            [ 4] 2259 	CPL			; Invert LSB
   0E8D 4F            [ 4] 2260 	LD	C,A		; Save "NOT" of LSB
   0E8E 7A            [ 4] 2261 	LD	A,D		; Get MSB
   0E8F 2F            [ 4] 2262 	CPL			; Invert MSB
   0E90 CD 69 10      [17] 2263 	CALL	ACPASS		; Save AC as current
   0E93 C1            [10] 2264 	POP	BC		; Clean up stack
   0E94 C3 D0 0C      [10] 2265 	JP	EVAL3		; Continue evaluation
                           2266 ;
   0E97 2B            [ 6] 2267 DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
   0E98 CD 46 08      [17] 2268 	CALL	GETCHR		; Get next character
   0E9B C8            [11] 2269 	RET	Z		; End of DIM statement
   0E9C CD C0 06      [17] 2270 	CALL	CHKSYN		; Make sure ', follows
   0E9F 2C                 2271 	.db	',
   0EA0 01 97 0E      [10] 2272 DIM:	LD	BC,DIMRET	; Return to "DIMRET"
   0EA3 C5            [11] 2273 	PUSH	BC		; Save on stack
   0EA4 F6                 2274 	.db	0x0F6		; Flag "Create" variable
   0EA5 AF            [ 4] 2275 GETVAR: XOR	A		; Find variable address,to DE
   0EA6 32 F1 80      [13] 2276 	LD	(LCRFLG),A	; Set locate / create flag
   0EA9 46            [ 7] 2277 	LD	B,(HL)		; Get First byte of name
   0EAA CD E0 08      [17] 2278 GTFNAM: CALL	CHKLTR		; See if a letter
   0EAD DA F8 03      [10] 2279 	JP	C,SNERR		; ?SN Error if not a letter
   0EB0 AF            [ 4] 2280 	XOR	A
   0EB1 4F            [ 4] 2281 	LD	C,A		; Clear second byte of name
   0EB2 32 F2 80      [13] 2282 	LD	(TYPE),A	; Set type to numeric
   0EB5 CD 46 08      [17] 2283 	CALL	GETCHR		; Get next character
   0EB8 DA C1 0E      [10] 2284 	JP	C,SVNAM2	; Numeric - Save in name
   0EBB CD E0 08      [17] 2285 	CALL	CHKLTR		; See if a letter
   0EBE DA CE 0E      [10] 2286 	JP	C,CHARTY	; Not a letter - Check type
   0EC1 4F            [ 4] 2287 SVNAM2: LD	C,A		; Save second byte of name
   0EC2 CD 46 08      [17] 2288 ENDNAM: CALL	GETCHR		; Get next character
   0EC5 DA C2 0E      [10] 2289 	JP	C,ENDNAM	; Numeric - Get another
   0EC8 CD E0 08      [17] 2290 	CALL	CHKLTR		; See if a letter
   0ECB D2 C2 0E      [10] 2291 	JP	NC,ENDNAM	; Letter - Get another
   0ECE D6 24         [ 7] 2292 CHARTY: SUB	'$		; String variable?
   0ED0 C2 DD 0E      [10] 2293 	JP	NZ,NOTSTR	; No - Numeric variable
   0ED3 3C            [ 4] 2294 	INC	A		; A = 1 (string type)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 43
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0ED4 32 F2 80      [13] 2295 	LD	(TYPE),A	; Set type to string
   0ED7 0F            [ 4] 2296 	RRCA			; A = 0x80 , Flag for string
   0ED8 81            [ 4] 2297 	ADD	A,C		; 2nd byte of name has bit 7 on
   0ED9 4F            [ 4] 2298 	LD	C,A		; Resave second byte on name
   0EDA CD 46 08      [17] 2299 	CALL	GETCHR		; Get next character
   0EDD 3A 10 81      [13] 2300 NOTSTR: LD	A,(FORFLG)	; Array name needed ?
   0EE0 3D            [ 4] 2301 	DEC	A
   0EE1 CA 8A 0F      [10] 2302 	JP	Z,ARLDSV	; Yes - Get array name
   0EE4 F2 ED 0E      [10] 2303 	JP	P,NSCFOR	; No array with "FOR" or "FN"
   0EE7 7E            [ 7] 2304 	LD	A,(HL)		; Get byte again
   0EE8 D6 28         [ 7] 2305 	SUB	'(		; Subscripted variable?
   0EEA CA 62 0F      [10] 2306 	JP	Z,SBSCPT	; Yes - Sort out subscript
                           2307 ;
   0EED AF            [ 4] 2308 NSCFOR: XOR	A		; Simple variable
   0EEE 32 10 81      [13] 2309 	LD	(FORFLG),A	; Clear "FOR" flag
   0EF1 E5            [11] 2310 	PUSH	HL		; Save code string address
   0EF2 50            [ 4] 2311 	LD	D,B		; DE = Variable name to find
   0EF3 59            [ 4] 2312 	LD	E,C
   0EF4 2A 23 81      [16] 2313 	LD	HL,(FNRGNM)	; FN argument name
   0EF7 CD BA 06      [17] 2314 	CALL	CPDEHL		; Is it the FN argument?
   0EFA 11 25 81      [10] 2315 	LD	DE,FNARG	; Point to argument value
   0EFD CA D0 15      [10] 2316 	JP	Z,POPHRT	; Yes - Return FN argument value
   0F00 2A 1D 81      [16] 2317 	LD	HL,(VAREND)	; End of variables
   0F03 EB            [ 4] 2318 	EX	DE,HL		; Address of end of search
   0F04 2A 1B 81      [16] 2319 	LD	HL,(PROGND)	; Start of variables address
   0F07 CD BA 06      [17] 2320 FNDVAR: CALL	CPDEHL		; End of variable list table?
   0F0A CA 20 0F      [10] 2321 	JP	Z,CFEVAL	; Yes - Called from EVAL?
   0F0D 79            [ 4] 2322 	LD	A,C		; Get second byte of name
   0F0E 96            [ 7] 2323 	SUB	(HL)		; Compare with name in list
   0F0F 23            [ 6] 2324 	INC	HL		; Move on to first byte
   0F10 C2 15 0F      [10] 2325 	JP	NZ,FNTHR	; Different - Find another
   0F13 78            [ 4] 2326 	LD	A,B		; Get first byte of name
   0F14 96            [ 7] 2327 	SUB	(HL)		; Compare with name in list
   0F15 23            [ 6] 2328 FNTHR:	INC	HL		; Move on to LSB of value
   0F16 CA 54 0F      [10] 2329 	JP	Z,RETADR	; Found - Return address
   0F19 23            [ 6] 2330 	INC	HL		; <- Skip
   0F1A 23            [ 6] 2331 	INC	HL		; <- over
   0F1B 23            [ 6] 2332 	INC	HL		; <- F.P.
   0F1C 23            [ 6] 2333 	INC	HL		; <- value
   0F1D C3 07 0F      [10] 2334 	JP	FNDVAR		; Keep looking
                           2335 ;
   0F20 E1            [10] 2336 CFEVAL: POP	HL		; Restore code string address
   0F21 E3            [19] 2337 	EX	(SP),HL		; Get return address
   0F22 D5            [11] 2338 	PUSH	DE		; Save address of variable
   0F23 11 A2 0D      [10] 2339 	LD	DE,FRMEVL	; Return address in EVAL
   0F26 CD BA 06      [17] 2340 	CALL	CPDEHL		; Called from EVAL ?
   0F29 D1            [10] 2341 	POP	DE		; Restore address of variable
   0F2A CA 57 0F      [10] 2342 	JP	Z,RETNUL	; Yes - Return null variable
   0F2D E3            [19] 2343 	EX	(SP),HL		; Put back return
   0F2E E5            [11] 2344 	PUSH	HL		; Save code string address
   0F2F C5            [11] 2345 	PUSH	BC		; Save variable name
   0F30 01 06 00      [10] 2346 	LD	BC,6		; 2 byte name plus 4 byte data
   0F33 2A 1F 81      [16] 2347 	LD	HL,(ARREND)	; End of arrays
   0F36 E5            [11] 2348 	PUSH	HL		; Save end of arrays
   0F37 09            [11] 2349 	ADD	HL,BC		; Move up 6 bytes
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 44
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0F38 C1            [10] 2350 	POP	BC		; Source address in BC
   0F39 E5            [11] 2351 	PUSH	HL		; Save new end address
   0F3A CD C4 03      [17] 2352 	CALL	MOVUP		; Move arrays up
   0F3D E1            [10] 2353 	POP	HL		; Restore new end address
   0F3E 22 1F 81      [16] 2354 	LD	(ARREND),HL	; Set new end address
   0F41 60            [ 4] 2355 	LD	H,B		; End of variables to HL
   0F42 69            [ 4] 2356 	LD	L,C
   0F43 22 1D 81      [16] 2357 	LD	(VAREND),HL	; Set new end address
                           2358 ;
   0F46 2B            [ 6] 2359 ZEROLP: DEC	HL		; Back through to zero variable
   0F47 36 00         [10] 2360 	LD	(HL),0		; Zero byte in variable
   0F49 CD BA 06      [17] 2361 	CALL	CPDEHL		; Done them all?
   0F4C C2 46 0F      [10] 2362 	JP	NZ,ZEROLP	; No - Keep on going
   0F4F D1            [10] 2363 	POP	DE		; Get variable name
   0F50 73            [ 7] 2364 	LD	(HL),E		; Store second character
   0F51 23            [ 6] 2365 	INC	HL
   0F52 72            [ 7] 2366 	LD	(HL),D		; Store first character
   0F53 23            [ 6] 2367 	INC	HL
   0F54 EB            [ 4] 2368 RETADR: EX	DE,HL		; Address of variable in DE
   0F55 E1            [10] 2369 	POP	HL		; Restore code string address
   0F56 C9            [10] 2370 	RET
                           2371 ;
   0F57 32 2C 81      [13] 2372 RETNUL: LD	(FPEXP),A	; Set result to zero
   0F5A 21 94 03      [10] 2373 	LD	HL,ZERBYT	; Also set a null string
   0F5D 22 29 81      [16] 2374 	LD	(FPREG),HL	; Save for EVAL
   0F60 E1            [10] 2375 	POP	HL		; Restore code string address
   0F61 C9            [10] 2376 	RET
                           2377 ;
   0F62 E5            [11] 2378 SBSCPT: PUSH	HL		; Save code string address
   0F63 2A F1 80      [16] 2379 	LD	HL,(LCRFLG)	; Locate/Create and Type
   0F66 E3            [19] 2380 	EX	(SP),HL		; Save and get code string
   0F67 57            [ 4] 2381 	LD	D,A		; Zero number of dimensions
   0F68 D5            [11] 2382 SCPTLP: PUSH	DE		; Save number of dimensions
   0F69 C5            [11] 2383 	PUSH	BC		; Save array name
   0F6A CD E8 08      [17] 2384 	CALL	FPSINT		; Get subscript (0-32767)
   0F6D C1            [10] 2385 	POP	BC		; Restore array name
   0F6E F1            [10] 2386 	POP	AF		; Get number of dimensions
   0F6F EB            [ 4] 2387 	EX	DE,HL
   0F70 E3            [19] 2388 	EX	(SP),HL		; Save subscript value
   0F71 E5            [11] 2389 	PUSH	HL		; Save LCRFLG and TYPE
   0F72 EB            [ 4] 2390 	EX	DE,HL
   0F73 3C            [ 4] 2391 	INC	A		; Count dimensions
   0F74 57            [ 4] 2392 	LD	D,A		; Save in D
   0F75 7E            [ 7] 2393 	LD	A,(HL)		; Get next byte in code string
   0F76 FE 2C         [ 7] 2394 	CP	',		; Comma (more to come)?
   0F78 CA 68 0F      [10] 2395 	JP	Z,SCPTLP	; Yes - More subscripts
   0F7B CD C0 06      [17] 2396 	CALL	CHKSYN		; Make sure ")" follows
   0F7E 29                 2397 	.ascii	")"
   0F7F 22 15 81      [16] 2398 	LD	(NXTOPR),HL	; Save code string address
   0F82 E1            [10] 2399 	POP	HL		; Get LCRFLG and TYPE
   0F83 22 F1 80      [16] 2400 	LD	(LCRFLG),HL	; Restore Locate/create & type
   0F86 1E 00         [ 7] 2401 	LD	E,0		; Flag not CSAVE* or CLOAD*
   0F88 D5            [11] 2402 	PUSH	DE		; Save number of dimensions (D)
   0F89 11                 2403 	.db	0x11		; Skip "PUSH HL" and "PUSH AF'
                           2404 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 45
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0F8A E5            [11] 2405 ARLDSV: PUSH	HL		; Save code string address
   0F8B F5            [11] 2406 	PUSH	AF		; A = 00 , Flags set = Z,N
   0F8C 2A 1D 81      [16] 2407 	LD	HL,(VAREND)	; Start of arrays
   0F8F 3E                 2408 	.db	0x3E		; Skip "ADD HL,DE"
   0F90 19            [11] 2409 FNDARY: ADD	HL,DE		; Move to next array start
   0F91 EB            [ 4] 2410 	EX	DE,HL
   0F92 2A 1F 81      [16] 2411 	LD	HL,(ARREND)	; End of arrays
   0F95 EB            [ 4] 2412 	EX	DE,HL		; Current array pointer
   0F96 CD BA 06      [17] 2413 	CALL	CPDEHL		; End of arrays found?
   0F99 CA C2 0F      [10] 2414 	JP	Z,CREARY	; Yes - Create array
   0F9C 7E            [ 7] 2415 	LD	A,(HL)		; Get second byte of name
   0F9D B9            [ 4] 2416 	CP	C		; Compare with name given
   0F9E 23            [ 6] 2417 	INC	HL		; Move on
   0F9F C2 A4 0F      [10] 2418 	JP	NZ,NXTARY	; Different - Find next array
   0FA2 7E            [ 7] 2419 	LD	A,(HL)		; Get first byte of name
   0FA3 B8            [ 4] 2420 	CP	B		; Compare with name given
   0FA4 23            [ 6] 2421 NXTARY: INC	HL		; Move on
   0FA5 5E            [ 7] 2422 	LD	E,(HL)		; Get LSB of next array address
   0FA6 23            [ 6] 2423 	INC	HL
   0FA7 56            [ 7] 2424 	LD	D,(HL)		; Get MSB of next array address
   0FA8 23            [ 6] 2425 	INC	HL
   0FA9 C2 90 0F      [10] 2426 	JP	NZ,FNDARY	; Not found - Keep looking
   0FAC 3A F1 80      [13] 2427 	LD	A,(LCRFLG)	; Found Locate or Create it?
   0FAF B7            [ 4] 2428 	OR	A
   0FB0 C2 01 04      [10] 2429 	JP	NZ,DDERR	; Create - ?DD Error
   0FB3 F1            [10] 2430 	POP	AF		; Locate - Get number of dim'ns
   0FB4 44            [ 4] 2431 	LD	B,H		; BC Points to array dim'ns
   0FB5 4D            [ 4] 2432 	LD	C,L
   0FB6 CA D0 15      [10] 2433 	JP	Z,POPHRT	; Jump if array load/save
   0FB9 96            [ 7] 2434 	SUB	(HL)		; Same number of dimensions?
   0FBA CA 20 10      [10] 2435 	JP	Z,FINDEL	; Yes - Find element
   0FBD 1E 10         [ 7] 2436 BSERR:	LD	E,BS		; ?BS Error
   0FBF C3 0C 04      [10] 2437 	JP	ERROR		; Output error
                           2438 ;
   0FC2 11 04 00      [10] 2439 CREARY: LD	DE,4		; 4 Bytes per entry
   0FC5 F1            [10] 2440 	POP	AF		; Array to save or 0 dim'ns?
   0FC6 CA 09 09      [10] 2441 	JP	Z,FCERR		; Yes - ?FC Error
   0FC9 71            [ 7] 2442 	LD	(HL),C		; Save second byte of name
   0FCA 23            [ 6] 2443 	INC	HL
   0FCB 70            [ 7] 2444 	LD	(HL),B		; Save first byte of name
   0FCC 23            [ 6] 2445 	INC	HL
   0FCD 4F            [ 4] 2446 	LD	C,A		; Number of dimensions to C
   0FCE CD D5 03      [17] 2447 	CALL	CHKSTK		; Check if enough memory
   0FD1 23            [ 6] 2448 	INC	HL		; Point to number of dimensions
   0FD2 23            [ 6] 2449 	INC	HL
   0FD3 22 0A 81      [16] 2450 	LD	(CUROPR),HL	; Save address of pointer
   0FD6 71            [ 7] 2451 	LD	(HL),C		; Set number of dimensions
   0FD7 23            [ 6] 2452 	INC	HL
   0FD8 3A F1 80      [13] 2453 	LD	A,(LCRFLG)	; Locate of Create?
   0FDB 17            [ 4] 2454 	RLA			; Carry set = Create
   0FDC 79            [ 4] 2455 	LD	A,C		; Get number of dimensions
   0FDD 01 0B 00      [10] 2456 CRARLP: LD	BC,10+1		; Default dimension size 10
   0FE0 D2 E5 0F      [10] 2457 	JP	NC,DEFSIZ	; Locate - Set default size
   0FE3 C1            [10] 2458 	POP	BC		; Get specified dimension size
   0FE4 03            [ 6] 2459 	INC	BC		; Include zero element
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 46
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   0FE5 71            [ 7] 2460 DEFSIZ: LD	(HL),C		; Save LSB of dimension size
   0FE6 23            [ 6] 2461 	INC	HL
   0FE7 70            [ 7] 2462 	LD	(HL),B		; Save MSB of dimension size
   0FE8 23            [ 6] 2463 	INC	HL
   0FE9 F5            [11] 2464 	PUSH	AF		; Save num' of dim'ns an status
   0FEA E5            [11] 2465 	PUSH	HL		; Save address of dim'n size
   0FEB CD 7B 17      [17] 2466 	CALL	MLDEBC		; Multiply DE by BC to find
   0FEE EB            [ 4] 2467 	EX	DE,HL		; amount of mem needed (to DE)
   0FEF E1            [10] 2468 	POP	HL		; Restore address of dimension
   0FF0 F1            [10] 2469 	POP	AF		; Restore number of dimensions
   0FF1 3D            [ 4] 2470 	DEC	A		; Count them
   0FF2 C2 DD 0F      [10] 2471 	JP	NZ,CRARLP	; Do next dimension if more
   0FF5 F5            [11] 2472 	PUSH	AF		; Save locate/create flag
   0FF6 42            [ 4] 2473 	LD	B,D		; MSB of memory needed
   0FF7 4B            [ 4] 2474 	LD	C,E		; LSB of memory needed
   0FF8 EB            [ 4] 2475 	EX	DE,HL
   0FF9 19            [11] 2476 	ADD	HL,DE		; Add bytes to array start
   0FFA DA ED 03      [10] 2477 	JP	C,OMERR		; Too big - Error
   0FFD CD DE 03      [17] 2478 	CALL	ENFMEM		; See if enough memory
   1000 22 1F 81      [16] 2479 	LD	(ARREND),HL	; Save new end of array
                           2480 ;
   1003 2B            [ 6] 2481 ZERARY: DEC	HL		; Back through array data
   1004 36 00         [10] 2482 	LD	(HL),0		; Set array element to zero
   1006 CD BA 06      [17] 2483 	CALL	CPDEHL		; All elements zeroed?
   1009 C2 03 10      [10] 2484 	JP	NZ,ZERARY	; No - Keep on going
   100C 03            [ 6] 2485 	INC	BC		; Number of bytes + 1
   100D 57            [ 4] 2486 	LD	D,A		; A=0
   100E 2A 0A 81      [16] 2487 	LD	HL,(CUROPR)	; Get address of array
   1011 5E            [ 7] 2488 	LD	E,(HL)		; Number of dimensions
   1012 EB            [ 4] 2489 	EX	DE,HL		; To HL
   1013 29            [11] 2490 	ADD	HL,HL		; Two bytes per dimension size
   1014 09            [11] 2491 	ADD	HL,BC		; Add number of bytes
   1015 EB            [ 4] 2492 	EX	DE,HL		; Bytes needed to DE
   1016 2B            [ 6] 2493 	DEC	HL
   1017 2B            [ 6] 2494 	DEC	HL
   1018 73            [ 7] 2495 	LD	(HL),E		; Save LSB of bytes needed
   1019 23            [ 6] 2496 	INC	HL
   101A 72            [ 7] 2497 	LD	(HL),D		; Save MSB of bytes needed
   101B 23            [ 6] 2498 	INC	HL
   101C F1            [10] 2499 	POP	AF		; Locate / Create?
   101D DA 44 10      [10] 2500 	JP	C,ENDDIM	; A is 0 , End if create
   1020 47            [ 4] 2501 FINDEL: LD	B,A		; Find array element
   1021 4F            [ 4] 2502 	LD	C,A
   1022 7E            [ 7] 2503 	LD	A,(HL)		; Number of dimensions
   1023 23            [ 6] 2504 	INC	HL
   1024 16                 2505 	.db	0x16		; Skip "POP HL"
   1025 E1            [10] 2506 FNDELP: POP	HL		; Address of next dim' size
   1026 5E            [ 7] 2507 	LD	E,(HL)		; Get LSB of dim'n size
   1027 23            [ 6] 2508 	INC	HL
   1028 56            [ 7] 2509 	LD	D,(HL)		; Get MSB of dim'n size
   1029 23            [ 6] 2510 	INC	HL
   102A E3            [19] 2511 	EX	(SP),HL		; Save address - Get index
   102B F5            [11] 2512 	PUSH	AF		; Save number of dim'ns
   102C CD BA 06      [17] 2513 	CALL	CPDEHL		; Dimension too large?
   102F D2 BD 0F      [10] 2514 	JP	NC,BSERR	; Yes - ?BS Error
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 47
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1032 E5            [11] 2515 	PUSH	HL		; Save index
   1033 CD 7B 17      [17] 2516 	CALL	MLDEBC		; Multiply previous by size
   1036 D1            [10] 2517 	POP	DE		; Index supplied to DE
   1037 19            [11] 2518 	ADD	HL,DE		; Add index to pointer
   1038 F1            [10] 2519 	POP	AF		; Number of dimensions
   1039 3D            [ 4] 2520 	DEC	A		; Count them
   103A 44            [ 4] 2521 	LD	B,H		; MSB of pointer
   103B 4D            [ 4] 2522 	LD	C,L		; LSB of pointer
   103C C2 25 10      [10] 2523 	JP	NZ,FNDELP	; More - Keep going
   103F 29            [11] 2524 	ADD	HL,HL		; 4 Bytes per element
   1040 29            [11] 2525 	ADD	HL,HL
   1041 C1            [10] 2526 	POP	BC		; Start of array
   1042 09            [11] 2527 	ADD	HL,BC		; Point to element
   1043 EB            [ 4] 2528 	EX	DE,HL		; Address of element to DE
   1044 2A 15 81      [16] 2529 ENDDIM: LD	HL,(NXTOPR)	; Got code string address
   1047 C9            [10] 2530 	RET
                           2531 ;
   1048 2A 1F 81      [16] 2532 FRE:	LD	HL,(ARREND)	; Start of free memory
   104B EB            [ 4] 2533 	EX	DE,HL		; To DE
   104C 21 00 00      [10] 2534 	LD	HL,0		; End of free memory
   104F 39            [11] 2535 	ADD	HL,SP		; Current stack value
   1050 3A F2 80      [13] 2536 	LD	A,(TYPE)	; Dummy argument type
   1053 B7            [ 4] 2537 	OR	A
   1054 CA 64 10      [10] 2538 	JP	Z,FRENUM	; Numeric - Free variable space
   1057 CD CB 12      [17] 2539 	CALL	GSTRCU		; Current string to pool
   105A CD CB 11      [17] 2540 	CALL	GARBGE		; Garbage collection
   105D 2A 9F 80      [16] 2541 	LD	HL,(STRSPC)	; Bottom of string space in use
   1060 EB            [ 4] 2542 	EX	DE,HL		; To DE
   1061 2A 08 81      [16] 2543 	LD	HL,(STRBOT)	; Bottom of string space
   1064 7D            [ 4] 2544 FRENUM: LD	A,L		; Get LSB of end
   1065 93            [ 4] 2545 	SUB	E		; Subtract LSB of beginning
   1066 4F            [ 4] 2546 	LD	C,A		; Save difference if C
   1067 7C            [ 4] 2547 	LD	A,H		; Get MSB of end
   1068 9A            [ 4] 2548 	SBC	A,D		; Subtract MSB of beginning
   1069 41            [ 4] 2549 ACPASS: LD	B,C		; Return integer AC
   106A 50            [ 4] 2550 ABPASS: LD	D,B		; Return integer AB
   106B 1E 00         [ 7] 2551 	LD	E,0
   106D 21 F2 80      [10] 2552 	LD	HL,TYPE		; Point to type
   1070 73            [ 7] 2553 	LD	(HL),E		; Set type to numeric
   1071 06 90         [ 7] 2554 	LD	B,0x80+16	; 16 bit integer
   1073 C3 A6 16      [10] 2555 	JP	RETINT		; Return the integr
                           2556 ;
   1076 3A F0 80      [13] 2557 POS:	LD	A,(CURPOS)	; Get cursor position
   1079 47            [ 4] 2558 PASSA:	LD	B,A		; Put A into AB
   107A AF            [ 4] 2559 	XOR	A		; Zero A
   107B C3 6A 10      [10] 2560 	JP	ABPASS		; Return integer AB
                           2561 ;
   107E CD 01 11      [17] 2562 DEF:	CALL	CHEKFN		; Get "FN" and name
   1081 CD F3 10      [17] 2563 	CALL	IDTEST		; Test for illegal direct
   1084 01 D9 09      [10] 2564 	LD	BC,DATA		; To get next statement
   1087 C5            [11] 2565 	PUSH	BC		; Save address for RETurn
   1088 D5            [11] 2566 	PUSH	DE		; Save address of function ptr
   1089 CD C0 06      [17] 2567 	CALL	CHKSYN		; Make sure "(" follows
   108C 28                 2568 	.ascii	"("
   108D CD A5 0E      [17] 2569 	CALL	GETVAR		; Get argument variable name
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 48
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1090 E5            [11] 2570 	PUSH	HL		; Save code string address
   1091 EB            [ 4] 2571 	EX	DE,HL		; Argument address to HL
   1092 2B            [ 6] 2572 	DEC	HL
   1093 56            [ 7] 2573 	LD	D,(HL)		; Get first byte of arg name
   1094 2B            [ 6] 2574 	DEC	HL
   1095 5E            [ 7] 2575 	LD	E,(HL)		; Get second byte of arg name
   1096 E1            [10] 2576 	POP	HL		; Restore code string address
   1097 CD B2 0C      [17] 2577 	CALL	TSTNUM		; Make sure numeric argument
   109A CD C0 06      [17] 2578 	CALL	CHKSYN		; Make sure ")" follows
   109D 29                 2579 	.ascii	")"
   109E CD C0 06      [17] 2580 	CALL	CHKSYN		; Make sure "=" follows
   10A1 B4                 2581 	.db	ZEQUAL		; "=" token
   10A2 44            [ 4] 2582 	LD	B,H		; Code string address to BC
   10A3 4D            [ 4] 2583 	LD	C,L
   10A4 E3            [19] 2584 	EX	(SP),HL		; Save code str , Get FN ptr
   10A5 71            [ 7] 2585 	LD	(HL),C		; Save LSB of FN code string
   10A6 23            [ 6] 2586 	INC	HL
   10A7 70            [ 7] 2587 	LD	(HL),B		; Save MSB of FN code string
   10A8 C3 40 11      [10] 2588 	JP	SVSTAD		; Save address and do function
                           2589 ;
   10AB CD 01 11      [17] 2590 DOFN:	CALL	CHEKFN		; Make sure FN follows
   10AE D5            [11] 2591 	PUSH	DE		; Save function pointer address
   10AF CD 86 0D      [17] 2592 	CALL	EVLPAR		; Evaluate expression in "()"
   10B2 CD B2 0C      [17] 2593 	CALL	TSTNUM		; Make sure numeric result
   10B5 E3            [19] 2594 	EX	(SP),HL		; Save code str , Get FN ptr
   10B6 5E            [ 7] 2595 	LD	E,(HL)		; Get LSB of FN code string
   10B7 23            [ 6] 2596 	INC	HL
   10B8 56            [ 7] 2597 	LD	D,(HL)		; Get MSB of FN code string
   10B9 23            [ 6] 2598 	INC	HL
   10BA 7A            [ 4] 2599 	LD	A,D		; And function DEFined?
   10BB B3            [ 4] 2600 	OR	E
   10BC CA 04 04      [10] 2601 	JP	Z,UFERR		; No - ?UF Error
   10BF 7E            [ 7] 2602 	LD	A,(HL)		; Get LSB of argument address
   10C0 23            [ 6] 2603 	INC	HL
   10C1 66            [ 7] 2604 	LD	H,(HL)		; Get MSB of argument address
   10C2 6F            [ 4] 2605 	LD	L,A		; HL = Arg variable address
   10C3 E5            [11] 2606 	PUSH	HL		; Save it
   10C4 2A 23 81      [16] 2607 	LD	HL,(FNRGNM)	; Get old argument name
   10C7 E3            [19] 2608 	EX	(SP),HL;	; Save old , Get new
   10C8 22 23 81      [16] 2609 	LD	(FNRGNM),HL	; Set new argument name
   10CB 2A 27 81      [16] 2610 	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
   10CE E5            [11] 2611 	PUSH	HL		; Save it
   10CF 2A 25 81      [16] 2612 	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
   10D2 E5            [11] 2613 	PUSH	HL		; Save it
   10D3 21 25 81      [10] 2614 	LD	HL,FNARG	; HL = Value of argument
   10D6 D5            [11] 2615 	PUSH	DE		; Save FN code string address
   10D7 CD E7 16      [17] 2616 	CALL	FPTHL		; Move FPREG to argument
   10DA E1            [10] 2617 	POP	HL		; Get FN code string address
   10DB CD AF 0C      [17] 2618 	CALL	GETNUM		; Get value from function
   10DE 2B            [ 6] 2619 	DEC	HL		; DEC 'cos GETCHR INCs
   10DF CD 46 08      [17] 2620 	CALL	GETCHR		; Get next character
   10E2 C2 F8 03      [10] 2621 	JP	NZ,SNERR	; Bad character in FN - Error
   10E5 E1            [10] 2622 	POP	HL		; Get MSB,EXP of old arg
   10E6 22 25 81      [16] 2623 	LD	(FNARG),HL	; Restore it
   10E9 E1            [10] 2624 	POP	HL		; Get LSB,NLSB of old arg
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 49
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   10EA 22 27 81      [16] 2625 	LD	(FNARG+2),HL	; Restore it
   10ED E1            [10] 2626 	POP	HL		; Get name of old arg
   10EE 22 23 81      [16] 2627 	LD	(FNRGNM),HL	; Restore it
   10F1 E1            [10] 2628 	POP	HL		; Restore code string address
   10F2 C9            [10] 2629 	RET
                           2630 ;
   10F3 E5            [11] 2631 IDTEST: PUSH	HL		; Save code string address
   10F4 2A A1 80      [16] 2632 	LD	HL,(LINEAT)	; Get current line number
   10F7 23            [ 6] 2633 	INC	HL		; -1 means direct statement
   10F8 7C            [ 4] 2634 	LD	A,H
   10F9 B5            [ 4] 2635 	OR	L
   10FA E1            [10] 2636 	POP	HL		; Restore code string address
   10FB C0            [11] 2637 	RET	NZ		; Return if in program
   10FC 1E 16         [ 7] 2638 	LD	E,ID		; ?ID Error
   10FE C3 0C 04      [10] 2639 	JP	ERROR
                           2640 ;
   1101 CD C0 06      [17] 2641 CHEKFN: CALL	CHKSYN		; Make sure FN follows
   1104 A7                 2642 	.db	ZFN		; "FN" token
   1105 3E 80         [ 7] 2643 	LD	A,0x80
   1107 32 10 81      [13] 2644 	LD	(FORFLG),A	; Flag FN name to find
   110A B6            [ 7] 2645 	OR	(HL)		; FN name has bit 7 set
   110B 47            [ 4] 2646 	LD	B,A		; in first byte of name
   110C CD AA 0E      [17] 2647 	CALL	GTFNAM		; Get FN name
   110F C3 B2 0C      [10] 2648 	JP	TSTNUM		; Make sure numeric function
                           2649 ;
   1112 CD B2 0C      [17] 2650 STR:	CALL	TSTNUM		; Make sure it's a number
   1115 CD 34 18      [17] 2651 	CALL	NUMASC		; Turn number into text
   1118 CD 46 11      [17] 2652 STR1:	CALL	CRTST		; Create string entry for it
   111B CD CB 12      [17] 2653 	CALL	GSTRCU		; Current string to pool
   111E 01 26 13      [10] 2654 	LD	BC,TOPOOL	; Save in string pool
   1121 C5            [11] 2655 	PUSH	BC		; Save address on stack
                           2656 ;
   1122 7E            [ 7] 2657 SAVSTR: LD	A,(HL)		; Get string length
   1123 23            [ 6] 2658 	INC	HL
   1124 23            [ 6] 2659 	INC	HL
   1125 E5            [11] 2660 	PUSH	HL		; Save pointer to string
   1126 CD A1 11      [17] 2661 	CALL	TESTR		; See if enough string space
   1129 E1            [10] 2662 	POP	HL		; Restore pointer to string
   112A 4E            [ 7] 2663 	LD	C,(HL)		; Get LSB of address
   112B 23            [ 6] 2664 	INC	HL
   112C 46            [ 7] 2665 	LD	B,(HL)		; Get MSB of address
   112D CD 3A 11      [17] 2666 	CALL	CRTMST		; Create string entry
   1130 E5            [11] 2667 	PUSH	HL		; Save pointer to MSB of addr
   1131 6F            [ 4] 2668 	LD	L,A		; Length of string
   1132 CD BE 12      [17] 2669 	CALL	TOSTRA		; Move to string area
   1135 D1            [10] 2670 	POP	DE		; Restore pointer to MSB
   1136 C9            [10] 2671 	RET
                           2672 ;
   1137 CD A1 11      [17] 2673 MKTMST: CALL	TESTR		; See if enough string space
   113A 21 04 81      [10] 2674 CRTMST: LD	HL,TMPSTR	; Temporary string
   113D E5            [11] 2675 	PUSH	HL		; Save it
   113E 77            [ 7] 2676 	LD	(HL),A		; Save length of string
   113F 23            [ 6] 2677 	INC	HL
   1140 23            [ 6] 2678 SVSTAD: INC	HL
   1141 73            [ 7] 2679 	LD	(HL),E		; Save LSB of address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 50
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1142 23            [ 6] 2680 	INC	HL
   1143 72            [ 7] 2681 	LD	(HL),D		; Save MSB of address
   1144 E1            [10] 2682 	POP	HL		; Restore pointer
   1145 C9            [10] 2683 	RET
                           2684 ;
   1146 2B            [ 6] 2685 CRTST:	DEC	HL		; DEC - INCed after
   1147 06 22         [ 7] 2686 QTSTR:	LD	B,'"		; Terminating quote
   1149 50            [ 4] 2687 	LD	D,B		; Quote to D
   114A E5            [11] 2688 DTSTR:	PUSH	HL		; Save start
   114B 0E FF         [ 7] 2689 	LD	C,-1		; Set counter to -1
   114D 23            [ 6] 2690 QTSTLP: INC	HL		; Move on
   114E 7E            [ 7] 2691 	LD	A,(HL)		; Get byte
   114F 0C            [ 4] 2692 	INC	C		; Count bytes
   1150 B7            [ 4] 2693 	OR	A		; End of line?
   1151 CA 5C 11      [10] 2694 	JP	Z,CRTSTE	; Yes - Create string entry
   1154 BA            [ 4] 2695 	CP	D		; Terminator D found?
   1155 CA 5C 11      [10] 2696 	JP	Z,CRTSTE	; Yes - Create string entry
   1158 B8            [ 4] 2697 	CP	B		; Terminator B found?
   1159 C2 4D 11      [10] 2698 	JP	NZ,QTSTLP	; No - Keep looking
   115C FE 22         [ 7] 2699 CRTSTE: CP	'"		; End with '"?
   115E CC 46 08      [17] 2700 	CALL	Z,GETCHR	; Yes - Get next character
   1161 E3            [19] 2701 	EX	(SP),HL		; Starting quote
   1162 23            [ 6] 2702 	INC	HL		; First byte of string
   1163 EB            [ 4] 2703 	EX	DE,HL		; To DE
   1164 79            [ 4] 2704 	LD	A,C		; Get length
   1165 CD 3A 11      [17] 2705 	CALL	CRTMST		; Create string entry
   1168 11 04 81      [10] 2706 TSTOPL: LD	DE,TMPSTR	; Temporary string
   116B 2A F6 80      [16] 2707 	LD	HL,(TMSTPT)	; Temporary string pool pointer
   116E 22 29 81      [16] 2708 	LD	(FPREG),HL	; Save address of string ptr
   1171 3E 01         [ 7] 2709 	LD	A,1
   1173 32 F2 80      [13] 2710 	LD	(TYPE),A	; Set type to string
   1176 CD EA 16      [17] 2711 	CALL	DETHL4		; Move string to pool
   1179 CD BA 06      [17] 2712 	CALL	CPDEHL		; Out of string pool?
   117C 22 F6 80      [16] 2713 	LD	(TMSTPT),HL	; Save new pointer
   117F E1            [10] 2714 	POP	HL		; Restore code string address
   1180 7E            [ 7] 2715 	LD	A,(HL)		; Get next code byte
   1181 C0            [11] 2716 	RET	NZ		; Return if pool OK
   1182 1E 1E         [ 7] 2717 	LD	E,ST		; ?ST Error
   1184 C3 0C 04      [10] 2718 	JP	ERROR		; String pool overflow
                           2719 ;
   1187 23            [ 6] 2720 PRNUMS: INC	HL		; Skip leading space
   1188 CD 46 11      [17] 2721 PRS:	CALL	CRTST		; Create string entry for it
   118B CD CB 12      [17] 2722 PRS1:	CALL	GSTRCU		; Current string to pool
   118E CD DE 16      [17] 2723 	CALL	LOADFP		; Move string block to BCDE
   1191 1C            [ 4] 2724 	INC	E		; Length + 1
   1192 1D            [ 4] 2725 PRSLP:	DEC	E		; Count characters
   1193 C8            [11] 2726 	RET	Z		; End of string
   1194 0A            [ 7] 2727 	LD	A,(BC)		; Get byte to output
   1195 CD CB 06      [17] 2728 	CALL	OUTC		; Output character in A
   1198 FE 0D         [ 7] 2729 	CP	CR		; Return?
   119A CC F4 0A      [17] 2730 	CALL	Z,DONULL	; Yes - Do nulls
   119D 03            [ 6] 2731 	INC	BC		; Next byte in string
   119E C3 92 11      [10] 2732 	JP	PRSLP		; More characters to output
                           2733 ;
   11A1 B7            [ 4] 2734 TESTR:	OR	A		; Test if enough room
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 51
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   11A2 0E                 2735 	.db	0x0E		; No garbage collection done
   11A3 F1            [10] 2736 GRBDON: POP	AF		; Garbage collection done
   11A4 F5            [11] 2737 	PUSH	AF		; Save status
   11A5 2A 9F 80      [16] 2738 	LD	HL,(STRSPC)	; Bottom of string space in use
   11A8 EB            [ 4] 2739 	EX	DE,HL		; To DE
   11A9 2A 08 81      [16] 2740 	LD	HL,(STRBOT)	; Bottom of string area
   11AC 2F            [ 4] 2741 	CPL			; Negate length (Top down)
   11AD 4F            [ 4] 2742 	LD	C,A		; -Length to BC
   11AE 06 FF         [ 7] 2743 	LD	B,-1		; BC = -ve length of string
   11B0 09            [11] 2744 	ADD	HL,BC		; Add to bottom of space in use
   11B1 23            [ 6] 2745 	INC	HL		; Plus one for 2's complement
   11B2 CD BA 06      [17] 2746 	CALL	CPDEHL		; Below string RAM area?
   11B5 DA BF 11      [10] 2747 	JP	C,TESTOS	; Tidy up if not done else err
   11B8 22 08 81      [16] 2748 	LD	(STRBOT),HL	; Save new bottom of area
   11BB 23            [ 6] 2749 	INC	HL		; Point to first byte of string
   11BC EB            [ 4] 2750 	EX	DE,HL		; Address to DE
   11BD F1            [10] 2751 POPAF:	POP	AF		; Throw away status push
   11BE C9            [10] 2752 	RET
                           2753 ;
   11BF F1            [10] 2754 TESTOS: POP	AF		; Garbage collect been done?
   11C0 1E 1A         [ 7] 2755 	LD	E,OS		; ?OS Error
   11C2 CA 0C 04      [10] 2756 	JP	Z,ERROR		; Yes - Not enough string apace
   11C5 BF            [ 4] 2757 	CP	A		; Flag garbage collect done
   11C6 F5            [11] 2758 	PUSH	AF		; Save status
   11C7 01 A3 11      [10] 2759 	LD	BC,GRBDON	; Garbage collection done
   11CA C5            [11] 2760 	PUSH	BC		; Save for RETurn
   11CB 2A F4 80      [16] 2761 GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
   11CE 22 08 81      [16] 2762 GARBLP: LD	(STRBOT),HL	; Reset string pointer
   11D1 21 00 00      [10] 2763 	LD	HL,0
   11D4 E5            [11] 2764 	PUSH	HL		; Flag no string found
   11D5 2A 9F 80      [16] 2765 	LD	HL,(STRSPC)	; Get bottom of string space
   11D8 E5            [11] 2766 	PUSH	HL		; Save bottom of string space
   11D9 21 F8 80      [10] 2767 	LD	HL,TMSTPL	; Temporary string pool
   11DC EB            [ 4] 2768 GRBLP:	EX	DE,HL
   11DD 2A F6 80      [16] 2769 	LD	HL,(TMSTPT)	; Temporary string pool pointer
   11E0 EB            [ 4] 2770 	EX	DE,HL
   11E1 CD BA 06      [17] 2771 	CALL	CPDEHL		; Temporary string pool done?
   11E4 01 DC 11      [10] 2772 	LD	BC,GRBLP	; Loop until string pool done
   11E7 C2 30 12      [10] 2773 	JP	NZ,STPOOL	; No - See if in string area
   11EA 2A 1B 81      [16] 2774 	LD	HL,(PROGND)	; Start of simple variables
   11ED EB            [ 4] 2775 SMPVAR: EX	DE,HL
   11EE 2A 1D 81      [16] 2776 	LD	HL,(VAREND)	; End of simple variables
   11F1 EB            [ 4] 2777 	EX	DE,HL
   11F2 CD BA 06      [17] 2778 	CALL	CPDEHL		; All simple strings done?
   11F5 CA 03 12      [10] 2779 	JP	Z,ARRLP		; Yes - Do string arrays
   11F8 7E            [ 7] 2780 	LD	A,(HL)		; Get type of variable
   11F9 23            [ 6] 2781 	INC	HL
   11FA 23            [ 6] 2782 	INC	HL
   11FB B7            [ 4] 2783 	OR	A		; "S" flag set if string
   11FC CD 33 12      [17] 2784 	CALL	STRADD		; See if string in string area
   11FF C3 ED 11      [10] 2785 	JP	SMPVAR		; Loop until simple ones done
                           2786 ;
   1202 C1            [10] 2787 GNXARY: POP	BC		; Scrap address of this array
   1203 EB            [ 4] 2788 ARRLP:	EX	DE,HL
   1204 2A 1F 81      [16] 2789 	LD	HL,(ARREND)	; End of string arrays
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 52
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1207 EB            [ 4] 2790 	EX	DE,HL
   1208 CD BA 06      [17] 2791 	CALL	CPDEHL		; All string arrays done?
   120B CA 59 12      [10] 2792 	JP	Z,SCNEND	; Yes - Move string if found
   120E CD DE 16      [17] 2793 	CALL	LOADFP		; Get array name to BCDE
   1211 7B            [ 4] 2794 	LD	A,E		; Get type of array	
   1212 E5            [11] 2795 	PUSH	HL		; Save address of num of dim'ns
   1213 09            [11] 2796 	ADD	HL,BC		; Start of next array
   1214 B7            [ 4] 2797 	OR	A		; Test type of array
   1215 F2 02 12      [10] 2798 	JP	P,GNXARY	; Numeric array - Ignore it
   1218 22 0A 81      [16] 2799 	LD	(CUROPR),HL	; Save address of next array
   121B E1            [10] 2800 	POP	HL		; Get address of num of dim'ns
   121C 4E            [ 7] 2801 	LD	C,(HL)		; BC = Number of dimensions
   121D 06 00         [ 7] 2802 	LD	B,0
   121F 09            [11] 2803 	ADD	HL,BC		; Two bytes per dimension size
   1220 09            [11] 2804 	ADD	HL,BC
   1221 23            [ 6] 2805 	INC	HL		; Plus one for number of dim'ns
   1222 EB            [ 4] 2806 GRBARY: EX	DE,HL
   1223 2A 0A 81      [16] 2807 	LD	HL,(CUROPR)	; Get address of next array
   1226 EB            [ 4] 2808 	EX	DE,HL
   1227 CD BA 06      [17] 2809 	CALL	CPDEHL		; Is this array finished?
   122A CA 03 12      [10] 2810 	JP	Z,ARRLP		; Yes - Get next one
   122D 01 22 12      [10] 2811 	LD	BC,GRBARY	; Loop until array all done
   1230 C5            [11] 2812 STPOOL: PUSH	BC		; Save return address
   1231 F6 80         [ 7] 2813 	OR	0x80		; Flag string type
   1233 7E            [ 7] 2814 STRADD: LD	A,(HL)		; Get string length
   1234 23            [ 6] 2815 	INC	HL
   1235 23            [ 6] 2816 	INC	HL
   1236 5E            [ 7] 2817 	LD	E,(HL)		; Get LSB of string address
   1237 23            [ 6] 2818 	INC	HL
   1238 56            [ 7] 2819 	LD	D,(HL)		; Get MSB of string address
   1239 23            [ 6] 2820 	INC	HL
   123A F0            [11] 2821 	RET	P		; Not a string - Return
   123B B7            [ 4] 2822 	OR	A		; Set flags on string length
   123C C8            [11] 2823 	RET	Z		; Null string - Return
   123D 44            [ 4] 2824 	LD	B,H		; Save variable pointer
   123E 4D            [ 4] 2825 	LD	C,L
   123F 2A 08 81      [16] 2826 	LD	HL,(STRBOT)	; Bottom of new area
   1242 CD BA 06      [17] 2827 	CALL	CPDEHL		; String been done?
   1245 60            [ 4] 2828 	LD	H,B		; Restore variable pointer
   1246 69            [ 4] 2829 	LD	L,C
   1247 D8            [11] 2830 	RET	C		; String done - Ignore
   1248 E1            [10] 2831 	POP	HL		; Return address
   1249 E3            [19] 2832 	EX	(SP),HL		; Lowest available string area
   124A CD BA 06      [17] 2833 	CALL	CPDEHL		; String within string area?
   124D E3            [19] 2834 	EX	(SP),HL		; Lowest available string area
   124E E5            [11] 2835 	PUSH	HL		; Re-save return address
   124F 60            [ 4] 2836 	LD	H,B		; Restore variable pointer
   1250 69            [ 4] 2837 	LD	L,C
   1251 D0            [11] 2838 	RET	NC		; Outside string area - Ignore
   1252 C1            [10] 2839 	POP	BC		; Get return , Throw 2 away
   1253 F1            [10] 2840 	POP	AF		; 
   1254 F1            [10] 2841 	POP	AF		; 
   1255 E5            [11] 2842 	PUSH	HL		; Save variable pointer
   1256 D5            [11] 2843 	PUSH	DE		; Save address of current
   1257 C5            [11] 2844 	PUSH	BC		; Put back return address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 53
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1258 C9            [10] 2845 	RET			; Go to it
                           2846 ;
   1259 D1            [10] 2847 SCNEND: POP	DE		; Addresses of strings
   125A E1            [10] 2848 	POP	HL		; 
   125B 7D            [ 4] 2849 	LD	A,L		; HL = 0 if no more to do
   125C B4            [ 4] 2850 	OR	H
   125D C8            [11] 2851 	RET	Z		; No more to do - Return
   125E 2B            [ 6] 2852 	DEC	HL
   125F 46            [ 7] 2853 	LD	B,(HL)		; MSB of address of string
   1260 2B            [ 6] 2854 	DEC	HL
   1261 4E            [ 7] 2855 	LD	C,(HL)		; LSB of address of string
   1262 E5            [11] 2856 	PUSH	HL		; Save variable address
   1263 2B            [ 6] 2857 	DEC	HL
   1264 2B            [ 6] 2858 	DEC	HL
   1265 6E            [ 7] 2859 	LD	L,(HL)		; HL = Length of string
   1266 26 00         [ 7] 2860 	LD	H,0
   1268 09            [11] 2861 	ADD	HL,BC		; Address of end of string+1
   1269 50            [ 4] 2862 	LD	D,B		; String address to DE
   126A 59            [ 4] 2863 	LD	E,C
   126B 2B            [ 6] 2864 	DEC	HL		; Last byte in string
   126C 44            [ 4] 2865 	LD	B,H		; Address to BC
   126D 4D            [ 4] 2866 	LD	C,L
   126E 2A 08 81      [16] 2867 	LD	HL,(STRBOT)	; Current bottom of string area
   1271 CD C7 03      [17] 2868 	CALL	MOVSTR		; Move string to new address
   1274 E1            [10] 2869 	POP	HL		; Restore variable address
   1275 71            [ 7] 2870 	LD	(HL),C		; Save new LSB of address
   1276 23            [ 6] 2871 	INC	HL
   1277 70            [ 7] 2872 	LD	(HL),B		; Save new MSB of address
   1278 69            [ 4] 2873 	LD	L,C		; Next string area+1 to HL
   1279 60            [ 4] 2874 	LD	H,B
   127A 2B            [ 6] 2875 	DEC	HL		; Next string area address
   127B C3 CE 11      [10] 2876 	JP	GARBLP		; Look for more strings
                           2877 ;
   127E C5            [11] 2878 CONCAT: PUSH	BC		; Save prec' opr & code string
   127F E5            [11] 2879 	PUSH	HL		; 
   1280 2A 29 81      [16] 2880 	LD	HL,(FPREG)	; Get first string
   1283 E3            [19] 2881 	EX	(SP),HL		; Save first string
   1284 CD 38 0D      [17] 2882 	CALL	OPRND		; Get second string
   1287 E3            [19] 2883 	EX	(SP),HL		; Restore first string
   1288 CD B3 0C      [17] 2884 	CALL	TSTSTR		; Make sure it's a string
   128B 7E            [ 7] 2885 	LD	A,(HL)		; Get length of second string
   128C E5            [11] 2886 	PUSH	HL		; Save first string
   128D 2A 29 81      [16] 2887 	LD	HL,(FPREG)	; Get second string
   1290 E5            [11] 2888 	PUSH	HL		; Save second string
   1291 86            [ 7] 2889 	ADD	A,(HL)		; Add length of second string
   1292 1E 1C         [ 7] 2890 	LD	E,LS		; ?LS Error
   1294 DA 0C 04      [10] 2891 	JP	C,ERROR		; String too long - Error
   1297 CD 37 11      [17] 2892 	CALL	MKTMST		; Make temporary string
   129A D1            [10] 2893 	POP	DE		; Get second string to DE
   129B CD CF 12      [17] 2894 	CALL	GSTRDE		; Move to string pool if needed
   129E E3            [19] 2895 	EX	(SP),HL		; Get first string
   129F CD CE 12      [17] 2896 	CALL	GSTRHL		; Move to string pool if needed
   12A2 E5            [11] 2897 	PUSH	HL		; Save first string
   12A3 2A 06 81      [16] 2898 	LD	HL,(TMPSTR+2)	; Temporary string address
   12A6 EB            [ 4] 2899 	EX	DE,HL		; To DE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 54
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   12A7 CD B5 12      [17] 2900 	CALL	SSTSA		; First string to string area
   12AA CD B5 12      [17] 2901 	CALL	SSTSA		; Second string to string area
   12AD 21 CD 0C      [10] 2902 	LD	HL,EVAL2	; Return to evaluation loop
   12B0 E3            [19] 2903 	EX	(SP),HL		; Save return,get code string
   12B1 E5            [11] 2904 	PUSH	HL		; Save code string address
   12B2 C3 68 11      [10] 2905 	JP	TSTOPL		; To temporary string to pool
                           2906 ;
   12B5 E1            [10] 2907 SSTSA:	POP	HL		; Return address
   12B6 E3            [19] 2908 	EX	(SP),HL		; Get string block,save return
   12B7 7E            [ 7] 2909 	LD	A,(HL)		; Get length of string
   12B8 23            [ 6] 2910 	INC	HL
   12B9 23            [ 6] 2911 	INC	HL
   12BA 4E            [ 7] 2912 	LD	C,(HL)		; Get LSB of string address
   12BB 23            [ 6] 2913 	INC	HL
   12BC 46            [ 7] 2914 	LD	B,(HL)		; Get MSB of string address
   12BD 6F            [ 4] 2915 	LD	L,A		; Length to L
   12BE 2C            [ 4] 2916 TOSTRA: INC	L		; INC - DECed after
   12BF 2D            [ 4] 2917 TSALP:	DEC	L		; Count bytes moved
   12C0 C8            [11] 2918 	RET	Z		; End of string - Return
   12C1 0A            [ 7] 2919 	LD	A,(BC)		; Get source
   12C2 12            [ 7] 2920 	LD	(DE),A		; Save destination
   12C3 03            [ 6] 2921 	INC	BC		; Next source
   12C4 13            [ 6] 2922 	INC	DE		; Next destination
   12C5 C3 BF 12      [10] 2923 	JP	TSALP		; Loop until string moved
                           2924 ;
   12C8 CD B3 0C      [17] 2925 GETSTR: CALL	TSTSTR		; Make sure it's a string
   12CB 2A 29 81      [16] 2926 GSTRCU: LD	HL,(FPREG)	; Get current string
   12CE EB            [ 4] 2927 GSTRHL: EX	DE,HL		; Save DE
   12CF CD E9 12      [17] 2928 GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
   12D2 EB            [ 4] 2929 	EX	DE,HL		; Restore DE
   12D3 C0            [11] 2930 	RET	NZ		; No - Return
   12D4 D5            [11] 2931 	PUSH	DE		; Save string
   12D5 50            [ 4] 2932 	LD	D,B		; String block address to DE
   12D6 59            [ 4] 2933 	LD	E,C
   12D7 1B            [ 6] 2934 	DEC	DE		; Point to length
   12D8 4E            [ 7] 2935 	LD	C,(HL)		; Get string length
   12D9 2A 08 81      [16] 2936 	LD	HL,(STRBOT)	; Current bottom of string area
   12DC CD BA 06      [17] 2937 	CALL	CPDEHL		; Last one in string area?
   12DF C2 E7 12      [10] 2938 	JP	NZ,POPHL	; No - Return
   12E2 47            [ 4] 2939 	LD	B,A		; Clear B (A=0)
   12E3 09            [11] 2940 	ADD	HL,BC		; Remove string from str' area
   12E4 22 08 81      [16] 2941 	LD	(STRBOT),HL	; Save new bottom of str' area
   12E7 E1            [10] 2942 POPHL:	POP	HL		; Restore string
   12E8 C9            [10] 2943 	RET
                           2944 ;
   12E9 2A F6 80      [16] 2945 BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
   12EC 2B            [ 6] 2946 	DEC	HL		; Back
   12ED 46            [ 7] 2947 	LD	B,(HL)		; Get MSB of address
   12EE 2B            [ 6] 2948 	DEC	HL		; Back
   12EF 4E            [ 7] 2949 	LD	C,(HL)		; Get LSB of address
   12F0 2B            [ 6] 2950 	DEC	HL		; Back
   12F1 2B            [ 6] 2951 	DEC	HL		; Back
   12F2 CD BA 06      [17] 2952 	CALL	CPDEHL		; String last in string pool?
   12F5 C0            [11] 2953 	RET	NZ		; Yes - Leave it
   12F6 22 F6 80      [16] 2954 	LD	(TMSTPT),HL	; Save new string pool top
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 55
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   12F9 C9            [10] 2955 	RET
                           2956 ;
   12FA 01 79 10      [10] 2957 LEN:	LD	BC,PASSA	; To return integer A
   12FD C5            [11] 2958 	PUSH	BC		; Save address
   12FE CD C8 12      [17] 2959 GETLEN: CALL	GETSTR		; Get string and its length
   1301 AF            [ 4] 2960 	XOR	A
   1302 57            [ 4] 2961 	LD	D,A		; Clear D
   1303 32 F2 80      [13] 2962 	LD	(TYPE),A	; Set type to numeric
   1306 7E            [ 7] 2963 	LD	A,(HL)		; Get length of string
   1307 B7            [ 4] 2964 	OR	A		; Set status flags
   1308 C9            [10] 2965 	RET
                           2966 ;
   1309 01 79 10      [10] 2967 ASC:	LD	BC,PASSA	; To return integer A
   130C C5            [11] 2968 	PUSH	BC		; Save address
   130D CD FE 12      [17] 2969 GTFLNM: CALL	GETLEN		; Get length of string
   1310 CA 09 09      [10] 2970 	JP	Z,FCERR		; Null string - Error
   1313 23            [ 6] 2971 	INC	HL
   1314 23            [ 6] 2972 	INC	HL
   1315 5E            [ 7] 2973 	LD	E,(HL)		; Get LSB of address
   1316 23            [ 6] 2974 	INC	HL
   1317 56            [ 7] 2975 	LD	D,(HL)		; Get MSB of address
   1318 1A            [ 7] 2976 	LD	A,(DE)		; Get first byte of string
   1319 C9            [10] 2977 	RET
                           2978 ;
   131A 3E 01         [ 7] 2979 CHR:	LD	A,1		; One character string
   131C CD 37 11      [17] 2980 	CALL	MKTMST		; Make a temporary string
   131F CD 13 14      [17] 2981 	CALL	MAKINT		; Make it integer A
   1322 2A 06 81      [16] 2982 	LD	HL,(TMPSTR+2)	; Get address of string
   1325 73            [ 7] 2983 	LD	(HL),E		; Save character
   1326 C1            [10] 2984 TOPOOL: POP	BC		; Clean up stack
   1327 C3 68 11      [10] 2985 	JP	TSTOPL		; Temporary string to pool
                           2986 ;
   132A CD C3 13      [17] 2987 LEFT:	CALL	LFRGNM		; Get number and ending ")"
   132D AF            [ 4] 2988 	XOR	A		; Start at first byte in string
   132E E3            [19] 2989 RIGHT1: EX	(SP),HL		; Save code string,Get string
   132F 4F            [ 4] 2990 	LD	C,A		; Starting position in string
   1330 E5            [11] 2991 MID1:	PUSH	HL		; Save string block address
   1331 7E            [ 7] 2992 	LD	A,(HL)		; Get length of string
   1332 B8            [ 4] 2993 	CP	B		; Compare with number given
   1333 DA 38 13      [10] 2994 	JP	C,ALLFOL	; All following bytes required
   1336 78            [ 4] 2995 	LD	A,B		; Get new length
   1337 11                 2996 	.db	0x11		; Skip "LD C,0"
   1338 0E 00         [ 7] 2997 ALLFOL: LD	C,0		; First byte of string
   133A C5            [11] 2998 	PUSH	BC		; Save position in string
   133B CD A1 11      [17] 2999 	CALL	TESTR		; See if enough string space
   133E C1            [10] 3000 	POP	BC		; Get position in string
   133F E1            [10] 3001 	POP	HL		; Restore string block address
   1340 E5            [11] 3002 	PUSH	HL		; And re-save it
   1341 23            [ 6] 3003 	INC	HL
   1342 23            [ 6] 3004 	INC	HL
   1343 46            [ 7] 3005 	LD	B,(HL)		; Get LSB of address
   1344 23            [ 6] 3006 	INC	HL
   1345 66            [ 7] 3007 	LD	H,(HL)		; Get MSB of address
   1346 68            [ 4] 3008 	LD	L,B		; HL = address of string
   1347 06 00         [ 7] 3009 	LD	B,0		; BC = starting address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 56
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1349 09            [11] 3010 	ADD	HL,BC		; Point to that byte
   134A 44            [ 4] 3011 	LD	B,H		; BC = source string
   134B 4D            [ 4] 3012 	LD	C,L
   134C CD 3A 11      [17] 3013 	CALL	CRTMST		; Create a string entry
   134F 6F            [ 4] 3014 	LD	L,A		; Length of new string
   1350 CD BE 12      [17] 3015 	CALL	TOSTRA		; Move string to string area
   1353 D1            [10] 3016 	POP	DE		; Clear stack
   1354 CD CF 12      [17] 3017 	CALL	GSTRDE		; Move to string pool if needed
   1357 C3 68 11      [10] 3018 	JP	TSTOPL		; Temporary string to pool
                           3019 ;
   135A CD C3 13      [17] 3020 RIGHT:	CALL	LFRGNM		; Get number and ending ")"
   135D D1            [10] 3021 	POP	DE		; Get string length
   135E D5            [11] 3022 	PUSH	DE		; And re-save
   135F 1A            [ 7] 3023 	LD	A,(DE)		; Get length
   1360 90            [ 4] 3024 	SUB	B		; Move back N bytes
   1361 C3 2E 13      [10] 3025 	JP	RIGHT1		; Go and get sub-string
                           3026 ;
   1364 EB            [ 4] 3027 MID:	EX	DE,HL		; Get code string address
   1365 7E            [ 7] 3028 	LD	A,(HL)		; Get next byte ', or ")"
   1366 CD C8 13      [17] 3029 	CALL	MIDNUM		; Get number supplied
   1369 04            [ 4] 3030 	INC	B		; Is it character zero?
   136A 05            [ 4] 3031 	DEC	B
   136B CA 09 09      [10] 3032 	JP	Z,FCERR		; Yes - Error
   136E C5            [11] 3033 	PUSH	BC		; Save starting position
   136F 1E FF         [ 7] 3034 	LD	E,255		; All of string
   1371 FE 29         [ 7] 3035 	CP	')		; Any length given?
   1373 CA 7D 13      [10] 3036 	JP	Z,RSTSTR	; No - Rest of string
   1376 CD C0 06      [17] 3037 	CALL	CHKSYN		; Make sure ', follows
   1379 2C                 3038 	.db	',
   137A CD 10 14      [17] 3039 	CALL	GETINT		; Get integer 0-255
   137D CD C0 06      [17] 3040 RSTSTR: CALL	CHKSYN		; Make sure ")" follows
   1380 29                 3041 	.ascii	")"
   1381 F1            [10] 3042 	POP	AF		; Restore starting position
   1382 E3            [19] 3043 	EX	(SP),HL		; Get string,8ave code string
   1383 01 30 13      [10] 3044 	LD	BC,MID1		; Continuation of MID$ routine
   1386 C5            [11] 3045 	PUSH	BC		; Save for return
   1387 3D            [ 4] 3046 	DEC	A		; Starting position-1
   1388 BE            [ 7] 3047 	CP	(HL)		; Compare with length
   1389 06 00         [ 7] 3048 	LD	B,0		; Zero bytes length
   138B D0            [11] 3049 	RET	NC		; Null string if start past end
   138C 4F            [ 4] 3050 	LD	C,A		; Save starting position-1
   138D 7E            [ 7] 3051 	LD	A,(HL)		; Get length of string
   138E 91            [ 4] 3052 	SUB	C		; Subtract start
   138F BB            [ 4] 3053 	CP	E		; Enough string for it?
   1390 47            [ 4] 3054 	LD	B,A		; Save maximum length available
   1391 D8            [11] 3055 	RET	C		; Truncate string if needed
   1392 43            [ 4] 3056 	LD	B,E		; Set specified length
   1393 C9            [10] 3057 	RET			; Go and create string
                           3058 ;
   1394 CD FE 12      [17] 3059 VAL:	CALL	GETLEN		; Get length of string
   1397 CA B1 14      [10] 3060 	JP	Z,RESZER	; Result zero
   139A 5F            [ 4] 3061 	LD	E,A		; Save length
   139B 23            [ 6] 3062 	INC	HL
   139C 23            [ 6] 3063 	INC	HL
   139D 7E            [ 7] 3064 	LD	A,(HL)		; Get LSB of address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 57
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   139E 23            [ 6] 3065 	INC	HL
   139F 66            [ 7] 3066 	LD	H,(HL)		; Get MSB of address
   13A0 6F            [ 4] 3067 	LD	L,A		; HL = String address
   13A1 E5            [11] 3068 	PUSH	HL		; Save string address
   13A2 19            [11] 3069 	ADD	HL,DE
   13A3 46            [ 7] 3070 	LD	B,(HL)		; Get end of string+1 byte
   13A4 72            [ 7] 3071 	LD	(HL),D		; Zero it to terminate
   13A5 E3            [19] 3072 	EX	(SP),HL		; Save string end,get start
   13A6 C5            [11] 3073 	PUSH	BC		; Save end+1 byte
   13A7 7E            [ 7] 3074 	LD	A,(HL)		; Get starting byte
   13A8 FE 24         [ 7] 3075 	CP	'$		; Hex number indicated? [function added]
   13AA C2 B2 13      [10] 3076 	JP	NZ,VAL1
u  13AD CD 00 00      [17] 3077 	CALL	HEXTFP		; Convert Hex to FPREG
   13B0 18 0D         [12] 3078 	JR	VAL3
   13B2 FE 25         [ 7] 3079 VAL1:	CP	'%		; Binary number indicated? [function added]
   13B4 C2 BC 13      [10] 3080 	JP	NZ,VAL2
   13B7 CD 34 1C      [17] 3081 	CALL	BINTFP		; Convert Bin to FPREG
   13BA 18 03         [12] 3082 	JR	VAL3
   13BC CD 96 17      [17] 3083 VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
   13BF C1            [10] 3084 VAL3:	POP	BC		; Restore end+1 byte
   13C0 E1            [10] 3085 	POP	HL		; Restore end+1 address
   13C1 70            [ 7] 3086 	LD	(HL),B		; Put back original byte
   13C2 C9            [10] 3087 	RET
                           3088 ;
   13C3 EB            [ 4] 3089 LFRGNM: EX	DE,HL		; Code string address to HL
   13C4 CD C0 06      [17] 3090 	CALL	CHKSYN		; Make sure ")" follows
   13C7 29                 3091 	.ascii	")"
   13C8 C1            [10] 3092 MIDNUM: POP	BC		; Get return address
   13C9 D1            [10] 3093 	POP	DE		; Get number supplied
   13CA C5            [11] 3094 	PUSH	BC		; Re-save return address
   13CB 43            [ 4] 3095 	LD	B,E		; Number to B
   13CC C9            [10] 3096 	RET
                           3097 ;
   13CD CD 13 14      [17] 3098 INP:	CALL	MAKINT		; Make it integer A
   13D0 32 84 80      [13] 3099 	LD	(INPORT),A	; Set input port
   13D3 CD 83 80      [17] 3100 	CALL	INPSUB		; Get input from port
   13D6 C3 79 10      [10] 3101 	JP	PASSA		; Return integer A
                           3102 ;
   13D9 CD FD 13      [17] 3103 POUT:	CALL	SETIO		; Set up port number
   13DC C3 4B 80      [10] 3104 	JP	OUTSUB		; Output data and return
                           3105 ;
   13DF CD FD 13      [17] 3106 WAIT:	CALL	SETIO		; Set up port number
   13E2 F5            [11] 3107 	PUSH	AF		; Save AND mask
   13E3 1E 00         [ 7] 3108 	LD	E,0		; Assume zero if none given
   13E5 2B            [ 6] 3109 	DEC	HL		; DEC 'cos GETCHR INCs
   13E6 CD 46 08      [17] 3110 	CALL	GETCHR		; Get next character
   13E9 CA F3 13      [10] 3111 	JP	Z,NOXOR		; No XOR byte given
   13EC CD C0 06      [17] 3112 	CALL	CHKSYN		; Make sure ', follows
   13EF 2C                 3113 	.db	',
   13F0 CD 10 14      [17] 3114 	CALL	GETINT		; Get integer 0-255 to XOR with
   13F3 C1            [10] 3115 NOXOR:	POP	BC		; Restore AND mask
   13F4 CD 83 80      [17] 3116 WAITLP: CALL	INPSUB		; Get input
   13F7 AB            [ 4] 3117 	XOR	E		; Flip selected bits
   13F8 A0            [ 4] 3118 	AND	B		; Result non-zero?
   13F9 CA F4 13      [10] 3119 	JP	Z,WAITLP	; No = keep waiting
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 58
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   13FC C9            [10] 3120 	RET
                           3121 ;
   13FD CD 10 14      [17] 3122 SETIO:	CALL	GETINT		; Get integer 0-255
   1400 32 84 80      [13] 3123 	LD	(INPORT),A	; Set input port
   1403 32 4C 80      [13] 3124 	LD	(OTPORT),A	; Set output port
   1406 CD C0 06      [17] 3125 	CALL	CHKSYN		; Make sure ', follows
   1409 2C                 3126 	.db	',
   140A C3 10 14      [10] 3127 	JP	GETINT		; Get integer 0-255 and return
                           3128 ;
   140D CD 46 08      [17] 3129 FNDNUM: CALL	GETCHR		; Get next character
   1410 CD AF 0C      [17] 3130 GETINT: CALL	GETNUM		; Get a number from 0 to 255
   1413 CD EE 08      [17] 3131 MAKINT: CALL	DEPINT		; Make sure value 0 - 255
   1416 7A            [ 4] 3132 	LD	A,D		; Get MSB of number
   1417 B7            [ 4] 3133 	OR	A		; Zero?
   1418 C2 09 09      [10] 3134 	JP	NZ,FCERR	; No - Error
   141B 2B            [ 6] 3135 	DEC	HL		; DEC 'cos GETCHR INCs
   141C CD 46 08      [17] 3136 	CALL	GETCHR		; Get next character
   141F 7B            [ 4] 3137 	LD	A,E		; Get number to A
   1420 C9            [10] 3138 	RET
                           3139 ;
   1421 CD F4 08      [17] 3140 PEEK:	CALL	DEINT		; Get memory address
   1424 1A            [ 7] 3141 	LD	A,(DE)		; Get byte in memory
   1425 C3 79 10      [10] 3142 	JP	PASSA		; Return integer A
                           3143 ;
   1428 CD AF 0C      [17] 3144 POKE:	CALL	GETNUM		; Get memory address
   142B CD F4 08      [17] 3145 	CALL	DEINT		; Get integer -32768 to 3276
   142E D5            [11] 3146 	PUSH	DE		; Save memory address
   142F CD C0 06      [17] 3147 	CALL	CHKSYN		; Make sure ', follows
   1432 2C                 3148 	.db	',
   1433 CD 10 14      [17] 3149 	CALL	GETINT		; Get integer 0-255
   1436 D1            [10] 3150 	POP	DE		; Restore memory address
   1437 12            [ 7] 3151 	LD	(DE),A		; Load it into memory
   1438 C9            [10] 3152 	RET
                           3153 ;
   1439 21 0D 19      [10] 3154 ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
   143C CD DE 16      [17] 3155 ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
   143F C3 4B 14      [10] 3156 	JP	FPADD		; Add BCDE to FPREG
                           3157 ;
   1442 CD DE 16      [17] 3158 SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
   1445 21                 3159 	.db	0x21		; Skip "POP BC" and "POP DE"
   1446 C1            [10] 3160 PSUB:	POP	BC		; Get FP number from stack
   1447 D1            [10] 3161 	POP	DE
   1448 CD B8 16      [17] 3162 SUBCDE: CALL	INVSGN		; Negate FPREG
   144B 78            [ 4] 3163 FPADD:	LD	A,B		; Get FP exponent
   144C B7            [ 4] 3164 	OR	A		; Is number zero?
   144D C8            [11] 3165 	RET	Z		; Yes - Nothing to add
   144E 3A 2C 81      [13] 3166 	LD	A,(FPEXP)	; Get FPREG exponent
   1451 B7            [ 4] 3167 	OR	A		; Is this number zero?
   1452 CA D0 16      [10] 3168 	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
   1455 90            [ 4] 3169 	SUB	B		; BCDE number larger?
   1456 D2 65 14      [10] 3170 	JP	NC,NOSWAP	; No - Don't swap them
   1459 2F            [ 4] 3171 	CPL			; Two's complement
   145A 3C            [ 4] 3172 	INC	A		;	FP exponent
   145B EB            [ 4] 3173 	EX	DE,HL
   145C CD C0 16      [17] 3174 	CALL	STAKFP		; Put FPREG on stack
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 59
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   145F EB            [ 4] 3175 	EX	DE,HL
   1460 CD D0 16      [17] 3176 	CALL	FPBCDE		; Move BCDE to FPREG
   1463 C1            [10] 3177 	POP	BC		; Restore number from stack
   1464 D1            [10] 3178 	POP	DE
   1465 FE 19         [ 7] 3179 NOSWAP: CP	24+1		; Second number insignificant?
   1467 D0            [11] 3180 	RET	NC		; Yes - First number is result
   1468 F5            [11] 3181 	PUSH	AF		; Save number of bits to scale
   1469 CD F5 16      [17] 3182 	CALL	SIGNS		; Set MSBs & sign of result
   146C 67            [ 4] 3183 	LD	H,A		; Save sign of result
   146D F1            [10] 3184 	POP	AF		; Restore scaling factor
   146E CD 0E 15      [17] 3185 	CALL	SCALE		; Scale BCDE to same exponent
   1471 B4            [ 4] 3186 	OR	H		; Result to be positive?
   1472 21 29 81      [10] 3187 	LD	HL,FPREG	; Point to FPREG
   1475 F2 8B 14      [10] 3188 	JP	P,MINCDE	; No - Subtract FPREG from CDE
   1478 CD EE 14      [17] 3189 	CALL	PLUCDE		; Add FPREG to CDE
   147B D2 D1 14      [10] 3190 	JP	NC,RONDUP	; No overflow - Round it up
   147E 23            [ 6] 3191 	INC	HL		; Point to exponent
   147F 34            [11] 3192 	INC	(HL)		; Increment it
   1480 CA 07 04      [10] 3193 	JP	Z,OVERR		; Number overflowed - Error
   1483 2E 01         [ 7] 3194 	LD	L,1		; 1 bit to shift right
   1485 CD 24 15      [17] 3195 	CALL	SHRT1		; Shift result right
   1488 C3 D1 14      [10] 3196 	JP	RONDUP		; Round it up
                           3197 ;
   148B AF            [ 4] 3198 MINCDE: XOR	A		; Clear A and carry
   148C 90            [ 4] 3199 	SUB	B		; Negate exponent
   148D 47            [ 4] 3200 	LD	B,A		; Re-save exponent
   148E 7E            [ 7] 3201 	LD	A,(HL)		; Get LSB of FPREG
   148F 9B            [ 4] 3202 	SBC	A, E		; Subtract LSB of BCDE
   1490 5F            [ 4] 3203 	LD	E,A		; Save LSB of BCDE
   1491 23            [ 6] 3204 	INC	HL
   1492 7E            [ 7] 3205 	LD	A,(HL)		; Get NMSB of FPREG
   1493 9A            [ 4] 3206 	SBC	A,D		; Subtract NMSB of BCDE
   1494 57            [ 4] 3207 	LD	D,A		; Save NMSB of BCDE
   1495 23            [ 6] 3208 	INC	HL
   1496 7E            [ 7] 3209 	LD	A,(HL)		; Get MSB of FPREG
   1497 99            [ 4] 3210 	SBC	A,C		; Subtract MSB of BCDE
   1498 4F            [ 4] 3211 	LD	C,A		; Save MSB of BCDE
   1499 DC FA 14      [17] 3212 CONPOS: CALL	C,COMPL		; Overflow - Make it positive
                           3213 ;
   149C 68            [ 4] 3214 BNORM:	LD	L,B		; L = Exponent
   149D 63            [ 4] 3215 	LD	H,E		; H = LSB
   149E AF            [ 4] 3216 	XOR	A
   149F 47            [ 4] 3217 BNRMLP: LD	B,A		; Save bit count
   14A0 79            [ 4] 3218 	LD	A,C		; Get MSB
   14A1 B7            [ 4] 3219 	OR	A		; Is it zero?
   14A2 C2 BE 14      [10] 3220 	JP	NZ,PNORM	; No - Do it bit at a time
   14A5 4A            [ 4] 3221 	LD	C,D		; MSB = NMSB
   14A6 54            [ 4] 3222 	LD	D,H		; NMSB= LSB
   14A7 65            [ 4] 3223 	LD	H,L		; LSB = VLSB
   14A8 6F            [ 4] 3224 	LD	L,A		; VLSB= 0
   14A9 78            [ 4] 3225 	LD	A,B		; Get exponent
   14AA D6 08         [ 7] 3226 	SUB	8		; Count 8 bits
   14AC FE E0         [ 7] 3227 	CP	0x0E0		; -24-8 Was number zero?
   14AE C2 9F 14      [10] 3228 	JP	NZ,BNRMLP	; No - Keep normalising
   14B1 AF            [ 4] 3229 RESZER: XOR	A		; Result is zero
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 60
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   14B2 32 2C 81      [13] 3230 SAVEXP: LD	(FPEXP),A	; Save result as zero
   14B5 C9            [10] 3231 	RET
                           3232 ;
   14B6 05            [ 4] 3233 NORMAL: DEC	B		; Count bits
   14B7 29            [11] 3234 	ADD	HL,HL		; Shift HL left
   14B8 7A            [ 4] 3235 	LD	A,D		; Get NMSB
   14B9 17            [ 4] 3236 	RLA			; Shift left with last bit
   14BA 57            [ 4] 3237 	LD	D,A		; Save NMSB
   14BB 79            [ 4] 3238 	LD	A,C		; Get MSB
   14BC 8F            [ 4] 3239 	ADC	A,A		; Shift left with last bit
   14BD 4F            [ 4] 3240 	LD	C,A		; Save MSB
   14BE F2 B6 14      [10] 3241 PNORM:	JP	P,NORMAL	; Not done - Keep going
   14C1 78            [ 4] 3242 	LD	A,B		; Number of bits shifted
   14C2 5C            [ 4] 3243 	LD	E,H		; Save HL in EB
   14C3 45            [ 4] 3244 	LD	B,L
   14C4 B7            [ 4] 3245 	OR	A		; Any shifting done?
   14C5 CA D1 14      [10] 3246 	JP	Z,RONDUP	; No - Round it up
   14C8 21 2C 81      [10] 3247 	LD	HL,FPEXP	; Point to exponent
   14CB 86            [ 7] 3248 	ADD	A,(HL)		; Add shifted bits
   14CC 77            [ 7] 3249 	LD	(HL),A		; Re-save exponent
   14CD D2 B1 14      [10] 3250 	JP	NC,RESZER	; Underflow - Result is zero
   14D0 C8            [11] 3251 	RET	Z		; Result is zero
   14D1 78            [ 4] 3252 RONDUP: LD	A,B		; Get VLSB of number
   14D2 21 2C 81      [10] 3253 RONDB:	LD	HL,FPEXP	; Point to exponent
   14D5 B7            [ 4] 3254 	OR	A		; Any rounding?
   14D6 FC E1 14      [17] 3255 	CALL	M,FPROND	; Yes - Round number up
   14D9 46            [ 7] 3256 	LD	B,(HL)		; B = Exponent
   14DA 23            [ 6] 3257 	INC	HL
   14DB 7E            [ 7] 3258 	LD	A,(HL)		; Get sign of result
kq 14DC                    3259 	AND	10000000B	; Only bit 7 needed
   14DC A9            [ 4] 3260 	XOR	C		; Set correct sign
   14DD 4F            [ 4] 3261 	LD	C,A		; Save correct sign in number
   14DE C3 D0 16      [10] 3262 	JP	FPBCDE		; Move BCDE to FPREG
                           3263 ;
   14E1 1C            [ 4] 3264 FPROND: INC	E		; Round LSB
   14E2 C0            [11] 3265 	RET	NZ		; Return if ok
   14E3 14            [ 4] 3266 	INC	D		; Round NMSB
   14E4 C0            [11] 3267 	RET	NZ		; Return if ok
   14E5 0C            [ 4] 3268 	INC	C		; Round MSB
   14E6 C0            [11] 3269 	RET	NZ		; Return if ok
   14E7 0E 80         [ 7] 3270 	LD	C,0x80		; Set normal value
   14E9 34            [11] 3271 	INC	(HL)		; Increment exponent
   14EA C0            [11] 3272 	RET	NZ		; Return if ok
   14EB C3 07 04      [10] 3273 	JP	OVERR		; Overflow error
                           3274 ;
   14EE 7E            [ 7] 3275 PLUCDE: LD	A,(HL)		; Get LSB of FPREG
   14EF 83            [ 4] 3276 	ADD	A,E		; Add LSB of BCDE
   14F0 5F            [ 4] 3277 	LD	E,A		; Save LSB of BCDE
   14F1 23            [ 6] 3278 	INC	HL
   14F2 7E            [ 7] 3279 	LD	A,(HL)		; Get NMSB of FPREG
   14F3 8A            [ 4] 3280 	ADC	A,D		; Add NMSB of BCDE
   14F4 57            [ 4] 3281 	LD	D,A		; Save NMSB of BCDE
   14F5 23            [ 6] 3282 	INC	HL
   14F6 7E            [ 7] 3283 	LD	A,(HL)		; Get MSB of FPREG
   14F7 89            [ 4] 3284 	ADC	A,C		; Add MSB of BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 61
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   14F8 4F            [ 4] 3285 	LD	C,A		; Save MSB of BCDE
   14F9 C9            [10] 3286 	RET
                           3287 ;
   14FA 21 2D 81      [10] 3288 COMPL:	LD	HL,SGNRES	; Sign of result
   14FD 7E            [ 7] 3289 	LD	A,(HL)		; Get sign of result
   14FE 2F            [ 4] 3290 	CPL			; Negate it
   14FF 77            [ 7] 3291 	LD	(HL),A		; Put it back
   1500 AF            [ 4] 3292 	XOR	A
   1501 6F            [ 4] 3293 	LD	L,A		; Set L to zero
   1502 90            [ 4] 3294 	SUB	B		; Negate exponent,set carry
   1503 47            [ 4] 3295 	LD	B,A		; Re-save exponent
   1504 7D            [ 4] 3296 	LD	A,L		; Load zero
   1505 9B            [ 4] 3297 	SBC	A,E		; Negate LSB
   1506 5F            [ 4] 3298 	LD	E,A		; Re-save LSB
   1507 7D            [ 4] 3299 	LD	A,L		; Load zero
   1508 9A            [ 4] 3300 	SBC	A,D		; Negate NMSB
   1509 57            [ 4] 3301 	LD	D,A		; Re-save NMSB
   150A 7D            [ 4] 3302 	LD	A,L		; Load zero
   150B 99            [ 4] 3303 	SBC	A,C		; Negate MSB
   150C 4F            [ 4] 3304 	LD	C,A		; Re-save MSB
   150D C9            [10] 3305 	RET
                           3306 ;
   150E 06 00         [ 7] 3307 SCALE:	LD	B,0		; Clear underflow
   1510 D6 08         [ 7] 3308 SCALLP: SUB	8		; 8 bits (a whole byte)?
   1512 DA 1D 15      [10] 3309 	JP	C,SHRITE	; No - Shift right A bits
   1515 43            [ 4] 3310 	LD	B,E		; <- Shift
   1516 5A            [ 4] 3311 	LD	E,D		; <- right
   1517 51            [ 4] 3312 	LD	D,C		; <- eight
   1518 0E 00         [ 7] 3313 	LD	C,0		; <- bits
   151A C3 10 15      [10] 3314 	JP	SCALLP		; More bits to shift
                           3315 ;
   151D C6 09         [ 7] 3316 SHRITE: ADD	A,8+1		; Adjust count
   151F 6F            [ 4] 3317 	LD	L,A		; Save bits to shift
   1520 AF            [ 4] 3318 SHRLP:	XOR	A		; Flag for all done
   1521 2D            [ 4] 3319 	DEC	L		; All shifting done?
   1522 C8            [11] 3320 	RET	Z		; Yes - Return
   1523 79            [ 4] 3321 	LD	A,C		; Get MSB
   1524 1F            [ 4] 3322 SHRT1:	RRA			; Shift it right
   1525 4F            [ 4] 3323 	LD	C,A		; Re-save
   1526 7A            [ 4] 3324 	LD	A,D		; Get NMSB
   1527 1F            [ 4] 3325 	RRA			; Shift right with last bit
   1528 57            [ 4] 3326 	LD	D,A		; Re-save it
   1529 7B            [ 4] 3327 	LD	A,E		; Get LSB
   152A 1F            [ 4] 3328 	RRA			; Shift right with last bit
   152B 5F            [ 4] 3329 	LD	E,A		; Re-save it
   152C 78            [ 4] 3330 	LD	A,B		; Get underflow
   152D 1F            [ 4] 3331 	RRA			; Shift right with last bit
   152E 47            [ 4] 3332 	LD	B,A		; Re-save underflow
   152F C3 20 15      [10] 3333 	JP	SHRLP		; More bits to do
                           3334 ;
   1532 00 00 00 81        3335 UNITY:	.db	 0x000,0x000,0x000,0x081	; 1.00000
                           3336 ;
   1536 03                 3337 LOGTAB: .db	3			; Table used by LOG
   1537 AA 56 19 80        3338 	.db	0x0AA,0x056,0x019,0x080	; 0.59898
   153B F1 22 76 80        3339 	.db	0x0F1,0x022,0x076,0x080	; 0.96147
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 62
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   153F 45 AA 38 82        3340 	.db	0x045,0x0AA,0x038,0x082	; 2.88539
                           3341 ;
   1543 CD 8F 16      [17] 3342 LOG:	CALL	TSTSGN		; Test sign of value
   1546 B7            [ 4] 3343 	OR	A
   1547 EA 09 09      [10] 3344 	JP	PE,FCERR	; ?FC Error if <= zero
   154A 21 2C 81      [10] 3345 	LD	HL,FPEXP	; Point to exponent
   154D 7E            [ 7] 3346 	LD	A,(HL)		; Get exponent
   154E 01 35 80      [10] 3347 	LD	BC,0x8035	; BCDE = SQR(1/2)
   1551 11 F3 04      [10] 3348 	LD	DE,0x04F3
   1554 90            [ 4] 3349 	SUB	B		; Scale value to be < 1
   1555 F5            [11] 3350 	PUSH	AF		; Save scale factor
   1556 70            [ 7] 3351 	LD	(HL),B		; Save new exponent
   1557 D5            [11] 3352 	PUSH	DE		; Save SQR(1/2)
   1558 C5            [11] 3353 	PUSH	BC
   1559 CD 4B 14      [17] 3354 	CALL	FPADD		; Add SQR(1/2) to value
   155C C1            [10] 3355 	POP	BC		; Restore SQR(1/2)
   155D D1            [10] 3356 	POP	DE
   155E 04            [ 4] 3357 	INC	B		; Make it SQR(2)
   155F CD E5 15      [17] 3358 	CALL	DVBCDE		; Divide by SQR(2)
   1562 21 32 15      [10] 3359 	LD	HL,UNITY	; Point to 1.
   1565 CD 42 14      [17] 3360 	CALL	SUBPHL		; Subtract FPREG from 1
   1568 21 36 15      [10] 3361 	LD	HL,LOGTAB	; Coefficient table
   156B CD D5 19      [17] 3362 	CALL	SUMSER		; Evaluate sum of series
   156E 01 80 80      [10] 3363 	LD	BC,0x8080	; BCDE = -0.5
   1571 11 00 00      [10] 3364 	LD	DE,0x0000
   1574 CD 4B 14      [17] 3365 	CALL	FPADD		; Subtract 0.5 from FPREG
   1577 F1            [10] 3366 	POP	AF		; Restore scale factor
   1578 CD 0A 18      [17] 3367 	CALL	RSCALE		; Re-scale number
   157B 01 31 80      [10] 3368 MULLN2: LD	BC,0x8031	; BCDE = Ln(2)
   157E 11 18 72      [10] 3369 	LD	DE,0x7218
   1581 21                 3370 	.db	0x21		; Skip "POP BC" and "POP DE"
                           3371 ;
   1582 C1            [10] 3372 MULT:	POP	BC		; Get number from stack
   1583 D1            [10] 3373 	POP	DE
   1584 CD 8F 16      [17] 3374 FPMULT: CALL	TSTSGN		; Test sign of FPREG
   1587 C8            [11] 3375 	RET	Z		; Return zero if zero
   1588 2E 00         [ 7] 3376 	LD	L,0		; Flag add exponents
   158A CD 4D 16      [17] 3377 	CALL	ADDEXP		; Add exponents
   158D 79            [ 4] 3378 	LD	A,C		; Get MSB of multiplier
   158E 32 3B 81      [13] 3379 	LD	(MULVAL),A	; Save MSB of multiplier
   1591 EB            [ 4] 3380 	EX	DE,HL
   1592 22 3C 81      [16] 3381 	LD	(MULVAL+1),HL	; Save rest of multiplier
   1595 01 00 00      [10] 3382 	LD	BC,0		; Partial product (BCDE) = zero
   1598 50            [ 4] 3383 	LD	D,B
   1599 58            [ 4] 3384 	LD	E,B
   159A 21 9C 14      [10] 3385 	LD	HL,BNORM	; Address of normalise
   159D E5            [11] 3386 	PUSH	HL		; Save for return
   159E 21 A6 15      [10] 3387 	LD	HL,MULT8	; Address of 8 bit multiply
   15A1 E5            [11] 3388 	PUSH	HL		; Save for NMSB,MSB
   15A2 E5            [11] 3389 	PUSH	HL		; 
   15A3 21 29 81      [10] 3390 	LD	HL,FPREG	; Point to number
   15A6 7E            [ 7] 3391 MULT8:	LD	A,(HL)		; Get LSB of number
   15A7 23            [ 6] 3392 	INC	HL		; Point to NMSB
   15A8 B7            [ 4] 3393 	OR	A		; Test LSB
   15A9 CA D2 15      [10] 3394 	JP	Z,BYTSFT	; Zero - shift to next byte
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 63
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   15AC E5            [11] 3395 	PUSH	HL		; Save address of number
   15AD 2E 08         [ 7] 3396 	LD	L,8		; 8 bits to multiply by
   15AF 1F            [ 4] 3397 MUL8LP: RRA			; Shift LSB right
   15B0 67            [ 4] 3398 	LD	H,A		; Save LSB
   15B1 79            [ 4] 3399 	LD	A,C		; Get MSB
   15B2 D2 C0 15      [10] 3400 	JP	NC,NOMADD	; Bit was zero - Don't add
   15B5 E5            [11] 3401 	PUSH	HL		; Save LSB and count
   15B6 2A 3C 81      [16] 3402 	LD	HL,(MULVAL+1)	; Get LSB and NMSB
   15B9 19            [11] 3403 	ADD	HL,DE		; Add NMSB and LSB
   15BA EB            [ 4] 3404 	EX	DE,HL		; Leave sum in DE
   15BB E1            [10] 3405 	POP	HL		; Restore MSB and count
   15BC 3A 3B 81      [13] 3406 	LD	A,(MULVAL)	; Get MSB of multiplier
   15BF 89            [ 4] 3407 	ADC	A,C		; Add MSB
   15C0 1F            [ 4] 3408 NOMADD: RRA			; Shift MSB right
   15C1 4F            [ 4] 3409 	LD	C,A		; Re-save MSB
   15C2 7A            [ 4] 3410 	LD	A,D		; Get NMSB
   15C3 1F            [ 4] 3411 	RRA			; Shift NMSB right
   15C4 57            [ 4] 3412 	LD	D,A		; Re-save NMSB
   15C5 7B            [ 4] 3413 	LD	A,E		; Get LSB
   15C6 1F            [ 4] 3414 	RRA			; Shift LSB right
   15C7 5F            [ 4] 3415 	LD	E,A		; Re-save LSB
   15C8 78            [ 4] 3416 	LD	A,B		; Get VLSB
   15C9 1F            [ 4] 3417 	RRA			; Shift VLSB right
   15CA 47            [ 4] 3418 	LD	B,A		; Re-save VLSB
   15CB 2D            [ 4] 3419 	DEC	L		; Count bits multiplied
   15CC 7C            [ 4] 3420 	LD	A,H		; Get LSB of multiplier
   15CD C2 AF 15      [10] 3421 	JP	NZ,MUL8LP	; More - Do it
   15D0 E1            [10] 3422 POPHRT: POP	HL		; Restore address of number
   15D1 C9            [10] 3423 	RET
                           3424 ;
   15D2 43            [ 4] 3425 BYTSFT: LD	B,E		; Shift partial product left
   15D3 5A            [ 4] 3426 	LD	E,D
   15D4 51            [ 4] 3427 	LD	D,C
   15D5 4F            [ 4] 3428 	LD	C,A
   15D6 C9            [10] 3429 	RET
                           3430 ;
   15D7 CD C0 16      [17] 3431 DIV10:	CALL	STAKFP		; Save FPREG on stack
   15DA 01 20 84      [10] 3432 	LD	BC,0x8420	; BCDE = 10.
   15DD 11 00 00      [10] 3433 	LD	DE,0x0000
   15E0 CD D0 16      [17] 3434 	CALL	FPBCDE		; Move 10 to FPREG
                           3435 ;
   15E3 C1            [10] 3436 DIV:	POP	BC		; Get number from stack
   15E4 D1            [10] 3437 	POP	DE
   15E5 CD 8F 16      [17] 3438 DVBCDE: CALL	TSTSGN		; Test sign of FPREG
   15E8 CA FB 03      [10] 3439 	JP	Z,DZERR		; Error if division by zero
   15EB 2E FF         [ 7] 3440 	LD	L,-1		; Flag subtract exponents
   15ED CD 4D 16      [17] 3441 	CALL	ADDEXP		; Subtract exponents
   15F0 34            [11] 3442 	INC	(HL)		; Add 2 to exponent to adjust
   15F1 34            [11] 3443 	INC	(HL)
   15F2 2B            [ 6] 3444 	DEC	HL		; Point to MSB
   15F3 7E            [ 7] 3445 	LD	A,(HL)		; Get MSB of dividend
   15F4 32 57 80      [13] 3446 	LD	(DIV3),A	; Save for subtraction
   15F7 2B            [ 6] 3447 	DEC	HL
   15F8 7E            [ 7] 3448 	LD	A,(HL)		; Get NMSB of dividend
   15F9 32 53 80      [13] 3449 	LD	(DIV2),A	; Save for subtraction
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 64
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   15FC 2B            [ 6] 3450 	DEC	HL
   15FD 7E            [ 7] 3451 	LD	A,(HL)		; Get MSB of dividend
   15FE 32 4F 80      [13] 3452 	LD	(DIV1),A	; Save for subtraction
   1601 41            [ 4] 3453 	LD	B,C		; Get MSB
   1602 EB            [ 4] 3454 	EX	DE,HL		; NMSB,LSB to HL
   1603 AF            [ 4] 3455 	XOR	A
   1604 4F            [ 4] 3456 	LD	C,A		; Clear MSB of quotient
   1605 57            [ 4] 3457 	LD	D,A		; Clear NMSB of quotient
   1606 5F            [ 4] 3458 	LD	E,A		; Clear LSB of quotient
   1607 32 5A 80      [13] 3459 	LD	(DIV4),A	; Clear overflow count
   160A E5            [11] 3460 DIVLP:	PUSH	HL		; Save divisor
   160B C5            [11] 3461 	PUSH	BC
   160C 7D            [ 4] 3462 	LD	A,L		; Get LSB of number
   160D CD 4E 80      [17] 3463 	CALL	DIVSUP		; Subt' divisor from dividend
   1610 DE 00         [ 7] 3464 	SBC	A,0		; Count for overflows
   1612 3F            [ 4] 3465 	CCF
   1613 D2 1D 16      [10] 3466 	JP	NC,RESDIV	; Restore divisor if borrow
   1616 32 5A 80      [13] 3467 	LD	(DIV4),A	; Re-save overflow count
   1619 F1            [10] 3468 	POP	AF		; Scrap divisor
   161A F1            [10] 3469 	POP	AF
   161B 37            [ 4] 3470 	SCF			; Set carry to
   161C D2                 3471 	.db	0x0D2		; Skip "POP BC" and "POP HL"
                           3472 ;
   161D C1            [10] 3473 RESDIV: POP	BC		; Restore divisor
   161E E1            [10] 3474 	POP	HL
   161F 79            [ 4] 3475 	LD	A,C		; Get MSB of quotient
   1620 3C            [ 4] 3476 	INC	A
   1621 3D            [ 4] 3477 	DEC	A
   1622 1F            [ 4] 3478 	RRA			; Bit 0 to bit 7
   1623 FA D2 14      [10] 3479 	JP	M,RONDB		; Done - Normalise result
   1626 17            [ 4] 3480 	RLA			; Restore carry
   1627 7B            [ 4] 3481 	LD	A,E		; Get LSB of quotient
   1628 17            [ 4] 3482 	RLA			; Double it
   1629 5F            [ 4] 3483 	LD	E,A		; Put it back
   162A 7A            [ 4] 3484 	LD	A,D		; Get NMSB of quotient
   162B 17            [ 4] 3485 	RLA			; Double it
   162C 57            [ 4] 3486 	LD	D,A		; Put it back
   162D 79            [ 4] 3487 	LD	A,C		; Get MSB of quotient
   162E 17            [ 4] 3488 	RLA			; Double it
   162F 4F            [ 4] 3489 	LD	C,A		; Put it back
   1630 29            [11] 3490 	ADD	HL,HL		; Double NMSB,LSB of divisor
   1631 78            [ 4] 3491 	LD	A,B		; Get MSB of divisor
   1632 17            [ 4] 3492 	RLA			; Double it
   1633 47            [ 4] 3493 	LD	B,A		; Put it back
   1634 3A 5A 80      [13] 3494 	LD	A,(DIV4)	; Get VLSB of quotient
   1637 17            [ 4] 3495 	RLA			; Double it
   1638 32 5A 80      [13] 3496 	LD	(DIV4),A	; Put it back
   163B 79            [ 4] 3497 	LD	A,C		; Get MSB of quotient
   163C B2            [ 4] 3498 	OR	D		; Merge NMSB
   163D B3            [ 4] 3499 	OR	E		; Merge LSB
   163E C2 0A 16      [10] 3500 	JP	NZ,DIVLP	; Not done - Keep dividing
   1641 E5            [11] 3501 	PUSH	HL		; Save divisor
   1642 21 2C 81      [10] 3502 	LD	HL,FPEXP	; Point to exponent
   1645 35            [11] 3503 	DEC	(HL)		; Divide by 2
   1646 E1            [10] 3504 	POP	HL		; Restore divisor
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 65
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1647 C2 0A 16      [10] 3505 	JP	NZ,DIVLP	; Ok - Keep going
   164A C3 07 04      [10] 3506 	JP	OVERR		; Overflow error
                           3507 ;
   164D 78            [ 4] 3508 ADDEXP: LD	A,B		; Get exponent of dividend
   164E B7            [ 4] 3509 	OR	A		; Test it
   164F CA 71 16      [10] 3510 	JP	Z,OVTST3	; Zero - Result zero
   1652 7D            [ 4] 3511 	LD	A,L		; Get add/subtract flag
   1653 21 2C 81      [10] 3512 	LD	HL,FPEXP	; Point to exponent
   1656 AE            [ 7] 3513 	XOR	(HL)		; Add or subtract it
   1657 80            [ 4] 3514 	ADD	A,B		; Add the other exponent
   1658 47            [ 4] 3515 	LD	B,A		; Save new exponent
   1659 1F            [ 4] 3516 	RRA			; Test exponent for overflow
   165A A8            [ 4] 3517 	XOR	B
   165B 78            [ 4] 3518 	LD	A,B		; Get exponent
   165C F2 70 16      [10] 3519 	JP	P,OVTST2	; Positive - Test for overflow
   165F C6 80         [ 7] 3520 	ADD	A,0x80		; Add excess 128
   1661 77            [ 7] 3521 	LD	(HL),A		; Save new exponent
   1662 CA D0 15      [10] 3522 	JP	Z,POPHRT	; Zero - Result zero
   1665 CD F5 16      [17] 3523 	CALL	SIGNS		; Set MSBs and sign of result
   1668 77            [ 7] 3524 	LD	(HL),A		; Save new exponent
   1669 2B            [ 6] 3525 	DEC	HL		; Point to MSB
   166A C9            [10] 3526 	RET
                           3527 ;
   166B CD 8F 16      [17] 3528 OVTST1: CALL	TSTSGN		; Test sign of FPREG
   166E 2F            [ 4] 3529 	CPL			; Invert sign
   166F E1            [10] 3530 	POP	HL		; Clean up stack
   1670 B7            [ 4] 3531 OVTST2: OR	A		; Test if new exponent zero
   1671 E1            [10] 3532 OVTST3: POP	HL		; Clear off return address
   1672 F2 B1 14      [10] 3533 	JP	P,RESZER	; Result zero
   1675 C3 07 04      [10] 3534 	JP	OVERR		; Overflow error
                           3535 ;
   1678 CD DB 16      [17] 3536 MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
   167B 78            [ 4] 3537 	LD	A,B		; Get exponent
   167C B7            [ 4] 3538 	OR	A		; Is it zero?
   167D C8            [11] 3539 	RET	Z		; Yes - Result is zero
   167E C6 02         [ 7] 3540 	ADD	A,2		; Multiply by 4
   1680 DA 07 04      [10] 3541 	JP	C,OVERR		; Overflow - ?OV Error
   1683 47            [ 4] 3542 	LD	B,A		; Re-save exponent
   1684 CD 4B 14      [17] 3543 	CALL	FPADD		; Add BCDE to FPREG (Times 5)
   1687 21 2C 81      [10] 3544 	LD	HL,FPEXP	; Point to exponent
   168A 34            [11] 3545 	INC	(HL)		; Double number (Times 10)
   168B C0            [11] 3546 	RET	NZ		; Ok - Return
   168C C3 07 04      [10] 3547 	JP	OVERR		; Overflow error
                           3548 ;
   168F 3A 2C 81      [13] 3549 TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
   1692 B7            [ 4] 3550 	OR	A
   1693 C8            [11] 3551 	RET	Z		; RETurn if number is zero
   1694 3A 2B 81      [13] 3552 	LD	A,(FPREG+2)	; Get MSB of FPREG
   1697 FE                 3553 	.db	0x0FE		; Test sign
   1698 2F            [ 4] 3554 RETREL: CPL			; Invert sign
   1699 17            [ 4] 3555 	RLA			; Sign bit to carry
   169A 9F            [ 4] 3556 FLGDIF: SBC	A,A		; Carry to all bits of A
   169B C0            [11] 3557 	RET	NZ		; Return -1 if negative
   169C 3C            [ 4] 3558 	INC	A		; Bump to +1
   169D C9            [10] 3559 	RET			; Positive - Return +1
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 66
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



                           3560 ;
   169E CD 8F 16      [17] 3561 SGN:	CALL	TSTSGN		; Test sign of FPREG
   16A1 06 88         [ 7] 3562 FLGREL: LD	B,0x80+8		; 8 bit integer in exponent
   16A3 11 00 00      [10] 3563 	LD	DE,0		; Zero NMSB and LSB
   16A6 21 2C 81      [10] 3564 RETINT: LD	HL,FPEXP	; Point to exponent
   16A9 4F            [ 4] 3565 	LD	C,A		; CDE = MSB,NMSB and LSB
   16AA 70            [ 7] 3566 	LD	(HL),B		; Save exponent
   16AB 06 00         [ 7] 3567 	LD	B,0		; CDE = integer to normalise
   16AD 23            [ 6] 3568 	INC	HL		; Point to sign of result
   16AE 36 80         [10] 3569 	LD	(HL),0x80	; Set sign of result
   16B0 17            [ 4] 3570 	RLA			; Carry = sign of integer
   16B1 C3 99 14      [10] 3571 	JP	CONPOS		; Set sign of result
                           3572 ;
   16B4 CD 8F 16      [17] 3573 ABS:	CALL	TSTSGN		; Test sign of FPREG
   16B7 F0            [11] 3574 	RET	P		; Return if positive
   16B8 21 2B 81      [10] 3575 INVSGN: LD	HL,FPREG+2	; Point to MSB
   16BB 7E            [ 7] 3576 	LD	A,(HL)		; Get sign of mantissa
   16BC EE 80         [ 7] 3577 	XOR	0x80		; Invert sign of mantissa
   16BE 77            [ 7] 3578 	LD	(HL),A		; Re-save sign of mantissa
   16BF C9            [10] 3579 	RET
                           3580 ;
   16C0 EB            [ 4] 3581 STAKFP: EX	DE,HL		; Save code string address
   16C1 2A 29 81      [16] 3582 	LD	HL,(FPREG)	; LSB,NLSB of FPREG
   16C4 E3            [19] 3583 	EX	(SP),HL		; Stack them,get return
   16C5 E5            [11] 3584 	PUSH	HL		; Re-save return
   16C6 2A 2B 81      [16] 3585 	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
   16C9 E3            [19] 3586 	EX	(SP),HL		; Stack them,get return
   16CA E5            [11] 3587 	PUSH	HL		; Re-save return
   16CB EB            [ 4] 3588 	EX	DE,HL		; Restore code string address
   16CC C9            [10] 3589 	RET
                           3590 ;
   16CD CD DE 16      [17] 3591 PHLTFP: CALL	LOADFP		; Number at HL to BCDE
   16D0 EB            [ 4] 3592 FPBCDE: EX	DE,HL		; Save code string address
   16D1 22 29 81      [16] 3593 	LD	(FPREG),HL	; Save LSB,NLSB of number
   16D4 60            [ 4] 3594 	LD	H,B		; Exponent of number
   16D5 69            [ 4] 3595 	LD	L,C		; MSB of number
   16D6 22 2B 81      [16] 3596 	LD	(FPREG+2),HL	; Save MSB and exponent
   16D9 EB            [ 4] 3597 	EX	DE,HL		; Restore code string address
   16DA C9            [10] 3598 	RET
                           3599 ;
   16DB 21 29 81      [10] 3600 BCDEFP: LD	HL,FPREG	; Point to FPREG
   16DE 5E            [ 7] 3601 LOADFP: LD	E,(HL)		; Get LSB of number
   16DF 23            [ 6] 3602 	INC	HL
   16E0 56            [ 7] 3603 	LD	D,(HL)		; Get NMSB of number
   16E1 23            [ 6] 3604 	INC	HL
   16E2 4E            [ 7] 3605 	LD	C,(HL)		; Get MSB of number
   16E3 23            [ 6] 3606 	INC	HL
   16E4 46            [ 7] 3607 	LD	B,(HL)		; Get exponent of number
   16E5 23            [ 6] 3608 INCHL:	INC	HL		; Used for conditional "INC HL"
   16E6 C9            [10] 3609 	RET
                           3610 ;
   16E7 11 29 81      [10] 3611 FPTHL:	LD	DE,FPREG	; Point to FPREG
   16EA 06 04         [ 7] 3612 DETHL4: LD	B,4		; 4 bytes to move
   16EC 1A            [ 7] 3613 DETHLB: LD	A,(DE)		; Get source
   16ED 77            [ 7] 3614 	LD	(HL),A		; Save destination
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 67
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   16EE 13            [ 6] 3615 	INC	DE		; Next source
   16EF 23            [ 6] 3616 	INC	HL		; Next destination
   16F0 05            [ 4] 3617 	DEC	B		; Count bytes
   16F1 C2 EC 16      [10] 3618 	JP	NZ,DETHLB	; Loop if more
   16F4 C9            [10] 3619 	RET
                           3620 ;
   16F5 21 2B 81      [10] 3621 SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
   16F8 7E            [ 7] 3622 	LD	A,(HL)		; Get MSB
   16F9 07            [ 4] 3623 	RLCA			; Old sign to carry
   16FA 37            [ 4] 3624 	SCF			; Set MSBit
   16FB 1F            [ 4] 3625 	RRA			; Set MSBit of MSB
   16FC 77            [ 7] 3626 	LD	(HL),A		; Save new MSB
   16FD 3F            [ 4] 3627 	CCF			; Complement sign
   16FE 1F            [ 4] 3628 	RRA			; Old sign to carry
   16FF 23            [ 6] 3629 	INC	HL
   1700 23            [ 6] 3630 	INC	HL
   1701 77            [ 7] 3631 	LD	(HL),A		; Set sign of result
   1702 79            [ 4] 3632 	LD	A,C		; Get MSB
   1703 07            [ 4] 3633 	RLCA			; Old sign to carry
   1704 37            [ 4] 3634 	SCF			; Set MSBit
   1705 1F            [ 4] 3635 	RRA			; Set MSBit of MSB
   1706 4F            [ 4] 3636 	LD	C,A		; Save MSB
   1707 1F            [ 4] 3637 	RRA
   1708 AE            [ 7] 3638 	XOR	(HL)		; New sign of result
   1709 C9            [10] 3639 	RET
                           3640 ;
   170A 78            [ 4] 3641 CMPNUM: LD	A,B		; Get exponent of number
   170B B7            [ 4] 3642 	OR	A
   170C CA 8F 16      [10] 3643 	JP	Z,TSTSGN	; Zero - Test sign of FPREG
   170F 21 98 16      [10] 3644 	LD	HL,RETREL	; Return relation routine
   1712 E5            [11] 3645 	PUSH	HL		; Save for return
   1713 CD 8F 16      [17] 3646 	CALL	TSTSGN		; Test sign of FPREG
   1716 79            [ 4] 3647 	LD	A,C		; Get MSB of number
   1717 C8            [11] 3648 	RET	Z		; FPREG zero - Number's MSB
   1718 21 2B 81      [10] 3649 	LD	HL,FPREG+2	; MSB of FPREG
   171B AE            [ 7] 3650 	XOR	(HL)		; Combine signs
   171C 79            [ 4] 3651 	LD	A,C		; Get MSB of number
   171D F8            [11] 3652 	RET	M		; Exit if signs different
   171E CD 24 17      [17] 3653 	CALL	CMPFP		; Compare FP numbers
   1721 1F            [ 4] 3654 	RRA			; Get carry to sign
   1722 A9            [ 4] 3655 	XOR	C		; Combine with MSB of number
   1723 C9            [10] 3656 	RET
                           3657 ;
   1724 23            [ 6] 3658 CMPFP:	INC	HL		; Point to exponent
   1725 78            [ 4] 3659 	LD	A,B		; Get exponent
   1726 BE            [ 7] 3660 	CP	(HL)		; Compare exponents
   1727 C0            [11] 3661 	RET	NZ		; Different
   1728 2B            [ 6] 3662 	DEC	HL		; Point to MBS
   1729 79            [ 4] 3663 	LD	A,C		; Get MSB
   172A BE            [ 7] 3664 	CP	(HL)		; Compare MSBs
   172B C0            [11] 3665 	RET	NZ		; Different
   172C 2B            [ 6] 3666 	DEC	HL		; Point to NMSB
   172D 7A            [ 4] 3667 	LD	A,D		; Get NMSB
   172E BE            [ 7] 3668 	CP	(HL)		; Compare NMSBs
   172F C0            [11] 3669 	RET	NZ		; Different
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 68
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1730 2B            [ 6] 3670 	DEC	HL		; Point to LSB
   1731 7B            [ 4] 3671 	LD	A,E		; Get LSB
   1732 96            [ 7] 3672 	SUB	(HL)		; Compare LSBs
   1733 C0            [11] 3673 	RET	NZ		; Different
   1734 E1            [10] 3674 	POP	HL		; Drop RETurn
   1735 E1            [10] 3675 	POP	HL		; Drop another RETurn
   1736 C9            [10] 3676 	RET
                           3677 ;
   1737 47            [ 4] 3678 FPINT:	LD	B,A		; <- Move
   1738 4F            [ 4] 3679 	LD	C,A		; <- exponent
   1739 57            [ 4] 3680 	LD	D,A		; <- to all
   173A 5F            [ 4] 3681 	LD	E,A		; <- bits
   173B B7            [ 4] 3682 	OR	A		; Test exponent
   173C C8            [11] 3683 	RET	Z		; Zero - Return zero
   173D E5            [11] 3684 	PUSH	HL		; Save pointer to number
   173E CD DB 16      [17] 3685 	CALL	BCDEFP		; Move FPREG to BCDE
   1741 CD F5 16      [17] 3686 	CALL	SIGNS		; Set MSBs & sign of result
   1744 AE            [ 7] 3687 	XOR	(HL)		; Combine with sign of FPREG
   1745 67            [ 4] 3688 	LD	H,A		; Save combined signs
   1746 FC 5B 17      [17] 3689 	CALL	M,DCBCDE	; Negative - Decrement BCDE
   1749 3E 98         [ 7] 3690 	LD	A,0x80+24	; 24 bits
   174B 90            [ 4] 3691 	SUB	B		; Bits to shift
   174C CD 0E 15      [17] 3692 	CALL	SCALE		; Shift BCDE
   174F 7C            [ 4] 3693 	LD	A,H		; Get combined sign
   1750 17            [ 4] 3694 	RLA			; Sign to carry
   1751 DC E1 14      [17] 3695 	CALL	C,FPROND	; Negative - Round number up
   1754 06 00         [ 7] 3696 	LD	B,0		; Zero exponent
   1756 DC FA 14      [17] 3697 	CALL	C,COMPL		; If negative make positive
   1759 E1            [10] 3698 	POP	HL		; Restore pointer to number
   175A C9            [10] 3699 	RET
                           3700 ;
   175B 1B            [ 6] 3701 DCBCDE: DEC	DE		; Decrement BCDE
   175C 7A            [ 4] 3702 	LD	A,D		; Test LSBs
   175D A3            [ 4] 3703 	AND	E
   175E 3C            [ 4] 3704 	INC	A
   175F C0            [11] 3705 	RET	NZ		; Exit if LSBs not FFFF
   1760 0B            [ 6] 3706 	DEC	BC		; Decrement MSBs
   1761 C9            [10] 3707 	RET
                           3708 ;
   1762 21 2C 81      [10] 3709 INT:	LD	HL,FPEXP	; Point to exponent
   1765 7E            [ 7] 3710 	LD	A,(HL)		; Get exponent
   1766 FE 98         [ 7] 3711 	CP	0x80+24		; Integer accuracy only?
   1768 3A 29 81      [13] 3712 	LD	A,(FPREG)	; Get LSB
   176B D0            [11] 3713 	RET	NC		; Yes - Already integer
   176C 7E            [ 7] 3714 	LD	A,(HL)		; Get exponent
   176D CD 37 17      [17] 3715 	CALL	FPINT		; F.P to integer
   1770 36 98         [10] 3716 	LD	(HL),0x80+24	; Save 24 bit integer
   1772 7B            [ 4] 3717 	LD	A,E		; Get LSB of number
   1773 F5            [11] 3718 	PUSH	AF		; Save LSB
   1774 79            [ 4] 3719 	LD	A,C		; Get MSB of number
   1775 17            [ 4] 3720 	RLA			; Sign to carry
   1776 CD 99 14      [17] 3721 	CALL	CONPOS		; Set sign of result
   1779 F1            [10] 3722 	POP	AF		; Restore LSB of number
   177A C9            [10] 3723 	RET
                           3724 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 69
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   177B 21 00 00      [10] 3725 MLDEBC: LD	HL,0		; Clear partial product
   177E 78            [ 4] 3726 	LD	A,B		; Test multiplier
   177F B1            [ 4] 3727 	OR	C
   1780 C8            [11] 3728 	RET	Z		; Return zero if zero
   1781 3E 10         [ 7] 3729 	LD	A,16		; 16 bits
   1783 29            [11] 3730 MLDBLP: ADD	HL,HL		; Shift P.P left
   1784 DA BD 0F      [10] 3731 	JP	C,BSERR		; ?BS Error if overflow
   1787 EB            [ 4] 3732 	EX	DE,HL
   1788 29            [11] 3733 	ADD	HL,HL		; Shift multiplier left
   1789 EB            [ 4] 3734 	EX	DE,HL
   178A D2 91 17      [10] 3735 	JP	NC,NOMLAD	; Bit was zero - No add
   178D 09            [11] 3736 	ADD	HL,BC		; Add multiplicand
   178E DA BD 0F      [10] 3737 	JP	C,BSERR		; ?BS Error if overflow
   1791 3D            [ 4] 3738 NOMLAD: DEC	A		; Count bits
   1792 C2 83 17      [10] 3739 	JP	NZ,MLDBLP	; More
   1795 C9            [10] 3740 	RET
                           3741 ;
   1796 FE 2D         [ 7] 3742 ASCTFP: CP	'-		; Negative?
   1798 F5            [11] 3743 	PUSH	AF		; Save it and flags
   1799 CA A2 17      [10] 3744 	JP	Z,CNVNUM	; Yes - Convert number
   179C FE 2B         [ 7] 3745 	CP	'+		; Positive?
   179E CA A2 17      [10] 3746 	JP	Z,CNVNUM	; Yes - Convert number
   17A1 2B            [ 6] 3747 	DEC	HL		; DEC 'cos GETCHR INCs
   17A2 CD B1 14      [17] 3748 CNVNUM: CALL	RESZER		; Set result to zero
   17A5 47            [ 4] 3749 	LD	B,A		; Digits after point counter
   17A6 57            [ 4] 3750 	LD	D,A		; Sign of exponent
   17A7 5F            [ 4] 3751 	LD	E,A		; Exponent of ten
   17A8 2F            [ 4] 3752 	CPL
   17A9 4F            [ 4] 3753 	LD	C,A		; Before or after point flag
   17AA CD 46 08      [17] 3754 MANLP:	CALL	GETCHR		; Get next character
   17AD DA F3 17      [10] 3755 	JP	C,ADDIG		; Digit - Add to number
   17B0 FE 2E         [ 7] 3756 	CP	'.
   17B2 CA CE 17      [10] 3757 	JP	Z,DPOINT	; '. - Flag point
   17B5 FE 45         [ 7] 3758 	CP	'E
   17B7 C2 D2 17      [10] 3759 	JP	NZ,CONEXP	; Not 'E - Scale number
   17BA CD 46 08      [17] 3760 	CALL	GETCHR		; Get next character
   17BD CD E8 0D      [17] 3761 	CALL	SGNEXP		; Get sign of exponent
   17C0 CD 46 08      [17] 3762 EXPLP:	CALL	GETCHR		; Get next character
   17C3 DA 15 18      [10] 3763 	JP	C,EDIGIT	; Digit - Add to exponent
   17C6 14            [ 4] 3764 	INC	D		; Is sign negative?
   17C7 C2 D2 17      [10] 3765 	JP	NZ,CONEXP	; No - Scale number
   17CA AF            [ 4] 3766 	XOR	A
   17CB 93            [ 4] 3767 	SUB	E		; Negate exponent
   17CC 5F            [ 4] 3768 	LD	E,A		; And re-save it
   17CD 0C            [ 4] 3769 	INC	C		; Flag end of number
   17CE 0C            [ 4] 3770 DPOINT: INC	C		; Flag point passed
   17CF CA AA 17      [10] 3771 	JP	Z,MANLP		; Zero - Get another digit
   17D2 E5            [11] 3772 CONEXP: PUSH	HL		; Save code string address
   17D3 7B            [ 4] 3773 	LD	A,E		; Get exponent
   17D4 90            [ 4] 3774 	SUB	B		; Subtract digits after point
   17D5 F4 EB 17      [17] 3775 SCALMI: CALL	P,SCALPL	; Positive - Multiply number
   17D8 F2 E1 17      [10] 3776 	JP	P,ENDCON	; Positive - All done
   17DB F5            [11] 3777 	PUSH	AF		; Save number of times to /10
   17DC CD D7 15      [17] 3778 	CALL	DIV10		; Divide by 10
   17DF F1            [10] 3779 	POP	AF		; Restore count
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 70
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   17E0 3C            [ 4] 3780 	INC	A		; Count divides
                           3781 ;
   17E1 C2 D5 17      [10] 3782 ENDCON: JP	NZ,SCALMI	; More to do
   17E4 D1            [10] 3783 	POP	DE		; Restore code string address
   17E5 F1            [10] 3784 	POP	AF		; Restore sign of number
   17E6 CC B8 16      [17] 3785 	CALL	Z,INVSGN	; Negative - Negate number
   17E9 EB            [ 4] 3786 	EX	DE,HL		; Code string address to HL
   17EA C9            [10] 3787 	RET
                           3788 ;
   17EB C8            [11] 3789 SCALPL: RET	Z		; Exit if no scaling needed
   17EC F5            [11] 3790 MULTEN: PUSH	AF		; Save count
   17ED CD 78 16      [17] 3791 	CALL	MLSP10		; Multiply number by 10
   17F0 F1            [10] 3792 	POP	AF		; Restore count
   17F1 3D            [ 4] 3793 	DEC	A		; Count multiplies
   17F2 C9            [10] 3794 	RET
                           3795 ;
   17F3 D5            [11] 3796 ADDIG:	PUSH	DE		; Save sign of exponent
   17F4 57            [ 4] 3797 	LD	D,A		; Save digit
   17F5 78            [ 4] 3798 	LD	A,B		; Get digits after point
   17F6 89            [ 4] 3799 	ADC	A,C		; Add one if after point
   17F7 47            [ 4] 3800 	LD	B,A		; Re-save counter
   17F8 C5            [11] 3801 	PUSH	BC		; Save point flags
   17F9 E5            [11] 3802 	PUSH	HL		; Save code string address
   17FA D5            [11] 3803 	PUSH	DE		; Save digit
   17FB CD 78 16      [17] 3804 	CALL	MLSP10		; Multiply number by 10
   17FE F1            [10] 3805 	POP	AF		; Restore digit
   17FF D6 30         [ 7] 3806 	SUB	'0		; Make it absolute
   1801 CD 0A 18      [17] 3807 	CALL	RSCALE		; Re-scale number
   1804 E1            [10] 3808 	POP	HL		; Restore code string address
   1805 C1            [10] 3809 	POP	BC		; Restore point flags
   1806 D1            [10] 3810 	POP	DE		; Restore sign of exponent
   1807 C3 AA 17      [10] 3811 	JP	MANLP		; Get another digit
                           3812 ;
   180A CD C0 16      [17] 3813 RSCALE: CALL	STAKFP		; Put number on stack
   180D CD A1 16      [17] 3814 	CALL	FLGREL		; Digit to add to FPREG
   1810 C1            [10] 3815 PADD:	POP	BC		; Restore number
   1811 D1            [10] 3816 	POP	DE
   1812 C3 4B 14      [10] 3817 	JP	FPADD		; Add BCDE to FPREG and return
                           3818 ;
   1815 7B            [ 4] 3819 EDIGIT: LD	A,E		; Get digit
   1816 07            [ 4] 3820 	RLCA			; Times 2
   1817 07            [ 4] 3821 	RLCA			; Times 4
   1818 83            [ 4] 3822 	ADD	A,E		; Times 5
   1819 07            [ 4] 3823 	RLCA			; Times 10
   181A 86            [ 7] 3824 	ADD	A,(HL)		; Add next digit
   181B D6 30         [ 7] 3825 	SUB	'0		; Make it absolute
   181D 5F            [ 4] 3826 	LD	E,A		; Save new digit
   181E C3 C0 17      [10] 3827 	JP	EXPLP		; Look for another digit
                           3828 ;
   1821 E5            [11] 3829 LINEIN: PUSH	HL		; Save code string address
   1822 21 90 03      [10] 3830 	LD	HL,INMSG	; Output " in "
   1825 CD 88 11      [17] 3831 	CALL	PRS		; Output string at HL
   1828 E1            [10] 3832 	POP	HL		; Restore code string address
   1829 EB            [ 4] 3833 PRNTHL: EX	DE,HL		; Code string address to DE
   182A AF            [ 4] 3834 	XOR	A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 71
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   182B 06 98         [ 7] 3835 	LD	B,0x80+24	; 24 bits
   182D CD A6 16      [17] 3836 	CALL	RETINT		; Return the integer
   1830 21 87 11      [10] 3837 	LD	HL,PRNUMS	; Print number string
   1833 E5            [11] 3838 	PUSH	HL		; Save for return
   1834 21 2E 81      [10] 3839 NUMASC: LD	HL,PBUFF	; Convert number to ASCII
   1837 E5            [11] 3840 	PUSH	HL		; Save for return
   1838 CD 8F 16      [17] 3841 	CALL	TSTSGN		; Test sign of FPREG
   183B 36 20         [10] 3842 	LD	(HL),' 	; Space at start
   183D F2 42 18      [10] 3843 	JP	P,SPCFST	; Positive - Space to start
   1840 36 2D         [10] 3844 	LD	(HL),'-	; '- sign at start
   1842 23            [ 6] 3845 SPCFST: INC	HL		; First byte of number
   1843 36 30         [10] 3846 	LD	(HL),'0	; '0 if zero
   1845 CA F8 18      [10] 3847 	JP	Z,JSTZER	; Return '0 if zero
   1848 E5            [11] 3848 	PUSH	HL		; Save buffer address
   1849 FC B8 16      [17] 3849 	CALL	M,INVSGN	; Negate FPREG if negative
   184C AF            [ 4] 3850 	XOR	A		; Zero A
   184D F5            [11] 3851 	PUSH	AF		; Save it
   184E CD FE 18      [17] 3852 	CALL	RNGTST		; Test number is in range
   1851 01 43 91      [10] 3853 SIXDIG: LD	BC,0x9143	; BCDE - 99999.9
   1854 11 F8 4F      [10] 3854 	LD	DE,0x4FF8
   1857 CD 0A 17      [17] 3855 	CALL	CMPNUM		; Compare numbers
   185A B7            [ 4] 3856 	OR	A
   185B E2 6F 18      [10] 3857 	JP	PO,INRNG	; > 99999.9 - Sort it out
   185E F1            [10] 3858 	POP	AF		; Restore count
   185F CD EC 17      [17] 3859 	CALL	MULTEN		; Multiply by ten
   1862 F5            [11] 3860 	PUSH	AF		; Re-save count
   1863 C3 51 18      [10] 3861 	JP	SIXDIG		; Test it again
                           3862 ;
   1866 CD D7 15      [17] 3863 GTSIXD: CALL	DIV10		; Divide by 10
   1869 F1            [10] 3864 	POP	AF		; Get count
   186A 3C            [ 4] 3865 	INC	A		; Count divides
   186B F5            [11] 3866 	PUSH	AF		; Re-save count
   186C CD FE 18      [17] 3867 	CALL	RNGTST		; Test number is in range
   186F CD 39 14      [17] 3868 INRNG:	CALL	ROUND		; Add 0.5 to FPREG
   1872 3C            [ 4] 3869 	INC	A
   1873 CD 37 17      [17] 3870 	CALL	FPINT		; F.P to integer
   1876 CD D0 16      [17] 3871 	CALL	FPBCDE		; Move BCDE to FPREG
   1879 01 06 03      [10] 3872 	LD	BC,0x0306	; 1E+06 to 1E-03 range
   187C F1            [10] 3873 	POP	AF		; Restore count
   187D 81            [ 4] 3874 	ADD	A,C		; 6 digits before point
   187E 3C            [ 4] 3875 	INC	A		; Add one
   187F FA 8B 18      [10] 3876 	JP	M,MAKNUM	; Do it in 'E form if < 1E-02
   1882 FE 08         [ 7] 3877 	CP	6+1+1		; More than 999999 ?
   1884 D2 8B 18      [10] 3878 	JP	NC,MAKNUM	; Yes - Do it in 'E form
   1887 3C            [ 4] 3879 	INC	A		; Adjust for exponent
   1888 47            [ 4] 3880 	LD	B,A		; Exponent of number
   1889 3E 02         [ 7] 3881 	LD	A,2		; Make it zero after
                           3882 ;
   188B 3D            [ 4] 3883 MAKNUM: DEC	A		; Adjust for digits to do
   188C 3D            [ 4] 3884 	DEC	A
   188D E1            [10] 3885 	POP	HL		; Restore buffer address
   188E F5            [11] 3886 	PUSH	AF		; Save count
   188F 11 11 19      [10] 3887 	LD	DE,POWERS	; Powers of ten
   1892 05            [ 4] 3888 	DEC	B		; Count digits before point
   1893 C2 9C 18      [10] 3889 	JP	NZ,DIGTXT	; Not zero - Do number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 72
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1896 36 2E         [10] 3890 	LD	(HL),'.	; Save point
   1898 23            [ 6] 3891 	INC	HL		; Move on
   1899 36 30         [10] 3892 	LD	(HL),'0	; Save zero
   189B 23            [ 6] 3893 	INC	HL		; Move on
   189C 05            [ 4] 3894 DIGTXT: DEC	B		; Count digits before point
   189D 36 2E         [10] 3895 	LD	(HL),'.	; Save point in case
   189F CC E5 16      [17] 3896 	CALL	Z,INCHL		; Last digit - move on
   18A2 C5            [11] 3897 	PUSH	BC		; Save digits before point
   18A3 E5            [11] 3898 	PUSH	HL		; Save buffer address
   18A4 D5            [11] 3899 	PUSH	DE		; Save powers of ten
   18A5 CD DB 16      [17] 3900 	CALL	BCDEFP		; Move FPREG to BCDE
   18A8 E1            [10] 3901 	POP	HL		; Powers of ten table
   18A9 06 2F         [ 7] 3902 	LD	B, '0-1	; ASCII '0 - 1
   18AB 04            [ 4] 3903 TRYAGN: INC	B		; Count subtractions
   18AC 7B            [ 4] 3904 	LD	A,E		; Get LSB
   18AD 96            [ 7] 3905 	SUB	(HL)		; Subtract LSB
   18AE 5F            [ 4] 3906 	LD	E,A		; Save LSB
   18AF 23            [ 6] 3907 	INC	HL
   18B0 7A            [ 4] 3908 	LD	A,D		; Get NMSB
   18B1 9E            [ 7] 3909 	SBC	A,(HL)		; Subtract NMSB
   18B2 57            [ 4] 3910 	LD	D,A		; Save NMSB
   18B3 23            [ 6] 3911 	INC	HL
   18B4 79            [ 4] 3912 	LD	A,C		; Get MSB
   18B5 9E            [ 7] 3913 	SBC	A,(HL)		; Subtract MSB
   18B6 4F            [ 4] 3914 	LD	C,A		; Save MSB
   18B7 2B            [ 6] 3915 	DEC	HL		; Point back to start
   18B8 2B            [ 6] 3916 	DEC	HL
   18B9 D2 AB 18      [10] 3917 	JP	NC,TRYAGN	; No overflow - Try again
   18BC CD EE 14      [17] 3918 	CALL	PLUCDE		; Restore number
   18BF 23            [ 6] 3919 	INC	HL		; Start of next number
   18C0 CD D0 16      [17] 3920 	CALL	FPBCDE		; Move BCDE to FPREG
   18C3 EB            [ 4] 3921 	EX	DE,HL		; Save point in table
   18C4 E1            [10] 3922 	POP	HL		; Restore buffer address
   18C5 70            [ 7] 3923 	LD	(HL),B		; Save digit in buffer
   18C6 23            [ 6] 3924 	INC	HL		; And move on
   18C7 C1            [10] 3925 	POP	BC		; Restore digit count
   18C8 0D            [ 4] 3926 	DEC	C		; Count digits
   18C9 C2 9C 18      [10] 3927 	JP	NZ,DIGTXT	; More - Do them
   18CC 05            [ 4] 3928 	DEC	B		; Any decimal part?
   18CD CA DC 18      [10] 3929 	JP	Z,DOEBIT	; No - Do 'E bit
   18D0 2B            [ 6] 3930 SUPTLZ: DEC	HL		; Move back through buffer
   18D1 7E            [ 7] 3931 	LD	A,(HL)		; Get character
   18D2 FE 30         [ 7] 3932 	CP	'0		; '0 character?
   18D4 CA D0 18      [10] 3933 	JP	Z,SUPTLZ	; Yes - Look back for more
   18D7 FE 2E         [ 7] 3934 	CP	'.		; A decimal point?
   18D9 C4 E5 16      [17] 3935 	CALL	NZ,INCHL	; Move back over digit
                           3936 ;
   18DC F1            [10] 3937 DOEBIT: POP	AF		; Get 'E flag
   18DD CA FB 18      [10] 3938 	JP	Z,NOENED	; No 'E needed - End buffer
   18E0 36 45         [10] 3939 	LD	(HL),'E	; Put 'E in buffer
   18E2 23            [ 6] 3940 	INC	HL		; And move on
   18E3 36 2B         [10] 3941 	LD	(HL),'+	; Put '+ in buffer
   18E5 F2 EC 18      [10] 3942 	JP	P,OUTEXP	; Positive - Output exponent
   18E8 36 2D         [10] 3943 	LD	(HL),'-	; Put '- in buffer
   18EA 2F            [ 4] 3944 	CPL			; Negate exponent
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 73
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   18EB 3C            [ 4] 3945 	INC	A
   18EC 06 2F         [ 7] 3946 OUTEXP: LD	B,'0-1		; ASCII '0 - 1
   18EE 04            [ 4] 3947 EXPTEN: INC	B		; Count subtractions
   18EF D6 0A         [ 7] 3948 	SUB	10		; Tens digit
   18F1 D2 EE 18      [10] 3949 	JP	NC,EXPTEN	; More to do
   18F4 C6 3A         [ 7] 3950 	ADD	A,'0+10	; Restore and make ASCII
   18F6 23            [ 6] 3951 	INC	HL		; Move on
   18F7 70            [ 7] 3952 	LD	(HL),B		; Save MSB of exponent
   18F8 23            [ 6] 3953 JSTZER: INC	HL		;
   18F9 77            [ 7] 3954 	LD	(HL),A		; Save LSB of exponent
   18FA 23            [ 6] 3955 	INC	HL
   18FB 71            [ 7] 3956 NOENED: LD	(HL),C		; Mark end of buffer
   18FC E1            [10] 3957 	POP	HL		; Restore code string address
   18FD C9            [10] 3958 	RET
                           3959 ;
   18FE 01 74 94      [10] 3960 RNGTST: LD	BC,0x9474	; BCDE = 999999.
   1901 11 F7 23      [10] 3961 	LD	DE,0x23F7
   1904 CD 0A 17      [17] 3962 	CALL	CMPNUM		; Compare numbers
   1907 B7            [ 4] 3963 	OR	A
   1908 E1            [10] 3964 	POP	HL		; Return address to HL
   1909 E2 66 18      [10] 3965 	JP	PO,GTSIXD	; Too big - Divide by ten
   190C E9            [ 4] 3966 	JP	(HL)		; Otherwise return to caller
                           3967 ;
   190D 00 00 00 80        3968 HALF:	.db	0x00,0x00,0x00,0x80	; 0.5
                           3969 ;
   1911 A0 86 01           3970 POWERS: .db	0x0A0,0x086,0x001	; 100000
   1914 10 27 00           3971 	.db	0x010,0x027,0x000	; 10000
   1917 E8 03 00           3972 	.db	0x0E8,0x003,0x000	; 1000
   191A 64 00 00           3973 	.db	0x064,0x000,0x000	; 100
   191D 0A 00 00           3974 	.db	0x00A,0x000,0x000	; 10
   1920 01 00 00           3975 	.db	0x001,0x000,0x000	; 1
                           3976 ;
   1923 21 B8 16      [10] 3977 NEGAFT: LD	HL,INVSGN	; Negate result
   1926 E3            [19] 3978 	EX	(SP),HL		; To be done after caller
   1927 E9            [ 4] 3979 	JP	(HL)		; Return to caller
                           3980 ;
   1928 CD C0 16      [17] 3981 SQR:	CALL	STAKFP		; Put value on stack
   192B 21 0D 19      [10] 3982 	LD	HL,HALF		; Set power to 1/2
   192E CD CD 16      [17] 3983 	CALL	PHLTFP		; Move 1/2 to FPREG
                           3984 ;
   1931 C1            [10] 3985 POWER:	POP	BC		; Get base
   1932 D1            [10] 3986 	POP	DE
   1933 CD 8F 16      [17] 3987 	CALL	TSTSGN		; Test sign of power
   1936 78            [ 4] 3988 	LD	A,B		; Get exponent of base
   1937 CA 74 19      [10] 3989 	JP	Z,EXP		; Make result 1 if zero
   193A F2 41 19      [10] 3990 	JP	P,POWER1	; Positive base - Ok
   193D B7            [ 4] 3991 	OR	A		; Zero to negative power?
   193E CA FB 03      [10] 3992 	JP	Z,DZERR		; Yes - ?/0 Error
   1941 B7            [ 4] 3993 POWER1: OR	A		; Base zero?
   1942 CA B2 14      [10] 3994 	JP	Z,SAVEXP	; Yes - Return zero
   1945 D5            [11] 3995 	PUSH	DE		; Save base
   1946 C5            [11] 3996 	PUSH	BC
   1947 79            [ 4] 3997 	LD	A,C		; Get MSB of base
kq 1948                    3998 	OR	01111111B	; Get sign status
   1948 CD DB 16      [17] 3999 	CALL	BCDEFP		; Move power to BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 74
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   194B F2 5C 19      [10] 4000 	JP	P,POWER2	; Positive base - Ok
   194E D5            [11] 4001 	PUSH	DE		; Save power
   194F C5            [11] 4002 	PUSH	BC
   1950 CD 62 17      [17] 4003 	CALL	INT		; Get integer of power
   1953 C1            [10] 4004 	POP	BC		; Restore power
   1954 D1            [10] 4005 	POP	DE
   1955 F5            [11] 4006 	PUSH	AF		; MSB of base
   1956 CD 0A 17      [17] 4007 	CALL	CMPNUM		; Power an integer?
   1959 E1            [10] 4008 	POP	HL		; Restore MSB of base
   195A 7C            [ 4] 4009 	LD	A,H		; but don't affect flags
   195B 1F            [ 4] 4010 	RRA			; Exponent odd or even?
   195C E1            [10] 4011 POWER2: POP	HL		; Restore MSB and exponent
   195D 22 2B 81      [16] 4012 	LD	(FPREG+2),HL	; Save base in FPREG
   1960 E1            [10] 4013 	POP	HL		; LSBs of base
   1961 22 29 81      [16] 4014 	LD	(FPREG),HL	; Save in FPREG
   1964 DC 23 19      [17] 4015 	CALL	C,NEGAFT	; Odd power - Negate result
   1967 CC B8 16      [17] 4016 	CALL	Z,INVSGN	; Negative base - Negate it
   196A D5            [11] 4017 	PUSH	DE		; Save power
   196B C5            [11] 4018 	PUSH	BC
   196C CD 43 15      [17] 4019 	CALL	LOG		; Get LOG of base
   196F C1            [10] 4020 	POP	BC		; Restore power
   1970 D1            [10] 4021 	POP	DE
   1971 CD 84 15      [17] 4022 	CALL	FPMULT		; Multiply LOG by power
                           4023 ;
   1974 CD C0 16      [17] 4024 EXP:	CALL	STAKFP		; Put value on stack
   1977 01 38 81      [10] 4025 	LD	BC,0x08138	; BCDE = 1/Ln(2)
   197A 11 3B AA      [10] 4026 	LD	DE,0x0AA3B
   197D CD 84 15      [17] 4027 	CALL	FPMULT		; Multiply value by 1/LN(2)
   1980 3A 2C 81      [13] 4028 	LD	A,(FPEXP)	; Get exponent
   1983 FE 88         [ 7] 4029 	CP	0x80+8		; Is it in range?
   1985 D2 6B 16      [10] 4030 	JP	NC,OVTST1	; No - Test for overflow
   1988 CD 62 17      [17] 4031 	CALL	INT		; Get INT of FPREG
   198B C6 80         [ 7] 4032 	ADD	A,0x80		; For excess 128
   198D C6 02         [ 7] 4033 	ADD	A,2		; Exponent > 126?
   198F DA 6B 16      [10] 4034 	JP	C,OVTST1	; Yes - Test for overflow
   1992 F5            [11] 4035 	PUSH	AF		; Save scaling factor
   1993 21 32 15      [10] 4036 	LD	HL,UNITY	; Point to 1.
   1996 CD 3C 14      [17] 4037 	CALL	ADDPHL		; Add 1 to FPREG
   1999 CD 7B 15      [17] 4038 	CALL	MULLN2		; Multiply by LN(2)
   199C F1            [10] 4039 	POP	AF		; Restore scaling factor
   199D C1            [10] 4040 	POP	BC		; Restore exponent
   199E D1            [10] 4041 	POP	DE
   199F F5            [11] 4042 	PUSH	AF		; Save scaling factor
   19A0 CD 48 14      [17] 4043 	CALL	SUBCDE		; Subtract exponent from FPREG
   19A3 CD B8 16      [17] 4044 	CALL	INVSGN		; Negate result
   19A6 21 B4 19      [10] 4045 	LD	HL,EXPTAB	; Coefficient table
   19A9 CD E4 19      [17] 4046 	CALL	SMSER1		; Sum the series
   19AC 11 00 00      [10] 4047 	LD	DE,0		; Zero LSBs
   19AF C1            [10] 4048 	POP	BC		; Scaling factor
   19B0 4A            [ 4] 4049 	LD	C,D		; Zero MSB
   19B1 C3 84 15      [10] 4050 	JP	FPMULT		; Scale result to correct value
                           4051 ;
   19B4 08                 4052 EXPTAB: .db	8			; Table used by EXP
   19B5 40 2E 94 74        4053 	.db	0x040,0x02E,0x094,0x074	; -1/7! (-1/5040)
   19B9 70 4F 2E 77        4054 	.db	0x070,0x04F,0x02E,0x077	;  1/6! ( 1/720)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 75
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   19BD 6E 02 88 7A        4055 	.db	0x06E,0x002,0x088,0x07A	; -1/5! (-1/120)
   19C1 E6 A0 2A 7C        4056 	.db	0x0E6,0x0A0,0x02A,0x07C	;  1/4! ( 1/24)
   19C5 50 AA AA 7E        4057 	.db	0x050,0x0AA,0x0AA,0x07E	; -1/3! (-1/6)
   19C9 FF FF 7F 7F        4058 	.db	0x0FF,0x0FF,0x07F,0x07F	;  1/2! ( 1/2)
   19CD 00 00 80 81        4059 	.db	0x000,0x000,0x080,0x081	; -1/1! (-1/1)
   19D1 00 00 00 81        4060 	.db	0x000,0x000,0x000,0x081	;  1/0! ( 1/1)
                           4061 ;
   19D5 CD C0 16      [17] 4062 SUMSER: CALL	STAKFP		; Put FPREG on stack
   19D8 11 82 15      [10] 4063 	LD	DE,MULT		; Multiply by "X"
   19DB D5            [11] 4064 	PUSH	DE		; To be done after
   19DC E5            [11] 4065 	PUSH	HL		; Save address of table
   19DD CD DB 16      [17] 4066 	CALL	BCDEFP		; Move FPREG to BCDE
   19E0 CD 84 15      [17] 4067 	CALL	FPMULT		; Square the value
   19E3 E1            [10] 4068 	POP	HL		; Restore address of table
   19E4 CD C0 16      [17] 4069 SMSER1: CALL	STAKFP		; Put value on stack
   19E7 7E            [ 7] 4070 	LD	A,(HL)		; Get number of coefficients
   19E8 23            [ 6] 4071 	INC	HL		; Point to start of table
   19E9 CD CD 16      [17] 4072 	CALL	PHLTFP		; Move coefficient to FPREG
   19EC 06                 4073 	.db	0x06		; Skip "POP AF"
   19ED F1            [10] 4074 SUMLP:	POP	AF		; Restore count
   19EE C1            [10] 4075 	POP	BC		; Restore number
   19EF D1            [10] 4076 	POP	DE
   19F0 3D            [ 4] 4077 	DEC	A		; Cont coefficients
   19F1 C8            [11] 4078 	RET	Z		; All done
   19F2 D5            [11] 4079 	PUSH	DE		; Save number
   19F3 C5            [11] 4080 	PUSH	BC
   19F4 F5            [11] 4081 	PUSH	AF		; Save count
   19F5 E5            [11] 4082 	PUSH	HL		; Save address in table
   19F6 CD 84 15      [17] 4083 	CALL	FPMULT		; Multiply FPREG by BCDE
   19F9 E1            [10] 4084 	POP	HL		; Restore address in table
   19FA CD DE 16      [17] 4085 	CALL	LOADFP		; Number at HL to BCDE
   19FD E5            [11] 4086 	PUSH	HL		; Save address in table
   19FE CD 4B 14      [17] 4087 	CALL	FPADD		; Add coefficient to FPREG
   1A01 E1            [10] 4088 	POP	HL		; Restore address in table
   1A02 C3 ED 19      [10] 4089 	JP	SUMLP		; More coefficients
                           4090 ;
   1A05 CD 8F 16      [17] 4091 RND:	CALL	TSTSGN		; Test sign of FPREG
   1A08 21 5E 80      [10] 4092 	LD	HL,SEED+2	; Random number seed
   1A0B FA 60 1A      [10] 4093 	JP	M,RESEED	; Negative - Re-seed
   1A0E 21 7F 80      [10] 4094 	LD	HL,LSTRND	; Last random number
   1A11 CD CD 16      [17] 4095 	CALL	PHLTFP		; Move last RND to FPREG
   1A14 21 5E 80      [10] 4096 	LD	HL,SEED+2	; Random number seed
   1A17 C8            [11] 4097 	RET	Z		; Return if RND(0)
   1A18 86            [ 7] 4098 	ADD	A,(HL)		; Add (SEED)+2)
kq 1A19                    4099 	AND	00000111B	; 0 to 7
   1A19 06 00         [ 7] 4100 	LD	B,0
   1A1B 77            [ 7] 4101 	LD	(HL),A		; Re-save seed
   1A1C 23            [ 6] 4102 	INC	HL		; Move to coefficient table
   1A1D 87            [ 4] 4103 	ADD	A,A		; 4 bytes
   1A1E 87            [ 4] 4104 	ADD	A,A		; per entry
   1A1F 4F            [ 4] 4105 	LD	C,A		; BC = Offset into table
   1A20 09            [11] 4106 	ADD	HL,BC		; Point to coefficient
   1A21 CD DE 16      [17] 4107 	CALL	LOADFP		; Coefficient to BCDE
   1A24 CD 84 15      [17] 4108 	CALL	FPMULT	;	; Multiply FPREG by coefficient
   1A27 3A 5D 80      [13] 4109 	LD	A,(SEED+1)	; Get (SEED+1)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 76
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1A2A 3C            [ 4] 4110 	INC	A		; Add 1
kq 1A2B                    4111 	AND	00000011B	; 0 to 3
   1A2B 06 00         [ 7] 4112 	LD	B,0
   1A2D FE 01         [ 7] 4113 	CP	1		; Is it zero?
   1A2F 88            [ 4] 4114 	ADC	A,B		; Yes - Make it 1
   1A30 32 5D 80      [13] 4115 	LD	(SEED+1),A	; Re-save seed
   1A33 21 64 1A      [10] 4116 	LD	HL,RNDTAB-4	; Addition table
   1A36 87            [ 4] 4117 	ADD	A,A		; 4 bytes
   1A37 87            [ 4] 4118 	ADD	A,A		; per entry
   1A38 4F            [ 4] 4119 	LD	C,A		; BC = Offset into table
   1A39 09            [11] 4120 	ADD	HL,BC		; Point to value
   1A3A CD 3C 14      [17] 4121 	CALL	ADDPHL		; Add value to FPREG
   1A3D CD DB 16      [17] 4122 RND1:	CALL	BCDEFP		; Move FPREG to BCDE
   1A40 7B            [ 4] 4123 	LD	A,E		; Get LSB
   1A41 59            [ 4] 4124 	LD	E,C		; LSB = MSB
kq 1A42                    4125 	XOR	01001111B	; Fiddle around
   1A42 4F            [ 4] 4126 	LD	C,A		; New MSB
   1A43 36 80         [10] 4127 	LD	(HL),0x80	; Set exponent
   1A45 2B            [ 6] 4128 	DEC	HL		; Point to MSB
   1A46 46            [ 7] 4129 	LD	B,(HL)		; Get MSB
   1A47 36 80         [10] 4130 	LD	(HL),0x80	; Make value -0.5
   1A49 21 5C 80      [10] 4131 	LD	HL,SEED		; Random number seed
   1A4C 34            [11] 4132 	INC	(HL)		; Count seed
   1A4D 7E            [ 7] 4133 	LD	A,(HL)		; Get seed
   1A4E D6 AB         [ 7] 4134 	SUB	171		; Do it modulo 171
   1A50 C2 57 1A      [10] 4135 	JP	NZ,RND2		; Non-zero - Ok
   1A53 77            [ 7] 4136 	LD	(HL),A		; Zero seed
   1A54 0C            [ 4] 4137 	INC	C		; Fillde about
   1A55 15            [ 4] 4138 	DEC	D		; with the
   1A56 1C            [ 4] 4139 	INC	E		; number
   1A57 CD 9C 14      [17] 4140 RND2:	CALL	BNORM		; Normalise number
   1A5A 21 7F 80      [10] 4141 	LD	HL,LSTRND	; Save random number
   1A5D C3 E7 16      [10] 4142 	JP	FPTHL		; Move FPREG to last and return
                           4143 ;
   1A60 77            [ 7] 4144 RESEED: LD	(HL),A		; Re-seed random numbers
   1A61 2B            [ 6] 4145 	DEC	HL
   1A62 77            [ 7] 4146 	LD	(HL),A
   1A63 2B            [ 6] 4147 	DEC	HL
   1A64 77            [ 7] 4148 	LD	(HL),A
   1A65 C3 3D 1A      [10] 4149 	JP	RND1		; Return RND seed
                           4150 ;
   1A68 68 B1 46 68        4151 RNDTAB: .db	0x068,0x0B1,0x046,0x068	; Table used by RND
   1A6C 99 E9 92 69        4152 	.db	0x099,0x0E9,0x092,0x069
   1A70 10 D1 75 68        4153 	.db	0x010,0x0D1,0x075,0x068
                           4154 ;
   1A74 21 BE 1A      [10] 4155 COS:	LD	HL,HALFPI	; Point to PI/2
   1A77 CD 3C 14      [17] 4156 	CALL	ADDPHL		; Add it to PPREG
   1A7A CD C0 16      [17] 4157 SIN:	CALL	STAKFP		; Put angle on stack
   1A7D 01 49 83      [10] 4158 	LD	BC,0x8349	; BCDE = 2 PI
   1A80 11 DB 0F      [10] 4159 	LD	DE,0x0FDB
   1A83 CD D0 16      [17] 4160 	CALL	FPBCDE		; Move 2 PI to FPREG
   1A86 C1            [10] 4161 	POP	BC		; Restore angle
   1A87 D1            [10] 4162 	POP	DE
   1A88 CD E5 15      [17] 4163 	CALL	DVBCDE		; Divide angle by 2 PI
   1A8B CD C0 16      [17] 4164 	CALL	STAKFP		; Put it on stack
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 77
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1A8E CD 62 17      [17] 4165 	CALL	INT		; Get INT of result
   1A91 C1            [10] 4166 	POP	BC		; Restore number
   1A92 D1            [10] 4167 	POP	DE
   1A93 CD 48 14      [17] 4168 	CALL	SUBCDE		; Make it 0 <= value < 1
   1A96 21 C2 1A      [10] 4169 	LD	HL,QUARTR	; Point to 0.25
   1A99 CD 42 14      [17] 4170 	CALL	SUBPHL		; Subtract value from 0.25
   1A9C CD 8F 16      [17] 4171 	CALL	TSTSGN		; Test sign of value
   1A9F 37            [ 4] 4172 	SCF			; Flag positive
   1AA0 F2 AA 1A      [10] 4173 	JP	P,SIN1		; Positive - Ok
   1AA3 CD 39 14      [17] 4174 	CALL	ROUND		; Add 0.5 to value
   1AA6 CD 8F 16      [17] 4175 	CALL	TSTSGN		; Test sign of value
   1AA9 B7            [ 4] 4176 	OR	A		; Flag negative
   1AAA F5            [11] 4177 SIN1:	PUSH	AF		; Save sign
   1AAB F4 B8 16      [17] 4178 	CALL	P,INVSGN	; Negate value if positive
   1AAE 21 C2 1A      [10] 4179 	LD	HL,QUARTR	; Point to 0.25
   1AB1 CD 3C 14      [17] 4180 	CALL	ADDPHL		; Add 0.25 to value
   1AB4 F1            [10] 4181 	POP	AF		; Restore sign
   1AB5 D4 B8 16      [17] 4182 	CALL	NC,INVSGN	; Negative - Make positive
   1AB8 21 C6 1A      [10] 4183 	LD	HL,SINTAB	; Coefficient table
   1ABB C3 D5 19      [10] 4184 	JP	SUMSER		; Evaluate sum of series
                           4185 ;
   1ABE DB 0F 49 81        4186 HALFPI: .db	0x0DB,0x00F,0x049,0x081	; 1.5708 (PI/2)
                           4187 ;
   1AC2 00 00 00 7F        4188 QUARTR: .db	0x000,0x000,0x000,0x07F	; 0.25
                           4189 ;
   1AC6 05                 4190 SINTAB: .db	5			; Table used by SIN
   1AC7 BA D7 1E 86        4191 	.db	0x0BA,0x0D7,0x01E,0x086	; 39.711
   1ACB 64 26 99 87        4192 	.db	0x064,0x026,0x099,0x087	;-76.575
   1ACF 58 34 23 87        4193 	.db	0x058,0x034,0x023,0x087	; 81.602
   1AD3 E0 5D A5 86        4194 	.db	0x0E0,0x05D,0x0A5,0x086	;-41.342
   1AD7 DA 0F 49 83        4195 	.db	0x0DA,0x00F,0x049,0x083	; 6.2832
                           4196 ;
   1ADB CD C0 16      [17] 4197 TAN:	CALL	STAKFP		; Put angle on stack
   1ADE CD 7A 1A      [17] 4198 	CALL	SIN		; Get SIN of angle
   1AE1 C1            [10] 4199 	POP	BC		; Restore angle
   1AE2 E1            [10] 4200 	POP	HL
   1AE3 CD C0 16      [17] 4201 	CALL	STAKFP		; Save SIN of angle
   1AE6 EB            [ 4] 4202 	EX	DE,HL		; BCDE = Angle
   1AE7 CD D0 16      [17] 4203 	CALL	FPBCDE		; Angle to FPREG
   1AEA CD 74 1A      [17] 4204 	CALL	COS		; Get COS of angle
   1AED C3 E3 15      [10] 4205 	JP	DIV		; TAN = SIN / COS
                           4206 ;
   1AF0 CD 8F 16      [17] 4207 ATN:	CALL	TSTSGN		; Test sign of value
   1AF3 FC 23 19      [17] 4208 	CALL	M,NEGAFT	; Negate result after if -ve
   1AF6 FC B8 16      [17] 4209 	CALL	M,INVSGN	; Negate value if -ve
   1AF9 3A 2C 81      [13] 4210 	LD	A,(FPEXP)	; Get exponent
   1AFC FE 81         [ 7] 4211 	CP	0x81		; Number less than 1?
   1AFE DA 0D 1B      [10] 4212 	JP	C,ATN1		; Yes - Get arc tangnt
   1B01 01 00 81      [10] 4213 	LD	BC,0x8100	; BCDE = 1
   1B04 51            [ 4] 4214 	LD	D,C
   1B05 59            [ 4] 4215 	LD	E,C
   1B06 CD E5 15      [17] 4216 	CALL	DVBCDE		; Get reciprocal of number
   1B09 21 42 14      [10] 4217 	LD	HL,SUBPHL	; Sub angle from PI/2
   1B0C E5            [11] 4218 	PUSH	HL		; Save for angle > 1
   1B0D 21 17 1B      [10] 4219 ATN1:	LD	HL,ATNTAB	; Coefficient table
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 78
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1B10 CD D5 19      [17] 4220 	CALL	SUMSER		; Evaluate sum of series
   1B13 21 BE 1A      [10] 4221 	LD	HL,HALFPI	; PI/2 - angle in case > 1
   1B16 C9            [10] 4222 	RET			; Number > 1 - Sub from PI/2
                           4223 ;
   1B17 09                 4224 ATNTAB: .db	9			; Table used by ATN
   1B18 4A D7 3B 78        4225 	.db	0x04A,0x0D7,0x03B,0x078	; 1/17
   1B1C 02 6E 84 7B        4226 	.db	0x002,0x06E,0x084,0x07B	;-1/15
   1B20 FE C1 2F 7C        4227 	.db	0x0FE,0x0C1,0x02F,0x07C	; 1/13
   1B24 74 31 9A 7D        4228 	.db	0x074,0x031,0x09A,0x07D	;-1/11
   1B28 84 3D 5A 7D        4229 	.db	0x084,0x03D,0x05A,0x07D	; 1/9
   1B2C C8 7F 91 7E        4230 	.db	0x0C8,0x07F,0x091,0x07E	;-1/7
   1B30 E4 BB 4C 7E        4231 	.db	0x0E4,0x0BB,0x04C,0x07E	; 1/5
   1B34 6C AA AA 7F        4232 	.db	0x06C,0x0AA,0x0AA,0x07F	;-1/3
   1B38 00 00 00 81        4233 	.db	0x000,0x000,0x000,0x081	; 1/1
                           4234 ;
                           4235 
   1B3C C9            [10] 4236 ARET:	RET			; A RETurn instruction
                           4237 ;
   1B3D D7            [11] 4238 GETINP: RST	0x10		;input a character
   1B3E C9            [10] 4239 	RET
                           4240 ;
   1B3F                    4241 CLS: 
   1B3F 3E 0C         [ 7] 4242 	LD	A,CS		; ASCII Clear screen
   1B41 C3 67 1C      [10] 4243 	JP	MONOUT		; Output character
                           4244 ;
   1B44 CD 10 14      [17] 4245 WIDTH:	CALL	GETINT		; Get integer 0-255
   1B47 7B            [ 4] 4246 	LD	A,E		; Width to A
   1B48 32 87 80      [13] 4247 	LD	(LWIDTH),A	; Set width
   1B4B C9            [10] 4248 	RET
                           4249 ;
   1B4C CD AF 0C      [17] 4250 LINES:	CALL	GETNUM		; Get a number
   1B4F CD F4 08      [17] 4251 	CALL	DEINT		; Get integer -32768 to 32767
   1B52 ED 53 8B 80   [20] 4252 	LD	(LINESC),DE	; Set lines counter
   1B56 ED 53 8D 80   [20] 4253 	LD	(LINESN),DE	; Set lines number
   1B5A C9            [10] 4254 	RET
                           4255 ;
   1B5B CD F4 08      [17] 4256 DEEK:	CALL	DEINT		; Get integer -32768 to 32767
   1B5E D5            [11] 4257 	PUSH	DE		; Save number
   1B5F E1            [10] 4258 	POP	HL		; Number to HL
   1B60 46            [ 7] 4259 	LD	B,(HL)		; Get LSB of contents
   1B61 23            [ 6] 4260 	INC	HL
   1B62 7E            [ 7] 4261 	LD	A,(HL)		; Get MSB of contents
   1B63 C3 6A 10      [10] 4262 	JP	ABPASS		; Return integer AB
                           4263 ;
   1B66 CD AF 0C      [17] 4264 DOKE:	CALL	GETNUM		; Get a number
   1B69 CD F4 08      [17] 4265 	CALL	DEINT		; Get integer -32768 to 32767
   1B6C D5            [11] 4266 	PUSH	DE		; Save address
   1B6D CD C0 06      [17] 4267 	CALL	CHKSYN		; Make sure ', follows
   1B70 2C                 4268 	.db	',
   1B71 CD AF 0C      [17] 4269 	CALL	GETNUM		; Get a number
   1B74 CD F4 08      [17] 4270 	CALL	DEINT		; Get integer -32768 to 32767
   1B77 E3            [19] 4271 	EX	(SP),HL		; Save value,get address
   1B78 73            [ 7] 4272 	LD	(HL),E		; Save LSB of value
   1B79 23            [ 6] 4273 	INC	HL
   1B7A 72            [ 7] 4274 	LD	(HL),D		; Save MSB of value
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 79
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1B7B E1            [10] 4275 	POP	HL		; Restore code string address
   1B7C C9            [10] 4276 	RET
                           4277 ;
                           4278 
                           4279 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                           4280 ;
   1B7D CD B2 0C      [17] 4281 HEX: 	CALL	TSTNUM		; Verify it's a number
   1B80 CD F4 08      [17] 4282 	CALL	DEINT		; Get integer -32768 to 32767
   1B83 C5            [11] 4283 	PUSH	BC		; Save contents of BC
   1B84 21 2E 81      [10] 4284 	LD	HL,PBUFF
   1B87 7A            [ 4] 4285 	LD	A,D		; Get high order into A
   1B88 FE 00         [ 7] 4286 	CP	0
   1B8A 28 0C         [12] 4287 	JR	Z,HEX2		; Skip output if both high digits are zero
u  1B8C CD 00 00      [17] 4288 	CALL	BYT2ASC		; Convert D to ASCII
   1B8F 78            [ 4] 4289 	LD	A,B
   1B90 FE 30         [ 7] 4290 	CP	'0
   1B92 28 02         [12] 4291 	JR	Z,HEX1		; Don't store high digit if zero
   1B94 70            [ 7] 4292 	LD	(HL),B		; Store it to PBUFF
   1B95 23            [ 6] 4293 	INC	HL		; Next location
   1B96 71            [ 7] 4294 HEX1:	LD	(HL),C		; Store C to PBUFF+1
   1B97 23            [ 6] 4295 	INC	HL		; Next location
   1B98 7B            [ 4] 4296 HEX2:	LD	A,E		; Get lower byte
u  1B99 CD 00 00      [17] 4297 	CALL	BYT2ASC		; Convert E to ASCII
   1B9C 7A            [ 4] 4298 	LD	A,D
   1B9D FE 00         [ 7] 4299 	CP	0
   1B9F 20 05         [12] 4300 	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
   1BA1 78            [ 4] 4301 	LD	A,B
   1BA2 FE 30         [ 7] 4302 	CP	'0		; If high digit of lower byte is zero then don't print
   1BA4 28 02         [12] 4303 	JR	Z,HEX4
   1BA6 70            [ 7] 4304 HEX3:	LD	(HL),B		; to PBUFF+2
   1BA7 23            [ 6] 4305 	INC	HL		; Next location
   1BA8 71            [ 7] 4306 HEX4:	LD	(HL),C		; to PBUFF+3
   1BA9 23            [ 6] 4307 	INC	HL		; PBUFF+4 to zero
   1BAA AF            [ 4] 4308 	XOR	A		; Terminating character
   1BAB 77            [ 7] 4309 	LD	(HL),A		; Store zero to terminate
   1BAC 23            [ 6] 4310 	INC	HL		; Make sure PBUFF is terminated
   1BAD 77            [ 7] 4311 	LD	(HL),A		; Store the double zero there
   1BAE C1            [10] 4312 	POP	BC		; Get BC back
   1BAF 21 2E 81      [10] 4313 	LD	HL,PBUFF	; Reset to start of PBUFF
   1BB2 C3 18 11      [10] 4314 	JP	STR1		; Convert the PBUFF to a string and return it
                           4315 ;
o  1BB5                    4316 BYT2ASC	LD	B,A		; Save original value
   1BB5 E6 0F         [ 7] 4317 	AND	0x0F		; Strip off upper nybble
   1BB7 FE 0A         [ 7] 4318 	CP	0x0A		; 0-9?
u  1BB9 38 00         [12] 4319 	JR	C,ADD30		; If A-F, add 7 more
   1BBB C6 07         [ 7] 4320 	ADD	A,0x07		; Bring value up to ASCII A-F
o  1BBD                    4321 ADD30	ADD	A,0x30		; And make ASCII
   1BBD 4F            [ 4] 4322 	LD	C,A		; Save converted char to C
   1BBE 78            [ 4] 4323 	LD	A,B		; Retrieve original value
   1BBF 0F            [ 4] 4324 	RRCA			; and Rotate it right
   1BC0 0F            [ 4] 4325 	RRCA
   1BC1 0F            [ 4] 4326 	RRCA
   1BC2 0F            [ 4] 4327 	RRCA
   1BC3 E6 0F         [ 7] 4328 	AND	0x0F		; Mask off upper nybble
   1BC5 FE 0A         [ 7] 4329 	CP	0x0A		; 0-9? < A hex?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 80
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



u  1BC7 38 00         [12] 4330 	JR	C,ADD301	; Skip Add 7
   1BC9 C6 07         [ 7] 4331 	ADD	A,0x07		; Bring it up to ASCII A-F
o  1BCB                    4332 ADD301	ADD	A,0x30		; And make it full ASCII
   1BCB 47            [ 4] 4333 	LD	B,A		; Store high order byte
   1BCC C9            [10] 4334 	RET	
                           4335 ;
                           4336 ; Convert "&Hnnnn" to FPREG
                           4337 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                           4338 ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
o  1BCD                    4339 HEXTFP	EX	DE,HL		; Move code string pointer to DE
   1BCD 21 00 00      [10] 4340 	LD	HL,0x0000	; Zero out the value
u  1BD0 CD 00 00      [17] 4341 	CALL	GETHEX		; Check the number for valid hex
   1BD3 DA FD 1B      [10] 4342 	JP	C,HXERR		; First value wasn't hex, HX error
u  1BD6 18 00         [12] 4343 	JR	HEXLP1		; Convert first character
o  1BD8                    4344 HEXLP	CALL	GETHEX		; Get second and addtional characters
u  1BD8 38 00         [12] 4345 	JR	C,HEXIT		; Exit if not a hex character
o  1BDA                    4346 HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
   1BDA 29            [11] 4347 	ADD	HL,HL
   1BDB 29            [11] 4348 	ADD	HL,HL
   1BDC 29            [11] 4349 	ADD	HL,HL
   1BDD B5            [ 4] 4350 	OR	L		; Add in D0-D3 into L
   1BDE 6F            [ 4] 4351 	LD	L,A		; Save new value
u  1BDF 18 00         [12] 4352 	JR	HEXLP		; And continue until all hex characters are in
                           4353 ;
o  1BE1                    4354 GETHEX	INC	DE		; Next location
   1BE1 1A            [ 7] 4355 	LD	A,(DE)		; Load character at pointer
   1BE2 FE 20         [ 7] 4356 	CP	' 
u  1BE4 CA 00 00      [10] 4357 	JP	Z,GETHEX	; Skip spaces
   1BE7 D6 30         [ 7] 4358 	SUB	0x30		; Get absolute value
   1BE9 D8            [11] 4359 	RET	C		; < "0", error
   1BEA FE 0A         [ 7] 4360 	CP	0x0A
u  1BEC 38 00         [12] 4361 	JR	C,NOSUB7	; Is already in the range 0-9
   1BEE D6 07         [ 7] 4362 	SUB	0x07		; Reduce to A-F
   1BF0 FE 0A         [ 7] 4363 	CP	0x0A		; Value should be $0A-$0F at this point
   1BF2 D8            [11] 4364 	RET	C		; CY set if was :		; < = > ? @
o  1BF3                    4365 NOSUB7	CP	0x10		; > Greater than "F"?
   1BF3 3F            [ 4] 4366 	CCF
   1BF4 C9            [10] 4367 	RET			; CY set if it wasn't valid hex
                           4368 	
o  1BF5                    4369 HEXIT	EX	DE,HL		; Value into DE, Code string into HL
   1BF5 7A            [ 4] 4370 	LD	A,D		; Load DE into AC
   1BF6 4B            [ 4] 4371 	LD	C,E		; For prep to 
   1BF7 E5            [11] 4372 	PUSH	HL
   1BF8 CD 69 10      [17] 4373 	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
   1BFB E1            [10] 4374 	POP	HL
   1BFC C9            [10] 4375 	RET
                           4376 ;
   1BFD 1E 26         [ 7] 4377 HXERR:	LD	E,HX		; ?HEX Error
   1BFF C3 0C 04      [10] 4378 	JP	ERROR
                           4379 ;
                           4380 ; BIN$(NN) Convert integer to a 1-16 char binary string
   1C02 CD B2 0C      [17] 4381 BIN:	CALL	TSTNUM		; Verify it's a number
   1C05 CD F4 08      [17] 4382 	CALL	DEINT		; Get integer -32768 to 32767
   1C08 C5            [11] 4383 BIN2:	PUSH	BC		; Save contents of BC
   1C09 21 2E 81      [10] 4384 	LD	HL,PBUFF
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 81
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1C0C 06 11         [ 7] 4385 	LD	B,17		; One higher than max char count
   1C0E                    4386 ZEROSUP:			; Suppress leading zeros
   1C0E 05            [ 4] 4387 	DEC	B		; Max 16 chars
   1C0F 78            [ 4] 4388 	LD	A,B
   1C10 FE 01         [ 7] 4389 	CP	0x01
   1C12 28 08         [12] 4390 	JR	Z,BITOUT	; Always output at least one character
   1C14 CB 13         [ 8] 4391 	RL	E
   1C16 CB 12         [ 8] 4392 	RL	D
   1C18 30 F4         [12] 4393 	JR	NC,ZEROSUP
   1C1A 18 04         [12] 4394 	JR	BITOUT2
   1C1C                    4395 BITOUT:	
   1C1C CB 13         [ 8] 4396 	RL	E
   1C1E CB 12         [ 8] 4397 	RL	D		; Top bit now in carry
   1C20                    4398 BITOUT2:
   1C20 3E 30         [ 7] 4399 	LD	A,'0		; Char for '0
   1C22 CE 00         [ 7] 4400 	ADC	A,0		; If carry set then '0 --> '1
   1C24 77            [ 7] 4401 	LD	(HL),A
   1C25 23            [ 6] 4402 	INC	HL
   1C26 05            [ 4] 4403 	DEC	B
   1C27 20 F3         [12] 4404 	JR	NZ,BITOUT
   1C29 AF            [ 4] 4405 	XOR	A		; Terminating character
   1C2A 77            [ 7] 4406 	LD	(HL),A		; Store zero to terminate
   1C2B 23            [ 6] 4407 	INC	HL		; Make sure PBUFF is terminated
   1C2C 77            [ 7] 4408 	LD	(HL),A		; Store the double zero there
   1C2D C1            [10] 4409 	POP	BC
   1C2E 21 2E 81      [10] 4410 	LD	HL,PBUFF
   1C31 C3 18 11      [10] 4411 	JP	STR1
                           4412 ;
                           4413 ; Convert "&Bnnnn" to FPREG
                           4414 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
   1C34 EB            [ 4] 4415 BINTFP: EX	DE,HL		; Move code string pointer to DE
   1C35 21 00 00      [10] 4416 	LD	HL,0x0000	; Zero out the value
   1C38 CD 51 1C      [17] 4417 	CALL	CHKBIN		; Check the number for valid bin
   1C3B DA 5F 1C      [10] 4418 	JP	C,BINERR	; First value wasn't bin, HX error
   1C3E D6 30         [ 7] 4419 BINIT:	SUB	'0
   1C40 29            [11] 4420 	ADD	HL,HL		; Rotate HL left
   1C41 B5            [ 4] 4421 	OR	L
   1C42 6F            [ 4] 4422 	LD	L,A
   1C43 CD 51 1C      [17] 4423 	CALL	CHKBIN		; Get second and addtional characters
   1C46 30 F6         [12] 4424 	JR	NC,BINIT	; Process if a bin character
   1C48 EB            [ 4] 4425 	EX	DE,HL		; Value into DE, Code string into HL
   1C49 7A            [ 4] 4426 	LD	A,D		; Load DE into AC
   1C4A 4B            [ 4] 4427 	LD	C,E		; For prep to 
   1C4B E5            [11] 4428 	PUSH	HL
   1C4C CD 69 10      [17] 4429 	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
   1C4F E1            [10] 4430 	POP	HL
   1C50 C9            [10] 4431 	RET
                           4432 ;
                           4433 ; Char is in A, NC if char is 0 or 1
   1C51 13            [ 6] 4434 CHKBIN: INC	DE
   1C52 1A            [ 7] 4435 	LD	A,(DE)
   1C53 FE 20         [ 7] 4436 	CP	' 
   1C55 CA 51 1C      [10] 4437 	JP	Z,CHKBIN	; Skip spaces
   1C58 FE 30         [ 7] 4438 	CP	'0		; Set C if < '0
   1C5A D8            [11] 4439 	RET	C
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 82
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025



   1C5B FE 32         [ 7] 4440 	CP	'2
   1C5D 3F            [ 4] 4441 	CCF			; Set C if > '1
   1C5E C9            [10] 4442 	RET
                           4443 ;
   1C5F 1E 28         [ 7] 4444 BINERR: LD	E,BN		; ?BIN Error
   1C61 C3 0C 04      [10] 4445 	JP	ERROR
                           4446 ;
   1C64 C3 51 00      [10] 4447 JJUMP1: JP	CSTART		; Go and initialise
                           4448 ;
   1C67 C3 08 00      [10] 4449 MONOUT: JP	0x0008		; output a char
                           4450 ;
   1C6A C3 00 00      [10] 4451 MONITR: JP	0x0000		; Restart (Normally Monitor Start)
                           4452 ;
   1C6D 3E 00         [ 7] 4453 INITST: LD	A,0		; Clear break flag
   1C6F 32 92 80      [13] 4454 	LD	(BRKFLG),A
   1C72 C3 58 00      [10] 4455 	JP	INIT
                           4456 ;
   1C75 F5            [11] 4457 TSTBIT: PUSH	AF		; Save bit mask
   1C76 A0            [ 4] 4458 	AND	B		; Get common bits
   1C77 C1            [10] 4459 	POP	BC		; Restore bit mask
   1C78 B8            [ 4] 4460 	CP	B		; Same bit set?
   1C79 3E 00         [ 7] 4461 	LD	A,0		; Return 0 in A
   1C7B C9            [10] 4462 	RET
                           4463 ;
   1C7C CD CB 06      [17] 4464 OUTNCR: CALL	OUTC		; Output character in A
   1C7F C3 EA 0A      [10] 4465 	JP	PRCRLF		; Output CRLF
                           4466 ;
                           4467 	END
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 83
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Symbol Table

    .__.$$$.       =   2710 L   |     .__.ABS.       =   0000 G
    .__.CPU.       =   0000 L   |     .__.H$L.       =   0000 L
  2 ABPASS             106A R   |   2 ABS                16B4 R
  2 ACCSUM             08D3 R   |   2 ACPASS             1069 R
    ADD30              **** X   |     ADD301             **** X
  2 ADDEXP             164D R   |   2 ADDIG              17F3 R
  2 ADDPHL             143C R   |   2 ALLFOL             1338 R
  2 ANTVLU             0BD3 R   |   2 ARET               1B3C R
  2 ARLDSV             0F8A R   |     ARREND         =   811F 
  2 ARRLP              1203 R   |   2 ASC                1309 R
  2 ASCTFP             1796 R   |   2 ASPCS              0B35 R
  2 ATN                1AF0 R   |   2 ATN1               1B0D R
  2 ATNTAB             1B17 R   |   2 ATOH               090E R
  2 BADINP             0B5A R   |   2 BAKSTK             03A1 R
  2 BAKTMP             12E9 R   |     BASTXT         =   80A3 
  2 BCDEFP             16DB R   |   2 BFREE              00D1 R
  2 BIN                1C02 R   |   2 BIN2               1C08 R
  2 BINERR             1C5F R   |   2 BINIT              1C3E R
  2 BINTFP             1C34 R   |   2 BITOUT             1C1C R
  2 BITOUT2            1C20 R   |     BKSP           =   0008 
    BN             =   0028     |   2 BNORM              149C R
  2 BNRMLP             149F R   |     BRK                **** X
    BRKFLG         =   8092     |     BRKLIN         =   8113 
  2 BRKMSG             039B R   |   2 BRKRET             00C2 R
    BS             =   0010     |   2 BSERR              0FBD R
    BUFFER         =   80A6     |     BYT2ASC            **** X
  2 BYTSFT             15D2 R   |   2 CFEVAL             0F20 R
  2 CHARTY             0ECE R   |   2 CHEKFN             1101 R
  2 CHKBIN             1C51 R   |   2 CHKLTR             08E0 R
  2 CHKSTK             03D5 R   |     CHKSUM         =   808F 
  2 CHKSYN             06C0 R   |   2 CHKTYP             0CB4 R
  2 CHR                131A R   |   2 CLEAR              0933 R
  2 CLOTST             06F5 R   |   2 CLREG              052A R
  2 CLRPTR             0505 R   |   2 CLS                1B3F R
  2 CMPFP              1724 R   |   2 CMPLG1             0E34 R
  2 CMPLOG             0E32 R   |   2 CMPNUM             170A R
  2 CMPRES             0E76 R   |   2 CMPSTR             0E5E R
    CN             =   0020     |   2 CNVNUM             17A2 R
  2 COLD               0044 R   |     COMMAN         =   8088 
  2 COMPL              14FA R   |   2 CONCAT             127E R
  2 CONEXP             17D2 R   |   2 CONPOS             1499 R
  2 CONT               08B8 R   |     CONTAD         =   8119 
  2 CONVAR             0D9F R   |   2 COPY               0060 R
  2 COS                1A74 R   |   2 COUNT              0761 R
  2 CPDEHL             06BA R   |   2 CPYLIT             05F6 R
    CR             =   000D     |   2 CRARLP             0FDD R
  2 CREARY             0FC2 R   |   2 CRESTR             0A32 R
  2 CRNCLP             055D R   |   2 CRTMST             113A R
  2 CRTST              1146 R   |   2 CRTSTE             115C R
  2 CRUN0xC            0554 R   |     CS             =   000C 
  2 CSTART             0051 R   |     CTLOFG         =   808A 
    CTRLC          =   0003     |     CTRLG          =   0007 
    CTRLO          =   000F     |     CTRLQ          =   0011 
    CTRLR          =   0012     |     CTRLS          =   0013 
    CTRLU          =   0015     |     CUROPR         =   810A 
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 84
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Symbol Table

    CURPOS         =   80F0     |   2 DATA               09D9 R
    DATFLG         =   80F3     |     DATLIN         =   810E 
  2 DATSNR             03F2 R   |   2 DCBCDE             175B R
  2 DDERR              0401 R   |   2 DEEK               1B5B R
  2 DEF                107E R   |   2 DEFSIZ             0FE5 R
  2 DEINT              08F4 R   |     DEL            =   007F 
  2 DELCHR             0626 R   |   2 DEPINT             08EE R
  2 DETHL4             16EA R   |   2 DETHLB             16EC R
  2 DIGTXT             189C R   |   2 DIM                0EA0 R
  2 DIMRET             0E97 R   |   2 DINPOS             06EF R
  2 DIV                15E3 R   |     DIV1           =   804F 
  2 DIV10              15D7 R   |     DIV2           =   8053 
    DIV3           =   8057     |     DIV4           =   805A 
  2 DIVLP              160A R   |     DIVSUP         =   804E 
  2 DOAGN              0543 R   |   2 DOCOM              0B06 R
  2 DODEL              0606 R   |   2 DOEBIT             18DC R
  2 DOFN               10AB R   |   2 DOKE               1B66 R
  2 DONULL             0AF4 R   |   2 DOSPC              0B30 R
  2 DOTAB              0B1D R   |   2 DPOINT             17CE R
  2 DTSTR              114A R   |   2 DVBCDE             15E5 R
    DZ             =   0014     |   2 DZERR              03FB R
  2 ECHDEL             061A R   |   2 EDIGIT             1815 R
  2 ENDBUF             05FD R   |   2 ENDCON             17E1 R
  2 ENDDIM             1044 R   |   2 ENDINP             0AE5 R
  2 ENDNAM             0EC2 R   |   2 ENDPRG             0894 R
  2 ENFMEM             03DE R   |   2 ERRIN              042C R
    ERRLIN         =   8117     |   2 ERRMSG             0389 R
  2 ERROR              040C R   |   2 ERRORS             02FF R
    ESC            =   001B     |   2 EVAL               0CC1 R
  2 EVAL1              0CC4 R   |   2 EVAL2              0CCD R
  2 EVAL3              0CD0 R   |   2 EVLPAR             0D86 R
  2 EVNOT              0E80 R   |   2 EXCUTE             0826 R
  2 EXP                1974 R   |   2 EXPLP              17C0 R
  2 EXPTAB             19B4 R   |   2 EXPTEN             18EE R
  2 EXTIG              0C2F R   |   2 FANDT              0C59 R
    FC             =   0008     |   2 FCERR              0909 R
  2 FDTLP              0C40 R   |   2 FINDEL             1020 R
  2 FLGDIF             169A R   |   2 FLGREL             16A1 R
    FNARG          =   8125     |   2 FNCTAB             0149 R
  2 FNDARY             0F90 R   |   2 FNDELP             1025 R
  2 FNDEND             04D8 R   |   2 FNDNUM             140D R
  2 FNDTOK             0742 R   |   2 FNDVAR             0F07 R
  2 FNDWRD             0587 R   |   2 FNOFST             0DB0 R
    FNRGNM         =   8123     |   2 FNTHR              0F15 R
  2 FNVAL              0DD7 R   |   2 FOPRND             0CF9 R
  2 FOR                078D R   |     FORFLG         =   8110 
  2 FORFND             07BD R   |   2 FORSLP             07A1 R
  2 FPADD              144B R   |   2 FPBCDE             16D0 R
    FPEXP          =   812C     |   2 FPINT              1737 R
  2 FPMULT             1584 R   |     FPREG          =   8129 
  2 FPROND             14E1 R   |   2 FPSINT             08E8 R
  2 FPTHL              16E7 R   |   2 FRE                1048 R
  2 FRENUM             1064 R   |   2 FRMEVL             0DA2 R
  2 GARBGE             11CB R   |   2 GARBLP             11CE R
  2 GETCHR             0846 R   |   2 GETCMD             0450 R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 85
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Symbol Table

    GETHEX             **** X   |   2 GETINP             1B3D R
  2 GETINT             1410 R   |   2 GETLEN             12FE R
  2 GETLIN             0637 R   |   2 GETLN              090F R
  2 GETNUM             0CAF R   |   2 GETNXT             05A0 R
  2 GETSTR             12C8 R   |   2 GETVAR             0EA5 R
  2 GNXARY             1202 R   |   2 GOFUNC             0DDF R
  2 GOSUB              0985 R   |   2 GOTO               0996 R
  2 GRBARY             1222 R   |   2 GRBDON             11A3 R
  2 GRBLP              11DC R   |   2 GSTRCU             12CB R
  2 GSTRDE             12CF R   |   2 GSTRHL             12CE R
  2 GTFLNM             130D R   |   2 GTFNAM             0EAA R
  2 GTLNLP             0912 R   |   2 GTSIXD             1866 R
  2 GTVLUS             0BAB R   |   2 HALF               190D R
  2 HALFPI             1ABE R   |   2 HEX                1B7D R
  2 HEX1               1B96 R   |   2 HEX2               1B98 R
  2 HEX3               1BA6 R   |   2 HEX4               1BA8 R
    HEXIT              **** X   |     HEXLP              **** X
    HEXLP1             **** X   |     HEXTFP             **** X
    HX             =   0026     |   2 HXERR              1BFD R
    ID             =   0016     |   2 IDTEST             10F3 R
  2 IF                 0A68 R   |   2 IFGO               0A76 R
  2 IFJMP              082D R   |   2 INCHL              16E5 R
  2 INCLEN             06EB R   |   2 INDFND             03BB R
  2 INEWLN             04A0 R   |   2 INIT               0058 R
  2 INITAB             0329 R   |   2 INITBE             0389 R
  2 INITST             1C6D R   |   2 INMSG              0390 R
  2 INP                13CD R   |   2 INPBIN             0BFD R
  2 INPBRK             0893 R   |     INPORT         =   8084 
    INPSUB         =   8083     |   2 INPUT              0B6B R
  2 INRNG              186F R   |   2 INT                1762 R
  2 INTVAR             0514 R   |   2 INVSGN             16B8 R
  2 ITMSEP             0BEE R   |   2 JJUMP1             1C64 R
  2 JSTZER             18F8 R   |   2 KBHIT              002E R
  2 KILFOR             0C9F R   |   2 KILIN              0631 R
    LCRFLG         =   80F1     |   2 LEFT               132A R
  2 LEN                12FA R   |   2 LET                09F0 R
  2 LETNUM             0A43 R   |   2 LETSTR             0A0B R
    LF             =   000A     |   2 LFRGNM             13C3 R
    LINEAT         =   80A1     |   2 LINEIN             1821 R
  2 LINES              1B4C R   |     LINESC         =   808B 
    LINESN         =   808D     |   2 LINFND             0489 R
  2 LIST               0704 R   |   2 LISTLP             0710 R
  2 LOADFP             16DE R   |   2 LOG                1543 R
  2 LOGTAB             1536 R   |   2 LOKFOR             03A5 R
    LOOPST         =   810C     |     LS             =   001C 
    LSTBIN         =   8111     |   2 LSTLP2             0730 R
  2 LSTLP3             0733 R   |     LSTRAM         =   80F4 
    LSTRND         =   807F     |   2 LTSTND             0C08 R
    LWIDTH         =   8087     |   2 MAKINT             1413 R
  2 MAKNUM             188B R   |   2 MANLP              17AA R
  2 MAT0xC             05CE R   |   2 MEMMSG             0117 R
  2 MID                1364 R   |   2 MID1               1330 R
  2 MIDNUM             13C8 R   |   2 MINCDE             148B R
  2 MINUS              0D8E R   |   2 MKTMST             1137 R
  2 MLDBLP             1783 R   |   2 MLDEBC             177B R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 86
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Symbol Table

  2 MLOOP              0078 R   |   2 MLSP10             1678 R
    MO             =   0024     |   2 MONITR             1C6A R
  2 MONOUT             1C67 R   |   2 MORDT              0C14 R
  2 MORINP             0640 R   |   2 MOVBUF             04BF R
  2 MOVDIR             05D6 R   |   2 MOVLP              03CA R
  2 MOVSTR             03C7 R   |   2 MOVUP              03C4 R
  2 MRPRNT             0A88 R   |   2 MSIZE              0075 R
  2 MUL8LP             15AF R   |   2 MULLN2             157B R
  2 MULT               1582 R   |   2 MULT8              15A6 R
  2 MULTEN             17EC R   |     MULVAL         =   813B 
  2 MVSTPT             0A3A R   |   2 NEDMOR             0BA7 R
  2 NEGAFT             1923 R   |   2 NEMEM              00C8 R
  2 NEW                0504 R   |   2 NEXITM             0B40 R
  2 NEXT               0C64 R   |   2 NEXT1              0C67 R
    NF             =   0000     |   2 NFERR              03FE R
    NMIFLG         =   8091     |   2 NOCHNG             05C6 R
  2 NOENED             18FB R   |   2 NOLIN              08A7 R
  2 NOMADD             15C0 R   |   2 NOMLAD             1791 R
  2 NOPMPT             0B85 R   |   2 NORMAL             14B6 R
  2 NOSPC              05BF R   |     NOSUB7             **** X
  2 NOSWAP             1465 R   |   2 NOTAMP             0D63 R
  2 NOTSTR             0EDD R   |   2 NOXOR              13F3 R
  2 NSCFOR             0EED R   |     NULFLG         =   8089 
  2 NULL               08CB R   |   2 NULLP              0AFB R
    NULLS          =   8086     |   2 NUMASC             1834 R
  2 NXTARY             0FA4 R   |   2 NXTBYT             05AE R
  2 NXTCHR             05ED R   |     NXTDAT         =   8121 
  2 NXTDTA             09D8 R   |   2 NXTITM             0B9F R
    NXTOPR         =   8115     |   2 NXTSTL             09DF R
  2 NXTSTT             09E2 R   |     OD             =   0006 
  2 OKMSG              0395 R   |     OM             =   000C 
  2 OMERR              03ED R   |   2 ON                 0A4A R
  2 ONGO               0A59 R   |   2 ONGOLP             0A5A R
  2 ONJMP              082E R   |   2 OPNPAR             0CBD R
  2 OPRND              0D38 R   |     OS             =   001A 
  2 OTKLN              062E R   |     OTPORT         =   804C 
  2 OUTC               06CB R   |   2 OUTEXP             18EC R
  2 OUTIT              06AC R   |   2 OUTNBS             06B2 R
  2 OUTNCR             1C7C R   |     OUTSUB         =   804B 
  2 OUTWRD             074C R   |     OV             =   000A 
  2 OVERR              0407 R   |   2 OVTST1             166B R
  2 OVTST2             1670 R   |   2 OVTST3             1671 R
  2 PADD               1810 R   |   2 PAND               0DF9 R
  2 PASSA              1079 R   |     PBUFF          =   812E 
  2 PEEK               1421 R   |   2 PEND               088E R
  2 PHLTFP             16CD R   |   2 PLUCDE             14EE R
  2 PNORM              14BE R   |     POINT          =   8096 
  2 POKE               1428 R   |   2 POPAF              11BD R
  2 POPHL              12E7 R   |   2 POPHRT             15D0 R
  2 POPNOK             0442 R   |   2 POR                0DF8 R
  2 POR1               0E1B R   |   2 POS                1076 R
  2 POSINT             08EB R   |   2 POUT               13D9 R
  2 POWER              1931 R   |   2 POWER1             1941 R
  2 POWER2             195C R   |   2 POWERS             1911 R
  2 PRCRLF             0AEA R   |   2 PRINT              0A8C R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 87
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Symbol Table

  2 PRITAB             02EA R   |   2 PRNTHL             1829 R
  2 PRNTLP             0A8F R   |   2 PRNTNB             0AD2 R
  2 PRNTOK             0443 R   |   2 PRNTST             0AD6 R
  2 PRNUMS             1187 R   |   2 PROCES             0659 R
    PROGND         =   811B     |     PROGST         =   813E 
  2 PROMPT             0547 R   |   2 PRS                1188 R
  2 PRS1               118B R   |   2 PRSLP              1192 R
    PSET           =   8099     |   2 PSUB               1446 R
  2 PTRLP              04CC R   |   2 PUTBUF             0698 R
  2 PUTCTL             069D R   |   2 PUTFID             0802 R
  2 QTSTLP             114D R   |   2 QTSTR              1147 R
  2 QUARTR             1AC2 R   |     RAMSIZ         =   1000 
    RAMTOP         =   8000     |     RD             =   0012 
  2 READ               0B9A R   |     READFG         =   8112 
  2 REDO               0B47 R   |   2 REM                09DB R
  2 RESDIV             161D R   |   2 RESEED             1A60 R
    RESET          =   809C     |   2 RESTNL             086B R
  2 RESTOR             0856 R   |   2 RESZER             14B1 R
  2 RETADR             0F54 R   |   2 RETINT             16A6 R
  2 RETLIN             09D3 R   |   2 RETNAD             05D2 R
  2 RETNUL             0F57 R   |   2 RETNUM             0D9A R
  2 RETREL             1698 R   |   2 RETURN             09B4 R
    RG             =   0004     |   2 RIGHT              135A R
  2 RIGHT1             132E R   |     RINPUT         =   8093 
  2 RLTLP              0CDD R   |   2 RND                1A05 R
  2 RND1               1A3D R   |   2 RND2               1A57 R
  2 RNDTAB             1A68 R   |   2 RNGTST             18FE R
    ROMTOP         =   0000     |   2 RONDB              14D2 R
  2 RONDUP             14D1 R   |   2 ROUND              1439 R
  2 RSCALE             180A R   |   2 RSLNBK             0784 R
  2 RSTSTR             137D R   |   2 RUN                0979 R
  2 RUNCNT             0806 R   |   2 RUNFST             0510 R
  2 RUNLIN             0995 R   |   2 RXA                001B R
  2 SAVEXP             14B2 R   |   2 SAVSTP             07F9 R
  2 SAVSTR             1122 R   |   2 SBSCPT             0F62 R
  2 SCALE              150E R   |   2 SCALLP             1510 R
  2 SCALMI             17D5 R   |   2 SCALPL             17EB R
  2 SCNEND             1259 R   |   2 SCPTLP             0F68 R
  2 SEAR0xC            059E R   |     SEED           =   805C 
  2 SETIO              13FD R   |   2 SETLIN             0758 R
  2 SETLIT             05E4 R   |   2 SETPTR             04C7 R
  2 SETTOP             0087 R   |   2 SFTPRG             0491 R
  2 SGN                169E R   |   2 SGNEXP             0DE8 R
    SGNRES         =   812D     |   2 SHRITE             151D R
  2 SHRLP              1520 R   |   2 SHRT1              1524 R
  2 SIGNON             00E0 R   |   2 SIGNS              16F5 R
  2 SIN                1A7A R   |   2 SIN1               1AAA R
  2 SINIT              0041 R   |   2 SINTAB             1AC6 R
  2 SIXDIG             1851 R   |   2 SMPVAR             11ED R
  2 SMSER1             19E4 R   |     SN             =   0002 
  2 SNERR              03F8 R   |   2 SPCFST             1842 R
  2 SPCLP              0B39 R   |   2 SQR                1928 R
  2 SRCHLN             04E4 R   |   2 SRCHLP             04E7 R
  2 SSTSA              12B5 R   |     ST             =   001E 
    STACK          =   80AB     |   2 STAKFP             16C0 R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 88
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Symbol Table

  2 STALL              087F R   |   2 STARTB             004A R
  2 STKTHS             0D21 R   |     STLOOK         =   81A2 
  2 STOP               088C R   |   2 STORED             0956 R
  2 STPOOL             1230 R   |   2 STR                1112 R
  2 STR1               1118 R   |   2 STRADD             1233 R
    STRBOT         =   8108     |   2 STRENT             0BF1 R
    STRSPC         =   809F     |   2 STTLIN             0ADD R
  2 SUBCDE             1448 R   |   2 SUBPHL             1442 R
  2 SUMLP              19ED R   |   2 SUMSER             19D5 R
  2 SUPTLZ             18D0 R   |   2 SVNAM2             0EC1 R
  2 SVSTAD             1140 R   |   2 TAN                1ADB R
  2 TESTOS             11BF R   |   2 TESTR              11A1 R
    TM             =   0018     |   2 TMERR              040A R
    TMPSTR         =   8104     |     TMSTPL         =   80F8 
    TMSTPT         =   80F6     |   2 TOPOOL             1326 R
  2 TOSTRA             12BE R   |   2 TRYAGN             18AB R
  2 TSALP              12BF R   |     TSTACK         =   80ED 
  2 TSTBIT             1C75 R   |   2 TSTBRK             0871 R
  2 TSTNUM             0CB2 R   |   2 TSTOPL             1168 R
  2 TSTRED             0E20 R   |   2 TSTREM             05E7 R
  2 TSTSGN             168F R   |   2 TSTSTR             0CB3 R
  2 TTYLIN             0637 R   |   2 TXA                0034 R
  2 TXAST1             0035 R   |     TYPE           =   80F2 
    UARTCR         =   E001     |     UARTDR         =   E000 
    UF             =   0022     |   2 UFERR              0404 R
    UL             =   000E     |   2 ULERR              09AF R
  2 UNITY              1532 R   |   2 UPDATA             086C R
    USR            =   8048     |   2 VAL                1394 R
  2 VAL1               13B2 R   |   2 VAL2               13BC R
  2 VAL3               13BF R   |     VAREND         =   811D 
  2 WAIT               13DF R   |   2 WAITLP             13F4 R
  2 WARM               0047 R   |   2 WARMST             00BF R
  2 WIDTH              1B44 R   |   2 WORDS              0181 R
  2 WORDTB             02A0 R   |     WRKSPC         =   8045 
  2 XXXXX              00CE R   |     ZDATA          =   0083 
    ZDIV           =   00AF     |     ZEND           =   0080 
    ZEQUAL         =   00B4     |   2 ZERARY             1003 R
  2 ZERBYT         =   0394 R   |   2 ZEROLP             0F46 R
  2 ZEROSUP            1C0E R   |     ZFN            =   00A7 
    ZFOR           =   0081     |     ZGOSUB         =   008C 
    ZGOTO          =   0088     |     ZGTR           =   00B3 
    ZLEFT          =   00CF     |     ZLTH           =   00B5 
    ZMINUS         =   00AD     |     ZNEW           =   00A4 
    ZNOT           =   00AA     |   2 ZONELP             0B14 R
    ZOR            =   00B2     |     ZPLUS          =   00AC 
    ZPOINT         =   00C7     |     ZPRINT         =   009E 
    ZREM           =   008E     |     ZSGN           =   00B6 
    ZSPC           =   00A8     |     ZSTEP          =   00AB 
    ZTAB           =   00A5     |     ZTHEN          =   00A9 
    ZTIMES         =   00AE     |     ZTO            =   00A6 

ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 89
Hexadecimal [16-Bits]                                 Sat Mar  1 22:10:24 2025

Area Table

[_CSEG]
   0 _CODE            size    0   flags C080
   2 TEST             size 1C82   flags  908
[_DSEG]
   1 _DATA            size    0   flags C0C0

