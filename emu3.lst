ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 1
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                              1         .area   TEST (ABS)                              
                              2 ;	EMUBASIC based on GRANT's BASIC
                              3 ;	TARGET: EMUZ80
                              4 ;	ASSEMBLER: ARCPIT XZ80.EXE
                              5 ;
                              6 ;	START UP ROUTINE
                              7 ;	VERSION 1.0, 2022/02/15
                              8 ;	WRITTEN by TETSUYA SUZUKI
                              9 ;
                             10 ;	MEMORY ASIGN
                     0000    11 ROMTOP  .equ    0x0000                              
                     8000    12 RAMTOP  .equ    0x8000                              
                     1000    13 RAMSIZ  .equ    0x1000                              
                     80ED    14 TSTACK  .equ    0x80ED                              
                             15 ;
                             16 ;	UART REGISTER ADDRESS
                     E000    17 UARTDR  .equ    0x0E000         ; UART DATA REGISTOR
                     E001    18 UARTCR  .equ    0x0E001         ; UART CONTROL REGISTOR
                             19 ;
                             20 ;	RESET (RST 00H)
   0000                      21         .org    ROMTOP                              
   0000 F3            [ 4]   22         DI                                    
   0001 31 ED 80      [10]   23         LD      SP,TSTACK                              
   0004 C3 3D 00      [10]   24         JP      SINIT                              
                             25 ;
                             26 ;	PUT 1CHAR (RST 08H)
   0008                      27         .org    ROMTOP+0x08                              
   0008 C3 30 00      [10]   28         JP      TXA                              
                             29 ;
                             30 ;	GET 1CHAR (RST 10H)
   0010                      31         .org    ROMTOP+0x10                              
   0010 C3 1B 00      [10]   32         JP      RXA                              
                             33 ;
                             34 ;	KBHIT (RST 18H)
   0018                      35         .org    ROMTOP+0x18                              
   0018 C3 2A 00      [10]   36         JP      KBHIT                              
                             37 ;
                             38 ;	UART -> A
   001B 3A 01 E0      [13]   39 RXA:    LD      A,(UARTCR)                              
   001E CB 47         [ 8]   40         BIT     0,A                              
   0020 28 F9         [12]   41         JR      Z,RXA                              
   0022 3A 00 E0      [13]   42         LD      A,(UARTDR)                              
q  0025                      43         CP      'a'                              
   0025 D8            [11]   44         RET     C                              
q  0026                      45         CP      'z'+1                              
   0026 D0            [11]   46         RET     NC                              
   0027 E6 DF         [ 7]   47         AND     0x0DF                              
   0029 C9            [10]   48         RET                                   
                             49 ;
                             50 ;	CHECK RECEIVE STATUS
   002A 3A 01 E0      [13]   51 KBHIT:  LD      A,(UARTCR)                              
   002D CB 47         [ 8]   52         BIT     0,A                              
   002F C9            [10]   53         RET                                   
                             54 ;
                             55 ;	A -> UART
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 2
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0030 F5            [11]   56 TXA:    PUSH    AF                              
   0031 3A 01 E0      [13]   57 TXAST1: LD      A,(UARTCR)                              
   0034 CB 4F         [ 8]   58         BIT     1,A                              
   0036 28 F9         [12]   59         JR      Z,TXAST1                              
   0038 F1            [10]   60         POP     AF                              
   0039 32 00 E0      [13]   61         LD      (UARTDR),A                              
   003C C9            [10]   62         RET                                   
                             63 ;
                             64 ;
                             65 ;	SYSTEM INITIALIZE
   003D                      66 SINIT:                                        
   003D C3 40 00      [10]   67         JP      COLD                              
                             68 ;
                             69 ;==================================================================================
                             70 ; The updates to the original BASIC within this file are copyright Grant Searle
                             71 ;
                             72 ; You have permission to use this for NON COMMERCIAL USE ONLY
                             73 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                             74 ;
                             75 ; http://searle.hostei.com/grant/index.html
                             76 ;
                             77 ; eMail: home.micros01@btinternet.com
                             78 ;
                             79 ; If the above don't work, please perform an Internet search to see if I have
                             80 ; updated the web page hosting service.
                             81 ;
                             82 ;==================================================================================
                             83 ;
                             84 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                             85 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                             86 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                             87 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                             88 ; the original ROM code (checksum A934H). PA
                             89 ;
                             90 ; GENERAL EQUATES
                             91 ;
                     0003    92 CTRLC   .equ    0x03            ; Control "C"
                     0007    93 CTRLG   .equ    0x07            ; Control "G"
                     0008    94 BKSP    .equ    0x08            ; Back space
                     000A    95 LF      .equ    0x0A            ; Line feed
                     000C    96 CS      .equ    0x0C            ; Clear screen
                     000D    97 CR      .equ    0x0D            ; Carriage return
                     000F    98 CTRLO   .equ    0x0F            ; Control "O"
                     0011    99 CTRLQ   .equ    0x11            ; Control "Q"
                     0012   100 CTRLR   .equ    0x12            ; Control "R"
                     0013   101 CTRLS   .equ    0x13            ; Control "S"
                     0015   102 CTRLU   .equ    0x15            ; Control "U"
                     001B   103 ESC     .equ    0x1B            ; Escape
                     007F   104 DEL     .equ    0x7F            ; Delete
                            105 ;
                            106 ; BASIC WORK SPACE LOCATIONS
                            107 ;
                     8045   108 WRKSPC  .equ    0x8045          ; BASIC Work space
                     8048   109 USR     .equ    WRKSPC+0x3      ; "USR (x)" jump
                     804B   110 OUTSUB  .equ    WRKSPC+0x6      ; "OUT p,n"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 3
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                     804C   111 OTPORT  .equ    WRKSPC+0x7      ; Port (p)
                     804E   112 DIVSUP  .equ    WRKSPC+0x9      ; Division support routine
                     804F   113 DIV1    .equ    WRKSPC+0x0A     ; <- Values
                     8053   114 DIV2    .equ    WRKSPC+0x0E     ; <- to
                     8057   115 DIV3    .equ    WRKSPC+0x12     ; <- be
                     805A   116 DIV4    .equ    WRKSPC+0x15     ; <- inserted
                     805C   117 SEED    .equ    WRKSPC+0x17     ; Random number seed
                     807F   118 LSTRND  .equ    WRKSPC+0x3A     ; Last random number
                     8083   119 INPSUB  .equ    WRKSPC+0x3E     ; #INP (x)" Routine
                     8084   120 INPORT  .equ    WRKSPC+0x3F     ; PORT (x)
                     8086   121 NULLS   .equ    WRKSPC+0x41     ; Number of nulls
                     8087   122 LWIDTH  .equ    WRKSPC+0x42     ; Terminal width
                     8088   123 COMMAN  .equ    WRKSPC+0x43     ; Width for commas
                     8089   124 NULFLG  .equ    WRKSPC+0x44     ; Null after input byte flag
                     808A   125 CTLOFG  .equ    WRKSPC+0x45     ; Control "O" flag
                     808B   126 LINESC  .equ    WRKSPC+0x46     ; Lines counter
                     808D   127 LINESN  .equ    WRKSPC+0x48     ; Lines number
                     808F   128 CHKSUM  .equ    WRKSPC+0x4A     ; Array load/save check sum
                     8091   129 NMIFLG  .equ    WRKSPC+0x4C     ; Flag for NMI break routine
                     8092   130 BRKFLG  .equ    WRKSPC+0x4D     ; Break flag
                     8093   131 RINPUT  .equ    WRKSPC+0x4E     ; Input reflection
                     8096   132 POINT   .equ    WRKSPC+0x51     ; "POINT" reflection (unused)
                     8099   133 PSET    .equ    WRKSPC+0x54     ; "SET"	reflection
                     809C   134 RESET   .equ    WRKSPC+0x57     ; "RESET" reflection
                     809F   135 STRSPC  .equ    WRKSPC+0x5A     ; Bottom of string space
                     80A1   136 LINEAT  .equ    WRKSPC+0x5C     ; Current line number
                     80A3   137 BASTXT  .equ    WRKSPC+0x5E     ; Pointer to start of program
                     80A6   138 BUFFER  .equ    WRKSPC+0x61     ; Input buffer
                     80AB   139 STACK   .equ    WRKSPC+0x66     ; Initial stack
                     80F0   140 CURPOS  .equ    WRKSPC+0x0AB    ; Character position on line
                     80F1   141 LCRFLG  .equ    WRKSPC+0x0AC    ; Locate/Create flag
                     80F2   142 TYPE    .equ    WRKSPC+0x0AD    ; Data type flag
                     80F3   143 DATFLG  .equ    WRKSPC+0x0AE    ; Literal statement flag
                     80F4   144 LSTRAM  .equ    WRKSPC+0x0AF    ; Last available RAM
                     80F6   145 TMSTPT  .equ    WRKSPC+0x0B1    ; Temporary string pointer
                     80F8   146 TMSTPL  .equ    WRKSPC+0x0B3    ; Temporary string pool
                     8104   147 TMPSTR  .equ    WRKSPC+0x0BF    ; Temporary string
                     8108   148 STRBOT  .equ    WRKSPC+0x0C3    ; Bottom of string space
                     810A   149 CUROPR  .equ    WRKSPC+0x0C5    ; Current operator in EVAL
                     810C   150 LOOPST  .equ    WRKSPC+0x0C7    ; First statement of loop
                     810E   151 DATLIN  .equ    WRKSPC+0x0C9    ; Line of current DATA item
                     8110   152 FORFLG  .equ    WRKSPC+0x0CB    ; "FOR" loop flag
                     8111   153 LSTBIN  .equ    WRKSPC+0x0CC    ; Last byte entered
                     8112   154 READFG  .equ    WRKSPC+0x0CD    ; Read/Input flag
                     8113   155 BRKLIN  .equ    WRKSPC+0x0CE    ; Line of break
                     8115   156 NXTOPR  .equ    WRKSPC+0x0D0    ; Next operator in EVAL
                     8117   157 ERRLIN  .equ    WRKSPC+0x0D2    ; Line of error
                     8119   158 CONTAD  .equ    WRKSPC+0x0D4    ; Where to CONTinue
                     811B   159 PROGND  .equ    WRKSPC+0x0D6    ; End of program
                     811D   160 VAREND  .equ    WRKSPC+0x0D8    ; End of variables
                     811F   161 ARREND  .equ    WRKSPC+0x0DA    ; End of arrays
                     8121   162 NXTDAT  .equ    WRKSPC+0x0DC    ; Next data item
                     8123   163 FNRGNM  .equ    WRKSPC+0x0DE    ; Name of FN argument
                     8125   164 FNARG   .equ    WRKSPC+0x0E0    ; FN argument value
                     8129   165 FPREG   .equ    WRKSPC+0x0E4    ; Floating point register
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 4
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                     812C   166 FPEXP   .equ    FPREG+3         ; Floating point exponent
                     812D   167 SGNRES  .equ    WRKSPC+0x0E8    ; Sign of result
                     812E   168 PBUFF   .equ    WRKSPC+0x0E9    ; Number print buffer
                     813B   169 MULVAL  .equ    WRKSPC+0x0F6    ; Multiplier
                     813E   170 PROGST  .equ    WRKSPC+0x0F9    ; Start of program text area
                     81A2   171 STLOOK  .equ    WRKSPC+0x15D    ; Start of memory test
                            172 ;
                            173 ; BASIC ERROR CODE VALUES
                            174 ;
                     0000   175 NF      .equ    0x00            ; NEXT without FOR
                     0002   176 SN      .equ    0x02            ; Syntax error
                     0004   177 RG      .equ    0x04            ; RETURN without GOSUB
                     0006   178 OD      .equ    0x06            ; Out of DATA
                     0008   179 FC      .equ    0x08            ; Function call error
                     000A   180 OV      .equ    0x0A            ; Overflow
                     000C   181 OM      .equ    0x0C            ; Out of memory
                     000E   182 UL      .equ    0x0E            ; Undefined line number
                     0010   183 BS      .equ    0x10            ; Bad subscript
                     0012   184 RD      .equ    0x12            ; Re-DIMensioned array
                     0014   185 DZ      .equ    0x14            ; Division by zero (/0)
                     0016   186 ID      .equ    0x16            ; Illegal direct
                     0018   187 TM      .equ    0x18            ; Type miss-match
                     001A   188 OS      .equ    0x1A            ; Out of string space
                     001C   189 LS      .equ    0x1C            ; String too long
                     001E   190 ST      .equ    0x1E            ; String formula too complex
                     0020   191 CN      .equ    0x20            ; Can't CONTinue
                     0022   192 UF      .equ    0x22            ; UnDEFined FN function
                     0024   193 MO      .equ    0x24            ; Missing operand
                     0026   194 HX      .equ    0x26            ; HEX error
                     0028   195 BN      .equ    0x28            ; BIN error
                            196 ;
   0040 C3 46 00      [10]  197 COLD:   JP      STARTB          ; Jump for cold start
   0043 C3 B9 00      [10]  198 WARM:   JP      WARMST          ; Jump for warm start
   0046 C3 4D 00      [10]  199 STARTB: JP      CSTART          ; Jump to initialise
                            200 ;
   0049 10 09               201         .dw     DEINT           ; Get integer -32768 to 32767
   004B AA 10               202         .dw     ABPASS          ; Return integer in AB
                            203 ;
   004D 21 45 80      [10]  204 CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
   0050 F9            [ 6]  205         LD      SP,HL           ; Set up a temporary stack
   0051 C3 9F 1C      [10]  206         JP      INITST          ; Go to initialise
                            207 ;
   0054 11 23 03      [10]  208 INIT:   LD      DE,INITAB       ; Initialise workspace
q  0057                     209         LD      B,INITBE-INITAB+; Bytes to copy
   0057 21 45 80      [10]  210         LD      HL,WRKSPC       ; Into workspace RAM
   005A 1A            [ 7]  211 COPY:   LD      A,(DE)          ; Get source
   005B 77            [ 7]  212         LD      (HL),A          ; To destination
   005C 23            [ 6]  213         INC     HL              ; Next destination
   005D 13            [ 6]  214         INC     DE              ; Next source
   005E 05            [ 4]  215         DEC     B               ; Count bytes
   005F C2 5A 00      [10]  216         JP      NZ,COPY         ; More to move
   0062 F9            [ 6]  217         LD      SP,HL           ; Temporary stack
   0063 CD 52 05      [17]  218         CALL    CLREG           ; Clear registers and stack
   0066 CD 16 0B      [17]  219         CALL    PRCRLF          ; Output CRLF
   0069 32 EF 80      [13]  220         LD      (BUFFER+72+1),A ; Mark end of buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 5
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   006C 32 3E 81      [13]  221         LD      (PROGST),A      ; Initialise program area
   006F 21 A2 81      [10]  222 MSIZE:  LD      HL,STLOOK       ; Point to start of RAM
   0072 23            [ 6]  223 MLOOP:  INC     HL              ; Next byte
   0073 7C            [ 4]  224         LD      A,H             ; Above address FFFF ?
   0074 B5            [ 4]  225         OR      L                              
   0075 CA 81 00      [10]  226         JP      Z,SETTOP        ; Yes - 64K RAM
   0078 7E            [ 7]  227         LD      A,(HL)          ; Get contents
   0079 47            [ 4]  228         LD      B,A             ; Save it
   007A 2F            [ 4]  229         CPL                     ; Flip all bits
   007B 77            [ 7]  230         LD      (HL),A          ; Put it back
   007C BE            [ 7]  231         CP      (HL)            ; RAM there if same
   007D 70            [ 7]  232         LD      (HL),B          ; Restore old contents
   007E CA 72 00      [10]  233         JP      Z,MLOOP         ; If RAM - test next byte
                            234 ;
   0081 2B            [ 6]  235 SETTOP: DEC     HL              ; Back one byte
   0082 11 A1 81      [10]  236         LD      DE,STLOOK-1     ; See if enough RAM
   0085 CD D1 06      [17]  237         CALL    CPDEHL          ; Compare DE with HL
   0088 DA C2 00      [10]  238         JP      C,NEMEM         ; If not enough RAM
   008B 11 CE FF      [10]  239         LD      DE,0-50         ; 50 Bytes string space
   008E 22 F4 80      [16]  240         LD      (LSTRAM),HL     ; Save last available RAM
   0091 19            [11]  241         ADD     HL,DE           ; Allocate string space
   0092 22 9F 80      [16]  242         LD      (STRSPC),HL     ; Save string space
   0095 CD 2D 05      [17]  243         CALL    CLRPTR          ; Clear program area
   0098 2A 9F 80      [16]  244         LD      HL,(STRSPC)     ; Get end of memory
   009B 11 EF FF      [10]  245         LD      DE,0-17         ; Offset for free bytes
   009E 19            [11]  246         ADD     HL,DE           ; Adjust HL
   009F 11 3E 81      [10]  247         LD      DE,PROGST       ; Start of program text
   00A2 7D            [ 4]  248         LD      A,L             ; Get LSB
   00A3 93            [ 4]  249         SUB     E               ; Adjust it
   00A4 6F            [ 4]  250         LD      L,A             ; Re-save
   00A5 7C            [ 4]  251         LD      A,H             ; Get MSB
   00A6 9A            [ 4]  252         SBC     A,D             ; Adjust it
   00A7 67            [ 4]  253         LD      H,A             ; Re-save
   00A8 E5            [11]  254         PUSH    HL              ; Save bytes free
   00A9 21 DA 00      [10]  255         LD      HL,SIGNON       ; Sign-on message
   00AC CD CB 11      [17]  256         CALL    PRS             ; Output string
   00AF E1            [10]  257         POP     HL              ; Get bytes free back
   00B0 CD 83 18      [17]  258         CALL    PRNTHL          ; Output amount of free memory
   00B3 21 CB 00      [10]  259         LD      HL,BFREE        ; " Bytes free" message
   00B6 CD CB 11      [17]  260         CALL    PRS             ; Output string
                            261 ;
   00B9 31 AB 80      [10]  262 WARMST: LD      SP,STACK        ; Temporary stack
   00BC CD 52 05      [17]  263 BRKRET: CALL    CLREG           ; Clear registers and stack
   00BF C3 6B 04      [10]  264         JP      PRNTOK          ; Go to get command line
                            265 ;
   00C2 21 11 01      [10]  266 NEMEM:  LD      HL,MEMMSG       ; Memory size not enough
   00C5 CD CB 11      [17]  267         CALL    PRS             ; Print it
   00C8 C3 C8 00      [10]  268 XXXXX:  JP      XXXXX           ; Stop
                            269 ;
   00CB 20 42 79 74 65 73   270 BFREE:  .ascii  " Bytes free"                              
        20 66 72 65 65
   00D6 0D 0A 00 00         271         .db     CR,LF,0,0                              
                            272 ;
   00DA 5A 38 30 20 42 41   273 SIGNON: .ascii  "Z80 BASIC Ver 4.7b"                              
        53 49 43 20 56 65
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 6
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



        72 20 34 2E 37 62
   00EC 0D 0A               274         .db     CR,LF                              
   00EE 43 6F 70 79 72 69   275         .ascii  "Copyright "                              
        67 68 74 20
   00F8 28                  276         .db     40                              
   00F9 43                  277         .ascii  "C"                              
   00FA 29                  278         .db     41                              
   00FB 20 31 39 37 38 20   279         .ascii  " 1978 by Microsoft"                              
        62 79 20 4D 69 63
        72 6F 73 6F 66 74
   010D 0D 0A 00 00         280         .db     CR,LF,0,0                              
                            281 ;
   0111 4D 65 6D 6F 72 79   282 MEMMSG: .ascii  "Memory size not enough"                              
        20 73 69 7A 65 20
        6E 6F 74 20 65 6E
        6F 75 67 68
   0127 0D 0A               283         .db     CR,LF                              
   0129 54 68 65 20 73 79   284         .ascii  "The system is stopped."                              
        73 74 65 6D 20 69
        73 20 73 74 6F 70
        70 65 64 2E
   013F 0D 0A 00 00         285         .db     CR,LF,0,0                              
                            286 ;
                            287 ; FUNCTION ADDRESS TABLE
                            288 ;
   0143 04 17               289 FNCTAB: .dw     SGN                              
   0145 C8 17               290         .dw     INT                              
   0147 1A 17               291         .dw     ABS                              
   0149 48 80               292         .dw     USR                              
   014B 88 10               293         .dw     FRE                              
   014D 10 14               294         .dw     INP                              
   014F B6 10               295         .dw     POS                              
   0151 7D 19               296         .dw     SQR                              
   0153 58 1A               297         .dw     RND                              
   0155 8F 15               298         .dw     LOG                              
   0157 C9 19               299         .dw     EXP                              
   0159 C4 1A               300         .dw     COS                              
   015B CA 1A               301         .dw     SIN                              
   015D 24 1B               302         .dw     TAN                              
   015F 39 1B               303         .dw     ATN                              
   0161 64 14               304         .dw     PEEK                              
   0163 9B 1B               305         .dw     DEEK                              
   0165 96 80               306         .dw     POINT                              
   0167 3D 13               307         .dw     LEN                              
   0169 57 11               308         .dw     STR                              
   016B DB 13               309         .dw     VAL                              
   016D 4C 13               310         .dw     ASC                              
   016F 5D 13               311         .dw     CHR                              
   0171 BD 1B               312         .dw     HEX                              
   0173 3C 1C               313         .dw     BIN                              
   0175 6D 13               314         .dw     LEFT                              
   0177 A3 13               315         .dw     RIGHT                              
   0179 AD 13               316         .dw     MID                              
                            317 ;
                            318 ; RESERVED WORD LIST
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 7
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                            319 ;
   017B C5                  320 WORDS:  .db     0x0C5                              
   017C 4E 44               321         .ascii  "ND"                              
   017E C6                  322         .db     0x0C6                              
   017F 4F 52               323         .ascii  "OR"                              
   0181 CE                  324         .db     0x0CE                              
   0182 45 58 54            325         .ascii  "EXT"                              
   0185 C4                  326         .db     0x0C4                              
   0186 41 54 41            327         .ascii  "ATA"                              
   0189 C9                  328         .db     0x0C9                              
   018A 4E 50 55 54         329         .ascii  "NPUT"                              
   018E C4                  330         .db     0x0C4                              
   018F 49 4D               331         .ascii  "IM"                              
   0191 D2                  332         .db     0x0D2                              
   0192 45 41 44            333         .ascii  "EAD"                              
   0195 CC                  334         .db     0x0CC                              
   0196 45 54               335         .ascii  "ET"                              
   0198 C7                  336         .db     0x0C7                              
   0199 4F 54 4F            337         .ascii  "OTO"                              
   019C D2                  338         .db     0x0D2                              
   019D 55 4E               339         .ascii  "UN"                              
   019F C9                  340         .db     0x0C9                              
   01A0 46                  341         .ascii  "F"                              
   01A1 D2                  342         .db     0x0D2                              
   01A2 45 53 54 4F 52 45   343         .ascii  "ESTORE"                              
   01A8 C7                  344         .db     0x0C7                              
   01A9 4F 53 55 42         345         .ascii  "OSUB"                              
   01AD D2                  346         .db     0x0D2                              
   01AE 45 54 55 52 4E      347         .ascii  "ETURN"                              
   01B3 D2                  348         .db     0x0D2                              
   01B4 45 4D               349         .ascii  "EM"                              
   01B6 D3                  350         .db     0x0D3                              
   01B7 54 4F 50            351         .ascii  "TOP"                              
   01BA CF                  352         .db     0x0CF                              
   01BB 55 54               353         .ascii  "UT"                              
   01BD CF                  354         .db     0x0CF                              
   01BE 4E                  355         .ascii  "N"                              
   01BF CE                  356         .db     0x0CE                              
   01C0 55 4C 4C            357         .ascii  "ULL"                              
   01C3 D7                  358         .db     0x0D7                              
   01C4 41 49 54            359         .ascii  "AIT"                              
   01C7 C4                  360         .db     0x0C4                              
   01C8 45 46               361         .ascii  "EF"                              
   01CA D0                  362         .db     0x0D0                              
   01CB 4F 4B 45            363         .ascii  "OKE"                              
   01CE C4                  364         .db     0x0C4                              
   01CF 4F 4B 45            365         .ascii  "OKE"                              
   01D2 D3                  366         .db     0x0D3                              
   01D3 43 52 45 45 4E      367         .ascii  "CREEN"                              
   01D8 CC                  368         .db     0x0CC                              
   01D9 49 4E 45 53         369         .ascii  "INES"                              
   01DD C3                  370         .db     0x0C3                              
   01DE 4C 53               371         .ascii  "LS"                              
   01E0 D7                  372         .db     0x0D7                              
   01E1 49 44 54 48         373         .ascii  "IDTH"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 8
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   01E5 CD                  374         .db     0x0CD                              
   01E6 4F 4E 49 54 4F 52   375         .ascii  "ONITOR"                              
   01EC D3                  376         .db     0x0D3                              
   01ED 45 54               377         .ascii  "ET"                              
   01EF D2                  378         .db     0x0D2                              
   01F0 45 53 45 54         379         .ascii  "ESET"                              
   01F4 D0                  380         .db     0x0D0                              
   01F5 52 49 4E 54         381         .ascii  "RINT"                              
   01F9 C3                  382         .db     0x0C3                              
   01FA 4F 4E 54            383         .ascii  "ONT"                              
   01FD CC                  384         .db     0x0CC                              
   01FE 49 53 54            385         .ascii  "IST"                              
   0201 C3                  386         .db     0x0C3                              
   0202 4C 45 41 52         387         .ascii  "LEAR"                              
   0206 C3                  388         .db     0x0C3                              
   0207 4C 4F 41 44         389         .ascii  "LOAD"                              
   020B C3                  390         .db     0x0C3                              
   020C 53 41 56 45         391         .ascii  "SAVE"                              
   0210 CE                  392         .db     0x0CE                              
   0211 45 57               393         .ascii  "EW"                              
                            394 ;
   0213 D4                  395         .db     0x0D4                              
   0214 41 42 28            396         .ascii  "AB("                              
   0217 D4                  397         .db     0x0D4                              
   0218 4F                  398         .ascii  "O"                              
   0219 C6                  399         .db     0x0C6                              
   021A 4E                  400         .ascii  "N"                              
   021B D3                  401         .db     0x0D3                              
   021C 50 43 28            402         .ascii  "PC("                              
   021F D4                  403         .db     0x0D4                              
   0220 48 45 4E            404         .ascii  "HEN"                              
   0223 CE                  405         .db     0x0CE                              
   0224 4F 54               406         .ascii  "OT"                              
   0226 D3                  407         .db     0x0D3                              
   0227 54 45 50            408         .ascii  "TEP"                              
                            409 ;
   022A AB                  410         .db     0x0AB                              
   022B AD                  411         .db     0x0AD                              
   022C AA                  412         .db     0x0AA                              
   022D AF                  413         .db     0x0AF                              
   022E DE                  414         .db     0x0DE                              
   022F C1                  415         .db     0x0C1                              
   0230 4E 44               416         .ascii  "ND"                              
   0232 CF                  417         .db     0x0CF                              
   0233 52                  418         .ascii  "R"                              
   0234 BE                  419         .db     0x0BE                              
   0235 BD                  420         .db     0x0BD                              
   0236 BC                  421         .db     0x0BC                              
                            422 ;
   0237 D3                  423         .db     0x0D3                              
   0238 47 4E               424         .ascii  "GN"                              
   023A C9                  425         .db     0x0C9                              
   023B 4E 54               426         .ascii  "NT"                              
   023D C1                  427         .db     0x0C1                              
   023E 42 53               428         .ascii  "BS"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 9
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0240 D5                  429         .db     0x0D5                              
   0241 53 52               430         .ascii  "SR"                              
   0243 C6                  431         .db     0x0C6                              
   0244 52 45               432         .ascii  "RE"                              
   0246 C9                  433         .db     0x0C9                              
   0247 4E 50               434         .ascii  "NP"                              
   0249 D0                  435         .db     0x0D0                              
   024A 4F 53               436         .ascii  "OS"                              
   024C D3                  437         .db     0x0D3                              
   024D 51 52               438         .ascii  "QR"                              
   024F D2                  439         .db     0x0D2                              
   0250 4E 44               440         .ascii  "ND"                              
   0252 CC                  441         .db     0x0CC                              
   0253 4F 47               442         .ascii  "OG"                              
   0255 C5                  443         .db     0x0C5                              
   0256 58 50               444         .ascii  "XP"                              
   0258 C3                  445         .db     0x0C3                              
   0259 4F 53               446         .ascii  "OS"                              
   025B D3                  447         .db     0x0D3                              
   025C 49 4E               448         .ascii  "IN"                              
   025E D4                  449         .db     0x0D4                              
   025F 41 4E               450         .ascii  "AN"                              
   0261 C1                  451         .db     0x0C1                              
   0262 54 4E               452         .ascii  "TN"                              
   0264 D0                  453         .db     0x0D0                              
   0265 45 45 4B            454         .ascii  "EEK"                              
   0268 C4                  455         .db     0x0C4                              
   0269 45 45 4B            456         .ascii  "EEK"                              
   026C D0                  457         .db     0x0D0                              
   026D 4F 49 4E 54         458         .ascii  "OINT"                              
   0271 CC                  459         .db     0x0CC                              
   0272 45 4E               460         .ascii  "EN"                              
   0274 D3                  461         .db     0x0D3                              
   0275 54 52 24            462         .ascii  "TR$"                              
   0278 D6                  463         .db     0x0D6                              
   0279 41 4C               464         .ascii  "AL"                              
   027B C1                  465         .db     0x0C1                              
   027C 53 43               466         .ascii  "SC"                              
   027E C3                  467         .db     0x0C3                              
   027F 48 52 24            468         .ascii  "HR$"                              
   0282 C8                  469         .db     0x0C8                              
   0283 45 58 24            470         .ascii  "EX$"                              
   0286 C2                  471         .db     0x0C2                              
   0287 49 4E 24            472         .ascii  "IN$"                              
   028A CC                  473         .db     0x0CC                              
   028B 45 46 54 24         474         .ascii  "EFT$"                              
   028F D2                  475         .db     0x0D2                              
   0290 49 47 48 54 24      476         .ascii  "IGHT$"                              
   0295 CD                  477         .db     0x0CD                              
   0296 49 44 24            478         .ascii  "ID$"                              
   0299 80                  479         .db     0x80            ; End of list marker
                            480 ;
                            481 ; KEYWORD ADDRESS TABLE
                            482 ;
   029A A2 08               483 WORDTB: .dw     PEND                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 10
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   029C A2 07               484         .dw     FOR                              
   029E 93 0C               485         .dw     NEXT                              
   02A0 F9 09               486         .dw     DATA                              
   02A2 97 0B               487         .dw     INPUT                              
   02A4 C1 0E               488         .dw     DIM                              
   02A6 CB 0B               489         .dw     READ                              
   02A8 0E 0A               490         .dw     LET                              
   02AA B0 09               491         .dw     GOTO                              
   02AC 93 09               492         .dw     RUN                              
   02AE 91 0A               493         .dw     IF                              
   02B0 66 08               494         .dw     RESTOR                              
   02B2 9F 09               495         .dw     GOSUB                              
   02B4 CE 09               496         .dw     RETURN                              
   02B6 FB 09               497         .dw     REM                              
   02B8 9C 08               498         .dw     STOP                              
   02BA 1C 14               499         .dw     POUT                              
   02BC 70 0A               500         .dw     ON                              
   02BE EB 08               501         .dw     NULL                              
   02C0 22 14               502         .dw     WAIT                              
   02C2 BE 10               503         .dw     DEF                              
   02C4 6B 14               504         .dw     POKE                              
   02C6 A6 1B               505         .dw     DOKE                              
   02C8 FB 09               506         .dw     REM                              
   02CA 8C 1B               507         .dw     LINES                              
   02CC 7F 1B               508         .dw     CLS                              
   02CE 84 1B               509         .dw     WIDTH                              
   02D0 9C 1C               510         .dw     MONITR                              
   02D2 99 80               511         .dw     PSET                              
   02D4 9C 80               512         .dw     RESET                              
   02D6 BA 0A               513         .dw     PRINT                              
   02D8 D8 08               514         .dw     CONT                              
   02DA 19 07               515         .dw     LIST                              
   02DC 4D 09               516         .dw     CLEAR                              
   02DE FB 09               517         .dw     REM                              
   02E0 FB 09               518         .dw     REM                              
   02E2 2C 05               519         .dw     NEW                              
                            520 ;
                            521 ; RESERVED WORD TOKEN VALUES
                            522 ;
                     0080   523 ZEND    .equ    0x080           ; END
                     0081   524 ZFOR    .equ    0x081           ; FOR
                     0083   525 ZDATA   .equ    0x083           ; DATA
                     0088   526 ZGOTO   .equ    0x088           ; GOTO
                     008C   527 ZGOSUB  .equ    0x08C           ; GOSUB
                     008E   528 ZREM    .equ    0x08E           ; REM
                     009E   529 ZPRINT  .equ    0x09E           ; PRINT
                     00A4   530 ZNEW    .equ    0x0A4           ; NEW
                            531 ;
                     00A5   532 ZTAB    .equ    0x0A5           ; TAB
                     00A6   533 ZTO     .equ    0x0A6           ; TO
                     00A7   534 ZFN     .equ    0x0A7           ; FN
                     00A8   535 ZSPC    .equ    0x0A8           ; SPC
                     00A9   536 ZTHEN   .equ    0x0A9           ; THEN
                     00AA   537 ZNOT    .equ    0x0AA           ; NOT
                     00AB   538 ZSTEP   .equ    0x0AB           ; STEP
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 11
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                            539 ;
                     00AC   540 ZPLUS   .equ    0x0AC           ; +
                     00AD   541 ZMINUS  .equ    0x0AD           ; -
                     00AE   542 ZTIMES  .equ    0x0AE           ; *
                     00AF   543 ZDIV    .equ    0x0AF           ; /
                     00B2   544 ZOR     .equ    0x0B2           ; OR
                     00B3   545 ZGTR    .equ    0x0B3           ; >
                     00B4   546 ZEQUAL  .equ    0x0B4           ; M
                     00B5   547 ZLTH    .equ    0x0B5           ; <
                     00B6   548 ZSGN    .equ    0x0B6           ; SGN
                     00C7   549 ZPOINT  .equ    0x0C7           ; POINT
                     00CF   550 ZLEFT   .equ    0x0CD+2         ; LEFT$
                            551 ;
                            552 ; ARITHMETIC PRECEDENCE TABLE
                            553 ;
   02E4 79                  554 PRITAB: .db     0x79            ; Precedence value
   02E5 6C 18               555         .dw     PADD            ; FPREG = <last> + FPREG
                            556 ;
   02E7 79                  557         .db     0x79            ; Precedence value
   02E8 96 14               558         .dw     PSUB            ; FPREG = <last> - FPREG
                            559 ;
   02EA 7C                  560         .db     0x7C            ; Precedence value
   02EB DB 15               561         .dw     MULT            ; PPREG = <last> * FPREG
                            562 ;
   02ED 7C                  563         .db     0x7C            ; Precedence value
   02EE 3C 16               564         .dw     DIV             ; FPREG = <last> / FPREG
                            565 ;
   02F0 7F                  566         .db     0x7F            ; Precedence value
   02F1 86 19               567         .dw     POWER           ; FPREG = <last> ^ FPREG
                            568 ;
   02F3 50                  569         .db     0x50            ; Precedence value
   02F4 1A 0E               570         .dw     PAND            ; FPREG = <last> AND FPREG
                            571 ;
   02F6 46                  572         .db     0x46            ; Precedence value
   02F7 17 0E               573         .dw     POR             ; FPREG = <last> OR FPREG
                            574 ;
                            575 ; BASIC ERROR CODE LIST
                            576 ;
   02F9 4E 46               577 ERRORS: .ascii  "NF"                              
q  02FB                     578         .db                     ; NEXT without FOR
   02FB 53 4E               579         .ascii  "SN"                              
q  02FD                     580         .db                     ; Syntax error
   02FD 52 47               581         .ascii  "RG"                              
q  02FF                     582         .db                     ; RETURN without GOSUB
   02FF 4F 44               583         .ascii  "OD"                              
q  0301                     584         .db                     ; Out of DATA
   0301 46 43               585         .ascii  "FC"                              
q  0303                     586         .db                     ; Illegal function call
   0303 4F 56               587         .ascii  "OV"                              
q  0305                     588         .db                     ; Overflow error
   0305 4F 4D               589         .ascii  "OM"                              
q  0307                     590         .db                     ; Out of memory
   0307 55 4C               591         .ascii  "UL"                              
q  0309                     592         .db                     ; Undefined line
   0309 42 53               593         .ascii  "BS"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 12
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



q  030B                     594         .db                     ; Bad subscript
   030B 44 44               595         .ascii  "DD"                              
q  030D                     596         .db                     ; Re-DIMensioned array
   030D 2F 30               597         .ascii  "/0"                              
q  030F                     598         .db                     ; Division by zero
   030F 49 44               599         .ascii  "ID"                              
q  0311                     600         .db                     ; Illegal direct
   0311 54 4D               601         .ascii  "TM"                              
q  0313                     602         .db                     ; Type mis-match
   0313 4F 53               603         .ascii  "OS"                              
q  0315                     604         .db                     ; Out of string space
   0315 4C 53               605         .ascii  "LS"                              
q  0317                     606         .db                     ; String too long
   0317 53 54               607         .ascii  "ST"                              
q  0319                     608         .db                     ; String formula too complex
   0319 43 4E               609         .ascii  "CN"                              
q  031B                     610         .db                     ; Can't CONTinue
   031B 55 46               611         .ascii  "UF"                              
q  031D                     612         .db                     ; Undefined FN function
   031D 4D 4F               613         .ascii  "MO"                              
q  031F                     614         .db                     ; Missing operand
   031F 48 58               615         .ascii  "HX"                              
q  0321                     616         .db                     ; HEX error
   0321 42 4E               617         .ascii  "BN"                              
q  0323                     618         .db                     ; BIN error
                            619 ;
                            620 ; INITIALISATION TABLE -------------------------------------------------------
                            621 ;
   0323 C3 B9 00      [10]  622 INITAB: JP      WARMST          ; Warm start jump
   0326 C3 25 09      [10]  623         JP      FCERR           ; "USR (X)" jump (Set to Error)
   0329 D3 00         [11]  624         OUT     (0),A           ; "OUT p,n" skeleton
   032B C9            [10]  625         RET                                   
   032C D6 00         [ 7]  626         SUB     0               ; Division support routine
   032E 6F            [ 4]  627         LD      L,A                              
   032F 7C            [ 4]  628         LD      A,H                              
   0330 DE 00         [ 7]  629         SBC     A,0                              
   0332 67            [ 4]  630         LD      H,A                              
   0333 78            [ 4]  631         LD      A,B                              
   0334 DE 00         [ 7]  632         SBC     A,0                              
   0336 47            [ 4]  633         LD      B,A                              
   0337 3E 00         [ 7]  634         LD      A,0                              
   0339 C9            [10]  635         RET                                   
   033A 00 00 00            636         .db     0,0,0           ; Random number seed table used by RND
kq 033D 35 4A 00            637         .db     0x035,0x04A,0CAH;-2.65145E+07
q  0340 39 1C 4C            638         .db     0x039,0x01C,076H; 1.61291E+07
kq 0343 22 95 00            639         .db     0x022,0x095,0B3H;-1.17691E+07
q  0346 0A DD 2F            640         .db     0x00A,0x0DD,047H; 1.30983E+07
q  0349 53 D1 63            641         .db     0x053,0x0D1,099H;-2-01612E+07
kq 034C 0A 1A 09            642         .db     0x00A,0x01A,09FH;-1.04269E+07
kq 034F 65 BC 00            643         .db     0x065,0x0BC,0CDH;-1.34831E+07
kq 0352 D6 77 03            644         .db     0x0D6,0x077,03EH; 1.24825E+07
kq 0355 52 C7 04            645         .db     0x052,0x0C7,04FH; Last random number
   0358 DB 00         [11]  646         IN      A,(0)           ; INP (x) skeleton
   035A C9            [10]  647         RET                                   
   035B 01                  648         .db     1               ; POS (x) number (1)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 13
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   035C FF                  649         .db     255             ; Terminal width (255 = no auto CRLF)
   035D 1C                  650         .db     28              ; Width for commas (3 columns)
   035E 00                  651         .db     0               ; No nulls after input bytes
   035F 00                  652         .db     0               ; Output enabled (^O off)
   0360 14 00               653         .dw     20              ; Initial lines counter
   0362 14 00               654         .dw     20              ; Initial lines number
   0364 00 00               655         .dw     0               ; Array load/save check sum
   0366 00                  656         .db     0               ; Break not by NMI
   0367 00                  657         .db     0               ; Break flag
   0368 C3 54 06      [10]  658         JP      TTYLIN          ; Input reflection (set to TTY)
   036B C3 00 00      [10]  659         JP      0x0000          ; POINT reflection unused
   036E C3 00 00      [10]  660         JP      0x0000          ; SET reflection
   0371 C3 00 00      [10]  661         JP      0x0000          ; RESET reflection
   0374 A2 81               662         .dw     STLOOK          ; Temp string space
   0376 FE FF               663         .dw     -2              ; Current line number (cold)
   0378 3F 81               664         .dw     PROGST+1        ; Start of program text
   037A                     665 INITBE:                                       
                            666 ;
                            667 ; END OF INITIALISATION TABLE ---------------------------------------------------
                            668 ;
   037A 20 45 72 72 6F 72   669 ERRMSG: .ascii  " Error"                              
   0380 00                  670         .db     0                              
   0381 20 69 6E 20         671 INMSG:  .ascii  " in "                              
   0385 00                  672         .db     0                              
u                    FFFF   673 ZERBYT  .equ    $-1             ; A zero byte
   0386 4F 6B               674 OKMSG:  .ascii  "Ok"                              
   0388 0D 0A 00 00         675         .db     CR,LF,0,0                              
   038C 42 72 65 61 6B      676 BRKMSG: .ascii  "Break"                              
   0391 00                  677         .db     0                              
                            678 ;
   0392 21 04 00      [10]  679 BAKSTK: LD      HL,4            ; Look for "FOR" block with
   0395 39            [11]  680         ADD     HL,SP           ; same index as specified
   0396 7E            [ 7]  681 LOKFOR: LD      A,(HL)          ; Get block ID
   0397 23            [ 6]  682         INC     HL              ; Point to index address
   0398 FE 81         [ 7]  683         CP      ZFOR            ; Is it a "FOR" token
   039A C0            [11]  684         RET     NZ              ; No - exit
   039B 4E            [ 7]  685         LD      C,(HL)          ; BC = Address of "FOR" index
   039C 23            [ 6]  686         INC     HL                              
   039D 46            [ 7]  687         LD      B,(HL)                              
   039E 23            [ 6]  688         INC     HL              ; Point to sign of STEP
   039F E5            [11]  689         PUSH    HL              ; Save pointer to sign
   03A0 69            [ 4]  690         LD      L,C             ; HL = address of "FOR" index
   03A1 60            [ 4]  691         LD      H,B                              
   03A2 7A            [ 4]  692         LD      A,D             ; See if an index was specified
   03A3 B3            [ 4]  693         OR      E               ; DE = 0 if no index specified
   03A4 EB            [ 4]  694         EX      DE,HL           ; Specified index into HL
   03A5 CA AC 03      [10]  695         JP      Z,INDFND        ; Skip if no index given
   03A8 EB            [ 4]  696         EX      DE,HL           ; Index back into DE
   03A9 CD D1 06      [17]  697         CALL    CPDEHL          ; Compare index with one given
   03AC 01 0D 00      [10]  698 INDFND: LD      BC,16-3         ; Offset to next block
   03AF E1            [10]  699         POP     HL              ; Restore pointer to sign
   03B0 C8            [11]  700         RET     Z               ; Return if block found
   03B1 09            [11]  701         ADD     HL,BC           ; Point to next block
   03B2 C3 96 03      [10]  702         JP      LOKFOR          ; Keep on looking
                            703 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 14
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   03B5 CD D6 03      [17]  704 MOVUP:  CALL    ENFMEM          ; See if enough memory
   03B8 C5            [11]  705 MOVSTR: PUSH    BC              ; Save end of source
   03B9 E3            [19]  706         EX      (SP),HL         ; Swap source and dest" end
   03BA C1            [10]  707         POP     BC              ; Get end of destination
   03BB CD D1 06      [17]  708 MOVLP:  CALL    CPDEHL          ; See if list moved
   03BE 7E            [ 7]  709         LD      A,(HL)          ; Get byte
   03BF 02            [ 7]  710         LD      (BC),A          ; Move it
   03C0 C8            [11]  711         RET     Z               ; Exit if all done
   03C1 0B            [ 6]  712         DEC     BC              ; Next byte to move to
   03C2 2B            [ 6]  713         DEC     HL              ; Next byte to move
   03C3 C3 BB 03      [10]  714         JP      MOVLP           ; Loop until all bytes moved
                            715 ;
   03C6 E5            [11]  716 CHKSTK: PUSH    HL              ; Save code string address
   03C7 2A 1F 81      [16]  717         LD      HL,(ARREND)     ; Lowest free memory
   03CA 06 00         [ 7]  718         LD      B,0             ; BC = Number of levels to test
   03CC 09            [11]  719         ADD     HL,BC           ; 2 Bytes for each level
   03CD 09            [11]  720         ADD     HL,BC                              
   03CE 3E                  721         .db     0x3E            ; Skip 
   03CF 50 55 53 48 20 48   722         .ascii  "PUSH HL"                              
        4C
   03D6 E5            [11]  723 ENFMEM: PUSH    HL              ; Save code string address
   03D7 3E D0         [ 7]  724         LD      A,0x0D0         ; LOW -48; 48 Bytes minimum RAM
   03D9 95            [ 4]  725         SUB     L                              
   03DA 6F            [ 4]  726         LD      L,A                              
   03DB 3E FF         [ 7]  727         LD      A,0x0FF         ; HIGH (-48); 48 Bytes minimum RAM
   03DD 9C            [ 4]  728         SBC     A,H                              
   03DE DA E5 03      [10]  729         JP      C,OMERR         ; Not enough - ?OM Error
   03E1 67            [ 4]  730         LD      H,A                              
   03E2 39            [11]  731         ADD     HL,SP           ; Test if stack is overflowed
   03E3 E1            [10]  732         POP     HL              ; Restore code string address
   03E4 D8            [11]  733         RET     C               ; Return if enough mmory
   03E5 1E 0C         [ 7]  734 OMERR:  LD      E,OM            ; ?OM Error
   03E7 C3 2E 04      [10]  735         JP      ERROR                              
                            736 ;
   03EA 2A 0E 81      [16]  737 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
   03ED 22 A1 80      [16]  738         LD      (LINEAT),HL     ; Save as current line
   03F0 1E 02         [ 7]  739 SNERR:  LD      E,SN            ; ?SN Error
   03F2 01                  740         .db     0x01            ; Skip 
   03F3 4C 44 20 45 2C 44   741         .ascii  "LD E,DZ"                              
        5A
   03FA 1E 14         [ 7]  742 DZERR:  LD      E,DZ            ; ?/0 Error
   03FC 01                  743         .db     0x01            ; Skip 
   03FD 4C 44 20 45 2C 4E   744         .ascii  "LD E,NF"                              
        46
   0404 1E 00         [ 7]  745 NFERR:  LD      E,NF            ; ?NF Error
   0406 01                  746         .db     0x01            ; Skip 
   0407 4C 44 20 45 2C 52   747         .ascii  "LD E,RD"                              
        44
   040E 1E 12         [ 7]  748 DDERR:  LD      E,RD            ; ?DD Error
   0410 01                  749         .db     0x01            ; Skip 
   0411 4C 44 20 45 2C 55   750         .ascii  "LD E,UF"                              
        46
   0418 1E 22         [ 7]  751 UFERR:  LD      E,UF            ; ?UF Error
   041A 01                  752         .db     0x01            ; Skip 
   041B 4C 44 20 45 2C 4F   753         .ascii  "LD E,OV"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 15
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



        56
   0422 1E 0A         [ 7]  754 OVERR:  LD      E,OV            ; ?OV Error
   0424 01                  755         .db     0x01            ; Skip 
   0425 4C 44 20 45 2C 54   756         .ascii  "LD E,TM"                              
        4D
   042C 1E 18         [ 7]  757 TMERR:  LD      E,TM            ; ?TM Error
                            758 ;
   042E CD 52 05      [17]  759 ERROR:  CALL    CLREG           ; Clear registers and stack
   0431 32 8A 80      [13]  760         LD      (CTLOFG),A      ; Enable output (A is 0)
   0434 CD 09 0B      [17]  761         CALL    STTLIN          ; Start new line
   0437 21 F9 02      [10]  762         LD      HL,ERRORS       ; Point to error codes
   043A 57            [ 4]  763         LD      D,A             ; D = 0 (A is 0)
q  043B 3E 3F         [ 7]  764         LD      A,'?'                              
   043D CD E2 06      [17]  765         CALL    OUTC            ; Output '?'
   0440 19            [11]  766         ADD     HL,DE           ; Offset to correct error code
   0441 7E            [ 7]  767         LD      A,(HL)          ; First character
   0442 CD E2 06      [17]  768         CALL    OUTC            ; Output it
   0445 CD 5C 08      [17]  769         CALL    GETCHR          ; Get next character
   0448 CD E2 06      [17]  770         CALL    OUTC            ; Output it
   044B 21 7A 03      [10]  771         LD      HL,ERRMSG       ; "Error" message
   044E CD CB 11      [17]  772 ERRIN:  CALL    PRS             ; Output message
   0451 2A A1 80      [16]  773         LD      HL,(LINEAT)     ; Get line of error
   0454 11 FE FF      [10]  774         LD      DE,-2           ; Cold start error if -2
   0457 CD D1 06      [17]  775         CALL    CPDEHL          ; See if cold start error
   045A CA 4D 00      [10]  776         JP      Z,CSTART        ; Cold start error - Restart
   045D 7C            [ 4]  777         LD      A,H             ; Was it a direct error?
   045E A5            [ 4]  778         AND     L               ; Line = -1 if direct error
   045F 3C            [ 4]  779         INC     A                              
   0460 C4 7B 18      [17]  780         CALL    NZ,LINEIN       ; No - output line of error
   0463 3E                  781         .db     0x3E            ; Skip 
   0464 50 4F 50 20 42 43   782         .ascii  "POP BC"                              
   046A C1            [10]  783 POPNOK: POP     BC              ; Drop address in input buffer
                            784 ;
   046B AF            [ 4]  785 PRNTOK: XOR     A               ; Output "Ok" and get command
   046C 32 8A 80      [13]  786         LD      (CTLOFG),A      ; Enable output
   046F CD 09 0B      [17]  787         CALL    STTLIN          ; Start new line
   0472 21 86 03      [10]  788         LD      HL,OKMSG        ; "Ok" message
   0475 CD CB 11      [17]  789         CALL    PRS             ; Output "Ok"
   0478 21 FF FF      [10]  790 GETCMD: LD      HL,-1           ; Flag direct mode
   047B 22 A1 80      [16]  791         LD      (LINEAT),HL     ; Save as current line
   047E CD 54 06      [17]  792         CALL    GETLIN          ; Get an input line
   0481 DA 78 04      [10]  793         JP      C,GETCMD        ; Get line again if break
   0484 CD 5C 08      [17]  794         CALL    GETCHR          ; Get first character
   0487 3C            [ 4]  795         INC     A               ; Test if end of line
   0488 3D            [ 4]  796         DEC     A               ; Without affecting Carry
   0489 CA 78 04      [10]  797         JP      Z,GETCMD        ; Nothing entered - Get another
   048C F5            [11]  798         PUSH    AF              ; Save Carry status
   048D CD 2A 09      [17]  799         CALL    ATOH            ; Get line number into DE
   0490 D5            [11]  800         PUSH    DE              ; Save line number
   0491 CD 7C 05      [17]  801         CALL    CRUNCH          ; Tokenise rest of line
   0494 47            [ 4]  802         LD      B,A             ; Length of tokenised line
   0495 D1            [10]  803         POP     DE              ; Restore line number
   0496 F1            [10]  804         POP     AF              ; Restore Carry
   0497 D2 3C 08      [10]  805         JP      NC,EXCUTE       ; No line number - Direct mode
   049A D5            [11]  806         PUSH    DE              ; Save line number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 16
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   049B C5            [11]  807         PUSH    BC              ; Save length of tokenised line
   049C AF            [ 4]  808         XOR     A                              
   049D 32 11 81      [13]  809         LD      (LSTBIN),A      ; Clear last byte input
   04A0 CD 5C 08      [17]  810         CALL    GETCHR          ; Get next character
   04A3 B7            [ 4]  811         OR      A               ; Set flags
   04A4 F5            [11]  812         PUSH    AF              ; And save them
   04A5 CD 0C 05      [17]  813         CALL    SRCHLN          ; Search for line number in DE
   04A8 DA B1 04      [10]  814         JP      C,LINFND        ; Jump if line found
   04AB F1            [10]  815         POP     AF              ; Get status
   04AC F5            [11]  816         PUSH    AF              ; And re-save
   04AD CA C9 09      [10]  817         JP      Z,ULERR         ; Nothing after number - Error
   04B0 B7            [ 4]  818         OR      A               ; Clear Carry
   04B1 C5            [11]  819 LINFND: PUSH    BC              ; Save address of line in prog
   04B2 D2 C8 04      [10]  820         JP      NC,INEWLN       ; Line not found - Insert new
   04B5 EB            [ 4]  821         EX      DE,HL           ; Next line address in DE
   04B6 2A 1B 81      [16]  822         LD      HL,(PROGND)     ; End of program
   04B9 1A            [ 7]  823 SFTPRG: LD      A,(DE)          ; Shift rest of program down
   04BA 02            [ 7]  824         LD      (BC),A                              
   04BB 03            [ 6]  825         INC     BC              ; Next destination
   04BC 13            [ 6]  826         INC     DE              ; Next source
   04BD CD D1 06      [17]  827         CALL    CPDEHL          ; All done?
   04C0 C2 B9 04      [10]  828         JP      NZ,SFTPRG       ; More to do
   04C3 60            [ 4]  829         LD      H,B             ; HL - New end of program
   04C4 69            [ 4]  830         LD      L,C                              
   04C5 22 1B 81      [16]  831         LD      (PROGND),HL     ; Update end of program
                            832 ;
   04C8 D1            [10]  833 INEWLN: POP     DE              ; Get address of line,
   04C9 F1            [10]  834         POP     AF              ; Get status
   04CA CA EF 04      [10]  835         JP      Z,SETPTR        ; No text - Set up pointers
   04CD 2A 1B 81      [16]  836         LD      HL,(PROGND)     ; Get end of program
   04D0 E3            [19]  837         EX      (SP),HL         ; Get length of input line
   04D1 C1            [10]  838         POP     BC              ; End of program to BC
   04D2 09            [11]  839         ADD     HL,BC           ; Find new end
   04D3 E5            [11]  840         PUSH    HL              ; Save new end
   04D4 CD B5 03      [17]  841         CALL    MOVUP           ; Make space for line
   04D7 E1            [10]  842         POP     HL              ; Restore new end
   04D8 22 1B 81      [16]  843         LD      (PROGND),HL     ; Update end of program pointer
   04DB EB            [ 4]  844         EX      DE,HL           ; Get line to move up in HL
   04DC 74            [ 7]  845         LD      (HL),H          ; Save MSB
   04DD D1            [10]  846         POP     DE              ; Get new line number
   04DE 23            [ 6]  847         INC     HL              ; Skip pointer
   04DF 23            [ 6]  848         INC     HL                              
   04E0 73            [ 7]  849         LD      (HL),E          ; Save LSB of line number
   04E1 23            [ 6]  850         INC     HL                              
   04E2 72            [ 7]  851         LD      (HL),D          ; Save MSB of line number
   04E3 23            [ 6]  852         INC     HL              ; To first byte in line
   04E4 11 A6 80      [10]  853         LD      DE,BUFFER       ; Copy buffer to program
   04E7 1A            [ 7]  854 MOVBUF: LD      A,(DE)          ; Get source
   04E8 77            [ 7]  855         LD      (HL),A          ; Save destinations
   04E9 23            [ 6]  856         INC     HL              ; Next source
   04EA 13            [ 6]  857         INC     DE              ; Next destination
   04EB B7            [ 4]  858         OR      A               ; Done?
   04EC C2 E7 04      [10]  859         JP      NZ,MOVBUF       ; No - Repeat
   04EF CD 38 05      [17]  860 SETPTR: CALL    RUNFST          ; Set line pointers
   04F2 23            [ 6]  861         INC     HL              ; To LSB of pointer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 17
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   04F3 EB            [ 4]  862         EX      DE,HL           ; Address to DE
   04F4 62            [ 4]  863 PTRLP:  LD      H,D             ; Address to HL
   04F5 6B            [ 4]  864         LD      L,E                              
   04F6 7E            [ 7]  865         LD      A,(HL)          ; Get LSB of pointer
   04F7 23            [ 6]  866         INC     HL              ; To MSB of pointer
   04F8 B6            [ 7]  867         OR      (HL)            ; Compare with MSB pointer
   04F9 CA 78 04      [10]  868         JP      Z,GETCMD        ; Get command line if end
   04FC 23            [ 6]  869         INC     HL              ; To LSB of line number
   04FD 23            [ 6]  870         INC     HL              ; Skip line number
   04FE 23            [ 6]  871         INC     HL              ; Point to first byte in line
   04FF AF            [ 4]  872         XOR     A               ; Looking for 00 byte
   0500 BE            [ 7]  873 FNDEND: CP      (HL)            ; Found end of line?
   0501 23            [ 6]  874         INC     HL              ; Move to next byte
   0502 C2 00 05      [10]  875         JP      NZ,FNDEND       ; No - Keep looking
   0505 EB            [ 4]  876         EX      DE,HL           ; Next line address to HL
   0506 73            [ 7]  877         LD      (HL),E          ; Save LSB of pointer
   0507 23            [ 6]  878         INC     HL                              
   0508 72            [ 7]  879         LD      (HL),D          ; Save MSB of pointer
   0509 C3 F4 04      [10]  880         JP      PTRLP           ; Do next line
                            881 ;
   050C 2A A3 80      [16]  882 SRCHLN: LD      HL,(BASTXT)     ; Start of program text
   050F 44            [ 4]  883 SRCHLP: LD      B,H             ; BC = Address to look at
   0510 4D            [ 4]  884         LD      C,L                              
   0511 7E            [ 7]  885         LD      A,(HL)          ; Get address of next line
   0512 23            [ 6]  886         INC     HL                              
   0513 B6            [ 7]  887         OR      (HL)            ; End of program found?
   0514 2B            [ 6]  888         DEC     HL                              
   0515 C8            [11]  889         RET     Z               ; Yes - Line not found
   0516 23            [ 6]  890         INC     HL                              
   0517 23            [ 6]  891         INC     HL                              
   0518 7E            [ 7]  892         LD      A,(HL)          ; Get LSB of line number
   0519 23            [ 6]  893         INC     HL                              
   051A 66            [ 7]  894         LD      H,(HL)          ; Get MSB of line number
   051B 6F            [ 4]  895         LD      L,A                              
   051C CD D1 06      [17]  896         CALL    CPDEHL          ; Compare with line in DE
   051F 60            [ 4]  897         LD      H,B             ; HL = Start of this line
   0520 69            [ 4]  898         LD      L,C                              
   0521 7E            [ 7]  899         LD      A,(HL)          ; Get LSB of next line address
   0522 23            [ 6]  900         INC     HL                              
   0523 66            [ 7]  901         LD      H,(HL)          ; Get MSB of next line address
   0524 6F            [ 4]  902         LD      L,A             ; Next line to HL
   0525 3F            [ 4]  903         CCF                                   
   0526 C8            [11]  904         RET     Z               ; Lines found - Exit
   0527 3F            [ 4]  905         CCF                                   
   0528 D0            [11]  906         RET     NC              ; Line not found,at line after
   0529 C3 0F 05      [10]  907         JP      SRCHLP          ; Keep looking
                            908 ;
   052C C0            [11]  909 NEW:    RET     NZ              ; Return if any more on line
   052D 2A A3 80      [16]  910 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
   0530 AF            [ 4]  911         XOR     A               ; Set program area to empty
   0531 77            [ 7]  912         LD      (HL),A          ; Save LSB = 00
   0532 23            [ 6]  913         INC     HL                              
   0533 77            [ 7]  914         LD      (HL),A          ; Save MSB = 00
   0534 23            [ 6]  915         INC     HL                              
   0535 22 1B 81      [16]  916         LD      (PROGND),HL     ; Set program end
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 18
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                            917 ;
   0538 2A A3 80      [16]  918 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
   053B 2B            [ 6]  919         DEC     HL                              
                            920 ;
   053C 22 13 81      [16]  921 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
   053F 2A F4 80      [16]  922         LD      HL,(LSTRAM)     ; Get end of RAM
   0542 22 08 81      [16]  923         LD      (STRBOT),HL     ; Clear string space
   0545 AF            [ 4]  924         XOR     A                              
   0546 CD 66 08      [17]  925         CALL    RESTOR          ; Reset DATA pointers
   0549 2A 1B 81      [16]  926         LD      HL,(PROGND)     ; Get end of program
   054C 22 1D 81      [16]  927         LD      (VAREND),HL     ; Clear variables
   054F 22 1F 81      [16]  928         LD      (ARREND),HL     ; Clear arrays
                            929 ;
   0552 C1            [10]  930 CLREG:  POP     BC              ; Save return address
   0553 2A 9F 80      [16]  931         LD      HL,(STRSPC)     ; Get end of working RAN
   0556 F9            [ 6]  932         LD      SP,HL           ; Set stack
   0557 21 F8 80      [10]  933         LD      HL,TMSTPL       ; Temporary string pool
   055A 22 F6 80      [16]  934         LD      (TMSTPT),HL     ; Reset temporary string ptr
   055D AF            [ 4]  935         XOR     A               ; A = 00
   055E 6F            [ 4]  936         LD      L,A             ; HL = 0000
   055F 67            [ 4]  937         LD      H,A                              
   0560 22 19 81      [16]  938         LD      (CONTAD),HL     ; No CONTinue
   0563 32 10 81      [13]  939         LD      (FORFLG),A      ; Clear FOR flag
   0566 22 23 81      [16]  940         LD      (FNRGNM),HL     ; Clear FN argument
   0569 E5            [11]  941         PUSH    HL              ; HL = 0000
   056A C5            [11]  942         PUSH    BC              ; Put back return
   056B 2A 13 81      [16]  943 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
   056E C9            [10]  944         RET                     ; Return to execution driver
                            945 ;
q  056F 3E 3F         [ 7]  946 PROMPT: LD      A,'?'           ; '?'
   0571 CD E2 06      [17]  947         CALL    OUTC            ; Output character
q  0574 3E 20         [ 7]  948         LD      A,' '           ; Space
   0576 CD E2 06      [17]  949         CALL    OUTC            ; Output character
   0579 C3 93 80      [10]  950         JP      RINPUT          ; Get input line
                            951 ;
   057C AF            [ 4]  952 CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
   057D 32 F3 80      [13]  953         LD      (DATFLG),A      ; Reset literal flag
   0580 0E 05         [ 7]  954         LD      C,2+3           ; 2 byte number and 3 nulls
   0582 11 A6 80      [10]  955         LD      DE,BUFFER       ; Start of input buffer
   0585 7E            [ 7]  956 CRNCLP: LD      A,(HL)          ; Get byte
q  0586                     957         CP      ' '             ; Is it a space?
   0586 CA F0 05      [10]  958         JP      Z,MOVDIR        ; Yes - Copy direct
   0589 47            [ 4]  959         LD      B,A             ; Save character
q  058A                     960         CP      '"'             ; Is it a quote?
   058A CA 0E 06      [10]  961         JP      Z,CPYLIT        ; Yes - Copy literal string
   058D B7            [ 4]  962         OR      A               ; Is it end of buffer?
   058E CA 15 06      [10]  963         JP      Z,ENDBUF        ; Yes - End buffer
   0591 3A F3 80      [13]  964         LD      A,(DATFLG)      ; Get data type
   0594 B7            [ 4]  965         OR      A               ; Literal?
   0595 7E            [ 7]  966         LD      A,(HL)          ; Get byte to copy
   0596 C2 F0 05      [10]  967         JP      NZ,MOVDIR       ; Literal - Copy direct
q  0599                     968         CP      '?'             ; Is it '?' short for PRINT
   0599 3E 9E         [ 7]  969         LD      A,ZPRINT        ; "PRINT" token
   059B CA F0 05      [10]  970         JP      Z,MOVDIR        ; Yes - replace it
   059E 7E            [ 7]  971         LD      A,(HL)          ; Get byte again
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 19
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



q  059F                     972         CP      '0'             ; Is it less than '0'
   059F DA A7 05      [10]  973         JP      C,FNDWRD        ; Yes - Look for reserved words
   05A2 FE 3C         [ 7]  974         CP      60              ; ";"+1; Is it "0123456789:;" ?
   05A4 DA F0 05      [10]  975         JP      C,MOVDIR        ; Yes - copy it direct
   05A7 D5            [11]  976 FNDWRD: PUSH    DE              ; Look for reserved words
   05A8 11 7A 01      [10]  977         LD      DE,WORDS-1      ; Point to table
   05AB C5            [11]  978         PUSH    BC              ; Save count
   05AC 01 EC 05      [10]  979         LD      BC,RETNAD       ; Where to return to
   05AF C5            [11]  980         PUSH    BC              ; Save return address
   05B0 06 7F         [ 7]  981         LD      B,ZEND-1        ; First token value -1
   05B2 7E            [ 7]  982         LD      A,(HL)          ; Get byte
q  05B3                     983         CP      'a'             ; Less than 'a' ?
   05B3 DA BA 05      [10]  984         JP      C,SEARCH        ; Yes - search for words
q  05B6                     985         CP      'z'+1           ; Greater than 'z' ?
   05B6 D2 BA 05      [10]  986         JP      NC,SEARCH       ; Yes - search for words
kq 05B9                     987         AND     01011111B       ; Force upper case
   05B9 77            [ 7]  988         LD      (HL),A          ; Replace byte
   05BA 4E            [ 7]  989 SEARCH: LD      C,(HL)          ; Search for a word
   05BB EB            [ 4]  990         EX      DE,HL                              
   05BC 23            [ 6]  991 GETNXT: INC     HL              ; Get next reserved word
   05BD B6            [ 7]  992         OR      (HL)            ; Start of word?
   05BE F2 BC 05      [10]  993         JP      P,GETNXT        ; No - move on
   05C1 04            [ 4]  994         INC     B               ; Increment token value
   05C2 7E            [ 7]  995         LD      A,(HL)          ; Get byte from table
kq 05C3                     996         AND     01111111B       ; Strip bit 7
   05C3 C8            [11]  997         RET     Z               ; Return if end of list
   05C4 B9            [ 4]  998         CP      C               ; Same character as in buffer?
   05C5 C2 BC 05      [10]  999         JP      NZ,GETNXT       ; No - get next word
   05C8 EB            [ 4] 1000         EX      DE,HL                              
   05C9 E5            [11] 1001         PUSH    HL              ; Save start of word
                           1002 ;
   05CA 13            [ 6] 1003 NXTBYT: INC     DE              ; Look through rest of word
   05CB 1A            [ 7] 1004         LD      A,(DE)          ; Get byte from table
   05CC B7            [ 4] 1005         OR      A               ; End of word ?
   05CD FA E8 05      [10] 1006         JP      M,MATCH         ; Yes - Match found
   05D0 4F            [ 4] 1007         LD      C,A             ; Save it
   05D1 78            [ 4] 1008         LD      A,B             ; Get token value
   05D2 FE 88         [ 7] 1009         CP      ZGOTO           ; Is it "GOTO" token ?
   05D4 C2 DB 05      [10] 1010         JP      NZ,NOSPC        ; No - Don't allow spaces
   05D7 CD 5C 08      [17] 1011         CALL    GETCHR          ; Get next character
   05DA 2B            [ 6] 1012         DEC     HL              ; Cancel increment from GETCHR
   05DB 23            [ 6] 1013 NOSPC:  INC     HL              ; Next byte
   05DC 7E            [ 7] 1014         LD      A,(HL)          ; Get byte
q  05DD                    1015         CP      'a'             ; Less than 'a' ?
   05DD DA E0 05      [10] 1016         JP      C,NOCHNG        ; Yes - don't change
kq 05E0                    1017         AND     01011111B       ; Make upper case
   05E0 B9            [ 4] 1018 NOCHNG: CP      C               ; Same as in buffer ?
   05E1 CA CA 05      [10] 1019         JP      Z,NXTBYT        ; Yes - keep testing
   05E4 E1            [10] 1020         POP     HL              ; Get back start of word
   05E5 C3 BA 05      [10] 1021         JP      SEARCH          ; Look at next word
                           1022 ;
   05E8 48            [ 4] 1023 MATCH:  LD      C,B             ; Word found - Save token value
   05E9 F1            [10] 1024         POP     AF              ; Throw away return
   05EA EB            [ 4] 1025         EX      DE,HL                              
   05EB C9            [10] 1026         RET                     ; Return to "RETNAD"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 20
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   05EC EB            [ 4] 1027 RETNAD: EX      DE,HL           ; Get address in string
   05ED 79            [ 4] 1028         LD      A,C             ; Get token value
   05EE C1            [10] 1029         POP     BC              ; Restore buffer length
   05EF D1            [10] 1030         POP     DE              ; Get destination address
   05F0 23            [ 6] 1031 MOVDIR: INC     HL              ; Next source in buffer
   05F1 12            [ 7] 1032         LD      (DE),A          ; Put byte in buffer
   05F2 13            [ 6] 1033         INC     DE              ; Move up buffer
   05F3 0C            [ 4] 1034         INC     C               ; Increment length of buffer
q  05F4                    1035         SUB     ':'             ; End of statement?
   05F4 CA FC 05      [10] 1036         JP      Z,SETLIT        ; Jump if multi-statement line
   05F7 FE 49         [ 7] 1037         CP      ZDATA-0x3A      ; Is it DATA statement ?
   05F9 C2 FF 05      [10] 1038         JP      NZ,TSTREM       ; No - see if REM
   05FC 32 F3 80      [13] 1039 SETLIT: LD      (DATFLG),A      ; Set literal flag
   05FF D6 54         [ 7] 1040 TSTREM: SUB     ZREM-0x3A       ; Is it REM?
   0601 C2 85 05      [10] 1041         JP      NZ,CRNCLP       ; No - Leave flag
   0604 47            [ 4] 1042         LD      B,A             ; Copy rest of buffer
   0605 7E            [ 7] 1043 NXTCHR: LD      A,(HL)          ; Get byte
   0606 B7            [ 4] 1044         OR      A               ; End of line ?
   0607 CA 15 06      [10] 1045         JP      Z,ENDBUF        ; Yes - Terminate buffer
   060A B8            [ 4] 1046         CP      B               ; End of statement ?
   060B CA F0 05      [10] 1047         JP      Z,MOVDIR        ; Yes - Get next one
   060E 23            [ 6] 1048 CPYLIT: INC     HL              ; Move up source string
   060F 12            [ 7] 1049         LD      (DE),A          ; Save in destination
   0610 0C            [ 4] 1050         INC     C               ; Increment length
   0611 13            [ 6] 1051         INC     DE              ; Move up destination
   0612 C3 05 06      [10] 1052         JP      NXTCHR          ; Repeat
                           1053 ;
   0615 21 A5 80      [10] 1054 ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
   0618 12            [ 7] 1055         LD      (DE),A          ; Mark end of buffer (A = 00)
   0619 13            [ 6] 1056         INC     DE                              
   061A 12            [ 7] 1057         LD      (DE),A          ; A = 00
   061B 13            [ 6] 1058         INC     DE                              
   061C 12            [ 7] 1059         LD      (DE),A          ; A = 00
   061D C9            [10] 1060         RET                                   
                           1061 ;
   061E 3A 89 80      [13] 1062 DODEL:  LD      A,(NULFLG)      ; Get null flag status
   0621 B7            [ 4] 1063         OR      A               ; Is it zero?
   0622 3E 00         [ 7] 1064         LD      A,0             ; Zero A - Leave flags
   0624 32 89 80      [13] 1065         LD      (NULFLG),A      ; Zero null flag
   0627 C2 37 06      [10] 1066         JP      NZ,ECHDEL       ; Set - Echo it
   062A 05            [ 4] 1067         DEC     B               ; Decrement length
   062B CA 54 06      [10] 1068         JP      Z,GETLIN        ; Get line again if empty
   062E CD E2 06      [17] 1069         CALL    OUTC            ; Output null character
   0631 3E                 1070         .db     0x3E            ; Skip 
   0632 44 45 43 20 42     1071         .ascii  "DEC B"                              
   0637 05            [ 4] 1072 ECHDEL: DEC     B               ; Count bytes in buffer
   0638 2B            [ 6] 1073         DEC     HL              ; Back space buffer
   0639 CA 4B 06      [10] 1074         JP      Z,OTKLN         ; No buffer - Try again
   063C 7E            [ 7] 1075         LD      A,(HL)          ; Get deleted byte
   063D CD E2 06      [17] 1076         CALL    OUTC            ; Echo it
   0640 C3 5D 06      [10] 1077         JP      MORINP          ; Get more input
                           1078 ;
   0643 05            [ 4] 1079 DELCHR: DEC     B               ; Count bytes in buffer
   0644 2B            [ 6] 1080         DEC     HL              ; Back space buffer
   0645 CD E2 06      [17] 1081         CALL    OUTC            ; Output character in A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 21
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0648 C2 5D 06      [10] 1082         JP      NZ,MORINP       ; Not end - Get more
   064B CD E2 06      [17] 1083 OTKLN:  CALL    OUTC            ; Output character in A
   064E CD 16 0B      [17] 1084 KILIN:  CALL    PRCRLF          ; Output CRLF
   0651 C3 54 06      [10] 1085         JP      TTYLIN          ; Get line again
                           1086 ;
   0654                    1087 GETLIN:                                       
   0654 21 A6 80      [10] 1088 TTYLIN: LD      HL,BUFFER       ; Get a line by character
   0657 06 01         [ 7] 1089         LD      B,1             ; Set buffer as empty
   0659 AF            [ 4] 1090         XOR     A                              
   065A 32 89 80      [13] 1091         LD      (NULFLG),A      ; Clear null flag
   065D CD 0A 07      [17] 1092 MORINP: CALL    CLOTST          ; Get character and test ^O
   0660 4F            [ 4] 1093         LD      C,A             ; Save character in C
   0661 FE 7F         [ 7] 1094         CP      DEL             ; Delete character?
   0663 CA 1E 06      [10] 1095         JP      Z,DODEL         ; Yes - Process it
   0666 3A 89 80      [13] 1096         LD      A,(NULFLG)      ; Get null flag
   0669 B7            [ 4] 1097         OR      A               ; Test null flag status
   066A CA 76 06      [10] 1098         JP      Z,PROCES        ; Reset - Process character
   066D 3E 00         [ 7] 1099         LD      A,0             ; Set a null
   066F CD E2 06      [17] 1100         CALL    OUTC            ; Output null
   0672 AF            [ 4] 1101         XOR     A               ; Clear A
   0673 32 89 80      [13] 1102         LD      (NULFLG),A      ; Reset null flag
   0676 79            [ 4] 1103 PROCES: LD      A,C             ; Get character
   0677 FE 07         [ 7] 1104         CP      CTRLG           ; Bell?
   0679 CA B4 06      [10] 1105         JP      Z,PUTCTL        ; Yes - Save it
   067C FE 03         [ 7] 1106         CP      CTRLC           ; Is it control "C"?
   067E CC 16 0B      [17] 1107         CALL    Z,PRCRLF        ; Yes - Output CRLF
   0681 37            [ 4] 1108         SCF                     ; Flag break
   0682 C8            [11] 1109         RET     Z               ; Return if control "C"
   0683 FE 0D         [ 7] 1110         CP      CR              ; Is it enter?
   0685 CA 11 0B      [10] 1111         JP      Z,ENDINP        ; Yes - Terminate input
   0688 FE 15         [ 7] 1112         CP      CTRLU           ; Is it control "U"?
   068A CA 4E 06      [10] 1113         JP      Z,KILIN         ; Yes - Get another line
q  068D                    1114         CP      '@'             ; Is it "kill line"?
   068D CA 4B 06      [10] 1115         JP      Z,OTKLN         ; Yes - Kill line
q  0690                    1116         CP      '_'             ; Is it delete?
   0690 CA 43 06      [10] 1117         JP      Z,DELCHR        ; Yes - Delete character
   0693 FE 08         [ 7] 1118         CP      BKSP            ; Is it backspace?
   0695 CA 43 06      [10] 1119         JP      Z,DELCHR        ; Yes - Delete character
   0698 FE 12         [ 7] 1120         CP      CTRLR           ; Is it control "R"?
   069A C2 B1 06      [10] 1121         JP      NZ,PUTBUF       ; No - Put in buffer
   069D C5            [11] 1122         PUSH    BC              ; Save buffer length
   069E D5            [11] 1123         PUSH    DE              ; Save DE
   069F E5            [11] 1124         PUSH    HL              ; Save buffer address
   06A0 36 00         [10] 1125         LD      (HL),0          ; Mark end of buffer
   06A2 CD AE 1C      [17] 1126         CALL    OUTNCR          ; Output and do CRLF
   06A5 21 A6 80      [10] 1127         LD      HL,BUFFER       ; Point to buffer start
   06A8 CD CB 11      [17] 1128         CALL    PRS             ; Output buffer
   06AB E1            [10] 1129         POP     HL              ; Restore buffer address
   06AC D1            [10] 1130         POP     DE              ; Restore DE
   06AD C1            [10] 1131         POP     BC              ; Restore buffer length
   06AE C3 5D 06      [10] 1132         JP      MORINP          ; Get another character
                           1133 ;
q  06B1                    1134 PUTBUF: CP      ' '             ; Is it a control code?
   06B1 DA 5D 06      [10] 1135         JP      C,MORINP        ; Yes - Ignore
   06B4 78            [ 4] 1136 PUTCTL: LD      A,B             ; Get number of bytes in buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 22
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   06B5 FE 49         [ 7] 1137         CP      72+1            ; Test for line overflow
   06B7 3E 07         [ 7] 1138         LD      A,CTRLG         ; Set a bell
   06B9 D2 C9 06      [10] 1139         JP      NC,OUTNBS       ; Ring bell if buffer full
   06BC 79            [ 4] 1140         LD      A,C             ; Get character
   06BD 71            [ 7] 1141         LD      (HL),C          ; Save in buffer
   06BE 32 11 81      [13] 1142         LD      (LSTBIN),A      ; Save last input byte
   06C1 23            [ 6] 1143         INC     HL              ; Move up buffer
   06C2 04            [ 4] 1144         INC     B               ; Increment length
   06C3 CD E2 06      [17] 1145 OUTIT:  CALL    OUTC            ; Output the character entered
   06C6 C3 5D 06      [10] 1146         JP      MORINP          ; Get another character
                           1147 ;
   06C9 CD E2 06      [17] 1148 OUTNBS: CALL    OUTC            ; Output bell and back over it
   06CC 3E 08         [ 7] 1149         LD      A,BKSP          ; Set back space
   06CE C3 C3 06      [10] 1150         JP      OUTIT           ; Output it and get more
                           1151 ;
   06D1 7C            [ 4] 1152 CPDEHL: LD      A,H             ; Get H
   06D2 92            [ 4] 1153         SUB     D               ; Compare with D
   06D3 C0            [11] 1154         RET     NZ              ; Different - Exit
   06D4 7D            [ 4] 1155         LD      A,L             ; Get L
   06D5 93            [ 4] 1156         SUB     E               ; Compare with E
   06D6 C9            [10] 1157         RET                     ; Return status
                           1158 ;
   06D7 7E            [ 7] 1159 CHKSYN: LD      A,(HL)          ; Check syntax of character
   06D8 E3            [19] 1160         EX      (SP),HL         ; Address of test byte
   06D9 BE            [ 7] 1161         CP      (HL)            ; Same as in code string?
   06DA 23            [ 6] 1162         INC     HL              ; Return address
   06DB E3            [19] 1163         EX      (SP),HL         ; Put it back
   06DC CA 5C 08      [10] 1164         JP      Z,GETCHR        ; Yes - Get next character
   06DF C3 F0 03      [10] 1165         JP      SNERR           ; Different - ?SN Error
                           1166 ;
   06E2 F5            [11] 1167 OUTC:   PUSH    AF              ; Save character
   06E3 3A 8A 80      [13] 1168         LD      A,(CTLOFG)      ; Get control "O" flag
   06E6 B7            [ 4] 1169         OR      A               ; Is it set?
   06E7 C2 00 12      [10] 1170         JP      NZ,POPAF        ; Yes - don't output
   06EA F1            [10] 1171         POP     AF              ; Restore character
   06EB C5            [11] 1172         PUSH    BC              ; Save buffer length
   06EC F5            [11] 1173         PUSH    AF              ; Save character
q  06ED                    1174         CP      ' '             ; Is it a control code?
   06ED DA 04 07      [10] 1175         JP      C,DINPOS        ; Yes - Don't INC POS(X)
   06F0 3A 87 80      [13] 1176         LD      A,(LWIDTH)      ; Get line width
   06F3 47            [ 4] 1177         LD      B,A             ; To B
   06F4 3A F0 80      [13] 1178         LD      A,(CURPOS)      ; Get cursor position
   06F7 04            [ 4] 1179         INC     B               ; Width 255?
   06F8 CA 00 07      [10] 1180         JP      Z,INCLEN        ; Yes - No width limit
   06FB 05            [ 4] 1181         DEC     B               ; Restore width
   06FC B8            [ 4] 1182         CP      B               ; At end of line?
   06FD CC 16 0B      [17] 1183         CALL    Z,PRCRLF        ; Yes - output CRLF
   0700 3C            [ 4] 1184 INCLEN: INC     A               ; Move on one character
   0701 32 F0 80      [13] 1185         LD      (CURPOS),A      ; Save new position
   0704 F1            [10] 1186 DINPOS: POP     AF              ; Restore character
   0705 C1            [10] 1187         POP     BC              ; Restore buffer length
   0706 CD 99 1C      [17] 1188         CALL    MONOUT          ; Send it
   0709 C9            [10] 1189         RET                                   
                           1190 ;
   070A CD 7D 1B      [17] 1191 CLOTST: CALL    GETINP          ; Get input character
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 23
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



kq 070D                    1192         AND     01111111B       ; Strip bit 7
   070D FE 0F         [ 7] 1193         CP      CTRLO           ; Is it control "O"?
   070F C0            [11] 1194         RET     NZ              ; No don't flip flag
   0710 3A 8A 80      [13] 1195         LD      A,(CTLOFG)      ; Get flag
   0713 2F            [ 4] 1196         CPL                     ; Flip it
   0714 32 8A 80      [13] 1197         LD      (CTLOFG),A      ; Put it back
   0717 AF            [ 4] 1198         XOR     A               ; Null character
   0718 C9            [10] 1199         RET                                   
                           1200 ;
   0719 CD 2A 09      [17] 1201 LIST:   CALL    ATOH            ; ASCII number to DE
   071C C0            [11] 1202         RET     NZ              ; Return if anything extra
   071D C1            [10] 1203         POP     BC              ; Rubbish - Not needed
   071E CD 0C 05      [17] 1204         CALL    SRCHLN          ; Search for line number in DE
   0721 C5            [11] 1205         PUSH    BC              ; Save address of line
   0722 CD 6D 07      [17] 1206         CALL    SETLIN          ; Set up lines counter
   0725 E1            [10] 1207 LISTLP: POP     HL              ; Restore address of line
   0726 4E            [ 7] 1208         LD      C,(HL)          ; Get LSB of next line
   0727 23            [ 6] 1209         INC     HL                              
   0728 46            [ 7] 1210         LD      B,(HL)          ; Get MSB of next line
   0729 23            [ 6] 1211         INC     HL                              
   072A 78            [ 4] 1212         LD      A,B             ; BC = 0 (End of program)?
   072B B1            [ 4] 1213         OR      C                              
   072C CA 6B 04      [10] 1214         JP      Z,PRNTOK        ; Yes - Go to command mode
   072F CD 76 07      [17] 1215         CALL    COUNT           ; Count lines
   0732 CD 81 08      [17] 1216         CALL    TSTBRK          ; Test for break key
   0735 C5            [11] 1217         PUSH    BC              ; Save address of next line
   0736 CD 16 0B      [17] 1218         CALL    PRCRLF          ; Output CRLF
   0739 5E            [ 7] 1219         LD      E,(HL)          ; Get LSB of line number
   073A 23            [ 6] 1220         INC     HL                              
   073B 56            [ 7] 1221         LD      D,(HL)          ; Get MSB of line number
   073C 23            [ 6] 1222         INC     HL                              
   073D E5            [11] 1223         PUSH    HL              ; Save address of line start
   073E EB            [ 4] 1224         EX      DE,HL           ; Line number to HL
   073F CD 83 18      [17] 1225         CALL    PRNTHL          ; Output line number in decimal
q  0742 3E 20         [ 7] 1226         LD      A,' '           ; Space after line number
   0744 E1            [10] 1227         POP     HL              ; Restore start of line address
   0745 CD E2 06      [17] 1228 LSTLP2: CALL    OUTC            ; Output character in A
   0748 7E            [ 7] 1229 LSTLP3: LD      A,(HL)          ; Get next byte in line
   0749 B7            [ 4] 1230         OR      A               ; End of line?
   074A 23            [ 6] 1231         INC     HL              ; To next byte in line
   074B CA 25 07      [10] 1232         JP      Z,LISTLP        ; Yes - get next line
   074E F2 45 07      [10] 1233         JP      P,LSTLP2        ; No token - output it
   0751 D6 7F         [ 7] 1234         SUB     ZEND-1          ; Find and output word
   0753 4F            [ 4] 1235         LD      C,A             ; Token offset+1 to C
   0754 11 7B 01      [10] 1236         LD      DE,WORDS        ; Reserved word list
   0757 1A            [ 7] 1237 FNDTOK: LD      A,(DE)          ; Get character in list
   0758 13            [ 6] 1238         INC     DE              ; Move on to next
   0759 B7            [ 4] 1239         OR      A               ; Is it start of word?
   075A F2 57 07      [10] 1240         JP      P,FNDTOK        ; No - Keep looking for word
   075D 0D            [ 4] 1241         DEC     C               ; Count words
   075E C2 57 07      [10] 1242         JP      NZ,FNDTOK       ; Not there - keep looking
kq 0761                    1243 OUTWRD: AND     01111111B       ; Strip bit 7
   0761 CD E2 06      [17] 1244         CALL    OUTC            ; Output first character
   0764 1A            [ 7] 1245         LD      A,(DE)          ; Get next character
   0765 13            [ 6] 1246         INC     DE              ; Move on to next
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 24
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0766 B7            [ 4] 1247         OR      A               ; Is it end of word?
   0767 F2 61 07      [10] 1248         JP      P,OUTWRD        ; No - output the rest
   076A C3 48 07      [10] 1249         JP      LSTLP3          ; Next byte in line
                           1250 ;
   076D E5            [11] 1251 SETLIN: PUSH    HL              ; Set up LINES counter
   076E 2A 8D 80      [16] 1252         LD      HL,(LINESN)     ; Get LINES number
   0771 22 8B 80      [16] 1253         LD      (LINESC),HL     ; Save in LINES counter
   0774 E1            [10] 1254         POP     HL                              
   0775 C9            [10] 1255         RET                                   
                           1256 ;
   0776 E5            [11] 1257 COUNT:  PUSH    HL              ; Save code string address
   0777 D5            [11] 1258         PUSH    DE                              
   0778 2A 8B 80      [16] 1259         LD      HL,(LINESC)     ; Get LINES counter
   077B 11 FF FF      [10] 1260         LD      DE,-1                              
   077E ED 5A         [15] 1261         ADC     HL,DE           ; Decrement
   0780 22 8B 80      [16] 1262         LD      (LINESC),HL     ; Put it back
   0783 D1            [10] 1263         POP     DE                              
   0784 E1            [10] 1264         POP     HL              ; Restore code string address
   0785 F0            [11] 1265         RET     P               ; Return if more lines to go
   0786 E5            [11] 1266         PUSH    HL              ; Save code string address
   0787 2A 8D 80      [16] 1267         LD      HL,(LINESN)     ; Get LINES number
   078A 22 8B 80      [16] 1268         LD      (LINESC),HL     ; Reset LINES counter
   078D CD 7D 1B      [17] 1269         CALL    GETINP          ; Get input character
   0790 FE 03         [ 7] 1270         CP      CTRLC           ; Is it control "C"?
   0792 CA 99 07      [10] 1271         JP      Z,RSLNBK        ; Yes - Reset LINES and break
   0795 E1            [10] 1272         POP     HL              ; Restore code string address
   0796 C3 76 07      [10] 1273         JP      COUNT           ; Keep on counting
                           1274 ;
   0799 2A 8D 80      [16] 1275 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
   079C 22 8B 80      [16] 1276         LD      (LINESC),HL     ; Reset LINES counter
   079F C3 BC 00      [10] 1277         JP      BRKRET          ; Go and output "Break"
                           1278 ;
   07A2 3E 64         [ 7] 1279 FOR:    LD      A,0x64          ; Flag "FOR" assignment
   07A4 32 10 81      [13] 1280         LD      (FORFLG),A      ; Save "FOR" flag
   07A7 CD 0E 0A      [17] 1281         CALL    LET             ; Set up initial index
   07AA C1            [10] 1282         POP     BC              ; Drop RETurn address
   07AB E5            [11] 1283         PUSH    HL              ; Save code string address
   07AC CD F9 09      [17] 1284         CALL    DATA            ; Get next statement address
   07AF 22 0C 81      [16] 1285         LD      (LOOPST),HL     ; Save it for start of loop
   07B2 21 02 00      [10] 1286         LD      HL,2            ; Offset for "FOR" block
   07B5 39            [11] 1287         ADD     HL,SP           ; Point to it
   07B6 CD 96 03      [17] 1288 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
   07B9 D1            [10] 1289         POP     DE              ; Get code string address
   07BA C2 D2 07      [10] 1290         JP      NZ,FORFND       ; No nesting found
   07BD 09            [11] 1291         ADD     HL,BC           ; Move into "FOR" block
   07BE D5            [11] 1292         PUSH    DE              ; Save code string address
   07BF 2B            [ 6] 1293         DEC     HL                              
   07C0 56            [ 7] 1294         LD      D,(HL)          ; Get MSB of loop statement
   07C1 2B            [ 6] 1295         DEC     HL                              
   07C2 5E            [ 7] 1296         LD      E,(HL)          ; Get LSB of loop statement
   07C3 23            [ 6] 1297         INC     HL                              
   07C4 23            [ 6] 1298         INC     HL                              
   07C5 E5            [11] 1299         PUSH    HL              ; Save block address
   07C6 2A 0C 81      [16] 1300         LD      HL,(LOOPST)     ; Get address of loop statement
   07C9 CD D1 06      [17] 1301         CALL    CPDEHL          ; Compare the FOR loops
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 25
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   07CC E1            [10] 1302         POP     HL              ; Restore block address
   07CD C2 B6 07      [10] 1303         JP      NZ,FORSLP       ; Different FORs - Find another
   07D0 D1            [10] 1304         POP     DE              ; Restore code string address
   07D1 F9            [ 6] 1305         LD      SP,HL           ; Remove all nested loops
                           1306 ;
   07D2 EB            [ 4] 1307 FORFND: EX      DE,HL           ; Code string address to HL
   07D3 0E 08         [ 7] 1308         LD      C,8                              
   07D5 CD C6 03      [17] 1309         CALL    CHKSTK          ; Check for 8 levels of stack
   07D8 E5            [11] 1310         PUSH    HL              ; Save code string address
   07D9 2A 0C 81      [16] 1311         LD      HL,(LOOPST)     ; Get first statement of loop
   07DC E3            [19] 1312         EX      (SP),HL         ; Save and restore code string
   07DD E5            [11] 1313         PUSH    HL              ; Re-save code string address
   07DE 2A A1 80      [16] 1314         LD      HL,(LINEAT)     ; Get current line number
   07E1 E3            [19] 1315         EX      (SP),HL         ; Save and restore code string
   07E2 CD DF 0C      [17] 1316         CALL    TSTNUM          ; Make sure it's a number
   07E5 CD D7 06      [17] 1317         CALL    CHKSYN          ; Make sure "TO" is next
   07E8 A6                 1318         .db     ZTO             ; 
   07E9 54 4F              1319         .ascii  "TO"                              
u  07EB 00                 1320         .db      token                              
   07EC CD DC 0C      [17] 1321         CALL    GETNUM          ; Get "TO" expression value
   07EF E5            [11] 1322         PUSH    HL              ; Save code string address
   07F0 CD 41 17      [17] 1323         CALL    BCDEFP          ; Move "TO" value to BCDE
   07F3 E1            [10] 1324         POP     HL              ; Restore code string address
   07F4 C5            [11] 1325         PUSH    BC              ; Save "TO" value in block
   07F5 D5            [11] 1326         PUSH    DE                              
   07F6 01 00 81      [10] 1327         LD      BC,0x8100       ; BCDE - 1 (default STEP)
   07F9 51            [ 4] 1328         LD      D,C             ; C=0
   07FA 5A            [ 4] 1329         LD      E,D             ; D=0
   07FB 7E            [ 7] 1330         LD      A,(HL)          ; Get next byte in code string
   07FC FE AB         [ 7] 1331         CP      ZSTEP           ; See if "STEP" is stated
   07FE 3E 01         [ 7] 1332         LD      A,1             ; Sign of step = 1
   0800 C2 11 08      [10] 1333         JP      NZ,SAVSTP       ; No STEP given - Default to 1
   0803 CD 5C 08      [17] 1334         CALL    GETCHR          ; Jump over "STEP" token
   0806 CD DC 0C      [17] 1335         CALL    GETNUM          ; Get step value
   0809 E5            [11] 1336         PUSH    HL              ; Save code string address
   080A CD 41 17      [17] 1337         CALL    BCDEFP          ; Move STEP to BCDE
   080D CD F5 16      [17] 1338         CALL    TSTSGN          ; Test sign of FPREG
   0810 E1            [10] 1339         POP     HL              ; Restore code string address
   0811 C5            [11] 1340 SAVSTP: PUSH    BC              ; Save the STEP value in block
   0812 D5            [11] 1341         PUSH    DE                              
   0813 F5            [11] 1342         PUSH    AF              ; Save sign of STEP
   0814 33            [ 6] 1343         INC     SP              ; Don't save flags
   0815 E5            [11] 1344         PUSH    HL              ; Save code string address
   0816 2A 13 81      [16] 1345         LD      HL,(BRKLIN)     ; Get address of index variable
   0819 E3            [19] 1346         EX      (SP),HL         ; Save and restore code string
   081A 06 81         [ 7] 1347 PUTFID: LD      B,ZFOR          ; "FOR" block marker
   081C C5            [11] 1348         PUSH    BC              ; Save it
   081D 33            [ 6] 1349         INC     SP              ; Don't save C
                           1350 ;
   081E CD 81 08      [17] 1351 RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
   0821 22 13 81      [16] 1352         LD      (BRKLIN),HL     ; Save code address for break
   0824 7E            [ 7] 1353         LD      A,(HL)          ; Get next byte in code string
q  0825                    1354         CP      ':'             ; Multi statement line?
   0825 CA 3C 08      [10] 1355         JP      Z,EXCUTE        ; Yes - Execute it
   0828 B7            [ 4] 1356         OR      A               ; End of line?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 26
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0829 C2 F0 03      [10] 1357         JP      NZ,SNERR        ; No - Syntax error
   082C 23            [ 6] 1358         INC     HL              ; Point to address of next line
   082D 7E            [ 7] 1359         LD      A,(HL)          ; Get LSB of line pointer
   082E 23            [ 6] 1360         INC     HL                              
   082F B6            [ 7] 1361         OR      (HL)            ; Is it zero (End of prog)?
   0830 CA B4 08      [10] 1362         JP      Z,ENDPRG        ; Yes - Terminate execution
   0833 23            [ 6] 1363         INC     HL              ; Point to line number
   0834 5E            [ 7] 1364         LD      E,(HL)          ; Get LSB of line number
   0835 23            [ 6] 1365         INC     HL                              
   0836 56            [ 7] 1366         LD      D,(HL)          ; Get MSB of line number
   0837 EB            [ 4] 1367         EX      DE,HL           ; Line number to HL
   0838 22 A1 80      [16] 1368         LD      (LINEAT),HL     ; Save as current line number
   083B EB            [ 4] 1369         EX      DE,HL           ; Line number back to DE
   083C CD 5C 08      [17] 1370 EXCUTE: CALL    GETCHR          ; Get key word
   083F 11 1E 08      [10] 1371         LD      DE,RUNCNT       ; Where to RETurn to
   0842 D5            [11] 1372         PUSH    DE              ; Save for RETurn
   0843 C8            [11] 1373 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
   0844 D6 80         [ 7] 1374 ONJMP:  SUB     ZEND            ; Is it a token?
   0846 DA 0E 0A      [10] 1375         JP      C,LET           ; No - try to assign it
   0849 FE 25         [ 7] 1376         CP      ZNEW+1-ZEND     ; END to NEW ?
   084B D2 F0 03      [10] 1377         JP      NC,SNERR        ; Not a key word - ?SN Error
   084E 07            [ 4] 1378         RLCA                    ; Double it
   084F 4F            [ 4] 1379         LD      C,A             ; BC = Offset into table
   0850 06 00         [ 7] 1380         LD      B,0                              
   0852 EB            [ 4] 1381         EX      DE,HL           ; Save code string address
   0853 21 9A 02      [10] 1382         LD      HL,WORDTB       ; Keyword address table
   0856 09            [11] 1383         ADD     HL,BC           ; Point to routine address
   0857 4E            [ 7] 1384         LD      C,(HL)          ; Get LSB of routine address
   0858 23            [ 6] 1385         INC     HL                              
   0859 46            [ 7] 1386         LD      B,(HL)          ; Get MSB of routine address
   085A C5            [11] 1387         PUSH    BC              ; Save routine address
   085B EB            [ 4] 1388         EX      DE,HL           ; Restore code string address
                           1389 ;
   085C 23            [ 6] 1390 GETCHR: INC     HL              ; Point to next character
   085D 7E            [ 7] 1391         LD      A,(HL)          ; Get next code string byte
q  085E                    1392         CP      ':'             ; Z if ':'
   085E D0            [11] 1393         RET     NC              ; NC if > "9"
q  085F                    1394         CP      ' '                              
   085F CA 5C 08      [10] 1395         JP      Z,GETCHR        ; Skip over spaces
q  0862                    1396         CP      '0'                              
   0862 3F            [ 4] 1397         CCF                     ; NC if < '0'
   0863 3C            [ 4] 1398         INC     A               ; Test for zero - Leave carry
   0864 3D            [ 4] 1399         DEC     A               ; Z if Null
   0865 C9            [10] 1400         RET                                   
                           1401 ;
   0866 EB            [ 4] 1402 RESTOR: EX      DE,HL           ; Save code string address
   0867 2A A3 80      [16] 1403         LD      HL,(BASTXT)     ; Point to start of program
   086A CA 7B 08      [10] 1404         JP      Z,RESTNL        ; Just RESTORE - reset pointer
   086D EB            [ 4] 1405         EX      DE,HL           ; Restore code string address
   086E CD 2A 09      [17] 1406         CALL    ATOH            ; Get line number to DE
   0871 E5            [11] 1407         PUSH    HL              ; Save code string address
   0872 CD 0C 05      [17] 1408         CALL    SRCHLN          ; Search for line number in DE
   0875 60            [ 4] 1409         LD      H,B             ; HL = Address of line
   0876 69            [ 4] 1410         LD      L,C                              
   0877 D1            [10] 1411         POP     DE              ; Restore code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 27
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0878 D2 C9 09      [10] 1412         JP      NC,ULERR        ; ?UL Error if not found
   087B 2B            [ 6] 1413 RESTNL: DEC     HL              ; Byte before DATA statement
   087C 22 21 81      [16] 1414 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
   087F EB            [ 4] 1415         EX      DE,HL           ; Restore code string address
   0880 C9            [10] 1416         RET                                   
                           1417 ;
                           1418 
   0881 DF            [11] 1419 TSTBRK: RST     0x18            ; Check input status
   0882 C8            [11] 1420         RET     Z               ; No key, go back
   0883 D7            [11] 1421         RST     0x10            ; Get the key into A
   0884 FE 1B         [ 7] 1422         CP      ESC             ; Escape key?
u  0886 28 00         [12] 1423         JR      Z,BRK           ; Yes, break
   0888 FE 03         [ 7] 1424         CP      CTRLC           ; <Ctrl-C>
u  088A 28 00         [12] 1425         JR      Z,BRK           ; Yes, break
   088C FE 13         [ 7] 1426         CP      CTRLS           ; Stop scrolling?
   088E C0            [11] 1427         RET     NZ              ; Other key, ignore
                           1428 ;
                           1429 
   088F D7            [11] 1430 STALL:  RST     0x10            ; Wait for key
   0890 FE 11         [ 7] 1431         CP      CTRLQ           ; Resume scrolling?
   0892 C8            [11] 1432         RET     Z               ; Release the chokehold
   0893 FE 03         [ 7] 1433         CP      CTRLC           ; Second break?
   0895 28 05         [12] 1434         JR      Z,STOP          ; Break during hold exits prog
   0897 18 F6         [12] 1435         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
                           1436 ;
o  0899                    1437 BRK     LD      A,0x0FF         ; Set BRKFLG
   0899 32 92 80      [13] 1438         LD      (BRKFLG),A      ; Store it
                           1439 ;
                           1440 
   089C C0            [11] 1441 STOP:   RET     NZ              ; Exit if anything else
   089D F6                 1442         .db     0x0F6           ; Flag 
   089E 53 54 4F 50        1443         .ascii  "STOP"                              
   08A2 C0            [11] 1444 PEND:   RET     NZ              ; Exit if anything else
   08A3 22 13 81      [16] 1445         LD      (BRKLIN),HL     ; Save point of break
   08A6 21                 1446         .db     0x21            ; Skip 
   08A7 4F 52 20 31 31 31  1447         .ascii  "OR 11111111B"                              
        31 31 31 31 31 42
kq 08B3                    1448 INPBRK: OR      11111111B       ; Flag "Break" wanted
   08B3 C1            [10] 1449         POP     BC              ; Return not needed and more
   08B4 2A A1 80      [16] 1450 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
   08B7 F5            [11] 1451         PUSH    AF              ; Save STOP / END status
   08B8 7D            [ 4] 1452         LD      A,L             ; Is it direct break?
   08B9 A4            [ 4] 1453         AND     H                              
   08BA 3C            [ 4] 1454         INC     A               ; Line is -1 if direct break
   08BB CA C7 08      [10] 1455         JP      Z,NOLIN         ; Yes - No line number
   08BE 22 17 81      [16] 1456         LD      (ERRLIN),HL     ; Save line of break
   08C1 2A 13 81      [16] 1457         LD      HL,(BRKLIN)     ; Get point of break
   08C4 22 19 81      [16] 1458         LD      (CONTAD),HL     ; Save point to CONTinue
   08C7 AF            [ 4] 1459 NOLIN:  XOR     A                              
   08C8 32 8A 80      [13] 1460         LD      (CTLOFG),A      ; Enable output
   08CB CD 09 0B      [17] 1461         CALL    STTLIN          ; Start a new line
   08CE F1            [10] 1462         POP     AF              ; Restore STOP / END status
   08CF 21 8C 03      [10] 1463         LD      HL,BRKMSG       ; "Break" message
   08D2 C2 4E 04      [10] 1464         JP      NZ,ERRIN        ; "in line" wanted?
   08D5 C3 6B 04      [10] 1465         JP      PRNTOK          ; Go to command mode
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 28
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                           1466 ;
   08D8 2A 19 81      [16] 1467 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
   08DB 7C            [ 4] 1468         LD      A,H             ; Is it zero?
   08DC B5            [ 4] 1469         OR      L                              
   08DD 1E 20         [ 7] 1470         LD      E,CN            ; ?CN Error
   08DF CA 2E 04      [10] 1471         JP      Z,ERROR         ; Yes - output "?CN Error"
   08E2 EB            [ 4] 1472         EX      DE,HL           ; Save code string address
   08E3 2A 17 81      [16] 1473         LD      HL,(ERRLIN)     ; Get line of last break
   08E6 22 A1 80      [16] 1474         LD      (LINEAT),HL     ; Set up current line number
   08E9 EB            [ 4] 1475         EX      DE,HL           ; Restore code string address
   08EA C9            [10] 1476         RET                     ; CONTinue where left off
                           1477 ;
   08EB CD 53 14      [17] 1478 NULL:   CALL    GETINT          ; Get integer 0-255
   08EE C0            [11] 1479         RET     NZ              ; Return if bad value
   08EF 32 86 80      [13] 1480         LD      (NULLS),A       ; Set nulls number
   08F2 C9            [10] 1481         RET                                   
                           1482 ;
                           1483 
   08F3 E5            [11] 1484 ACCSUM: PUSH    HL              ; Save address in array
   08F4 2A 8F 80      [16] 1485         LD      HL,(CHKSUM)     ; Get check sum
   08F7 06 00         [ 7] 1486         LD      B,0             ; BC - Value of byte
   08F9 4F            [ 4] 1487         LD      C,A                              
   08FA 09            [11] 1488         ADD     HL,BC           ; Add byte to check sum
   08FB 22 8F 80      [16] 1489         LD      (CHKSUM),HL     ; Re-save check sum
   08FE E1            [10] 1490         POP     HL              ; Restore address in array
   08FF C9            [10] 1491         RET                                   
                           1492 ;
   0900 7E            [ 7] 1493 CHKLTR: LD      A,(HL)          ; Get byte
q  0901                    1494         CP      'A'             ; < 'a' ?
   0901 D8            [11] 1495         RET     C               ; Carry set if not letter
q  0902                    1496         CP      'Z'+1           ; > 'z' ?
   0902 3F            [ 4] 1497         CCF                                   
   0903 C9            [10] 1498         RET                     ; Carry set if not letter
                           1499 ;
   0904 CD 5C 08      [17] 1500 FPSINT: CALL    GETCHR          ; Get next character
   0907 CD DC 0C      [17] 1501 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
   090A CD F5 16      [17] 1502 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
   090D FA 25 09      [10] 1503         JP      M,FCERR         ; Negative - ?FC Error
   0910 3A 2C 81      [13] 1504 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
   0913 FE 90         [ 7] 1505         CP      0x80+16         ; Exponent in range (16 bits)?
   0915 DA 9D 17      [10] 1506         JP      C,FPINT         ; Yes - convert it
   0918 01 80 90      [10] 1507         LD      BC,0x9080       ; BCDE = -32768
   091B 11 00 00      [10] 1508         LD      DE,0000                              
   091E E5            [11] 1509         PUSH    HL              ; Save code string address
   091F CD 70 17      [17] 1510         CALL    CMPNUM          ; Compare FPREG with BCDE
   0922 E1            [10] 1511         POP     HL              ; Restore code string address
   0923 51            [ 4] 1512         LD      D,C             ; MSB to D
   0924 C8            [11] 1513         RET     Z               ; Return if in range
   0925 1E 08         [ 7] 1514 FCERR:  LD      E,FC            ; ?FC Error
   0927 C3 2E 04      [10] 1515         JP      ERROR           ; Output error-
                           1516 ;
   092A 2B            [ 6] 1517 ATOH:   DEC     HL              ; ASCII number to DE binary
   092B 11 00 00      [10] 1518 GETLN:  LD      DE,0            ; Get number to DE
   092E CD 5C 08      [17] 1519 GTLNLP: CALL    GETCHR          ; Get next character
   0931 D0            [11] 1520         RET     NC              ; Exit if not a digit
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 29
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0932 E5            [11] 1521         PUSH    HL              ; Save code string address
   0933 F5            [11] 1522         PUSH    AF              ; Save digit
   0934 21 98 19      [10] 1523         LD      HL,65529/10     ; Largest number 65529
   0937 CD D1 06      [17] 1524         CALL    CPDEHL          ; Number in range?
   093A DA F0 03      [10] 1525         JP      C,SNERR         ; No - ?SN Error
   093D 62            [ 4] 1526         LD      H,D             ; HL = Number
   093E 6B            [ 4] 1527         LD      L,E                              
   093F 19            [11] 1528         ADD     HL,DE           ; Times 2
   0940 29            [11] 1529         ADD     HL,HL           ; Times 4
   0941 19            [11] 1530         ADD     HL,DE           ; Times 5
   0942 29            [11] 1531         ADD     HL,HL           ; Times 10
   0943 F1            [10] 1532         POP     AF              ; Restore digit
q  0944                    1533         SUB     '0'             ; Make it 0 to 9
   0944 5F            [ 4] 1534         LD      E,A             ; DE = Value of digit
   0945 16 00         [ 7] 1535         LD      D,0                              
   0947 19            [11] 1536         ADD     HL,DE           ; Add to number
   0948 EB            [ 4] 1537         EX      DE,HL           ; Number to DE
   0949 E1            [10] 1538         POP     HL              ; Restore code string address
   094A C3 2E 09      [10] 1539         JP      GTLNLP          ; Go to next character
                           1540 ;
   094D CA 3C 05      [10] 1541 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
   0950 CD 07 09      [17] 1542         CALL    POSINT          ; Get integer 0 to 32767 to DE
   0953 2B            [ 6] 1543         DEC     HL              ; Cancel increment
   0954 CD 5C 08      [17] 1544         CALL    GETCHR          ; Get next character
   0957 E5            [11] 1545         PUSH    HL              ; Save code string address
   0958 2A F4 80      [16] 1546         LD      HL,(LSTRAM)     ; Get end of RAM
   095B CA 70 09      [10] 1547         JP      Z,STORED        ; No value given - Use stored
   095E E1            [10] 1548         POP     HL              ; Restore code string address
   095F CD D7 06      [17] 1549         CALL    CHKSYN          ; Check for comma
q  0962 2C                 1550         .db     ','                              
   0963 D5            [11] 1551         PUSH    DE              ; Save number
   0964 CD 07 09      [17] 1552         CALL    POSINT          ; Get integer 0 to 32767
   0967 2B            [ 6] 1553         DEC     HL              ; Cancel increment
   0968 CD 5C 08      [17] 1554         CALL    GETCHR          ; Get next character
   096B C2 F0 03      [10] 1555         JP      NZ,SNERR        ; ?SN Error if more on line
   096E E3            [19] 1556         EX      (SP),HL         ; Save code string address
   096F EB            [ 4] 1557         EX      DE,HL           ; Number to DE
   0970 7D            [ 4] 1558 STORED: LD      A,L             ; Get LSB of new RAM top
   0971 93            [ 4] 1559         SUB     E               ; Subtract LSB of string space
   0972 5F            [ 4] 1560         LD      E,A             ; Save LSB
   0973 7C            [ 4] 1561         LD      A,H             ; Get MSB of new RAM top
   0974 9A            [ 4] 1562         SBC     A,D             ; Subtract MSB of string space
   0975 57            [ 4] 1563         LD      D,A             ; Save MSB
   0976 DA E5 03      [10] 1564         JP      C,OMERR         ; ?OM Error if not enough mem
   0979 E5            [11] 1565         PUSH    HL              ; Save RAM top
   097A 2A 1B 81      [16] 1566         LD      HL,(PROGND)     ; Get program end
   097D 01 28 00      [10] 1567         LD      BC,40           ; 40 Bytes minimum working RAM
   0980 09            [11] 1568         ADD     HL,BC           ; Get lowest address
   0981 CD D1 06      [17] 1569         CALL    CPDEHL          ; Enough memory?
   0984 D2 E5 03      [10] 1570         JP      NC,OMERR        ; No - ?OM Error
   0987 EB            [ 4] 1571         EX      DE,HL           ; RAM top to HL
   0988 22 9F 80      [16] 1572         LD      (STRSPC),HL     ; Set new string space
   098B E1            [10] 1573         POP     HL              ; End of memory to use
   098C 22 F4 80      [16] 1574         LD      (LSTRAM),HL     ; Set new top of RAM
   098F E1            [10] 1575         POP     HL              ; Restore code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 30
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0990 C3 3C 05      [10] 1576         JP      INTVAR          ; Initialise variables
                           1577 ;
   0993 CA 38 05      [10] 1578 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
   0996 CD 3C 05      [17] 1579         CALL    INTVAR          ; Initialise variables
   0999 01 1E 08      [10] 1580         LD      BC,RUNCNT       ; Execution driver loop
   099C C3 AF 09      [10] 1581         JP      RUNLIN          ; RUN from line number
                           1582 ;
   099F 0E 03         [ 7] 1583 GOSUB:  LD      C,3             ; 3 Levels of stack needed
   09A1 CD C6 03      [17] 1584         CALL    CHKSTK          ; Check for 3 levels of stack
   09A4 C1            [10] 1585         POP     BC              ; Get return address
   09A5 E5            [11] 1586         PUSH    HL              ; Save code string for RETURN
   09A6 E5            [11] 1587         PUSH    HL              ; And for GOSUB routine
   09A7 2A A1 80      [16] 1588         LD      HL,(LINEAT)     ; Get current line
   09AA E3            [19] 1589         EX      (SP),HL         ; Into stack - Code string out
   09AB 3E 8C         [ 7] 1590         LD      A,ZGOSUB        ; "GOSUB" token
   09AD F5            [11] 1591         PUSH    AF              ; Save token
   09AE 33            [ 6] 1592         INC     SP              ; Don't save flags
                           1593 ;
   09AF C5            [11] 1594 RUNLIN: PUSH    BC              ; Save return address
   09B0 CD 2A 09      [17] 1595 GOTO:   CALL    ATOH            ; ASCII number to DE binary
   09B3 CD FB 09      [17] 1596         CALL    REM             ; Get end of line
   09B6 E5            [11] 1597         PUSH    HL              ; Save end of line
   09B7 2A A1 80      [16] 1598         LD      HL,(LINEAT)     ; Get current line
   09BA CD D1 06      [17] 1599         CALL    CPDEHL          ; Line after current?
   09BD E1            [10] 1600         POP     HL              ; Restore end of line
   09BE 23            [ 6] 1601         INC     HL              ; Start of next line
   09BF DC 0F 05      [17] 1602         CALL    C,SRCHLP        ; Line is after current line
   09C2 D4 0C 05      [17] 1603         CALL    NC,SRCHLN       ; Line is before current line
   09C5 60            [ 4] 1604         LD      H,B             ; Set up code string address
   09C6 69            [ 4] 1605         LD      L,C                              
   09C7 2B            [ 6] 1606         DEC     HL              ; Incremented after
   09C8 D8            [11] 1607         RET     C               ; Line found
   09C9 1E 0E         [ 7] 1608 ULERR:  LD      E,UL            ; ?UL Error
   09CB C3 2E 04      [10] 1609         JP      ERROR           ; Output error message
                           1610 ;
   09CE C0            [11] 1611 RETURN: RET     NZ              ; Return if not just RETURN
   09CF 16 FF         [ 7] 1612         LD      D,-1            ; Flag "GOSUB" search
   09D1 CD 92 03      [17] 1613         CALL    BAKSTK          ; Look "GOSUB" block
   09D4 F9            [ 6] 1614         LD      SP,HL           ; Kill all FORs in subroutine
   09D5 FE 8C         [ 7] 1615         CP      ZGOSUB          ; Test for "GOSUB" token
   09D7 1E 04         [ 7] 1616         LD      E,RG            ; ?RG Error
   09D9 C2 2E 04      [10] 1617         JP      NZ,ERROR        ; Error if no "GOSUB" found
   09DC E1            [10] 1618         POP     HL              ; Get RETURN line number
   09DD 22 A1 80      [16] 1619         LD      (LINEAT),HL     ; Save as current
   09E0 23            [ 6] 1620         INC     HL              ; Was it from direct statement?
   09E1 7C            [ 4] 1621         LD      A,H                              
   09E2 B5            [ 4] 1622         OR      L               ; Return to line
   09E3 C2 ED 09      [10] 1623         JP      NZ,RETLIN       ; No - Return to line
   09E6 3A 11 81      [13] 1624         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
   09E9 B7            [ 4] 1625         OR      A               ; If so buffer is corrupted
   09EA C2 6A 04      [10] 1626         JP      NZ,POPNOK       ; Yes - Go to command mode
   09ED 21 1E 08      [10] 1627 RETLIN: LD      HL,RUNCNT       ; Execution driver loop
   09F0 E3            [19] 1628         EX      (SP),HL         ; Into stack - Code string out
   09F1 3E                 1629         .db     0x3E            ; Skip 
   09F2 50 4F 50 20 48 4C  1630         .ascii  "POP HL"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 31
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   09F8 E1            [10] 1631 NXTDTA: POP     HL              ; Restore code string address
                           1632 ;
   09F9 01 3A              1633 DATA:   .db     0x01,0x3A       ; ':' End of statement
   09FB 0E 00         [ 7] 1634 REM:    LD      C,0             ; 00	End of statement
   09FD 06 00         [ 7] 1635         LD      B,0                              
   09FF 79            [ 4] 1636 NXTSTL: LD      A,C             ; Statement and byte
   0A00 48            [ 4] 1637         LD      C,B                              
   0A01 47            [ 4] 1638         LD      B,A             ; Statement end byte
   0A02 7E            [ 7] 1639 NXTSTT: LD      A,(HL)          ; Get byte
   0A03 B7            [ 4] 1640         OR      A               ; End of line?
   0A04 C8            [11] 1641         RET     Z               ; Yes - Exit
   0A05 B8            [ 4] 1642         CP      B               ; End of statement?
   0A06 C8            [11] 1643         RET     Z               ; Yes - Exit
   0A07 23            [ 6] 1644         INC     HL              ; Next byte
q  0A08                    1645         CP      '"'             ; Literal string?
   0A08 CA FF 09      [10] 1646         JP      Z,NXTSTL        ; Yes - Look for another '"'
   0A0B C3 02 0A      [10] 1647         JP      NXTSTT          ; Keep looking
                           1648 ;
   0A0E CD CD 0E      [17] 1649 LET:    CALL    GETVAR          ; Get variable name
   0A11 CD D7 06      [17] 1650         CALL    CHKSYN          ; Make sure "=" follows
   0A14 B4                 1651         .db     ZEQUAL          ; 
   0A15 3D                 1652         .ascii  "="                              
u  0A16 00                 1653         .db      token                              
   0A17 D5            [11] 1654         PUSH    DE              ; Save address of variable
   0A18 3A F2 80      [13] 1655         LD      A,(TYPE)        ; Get data type
   0A1B F5            [11] 1656         PUSH    AF              ; Save type
   0A1C CD EE 0C      [17] 1657         CALL    EVAL            ; Evaluate expression
   0A1F F1            [10] 1658         POP     AF              ; Restore type
   0A20 E3            [19] 1659         EX      (SP),HL         ; Save code - Get var addr
   0A21 22 13 81      [16] 1660         LD      (BRKLIN),HL     ; Save address of variable
   0A24 1F            [ 4] 1661         RRA                     ; Adjust type
   0A25 CD E1 0C      [17] 1662         CALL    CHKTYP          ; Check types are the same
   0A28 CA 69 0A      [10] 1663         JP      Z,LETNUM        ; Numeric - Move value
   0A2B E5            [11] 1664 LETSTR: PUSH    HL              ; Save address of string var
   0A2C 2A 29 81      [16] 1665         LD      HL,(FPREG)      ; Pointer to string entry
   0A2F E5            [11] 1666         PUSH    HL              ; Save it on stack
   0A30 23            [ 6] 1667         INC     HL              ; Skip over length
   0A31 23            [ 6] 1668         INC     HL                              
   0A32 5E            [ 7] 1669         LD      E,(HL)          ; LSB of string address
   0A33 23            [ 6] 1670         INC     HL                              
   0A34 56            [ 7] 1671         LD      D,(HL)          ; MSB of string address
   0A35 2A A3 80      [16] 1672         LD      HL,(BASTXT)     ; Point to start of program
   0A38 CD D1 06      [17] 1673         CALL    CPDEHL          ; Is string before program?
   0A3B D2 58 0A      [10] 1674         JP      NC,CRESTR       ; Yes - Create string entry
   0A3E 2A 9F 80      [16] 1675         LD      HL,(STRSPC)     ; Point to string space
   0A41 CD D1 06      [17] 1676         CALL    CPDEHL          ; Is string literal in program?
   0A44 D1            [10] 1677         POP     DE              ; Restore address of string
   0A45 D2 60 0A      [10] 1678         JP      NC,MVSTPT       ; Yes - Set up pointer
   0A48 21 04 81      [10] 1679         LD      HL,TMPSTR       ; Temporary string pool
   0A4B CD D1 06      [17] 1680         CALL    CPDEHL          ; Is string in temporary pool?
   0A4E D2 60 0A      [10] 1681         JP      NC,MVSTPT       ; No - Set up pointer
   0A51 3E                 1682         .db     0x3E            ; Skip 
   0A52 50 4F 50 20 44 45  1683         .ascii  "POP DE"                              
   0A58 D1            [10] 1684 CRESTR: POP     DE              ; Restore address of string
   0A59 CD 2C 13      [17] 1685         CALL    BAKTMP          ; Back to last tmp-str entry
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 32
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0A5C EB            [ 4] 1686         EX      DE,HL           ; Address of string entry
   0A5D CD 67 11      [17] 1687         CALL    SAVSTR          ; Save string in string area
   0A60 CD 2C 13      [17] 1688 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
   0A63 E1            [10] 1689         POP     HL              ; Get string pointer
   0A64 CD 50 17      [17] 1690         CALL    DETHL4          ; Move string pointer to var
   0A67 E1            [10] 1691         POP     HL              ; Restore code string address
   0A68 C9            [10] 1692         RET                                   
                           1693 ;
   0A69 E5            [11] 1694 LETNUM: PUSH    HL              ; Save address of variable
   0A6A CD 4D 17      [17] 1695         CALL    FPTHL           ; Move value to variable
   0A6D D1            [10] 1696         POP     DE              ; Restore address of variable
   0A6E E1            [10] 1697         POP     HL              ; Restore code string address
   0A6F C9            [10] 1698         RET                                   
                           1699 ;
   0A70 CD 53 14      [17] 1700 ON:     CALL    GETINT          ; Get integer 0-255
   0A73 7E            [ 7] 1701         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
   0A74 47            [ 4] 1702         LD      B,A             ; Save in B
   0A75 FE 8C         [ 7] 1703         CP      ZGOSUB          ; "GOSUB" token?
   0A77 CA 84 0A      [10] 1704         JP      Z,ONGO          ; Yes - Find line number
   0A7A CD D7 06      [17] 1705         CALL    CHKSYN          ; Make sure it's "GOTO"
   0A7D 88                 1706         .db     ZGOTO           ; 
   0A7E 47 4F 54 4F        1707         .ascii  "GOTO"                              
u  0A82 00                 1708         .db      token                              
   0A83 2B            [ 6] 1709         DEC     HL              ; Cancel increment
   0A84 4B            [ 4] 1710 ONGO:   LD      C,E             ; Integer of branch value
   0A85 0D            [ 4] 1711 ONGOLP: DEC     C               ; Count branches
   0A86 78            [ 4] 1712         LD      A,B             ; Get "GOTO" or "GOSUB" token
   0A87 CA 44 08      [10] 1713         JP      Z,ONJMP         ; Go to that line if right one
   0A8A CD 2B 09      [17] 1714         CALL    GETLN           ; Get line number to DE
q  0A8D                    1715         CP      ','             ; Another line number?
   0A8D C0            [11] 1716         RET     NZ              ; No - Drop through
   0A8E C3 85 0A      [10] 1717         JP      ONGOLP          ; Yes - loop
                           1718 ;
   0A91 CD EE 0C      [17] 1719 IF:     CALL    EVAL            ; Evaluate expression
   0A94 7E            [ 7] 1720         LD      A,(HL)          ; Get token
   0A95 FE 88         [ 7] 1721         CP      ZGOTO           ; "GOTO" token?
   0A97 CA A4 0A      [10] 1722         JP      Z,IFGO          ; Yes - Get line
   0A9A CD D7 06      [17] 1723         CALL    CHKSYN          ; Make sure it's "THEN"
   0A9D A9                 1724         .db     ZTHEN           ; 
   0A9E 54 48 45 4E        1725         .ascii  "THEN"                              
u  0AA2 00                 1726         .db      token                              
   0AA3 2B            [ 6] 1727         DEC     HL              ; Cancel increment
   0AA4 CD DF 0C      [17] 1728 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
   0AA7 CD F5 16      [17] 1729         CALL    TSTSGN          ; Test state of expression
   0AAA CA FB 09      [10] 1730         JP      Z,REM           ; False - Drop through
   0AAD CD 5C 08      [17] 1731         CALL    GETCHR          ; Get next character
   0AB0 DA B0 09      [10] 1732         JP      C,GOTO          ; Number - GOTO that line
   0AB3 C3 43 08      [10] 1733         JP      IFJMP           ; Otherwise do statement
                           1734 ;
   0AB6 2B            [ 6] 1735 MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
   0AB7 CD 5C 08      [17] 1736         CALL    GETCHR          ; Get next character
   0ABA CA 16 0B      [10] 1737 PRINT:  JP      Z,PRCRLF        ; CRLF if just PRINT
   0ABD C8            [11] 1738 PRNTLP: RET     Z               ; End of list - Exit
   0ABE FE A5         [ 7] 1739         CP      ZTAB            ; "TAB(" token?
   0AC0 CA 49 0B      [10] 1740         JP      Z,DOTAB         ; Yes - Do TAB routine
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 33
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0AC3 FE A8         [ 7] 1741         CP      ZSPC            ; "SPC(" token?
   0AC5 CA 49 0B      [10] 1742         JP      Z,DOTAB         ; Yes - Do SPC routine
   0AC8 E5            [11] 1743         PUSH    HL              ; Save code string address
q  0AC9                    1744         CP      ','             ; Comma?
   0AC9 CA 32 0B      [10] 1745         JP      Z,DOCOM         ; Yes - Move to next zone
   0ACC FE 3B         [ 7] 1746         CP      59              ;";"		; Semi-colon?
   0ACE CA 6C 0B      [10] 1747         JP      Z,NEXITM        ; Do semi-colon routine
   0AD1 C1            [10] 1748         POP     BC              ; Code string address to BC
   0AD2 CD EE 0C      [17] 1749         CALL    EVAL            ; Evaluate expression
   0AD5 E5            [11] 1750         PUSH    HL              ; Save code string address
   0AD6 3A F2 80      [13] 1751         LD      A,(TYPE)        ; Get variable type
   0AD9 B7            [ 4] 1752         OR      A               ; Is it a string variable?
   0ADA C2 02 0B      [10] 1753         JP      NZ,PRNTST       ; Yes - Output string contents
   0ADD CD 8E 18      [17] 1754         CALL    NUMASC          ; Convert number to text
   0AE0 CD 8B 11      [17] 1755         CALL    CRTST           ; Create temporary string
q  0AE3 36 20         [10] 1756         LD      (HL),' '        ; Followed by a space
   0AE5 2A 29 81      [16] 1757         LD      HL,(FPREG)      ; Get length of output
   0AE8 34            [11] 1758         INC     (HL)            ; Plus 1 for the space
   0AE9 2A 29 81      [16] 1759         LD      HL,(FPREG)      ; < Not needed >
   0AEC 3A 87 80      [13] 1760         LD      A,(LWIDTH)      ; Get width of line
   0AEF 47            [ 4] 1761         LD      B,A             ; To B
   0AF0 04            [ 4] 1762         INC     B               ; Width 255 (No limit)?
   0AF1 CA FE 0A      [10] 1763         JP      Z,PRNTNB        ; Yes - Output number string
   0AF4 04            [ 4] 1764         INC     B               ; Adjust it
   0AF5 3A F0 80      [13] 1765         LD      A,(CURPOS)      ; Get cursor position
   0AF8 86            [ 7] 1766         ADD     A,(HL)          ; Add length of string
   0AF9 3D            [ 4] 1767         DEC     A               ; Adjust it
   0AFA B8            [ 4] 1768         CP      B               ; Will output fit on this line?
   0AFB D4 16 0B      [17] 1769         CALL    NC,PRCRLF       ; No - CRLF first
   0AFE CD CE 11      [17] 1770 PRNTNB: CALL    PRS1            ; Output string at (HL)
   0B01 AF            [ 4] 1771         XOR     A               ; Skip CALL by setting 'z' flag
   0B02 C4 CE 11      [17] 1772 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
   0B05 E1            [10] 1773         POP     HL              ; Restore code string address
   0B06 C3 B6 0A      [10] 1774         JP      MRPRNT          ; See if more to PRINT
                           1775 ;
   0B09 3A F0 80      [13] 1776 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
   0B0C B7            [ 4] 1777         OR      A               ; Already at start?
   0B0D C8            [11] 1778         RET     Z               ; Yes - Do nothing
   0B0E C3 16 0B      [10] 1779         JP      PRCRLF          ; Start a new line
                           1780 ;
   0B11 36 00         [10] 1781 ENDINP: LD      (HL),0          ; Mark end of buffer
   0B13 21 A5 80      [10] 1782         LD      HL,BUFFER-1     ; Point to buffer
   0B16 3E 0D         [ 7] 1783 PRCRLF: LD      A,CR            ; Load a CR
   0B18 CD E2 06      [17] 1784         CALL    OUTC            ; Output character
   0B1B 3E 0A         [ 7] 1785         LD      A,LF            ; Load a LF
   0B1D CD E2 06      [17] 1786         CALL    OUTC            ; Output character
   0B20 AF            [ 4] 1787 DONULL: XOR     A               ; Set to position 0
   0B21 32 F0 80      [13] 1788         LD      (CURPOS),A      ; Store it
   0B24 3A 86 80      [13] 1789         LD      A,(NULLS)       ; Get number of nulls
   0B27 3D            [ 4] 1790 NULLP:  DEC     A               ; Count them
   0B28 C8            [11] 1791         RET     Z               ; Return if done
   0B29 F5            [11] 1792         PUSH    AF              ; Save count
   0B2A AF            [ 4] 1793         XOR     A               ; Load a null
   0B2B CD E2 06      [17] 1794         CALL    OUTC            ; Output it
   0B2E F1            [10] 1795         POP     AF              ; Restore count
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 34
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0B2F C3 27 0B      [10] 1796         JP      NULLP           ; Keep counting
                           1797 ;
   0B32 3A 88 80      [13] 1798 DOCOM:  LD      A,(COMMAN)      ; Get comma width
   0B35 47            [ 4] 1799         LD      B,A             ; Save in B
   0B36 3A F0 80      [13] 1800         LD      A,(CURPOS)      ; Get current position
   0B39 B8            [ 4] 1801         CP      B               ; Within the limit?
   0B3A D4 16 0B      [17] 1802         CALL    NC,PRCRLF       ; No - output CRLF
   0B3D D2 6C 0B      [10] 1803         JP      NC,NEXITM       ; Get next item
   0B40 D6 0E         [ 7] 1804 ZONELP: SUB     14              ; Next zone of 14 characters
   0B42 D2 40 0B      [10] 1805         JP      NC,ZONELP       ; Repeat if more zones
   0B45 2F            [ 4] 1806         CPL                     ; Number of spaces to output
   0B46 C3 61 0B      [10] 1807         JP      ASPCS           ; Output them
                           1808 ;
   0B49 F5            [11] 1809 DOTAB:  PUSH    AF              ; Save token
   0B4A CD 50 14      [17] 1810         CALL    FNDNUM          ; Evaluate expression
   0B4D CD D7 06      [17] 1811         CALL    CHKSYN          ; Make sure ")" follows
   0B50 29                 1812         .ascii  ")"                              
   0B51 2B            [ 6] 1813         DEC     HL              ; Back space on to ")"
   0B52 F1            [10] 1814         POP     AF              ; Restore token
   0B53 D6 A8         [ 7] 1815         SUB     ZSPC            ; Was it "SPC(" ?
   0B55 E5            [11] 1816         PUSH    HL              ; Save code string address
   0B56 CA 5C 0B      [10] 1817         JP      Z,DOSPC         ; Yes - Do 'E' spaces
   0B59 3A F0 80      [13] 1818         LD      A,(CURPOS)      ; Get current position
   0B5C 2F            [ 4] 1819 DOSPC:  CPL                     ; Number of spaces to print to
   0B5D 83            [ 4] 1820         ADD     A,E             ; Total number to print
   0B5E D2 6C 0B      [10] 1821         JP      NC,NEXITM       ; TAB < Current POS(X)
   0B61 3C            [ 4] 1822 ASPCS:  INC     A               ; Output A spaces
   0B62 47            [ 4] 1823         LD      B,A             ; Save number to print
q  0B63 3E 20         [ 7] 1824         LD      A,' '           ; Space
   0B65 CD E2 06      [17] 1825 SPCLP:  CALL    OUTC            ; Output character in A
   0B68 05            [ 4] 1826         DEC     B               ; Count them
   0B69 C2 65 0B      [10] 1827         JP      NZ,SPCLP        ; Repeat if more
   0B6C E1            [10] 1828 NEXITM: POP     HL              ; Restore code string address
   0B6D CD 5C 08      [17] 1829         CALL    GETCHR          ; Get next character
   0B70 C3 BD 0A      [10] 1830         JP      PRNTLP          ; More to print
                           1831 ;
   0B73 3F 52 65 64 6F 20  1832 REDO:   .ascii  "?Redo from start"                              
        66 72 6F 6D 20 73
        74 61 72 74
   0B83 0D 0A 00           1833         .db     CR,LF,0                              
                           1834 ;
   0B86 3A 12 81      [13] 1835 BADINP: LD      A,(READFG)      ; READ or INPUT?
   0B89 B7            [ 4] 1836         OR      A                              
   0B8A C2 EA 03      [10] 1837         JP      NZ,DATSNR       ; READ - ?SN Error
   0B8D C1            [10] 1838         POP     BC              ; Throw away code string addr
   0B8E 21 73 0B      [10] 1839         LD      HL,REDO         ; "Redo from start" message
   0B91 CD CB 11      [17] 1840         CALL    PRS             ; Output string
   0B94 C3 6B 05      [10] 1841         JP      DOAGN           ; Do last INPUT again
                           1842 ;
   0B97 CD 35 11      [17] 1843 INPUT:  CALL    IDTEST          ; Test for illegal direct
   0B9A 7E            [ 7] 1844         LD      A,(HL)          ; Get character after "INPUT"
q  0B9B                    1845         CP      '"'             ; Is there a prompt string?
   0B9B 3E 00         [ 7] 1846         LD      A,0             ; Clear A and leave flags
   0B9D 32 8A 80      [13] 1847         LD      (CTLOFG),A      ; Enable output
   0BA0 C2 B6 0B      [10] 1848         JP      NZ,NOPMPT       ; No prompt - get input
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 35
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0BA3 CD 8C 11      [17] 1849         CALL    QTSTR           ; Get string terminated by '"'
   0BA6 CD D7 06      [17] 1850         CALL    CHKSYN          ; Check for ';' after prompt
q  0BA9 3B                 1851         .db     ';'                              
   0BAA E5            [11] 1852         PUSH    HL              ; Save code string address
   0BAB CD CE 11      [17] 1853         CALL    PRS1            ; Output prompt string
   0BAE 3E                 1854         .db     0x3E            ; Skip 
   0BAF 50 55 53 48 20 48  1855         .ascii  "PUSH HL"                              
        4C
   0BB6 E5            [11] 1856 NOPMPT: PUSH    HL              ; Save code string address
   0BB7 CD 6F 05      [17] 1857         CALL    PROMPT          ; Get input with "? " prompt
   0BBA C1            [10] 1858         POP     BC              ; Restore code string address
   0BBB DA B3 08      [10] 1859         JP      C,INPBRK        ; Break pressed - Exit
   0BBE 23            [ 6] 1860         INC     HL              ; Next byte
   0BBF 7E            [ 7] 1861         LD      A,(HL)          ; Get it
   0BC0 B7            [ 4] 1862         OR      A               ; End of line?
   0BC1 2B            [ 6] 1863         DEC     HL              ; Back again
   0BC2 C5            [11] 1864         PUSH    BC              ; Re-save code string address
   0BC3 CA F8 09      [10] 1865         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
q  0BC6 36 2C         [10] 1866         LD      (HL),','        ; Store comma as separator
   0BC8 C3 D4 0B      [10] 1867         JP      NXTITM          ; Get next item
                           1868 ;
   0BCB E5            [11] 1869 READ:   PUSH    HL              ; Save code string address
   0BCC 2A 21 81      [16] 1870         LD      HL,(NXTDAT)     ; Next DATA statement
   0BCF F6                 1871         .db     0x0F6           ; Flag 
   0BD0 52 45 41 44        1872         .ascii  "READ"                              
   0BD4 AF            [ 4] 1873 NXTITM: XOR     A               ; Flag "INPUT"
   0BD5 32 12 81      [13] 1874         LD      (READFG),A      ; Save "READ"/"INPUT" flag
   0BD8 E3            [19] 1875         EX      (SP),HL         ; Get code str' , Save pointer
   0BD9 C3 E0 0B      [10] 1876         JP      GTVLUS          ; Get values
                           1877 ;
   0BDC CD D7 06      [17] 1878 NEDMOR: CALL    CHKSYN          ; Check for comma between items
q  0BDF 2C                 1879         .db     ','                              
   0BE0 CD CD 0E      [17] 1880 GTVLUS: CALL    GETVAR          ; Get variable name
   0BE3 E3            [19] 1881         EX      (SP),HL         ; Save code str" , Get pointer
   0BE4 D5            [11] 1882         PUSH    DE              ; Save variable address
   0BE5 7E            [ 7] 1883         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
q  0BE6                    1884         CP      ','             ; Comma?
   0BE6 CA 06 0C      [10] 1885         JP      Z,ANTVLU        ; Yes - Get another value
   0BE9 3A 12 81      [13] 1886         LD      A,(READFG)      ; Is it READ?
   0BEC B7            [ 4] 1887         OR      A                              
   0BED C2 6F 0C      [10] 1888         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
q  0BF0 3E 3F         [ 7] 1889         LD      A,'?'           ; More INPUT needed
   0BF2 CD E2 06      [17] 1890         CALL    OUTC            ; Output character
   0BF5 CD 6F 05      [17] 1891         CALL    PROMPT          ; Get INPUT with prompt
   0BF8 D1            [10] 1892         POP     DE              ; Variable address
   0BF9 C1            [10] 1893         POP     BC              ; Code string address
   0BFA DA B3 08      [10] 1894         JP      C,INPBRK        ; Break pressed
   0BFD 23            [ 6] 1895         INC     HL              ; Point to next DATA byte
   0BFE 7E            [ 7] 1896         LD      A,(HL)          ; Get byte
   0BFF B7            [ 4] 1897         OR      A               ; Is it zero (No input) ?
   0C00 2B            [ 6] 1898         DEC     HL              ; Back space INPUT pointer
   0C01 C5            [11] 1899         PUSH    BC              ; Save code string address
   0C02 CA F8 09      [10] 1900         JP      Z,NXTDTA        ; Find end of buffer
   0C05 D5            [11] 1901         PUSH    DE              ; Save variable address
   0C06 3A F2 80      [13] 1902 ANTVLU: LD      A,(TYPE)        ; Check data type
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 36
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0C09 B7            [ 4] 1903         OR      A               ; Is it numeric?
   0C0A CA 2E 0C      [10] 1904         JP      Z,INPBIN        ; Yes - Convert to binary
   0C0D CD 5C 08      [17] 1905         CALL    GETCHR          ; Get next character
   0C10 57            [ 4] 1906         LD      D,A             ; Save input character
   0C11 47            [ 4] 1907         LD      B,A             ; Again
q  0C12                    1908         CP      '"'             ; Start of literal sting?
   0C12 CA 22 0C      [10] 1909         JP      Z,STRENT        ; Yes - Create string entry
   0C15 3A 12 81      [13] 1910         LD      A,(READFG)      ; "READ" or "INPUT" ?
   0C18 B7            [ 4] 1911         OR      A                              
   0C19 57            [ 4] 1912         LD      D,A             ; Save 00 if "INPUT"
   0C1A CA 1F 0C      [10] 1913         JP      Z,ITMSEP        ; "INPUT" - End with 00
q  0C1D 16 3A         [ 7] 1914         LD      D,':'           ; "DATA" - End with 00 or ':'
q  0C1F 06 2C         [ 7] 1915 ITMSEP: LD      B,','           ; Item separator
   0C21 2B            [ 6] 1916         DEC     HL              ; Back space for DTSTR
   0C22 CD 8F 11      [17] 1917 STRENT: CALL    DTSTR           ; Get string terminated by D
   0C25 EB            [ 4] 1918         EX      DE,HL           ; String address to DE
   0C26 21 39 0C      [10] 1919         LD      HL,LTSTND       ; Where to go after LETSTR
   0C29 E3            [19] 1920         EX      (SP),HL         ; Save HL , get input pointer
   0C2A D5            [11] 1921         PUSH    DE              ; Save address of string
   0C2B C3 2B 0A      [10] 1922         JP      LETSTR          ; Assign string to variable
                           1923 ;
   0C2E CD 5C 08      [17] 1924 INPBIN: CALL    GETCHR          ; Get next character
   0C31 CD FC 17      [17] 1925         CALL    ASCTFP          ; Convert ASCII to FP number
   0C34 E3            [19] 1926         EX      (SP),HL         ; Save input ptr, Get var addr
   0C35 CD 4D 17      [17] 1927         CALL    FPTHL           ; Move FPREG to variable
   0C38 E1            [10] 1928         POP     HL              ; Restore input pointer
   0C39 2B            [ 6] 1929 LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
   0C3A CD 5C 08      [17] 1930         CALL    GETCHR          ; Get next character
   0C3D CA 43 0C      [10] 1931         JP      Z,MORDT         ; End of line - More needed?
q  0C40                    1932         CP      ','             ; Another value?
   0C40 C2 86 0B      [10] 1933         JP      NZ,BADINP       ; No - Bad input
   0C43 E3            [19] 1934 MORDT:  EX      (SP),HL         ; Get code string address
   0C44 2B            [ 6] 1935         DEC     HL              ; DEC 'cos GETCHR INCs
   0C45 CD 5C 08      [17] 1936         CALL    GETCHR          ; Get next character
   0C48 C2 DC 0B      [10] 1937         JP      NZ,NEDMOR       ; More needed - Get it
   0C4B D1            [10] 1938         POP     DE              ; Restore DATA pointer
   0C4C 3A 12 81      [13] 1939         LD      A,(READFG)      ; "READ" or "INPUT" ?
   0C4F B7            [ 4] 1940         OR      A                              
   0C50 EB            [ 4] 1941         EX      DE,HL           ; DATA pointer to HL
   0C51 C2 7C 08      [10] 1942         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
   0C54 D5            [11] 1943         PUSH    DE              ; Save code string address
   0C55 B6            [ 7] 1944         OR      (HL)            ; More input given?
   0C56 21 5E 0C      [10] 1945         LD      HL,EXTIG        ; "?Extra ignored" message
   0C59 C4 CB 11      [17] 1946         CALL    NZ,PRS          ; Output string if extra given
   0C5C E1            [10] 1947         POP     HL              ; Restore code string address
   0C5D C9            [10] 1948         RET                                   
                           1949 ;
   0C5E 3F 45 78 74 72 61  1950 EXTIG:  .ascii  "?Extra ignored"                              
        20 69 67 6E 6F 72
        65 64
   0C6C 0D 0A 00           1951         .db     CR,LF,0                              
                           1952 ;
   0C6F CD F9 09      [17] 1953 FDTLP:  CALL    DATA            ; Get next statement
   0C72 B7            [ 4] 1954         OR      A               ; End of line?
   0C73 C2 88 0C      [10] 1955         JP      NZ,FANDT        ; No - See if DATA statement
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 37
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0C76 23            [ 6] 1956         INC     HL                              
   0C77 7E            [ 7] 1957         LD      A,(HL)          ; End of program?
   0C78 23            [ 6] 1958         INC     HL                              
   0C79 B6            [ 7] 1959         OR      (HL)            ; 00 00 Ends program
   0C7A 1E 06         [ 7] 1960         LD      E,OD            ; ?OD Error
   0C7C CA 2E 04      [10] 1961         JP      Z,ERROR         ; Yes - Out of DATA
   0C7F 23            [ 6] 1962         INC     HL                              
   0C80 5E            [ 7] 1963         LD      E,(HL)          ; LSB of line number
   0C81 23            [ 6] 1964         INC     HL                              
   0C82 56            [ 7] 1965         LD      D,(HL)          ; MSB of line number
   0C83 EB            [ 4] 1966         EX      DE,HL                              
   0C84 22 0E 81      [16] 1967         LD      (DATLIN),HL     ; Set line of current DATA item
   0C87 EB            [ 4] 1968         EX      DE,HL                              
   0C88 CD 5C 08      [17] 1969 FANDT:  CALL    GETCHR          ; Get next character
   0C8B FE 83         [ 7] 1970         CP      ZDATA           ; "DATA" token
   0C8D C2 6F 0C      [10] 1971         JP      NZ,FDTLP        ; No "DATA" - Keep looking
   0C90 C3 06 0C      [10] 1972         JP      ANTVLU          ; Found - Convert input
                           1973 ;
   0C93 11 00 00      [10] 1974 NEXT:   LD      DE,0            ; In case no index given
   0C96 C4 CD 0E      [17] 1975 NEXT1:  CALL    NZ,GETVAR       ; Get index address
   0C99 22 13 81      [16] 1976         LD      (BRKLIN),HL     ; Save code string address
   0C9C CD 92 03      [17] 1977         CALL    BAKSTK          ; Look for "FOR" block
   0C9F C2 04 04      [10] 1978         JP      NZ,NFERR        ; No "FOR" - ?NF Error
   0CA2 F9            [ 6] 1979         LD      SP,HL           ; Clear nested loops
   0CA3 D5            [11] 1980         PUSH    DE              ; Save index address
   0CA4 7E            [ 7] 1981         LD      A,(HL)          ; Get sign of STEP
   0CA5 23            [ 6] 1982         INC     HL                              
   0CA6 F5            [11] 1983         PUSH    AF              ; Save sign of STEP
   0CA7 D5            [11] 1984         PUSH    DE              ; Save index address
   0CA8 CD 33 17      [17] 1985         CALL    PHLTFP          ; Move index value to FPREG
   0CAB E3            [19] 1986         EX      (SP),HL         ; Save address of TO value
   0CAC E5            [11] 1987         PUSH    HL              ; Save address of index
   0CAD CD 7F 14      [17] 1988         CALL    ADDPHL          ; Add STEP to index value
   0CB0 E1            [10] 1989         POP     HL              ; Restore address of index
   0CB1 CD 4D 17      [17] 1990         CALL    FPTHL           ; Move value to index variable
   0CB4 E1            [10] 1991         POP     HL              ; Restore address of TO value
   0CB5 CD 44 17      [17] 1992         CALL    LOADFP          ; Move TO value to BCDE
   0CB8 E5            [11] 1993         PUSH    HL              ; Save address of line of FOR
   0CB9 CD 70 17      [17] 1994         CALL    CMPNUM          ; Compare index with TO value
   0CBC E1            [10] 1995         POP     HL              ; Restore address of line num
   0CBD C1            [10] 1996         POP     BC              ; Address of sign of STEP
   0CBE 90            [ 4] 1997         SUB     B               ; Compare with expected sign
   0CBF CD 44 17      [17] 1998         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
   0CC2 CA CE 0C      [10] 1999         JP      Z,KILFOR        ; Loop finished - Terminate it
   0CC5 EB            [ 4] 2000         EX      DE,HL           ; Loop statement line number
   0CC6 22 A1 80      [16] 2001         LD      (LINEAT),HL     ; Set loop line number
   0CC9 69            [ 4] 2002         LD      L,C             ; Set code string to loop
   0CCA 60            [ 4] 2003         LD      H,B                              
   0CCB C3 1A 08      [10] 2004         JP      PUTFID          ; Put back "FOR" and continue
                           2005 ;
   0CCE F9            [ 6] 2006 KILFOR: LD      SP,HL           ; Remove "FOR" block
   0CCF 2A 13 81      [16] 2007         LD      HL,(BRKLIN)     ; Code string after "NEXT"
   0CD2 7E            [ 7] 2008         LD      A,(HL)          ; Get next byte in code string
q  0CD3                    2009         CP      ','             ; More NEXTs ?
   0CD3 C2 1E 08      [10] 2010         JP      NZ,RUNCNT       ; No - Do next statement
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 38
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0CD6 CD 5C 08      [17] 2011         CALL    GETCHR          ; Position to index name
   0CD9 CD 96 0C      [17] 2012         CALL    NEXT1           ; Re-enter NEXT routine
                           2013 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           2014 ;
   0CDC CD EE 0C      [17] 2015 GETNUM: CALL    EVAL            ; Get a numeric expression
   0CDF F6                 2016 TSTNUM: .db     0x0F6           ; Clear carry (numeric)
   0CE0 37            [ 4] 2017 TSTSTR: SCF                     ; Set carry (string)
   0CE1 3A F2 80      [13] 2018 CHKTYP: LD      A,(TYPE)        ; Check types match
   0CE4 8F            [ 4] 2019         ADC     A,A             ; Expected + actual
   0CE5 B7            [ 4] 2020         OR      A               ; Clear carry , set parity
   0CE6 E8            [11] 2021         RET     PE              ; Even parity - Types match
   0CE7 C3 2C 04      [10] 2022         JP      TMERR           ; Different types - Error
                           2023 ;
   0CEA CD D7 06      [17] 2024 OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
   0CED 28                 2025         .ascii  "("                              
   0CEE 2B            [ 6] 2026 EVAL:   DEC     HL              ; Evaluate expression & save
   0CEF 16 00         [ 7] 2027         LD      D,0             ; Precedence value
   0CF1 D5            [11] 2028 EVAL1:  PUSH    DE              ; Save precedence
   0CF2 0E 01         [ 7] 2029         LD      C,1                              
   0CF4 CD C6 03      [17] 2030         CALL    CHKSTK          ; Check for 1 level of stack
   0CF7 CD 65 0D      [17] 2031         CALL    OPRND           ; Get next expression value
   0CFA 22 15 81      [16] 2032 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
   0CFD 2A 15 81      [16] 2033 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
   0D00 C1            [10] 2034         POP     BC              ; Precedence value and operator
   0D01 78            [ 4] 2035         LD      A,B             ; Get precedence value
   0D02 FE 78         [ 7] 2036         CP      0x78            ; "AND" or "OR" ?
   0D04 D4 DF 0C      [17] 2037         CALL    NC,TSTNUM       ; No - Make sure it's a number
   0D07 7E            [ 7] 2038         LD      A,(HL)          ; Get next operator / function
   0D08 16 00         [ 7] 2039         LD      D,0             ; Clear Last relation
   0D0A D6 B3         [ 7] 2040 RLTLP:  SUB     ZGTR            ; ">" Token
   0D0C DA 26 0D      [10] 2041         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
   0D0F FE 03         [ 7] 2042         CP      ZLTH+1-ZGTR     ; < = >
   0D11 D2 26 0D      [10] 2043         JP      NC,FOPRND       ; Function - Call it
   0D14 FE 01         [ 7] 2044         CP      ZEQUAL-ZGTR     ; "="
   0D16 17            [ 4] 2045         RLA                     ; <- Test for legal
   0D17 AA            [ 4] 2046         XOR     D               ; <- combinations of < = >
   0D18 BA            [ 4] 2047         CP      D               ; <- by combining last token
   0D19 57            [ 4] 2048         LD      D,A             ; <- with current one
   0D1A DA F0 03      [10] 2049         JP      C,SNERR         ; Error if "<<' '==" or ">>"
   0D1D 22 0A 81      [16] 2050         LD      (CUROPR),HL     ; Save address of current token
   0D20 CD 5C 08      [17] 2051         CALL    GETCHR          ; Get next character
   0D23 C3 0A 0D      [10] 2052         JP      RLTLP           ; Treat the two as one
                           2053 ;
   0D26 7A            [ 4] 2054 FOPRND: LD      A,D             ; < = > found ?
   0D27 B7            [ 4] 2055         OR      A                              
   0D28 C2 41 0E      [10] 2056         JP      NZ,TSTRED       ; Yes - Test for reduction
   0D2B 7E            [ 7] 2057         LD      A,(HL)          ; Get operator token
   0D2C 22 0A 81      [16] 2058         LD      (CUROPR),HL     ; Save operator address
   0D2F D6 AC         [ 7] 2059         SUB     ZPLUS           ; Operator or function?
   0D31 D8            [11] 2060         RET     C               ; Neither - Exit
   0D32 FE 07         [ 7] 2061         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
   0D34 D0            [11] 2062         RET     NC              ; No - Exit
   0D35 5F            [ 4] 2063         LD      E,A             ; Coded operator
   0D36 3A F2 80      [13] 2064         LD      A,(TYPE)        ; Get data type
   0D39 3D            [ 4] 2065         DEC     A               ; FF = numeric , 00 = string
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 39
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0D3A B3            [ 4] 2066         OR      E               ; Combine with coded operator
   0D3B 7B            [ 4] 2067         LD      A,E             ; Get coded operator
   0D3C CA C1 12      [10] 2068         JP      Z,CONCAT        ; String concatenation
   0D3F 07            [ 4] 2069         RLCA                    ; Times 2
   0D40 83            [ 4] 2070         ADD     A,E             ; Times 3
   0D41 5F            [ 4] 2071         LD      E,A             ; To DE (D is 0)
   0D42 21 E4 02      [10] 2072         LD      HL,PRITAB       ; Precedence table
   0D45 19            [11] 2073         ADD     HL,DE           ; To the operator concerned
   0D46 78            [ 4] 2074         LD      A,B             ; Last operator precedence
   0D47 56            [ 7] 2075         LD      D,(HL)          ; Get evaluation precedence
   0D48 BA            [ 4] 2076         CP      D               ; Compare with eval precedence
   0D49 D0            [11] 2077         RET     NC              ; Exit if higher precedence
   0D4A 23            [ 6] 2078         INC     HL              ; Point to routine address
   0D4B CD DF 0C      [17] 2079         CALL    TSTNUM          ; Make sure it's a number
                           2080 ;
   0D4E C5            [11] 2081 STKTHS: PUSH    BC              ; Save last precedence & token
   0D4F 01 FD 0C      [10] 2082         LD      BC,EVAL3        ; Where to go on prec' break
   0D52 C5            [11] 2083         PUSH    BC              ; Save on stack for return
   0D53 43            [ 4] 2084         LD      B,E             ; Save operator
   0D54 4A            [ 4] 2085         LD      C,D             ; Save precedence
   0D55 CD 26 17      [17] 2086         CALL    STAKFP          ; Move value to stack
   0D58 58            [ 4] 2087         LD      E,B             ; Restore operator
   0D59 51            [ 4] 2088         LD      D,C             ; Restore precedence
   0D5A 4E            [ 7] 2089         LD      C,(HL)          ; Get LSB of routine address
   0D5B 23            [ 6] 2090         INC     HL                              
   0D5C 46            [ 7] 2091         LD      B,(HL)          ; Get MSB of routine address
   0D5D 23            [ 6] 2092         INC     HL                              
   0D5E C5            [11] 2093         PUSH    BC              ; Save routine address
   0D5F 2A 0A 81      [16] 2094         LD      HL,(CUROPR)     ; Address of current operator
   0D62 C3 F1 0C      [10] 2095         JP      EVAL1           ; Loop until prec' break
                           2096 ;
   0D65 AF            [ 4] 2097 OPRND:  XOR     A               ; Get operand routine
   0D66 32 F2 80      [13] 2098         LD      (TYPE),A        ; Set numeric expected
   0D69 CD 5C 08      [17] 2099         CALL    GETCHR          ; Get next character
   0D6C 1E 24         [ 7] 2100         LD      E,MO            ; ?MO Error
   0D6E CA 2E 04      [10] 2101         JP      Z,ERROR         ; No operand - Error
   0D71 DA FC 17      [10] 2102         JP      C,ASCTFP        ; Number - Get value
   0D74 CD 00 09      [17] 2103         CALL    CHKLTR          ; See if a letter
   0D77 D2 C2 0D      [10] 2104         JP      NC,CONVAR       ; Letter - Find variable
q  0D7A                    2105         CP      '&'             ; &H = HEX, &B = BINARY
   0D7A 20 0E         [12] 2106         JR      NZ,NOTAMP                              
   0D7C CD 5C 08      [17] 2107         CALL    GETCHR          ; Get next character
q  0D7F                    2108         CP      'H'             ; Hex number indicated? [function added]
u  0D7F CA 00 00      [10] 2109         JP      Z,HEXTFP        ; Convert Hex to FPREG
q  0D82                    2110         CP      'B'             ; Binary number indicated? [function added]
   0D82 CA 6E 1C      [10] 2111         JP      Z,BINTFP        ; Convert Bin to FPREG
   0D85 1E 02         [ 7] 2112         LD      E,SN            ; If neither then a ?SN Error
   0D87 CA 2E 04      [10] 2113         JP      Z,ERROR                              
   0D8A FE AC         [ 7] 2114 NOTAMP: CP      ZPLUS           ; '+' Token ?
   0D8C CA 65 0D      [10] 2115         JP      Z,OPRND         ; Yes - Look for operand
q  0D8F                    2116         CP      '.'             ; '.' ?
   0D8F CA FC 17      [10] 2117         JP      Z,ASCTFP        ; Yes - Create FP number
   0D92 FE AD         [ 7] 2118         CP      ZMINUS          ; '-' Token ?
   0D94 CA B1 0D      [10] 2119         JP      Z,MINUS         ; Yes - Do minus
q  0D97                    2120         CP      '"'             ; Literal string ?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 40
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0D97 CA 8C 11      [10] 2121         JP      Z,QTSTR         ; Get string terminated by '"'
   0D9A FE AA         [ 7] 2122         CP      ZNOT            ; "NOT" Token ?
   0D9C CA A1 0E      [10] 2123         JP      Z,EVNOT         ; Yes - Eval NOT expression
   0D9F FE A7         [ 7] 2124         CP      ZFN             ; "FN" Token ?
   0DA1 CA ED 10      [10] 2125         JP      Z,DOFN          ; Yes - Do FN routine
   0DA4 D6 B6         [ 7] 2126         SUB     ZSGN            ; Is it a function?
   0DA6 D2 D3 0D      [10] 2127         JP      NC,FNOFST       ; Yes - Evaluate function
   0DA9 CD EA 0C      [17] 2128 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
   0DAC CD D7 06      [17] 2129         CALL    CHKSYN          ; Make sure ")" follows
   0DAF 29                 2130         .ascii  ")"                              
   0DB0 C9            [10] 2131         RET                                   
                           2132 ;
   0DB1 16 7D         [ 7] 2133 MINUS:  LD      D,0x7D          ; '-' precedence
   0DB3 CD F1 0C      [17] 2134         CALL    EVAL1           ; Evaluate until prec' break
   0DB6 2A 15 81      [16] 2135         LD      HL,(NXTOPR)     ; Get next operator address
   0DB9 E5            [11] 2136         PUSH    HL              ; Save next operator address
   0DBA CD 1E 17      [17] 2137         CALL    INVSGN          ; Negate value
   0DBD CD DF 0C      [17] 2138 RETNUM: CALL    TSTNUM          ; Make sure it's a number
   0DC0 E1            [10] 2139         POP     HL              ; Restore next operator address
   0DC1 C9            [10] 2140         RET                                   
                           2141 ;
   0DC2 CD CD 0E      [17] 2142 CONVAR: CALL    GETVAR          ; Get variable address to DE
   0DC5 E5            [11] 2143 FRMEVL: PUSH    HL              ; Save code string address
   0DC6 EB            [ 4] 2144         EX      DE,HL           ; Variable address to HL
   0DC7 22 29 81      [16] 2145         LD      (FPREG),HL      ; Save address of variable
   0DCA 3A F2 80      [13] 2146         LD      A,(TYPE)        ; Get type
   0DCD B7            [ 4] 2147         OR      A               ; Numeric?
   0DCE CC 33 17      [17] 2148         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
   0DD1 E1            [10] 2149         POP     HL              ; Restore code string address
   0DD2 C9            [10] 2150         RET                                   
                           2151 ;
   0DD3 06 00         [ 7] 2152 FNOFST: LD      B,0             ; Get address of function
   0DD5 07            [ 4] 2153         RLCA                    ; Double function offset
   0DD6 4F            [ 4] 2154         LD      C,A             ; BC = Offset in function table
   0DD7 C5            [11] 2155         PUSH    BC              ; Save adjusted token value
   0DD8 CD 5C 08      [17] 2156         CALL    GETCHR          ; Get next character
   0DDB 79            [ 4] 2157         LD      A,C             ; Get adjusted token value
   0DDC FE 31         [ 7] 2158         CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
   0DDE DA FA 0D      [10] 2159         JP      C,FNVAL         ; No - Do function
   0DE1 CD EA 0C      [17] 2160         CALL    OPNPAR          ; Evaluate expression	(X,...
   0DE4 CD D7 06      [17] 2161         CALL    CHKSYN          ; Make sure ',' follows
q  0DE7 2C                 2162         .db     ','                              
   0DE8 CD E0 0C      [17] 2163         CALL    TSTSTR          ; Make sure it's a string
   0DEB EB            [ 4] 2164         EX      DE,HL           ; Save code string address
   0DEC 2A 29 81      [16] 2165         LD      HL,(FPREG)      ; Get address of string
   0DEF E3            [19] 2166         EX      (SP),HL         ; Save address of string
   0DF0 E5            [11] 2167         PUSH    HL              ; Save adjusted token value
   0DF1 EB            [ 4] 2168         EX      DE,HL           ; Restore code string address
   0DF2 CD 53 14      [17] 2169         CALL    GETINT          ; Get integer 0-255
   0DF5 EB            [ 4] 2170         EX      DE,HL           ; Save code string address
   0DF6 E3            [19] 2171         EX      (SP),HL         ; Save integer,HL = adj' token
   0DF7 C3 02 0E      [10] 2172         JP      GOFUNC          ; Jump to string function
                           2173 ;
   0DFA CD A9 0D      [17] 2174 FNVAL:  CALL    EVLPAR          ; Evaluate expression
   0DFD E3            [19] 2175         EX      (SP),HL         ; HL = Adjusted token value
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 41
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0DFE 11 BD 0D      [10] 2176         LD      DE,RETNUM       ; Return number from function
   0E01 D5            [11] 2177         PUSH    DE              ; Save on stack
   0E02 01 43 01      [10] 2178 GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
   0E05 09            [11] 2179         ADD     HL,BC           ; Point to right address
   0E06 4E            [ 7] 2180         LD      C,(HL)          ; Get LSB of address
   0E07 23            [ 6] 2181         INC     HL              ;
   0E08 66            [ 7] 2182         LD      H,(HL)          ; Get MSB of address
   0E09 69            [ 4] 2183         LD      L,C             ; Address to HL
   0E0A E9            [ 4] 2184         JP      (HL)            ; Jump to function
                           2185 ;
   0E0B 15            [ 4] 2186 SGNEXP: DEC     D               ; Dee to flag negative exponent
   0E0C FE AD         [ 7] 2187         CP      ZMINUS          ; '-' token ?
   0E0E C8            [11] 2188         RET     Z               ; Yes - Return
q  0E0F                    2189         CP      '-'             ; '-' ASCII ?
   0E0F C8            [11] 2190         RET     Z               ; Yes - Return
   0E10 14            [ 4] 2191         INC     D               ; Inc to flag positive exponent
q  0E11                    2192         CP      '+'             ; '+' ASCII ?
   0E11 C8            [11] 2193         RET     Z               ; Yes - Return
   0E12 FE AC         [ 7] 2194         CP      ZPLUS           ; '+' token ?
   0E14 C8            [11] 2195         RET     Z               ; Yes - Return
   0E15 2B            [ 6] 2196         DEC     HL              ; DEC 'cos GETCHR INCs
   0E16 C9            [10] 2197         RET                     ; Return "NZ"
                           2198 ;
   0E17 F6                 2199 POR:    .db     0x0F6           ; Flag 
   0E18 4F 52              2200         .ascii  "OR"                              
   0E1A AF            [ 4] 2201 PAND:   XOR     A               ; Flag "AND"
   0E1B F5            [11] 2202         PUSH    AF              ; Save "AND" / "OR" flag
   0E1C CD DF 0C      [17] 2203         CALL    TSTNUM          ; Make sure it's a number
   0E1F CD 10 09      [17] 2204         CALL    DEINT           ; Get integer -32768 to 32767
   0E22 F1            [10] 2205         POP     AF              ; Restore "AND" / "OR" flag
   0E23 EB            [ 4] 2206         EX      DE,HL           ; <- Get last
   0E24 C1            [10] 2207         POP     BC              ; <- value
   0E25 E3            [19] 2208         EX      (SP),HL         ; <- from
   0E26 EB            [ 4] 2209         EX      DE,HL           ; <- stack
   0E27 CD 36 17      [17] 2210         CALL    FPBCDE          ; Move last value to FPREG
   0E2A F5            [11] 2211         PUSH    AF              ; Save "AND" / "OR" flag
   0E2B CD 10 09      [17] 2212         CALL    DEINT           ; Get integer -32768 to 32767
   0E2E F1            [10] 2213         POP     AF              ; Restore "AND" / "OR" flag
   0E2F C1            [10] 2214         POP     BC              ; Get value
   0E30 79            [ 4] 2215         LD      A,C             ; Get LSB
   0E31 21 A9 10      [10] 2216         LD      HL,ACPASS       ; Address of save AC as current
   0E34 C2 3C 0E      [10] 2217         JP      NZ,POR1         ; Jump if OR
   0E37 A3            [ 4] 2218         AND     E               ; "AND" LSBs
   0E38 4F            [ 4] 2219         LD      C,A             ; Save LSB
   0E39 78            [ 4] 2220         LD      A,B             ; Get MBS
   0E3A A2            [ 4] 2221         AND     D               ; "AND" MSBs
   0E3B E9            [ 4] 2222         JP      (HL)            ; Save AC as current (ACPASS)
                           2223 ;
   0E3C B3            [ 4] 2224 POR1:   OR      E               ; "OR" LSBs
   0E3D 4F            [ 4] 2225         LD      C,A             ; Save LSB
   0E3E 78            [ 4] 2226         LD      A,B             ; Get MSB
   0E3F B2            [ 4] 2227         OR      D               ; "OR" MSBs
   0E40 E9            [ 4] 2228         JP      (HL)            ; Save AC as current (ACPASS)
                           2229 ;
   0E41 21 53 0E      [10] 2230 TSTRED: LD      HL,CMPLOG       ; Logical compare routine
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 42
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0E44 3A F2 80      [13] 2231         LD      A,(TYPE)        ; Get data type
   0E47 1F            [ 4] 2232         RRA                     ; Carry set = string
   0E48 7A            [ 4] 2233         LD      A,D             ; Get last precedence value
   0E49 17            [ 4] 2234         RLA                     ; Times 2 plus carry
   0E4A 5F            [ 4] 2235         LD      E,A             ; To E
   0E4B 16 64         [ 7] 2236         LD      D,0x64          ; Relational precedence
   0E4D 78            [ 4] 2237         LD      A,B             ; Get current precedence
   0E4E BA            [ 4] 2238         CP      D               ; Compare with last
   0E4F D0            [11] 2239         RET     NC              ; Eval if last was rel' or log'
   0E50 C3 4E 0D      [10] 2240         JP      STKTHS          ; Stack this one and get next
                           2241 ;
   0E53 55 0E              2242 CMPLOG: .dw     CMPLG1          ; Compare two values / strings
   0E55 79            [ 4] 2243 CMPLG1: LD      A,C             ; Get data type
   0E56 B7            [ 4] 2244         OR      A                              
   0E57 1F            [ 4] 2245         RRA                                   
   0E58 C1            [10] 2246         POP     BC              ; Get last expression to BCDE
   0E59 D1            [10] 2247         POP     DE                              
   0E5A F5            [11] 2248         PUSH    AF              ; Save status
   0E5B CD E1 0C      [17] 2249         CALL    CHKTYP          ; Check that types match
   0E5E 21 97 0E      [10] 2250         LD      HL,CMPRES       ; Result to comparison
   0E61 E5            [11] 2251         PUSH    HL              ; Save for RETurn
   0E62 CA 70 17      [10] 2252         JP      Z,CMPNUM        ; Compare values if numeric
   0E65 AF            [ 4] 2253         XOR     A               ; Compare two strings
   0E66 32 F2 80      [13] 2254         LD      (TYPE),A        ; Set type to numeric
   0E69 D5            [11] 2255         PUSH    DE              ; Save string name
   0E6A CD 0E 13      [17] 2256         CALL    GSTRCU          ; Get current string
   0E6D 7E            [ 7] 2257         LD      A,(HL)          ; Get length of string
   0E6E 23            [ 6] 2258         INC     HL                              
   0E6F 23            [ 6] 2259         INC     HL                              
   0E70 4E            [ 7] 2260         LD      C,(HL)          ; Get LSB of address
   0E71 23            [ 6] 2261         INC     HL                              
   0E72 46            [ 7] 2262         LD      B,(HL)          ; Get MSB of address
   0E73 D1            [10] 2263         POP     DE              ; Restore string name
   0E74 C5            [11] 2264         PUSH    BC              ; Save address of string
   0E75 F5            [11] 2265         PUSH    AF              ; Save length of string
   0E76 CD 12 13      [17] 2266         CALL    GSTRDE          ; Get second string
   0E79 CD 44 17      [17] 2267         CALL    LOADFP          ; Get address of second string
   0E7C F1            [10] 2268         POP     AF              ; Restore length of string 1
   0E7D 57            [ 4] 2269         LD      D,A             ; Length to D
   0E7E E1            [10] 2270         POP     HL              ; Restore address of string 1
   0E7F 7B            [ 4] 2271 CMPSTR: LD      A,E             ; Bytes of string 2 to do
   0E80 B2            [ 4] 2272         OR      D               ; Bytes of string 1 to do
   0E81 C8            [11] 2273         RET     Z               ; Exit if all bytes compared
   0E82 7A            [ 4] 2274         LD      A,D             ; Get bytes of string 1 to do
   0E83 D6 01         [ 7] 2275         SUB     1                              
   0E85 D8            [11] 2276         RET     C               ; Exit if end of string 1
   0E86 AF            [ 4] 2277         XOR     A                              
   0E87 BB            [ 4] 2278         CP      E               ; Bytes of string 2 to do
   0E88 3C            [ 4] 2279         INC     A                              
   0E89 D0            [11] 2280         RET     NC              ; Exit if end of string 2
   0E8A 15            [ 4] 2281         DEC     D               ; Count bytes in string 1
   0E8B 1D            [ 4] 2282         DEC     E               ; Count bytes in string 2
   0E8C 0A            [ 7] 2283         LD      A,(BC)          ; Byte in string 2
   0E8D BE            [ 7] 2284         CP      (HL)            ; Compare to byte in string 1
   0E8E 23            [ 6] 2285         INC     HL              ; Move up string 1
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 43
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0E8F 03            [ 6] 2286         INC     BC              ; Move up string 2
   0E90 CA 7F 0E      [10] 2287         JP      Z,CMPSTR        ; Same - Try next bytes
   0E93 3F            [ 4] 2288         CCF                     ; Flag difference (">" or "<")
   0E94 C3 00 17      [10] 2289         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                           2290 ;
   0E97 3C            [ 4] 2291 CMPRES: INC     A               ; Increment current value
   0E98 8F            [ 4] 2292         ADC     A,A             ; Double plus carry
   0E99 C1            [10] 2293         POP     BC              ; Get other value
   0E9A A0            [ 4] 2294         AND     B               ; Combine them
   0E9B C6 FF         [ 7] 2295         ADD     A,-1            ; Carry set if different
   0E9D 9F            [ 4] 2296         SBC     A,A             ; 00 - Equal , FF - Different
   0E9E C3 07 17      [10] 2297         JP      FLGREL          ; Set current value & continue
                           2298 ;
   0EA1 16 5A         [ 7] 2299 EVNOT:  LD      D,0x5A          ; Precedence value for "NOT"
   0EA3 CD F1 0C      [17] 2300         CALL    EVAL1           ; Eval until precedence break
   0EA6 CD DF 0C      [17] 2301         CALL    TSTNUM          ; Make sure it's a number
   0EA9 CD 10 09      [17] 2302         CALL    DEINT           ; Get integer -32768 - 32767
   0EAC 7B            [ 4] 2303         LD      A,E             ; Get LSB
   0EAD 2F            [ 4] 2304         CPL                     ; Invert LSB
   0EAE 4F            [ 4] 2305         LD      C,A             ; Save "NOT" of LSB
   0EAF 7A            [ 4] 2306         LD      A,D             ; Get MSB
   0EB0 2F            [ 4] 2307         CPL                     ; Invert MSB
   0EB1 CD A9 10      [17] 2308         CALL    ACPASS          ; Save AC as current
   0EB4 C1            [10] 2309         POP     BC              ; Clean up stack
   0EB5 C3 FD 0C      [10] 2310         JP      EVAL3           ; Continue evaluation
                           2311 ;
   0EB8 2B            [ 6] 2312 DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
   0EB9 CD 5C 08      [17] 2313         CALL    GETCHR          ; Get next character
   0EBC C8            [11] 2314         RET     Z               ; End of DIM statement
   0EBD CD D7 06      [17] 2315         CALL    CHKSYN          ; Make sure ',' follows
q  0EC0 2C                 2316         .db     ','                              
   0EC1 01 B8 0E      [10] 2317 DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
   0EC4 C5            [11] 2318         PUSH    BC              ; Save on stack
   0EC5 F6                 2319         .db     0x0F6           ; Flag 
   0EC6 43 72 65 61 74 65  2320         .ascii  "Create"                              
u  0ECC 00                 2321         .db      variable                              
   0ECD AF            [ 4] 2322 GETVAR: XOR     A               ; Find variable address,to DE
   0ECE 32 F1 80      [13] 2323         LD      (LCRFLG),A      ; Set locate / create flag
   0ED1 46            [ 7] 2324         LD      B,(HL)          ; Get First byte of name
   0ED2 CD 00 09      [17] 2325 GTFNAM: CALL    CHKLTR          ; See if a letter
   0ED5 DA F0 03      [10] 2326         JP      C,SNERR         ; ?SN Error if not a letter
   0ED8 AF            [ 4] 2327         XOR     A                              
   0ED9 4F            [ 4] 2328         LD      C,A             ; Clear second byte of name
   0EDA 32 F2 80      [13] 2329         LD      (TYPE),A        ; Set type to numeric
   0EDD CD 5C 08      [17] 2330         CALL    GETCHR          ; Get next character
   0EE0 DA E9 0E      [10] 2331         JP      C,SVNAM2        ; Numeric - Save in name
   0EE3 CD 00 09      [17] 2332         CALL    CHKLTR          ; See if a letter
   0EE6 DA F6 0E      [10] 2333         JP      C,CHARTY        ; Not a letter - Check type
   0EE9 4F            [ 4] 2334 SVNAM2: LD      C,A             ; Save second byte of name
   0EEA CD 5C 08      [17] 2335 ENDNAM: CALL    GETCHR          ; Get next character
   0EED DA EA 0E      [10] 2336         JP      C,ENDNAM        ; Numeric - Get another
   0EF0 CD 00 09      [17] 2337         CALL    CHKLTR          ; See if a letter
   0EF3 D2 EA 0E      [10] 2338         JP      NC,ENDNAM       ; Letter - Get another
q  0EF6                    2339 CHARTY: SUB     '$'             ; String variable?
   0EF6 C2 03 0F      [10] 2340         JP      NZ,NOTSTR       ; No - Numeric variable
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 44
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0EF9 3C            [ 4] 2341         INC     A               ; A = 1 (string type)
   0EFA 32 F2 80      [13] 2342         LD      (TYPE),A        ; Set type to string
   0EFD 0F            [ 4] 2343         RRCA                    ; A = 80H , Flag for string
   0EFE 81            [ 4] 2344         ADD     A,C             ; 2nd byte of name has bit 7 on
   0EFF 4F            [ 4] 2345         LD      C,A             ; Resave second byte on name
   0F00 CD 5C 08      [17] 2346         CALL    GETCHR          ; Get next character
   0F03 3A 10 81      [13] 2347 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
   0F06 3D            [ 4] 2348         DEC     A                              
   0F07 CA BB 0F      [10] 2349         JP      Z,ARLDSV        ; Yes - Get array name
   0F0A F2 11 0F      [10] 2350         JP      P,NSCFOR        ; No array with "FOR" or "FN"
   0F0D 7E            [ 7] 2351         LD      A,(HL)          ; Get byte again
q  0F0E                    2352         SUB     '('             ; Subscripted variable?
   0F0E CA 86 0F      [10] 2353         JP      Z,SBSCPT        ; Yes - Sort out subscript
                           2354 ;
   0F11 AF            [ 4] 2355 NSCFOR: XOR     A               ; Simple variable
   0F12 32 10 81      [13] 2356         LD      (FORFLG),A      ; Clear "FOR" flag
   0F15 E5            [11] 2357         PUSH    HL              ; Save code string address
   0F16 50            [ 4] 2358         LD      D,B             ; DE = Variable name to find
   0F17 59            [ 4] 2359         LD      E,C                              
   0F18 2A 23 81      [16] 2360         LD      HL,(FNRGNM)     ; FN argument name
   0F1B CD D1 06      [17] 2361         CALL    CPDEHL          ; Is it the FN argument?
   0F1E 11 25 81      [10] 2362         LD      DE,FNARG        ; Point to argument value
   0F21 CA 29 16      [10] 2363         JP      Z,POPHRT        ; Yes - Return FN argument value
   0F24 2A 1D 81      [16] 2364         LD      HL,(VAREND)     ; End of variables
   0F27 EB            [ 4] 2365         EX      DE,HL           ; Address of end of search
   0F28 2A 1B 81      [16] 2366         LD      HL,(PROGND)     ; Start of variables address
   0F2B CD D1 06      [17] 2367 FNDVAR: CALL    CPDEHL          ; End of variable list table?
   0F2E CA 44 0F      [10] 2368         JP      Z,CFEVAL        ; Yes - Called from EVAL?
   0F31 79            [ 4] 2369         LD      A,C             ; Get second byte of name
   0F32 96            [ 7] 2370         SUB     (HL)            ; Compare with name in list
   0F33 23            [ 6] 2371         INC     HL              ; Move on to first byte
   0F34 C2 39 0F      [10] 2372         JP      NZ,FNTHR        ; Different - Find another
   0F37 78            [ 4] 2373         LD      A,B             ; Get first byte of name
   0F38 96            [ 7] 2374         SUB     (HL)            ; Compare with name in list
   0F39 23            [ 6] 2375 FNTHR:  INC     HL              ; Move on to LSB of value
   0F3A CA 78 0F      [10] 2376         JP      Z,RETADR        ; Found - Return address
   0F3D 23            [ 6] 2377         INC     HL              ; <- Skip
   0F3E 23            [ 6] 2378         INC     HL              ; <- over
   0F3F 23            [ 6] 2379         INC     HL              ; <- F.P.
   0F40 23            [ 6] 2380         INC     HL              ; <- value
   0F41 C3 2B 0F      [10] 2381         JP      FNDVAR          ; Keep looking
                           2382 ;
   0F44 E1            [10] 2383 CFEVAL: POP     HL              ; Restore code string address
   0F45 E3            [19] 2384         EX      (SP),HL         ; Get return address
   0F46 D5            [11] 2385         PUSH    DE              ; Save address of variable
   0F47 11 C5 0D      [10] 2386         LD      DE,FRMEVL       ; Return address in EVAL
   0F4A CD D1 06      [17] 2387         CALL    CPDEHL          ; Called from EVAL ?
   0F4D D1            [10] 2388         POP     DE              ; Restore address of variable
   0F4E CA 7B 0F      [10] 2389         JP      Z,RETNUL        ; Yes - Return null variable
   0F51 E3            [19] 2390         EX      (SP),HL         ; Put back return
   0F52 E5            [11] 2391         PUSH    HL              ; Save code string address
   0F53 C5            [11] 2392         PUSH    BC              ; Save variable name
   0F54 01 06 00      [10] 2393         LD      BC,6            ; 2 byte name plus 4 byte data
   0F57 2A 1F 81      [16] 2394         LD      HL,(ARREND)     ; End of arrays
   0F5A E5            [11] 2395         PUSH    HL              ; Save end of arrays
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 45
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0F5B 09            [11] 2396         ADD     HL,BC           ; Move up 6 bytes
   0F5C C1            [10] 2397         POP     BC              ; Source address in BC
   0F5D E5            [11] 2398         PUSH    HL              ; Save new end address
   0F5E CD B5 03      [17] 2399         CALL    MOVUP           ; Move arrays up
   0F61 E1            [10] 2400         POP     HL              ; Restore new end address
   0F62 22 1F 81      [16] 2401         LD      (ARREND),HL     ; Set new end address
   0F65 60            [ 4] 2402         LD      H,B             ; End of variables to HL
   0F66 69            [ 4] 2403         LD      L,C                              
   0F67 22 1D 81      [16] 2404         LD      (VAREND),HL     ; Set new end address
                           2405 ;
   0F6A 2B            [ 6] 2406 ZEROLP: DEC     HL              ; Back through to zero variable
   0F6B 36 00         [10] 2407         LD      (HL),0          ; Zero byte in variable
   0F6D CD D1 06      [17] 2408         CALL    CPDEHL          ; Done them all?
   0F70 C2 6A 0F      [10] 2409         JP      NZ,ZEROLP       ; No - Keep on going
   0F73 D1            [10] 2410         POP     DE              ; Get variable name
   0F74 73            [ 7] 2411         LD      (HL),E          ; Store second character
   0F75 23            [ 6] 2412         INC     HL                              
   0F76 72            [ 7] 2413         LD      (HL),D          ; Store first character
   0F77 23            [ 6] 2414         INC     HL                              
   0F78 EB            [ 4] 2415 RETADR: EX      DE,HL           ; Address of variable in DE
   0F79 E1            [10] 2416         POP     HL              ; Restore code string address
   0F7A C9            [10] 2417         RET                                   
                           2418 ;
   0F7B 32 2C 81      [13] 2419 RETNUL: LD      (FPEXP),A       ; Set result to zero
   0F7E 21 FF FF      [10] 2420         LD      HL,ZERBYT       ; Also set a null string
   0F81 22 29 81      [16] 2421         LD      (FPREG),HL      ; Save for EVAL
   0F84 E1            [10] 2422         POP     HL              ; Restore code string address
   0F85 C9            [10] 2423         RET                                   
                           2424 ;
   0F86 E5            [11] 2425 SBSCPT: PUSH    HL              ; Save code string address
   0F87 2A F1 80      [16] 2426         LD      HL,(LCRFLG)     ; Locate/Create and Type
   0F8A E3            [19] 2427         EX      (SP),HL         ; Save and get code string
   0F8B 57            [ 4] 2428         LD      D,A             ; Zero number of dimensions
   0F8C D5            [11] 2429 SCPTLP: PUSH    DE              ; Save number of dimensions
   0F8D C5            [11] 2430         PUSH    BC              ; Save array name
   0F8E CD 04 09      [17] 2431         CALL    FPSINT          ; Get subscript (0-32767)
   0F91 C1            [10] 2432         POP     BC              ; Restore array name
   0F92 F1            [10] 2433         POP     AF              ; Get number of dimensions
   0F93 EB            [ 4] 2434         EX      DE,HL                              
   0F94 E3            [19] 2435         EX      (SP),HL         ; Save subscript value
   0F95 E5            [11] 2436         PUSH    HL              ; Save LCRFLG and TYPE
   0F96 EB            [ 4] 2437         EX      DE,HL                              
   0F97 3C            [ 4] 2438         INC     A               ; Count dimensions
   0F98 57            [ 4] 2439         LD      D,A             ; Save in D
   0F99 7E            [ 7] 2440         LD      A,(HL)          ; Get next byte in code string
q  0F9A                    2441         CP      ','             ; Comma (more to come)?
   0F9A CA 8C 0F      [10] 2442         JP      Z,SCPTLP        ; Yes - More subscripts
   0F9D CD D7 06      [17] 2443         CALL    CHKSYN          ; Make sure ")" follows
   0FA0 29                 2444         .ascii  ")"                              
   0FA1 22 15 81      [16] 2445         LD      (NXTOPR),HL     ; Save code string address
   0FA4 E1            [10] 2446         POP     HL              ; Get LCRFLG and TYPE
   0FA5 22 F1 80      [16] 2447         LD      (LCRFLG),HL     ; Restore Locate/create & type
   0FA8 1E 00         [ 7] 2448         LD      E,0             ; Flag not CSAVE* or CLOAD*
   0FAA D5            [11] 2449         PUSH    DE              ; Save number of dimensions (D)
   0FAB 11                 2450         .db     0x11            ; Skip 
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 46
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   0FAC 50 55 53 48 20 48  2451         .ascii  "PUSH HL"                              
        4C
u  0FB3 00                 2452         .db      and                               
   0FB4 50 55 53 48 20 41  2453         .ascii  "PUSH AF"                              
        46
                           2454 ;
   0FBB E5            [11] 2455 ARLDSV: PUSH    HL              ; Save code string address
   0FBC F5            [11] 2456         PUSH    AF              ; A = 00 , Flags set = Z,N
   0FBD 2A 1D 81      [16] 2457         LD      HL,(VAREND)     ; Start of arrays
   0FC0 3E                 2458         .db     0x3E            ; Skip 
   0FC1 41 44 44 20 48 4C  2459         .ascii  "ADD HL,DE"                              
        2C 44 45
   0FCA 19            [11] 2460 FNDARY: ADD     HL,DE           ; Move to next array start
   0FCB EB            [ 4] 2461         EX      DE,HL                              
   0FCC 2A 1F 81      [16] 2462         LD      HL,(ARREND)     ; End of arrays
   0FCF EB            [ 4] 2463         EX      DE,HL           ; Current array pointer
   0FD0 CD D1 06      [17] 2464         CALL    CPDEHL          ; End of arrays found?
   0FD3 CA FC 0F      [10] 2465         JP      Z,CREARY        ; Yes - Create array
   0FD6 7E            [ 7] 2466         LD      A,(HL)          ; Get second byte of name
   0FD7 B9            [ 4] 2467         CP      C               ; Compare with name given
   0FD8 23            [ 6] 2468         INC     HL              ; Move on
   0FD9 C2 DE 0F      [10] 2469         JP      NZ,NXTARY       ; Different - Find next array
   0FDC 7E            [ 7] 2470         LD      A,(HL)          ; Get first byte of name
   0FDD B8            [ 4] 2471         CP      B               ; Compare with name given
   0FDE 23            [ 6] 2472 NXTARY: INC     HL              ; Move on
   0FDF 5E            [ 7] 2473         LD      E,(HL)          ; Get LSB of next array address
   0FE0 23            [ 6] 2474         INC     HL                              
   0FE1 56            [ 7] 2475         LD      D,(HL)          ; Get MSB of next array address
   0FE2 23            [ 6] 2476         INC     HL                              
   0FE3 C2 CA 0F      [10] 2477         JP      NZ,FNDARY       ; Not found - Keep looking
   0FE6 3A F1 80      [13] 2478         LD      A,(LCRFLG)      ; Found Locate or Create it?
   0FE9 B7            [ 4] 2479         OR      A                              
   0FEA C2 0E 04      [10] 2480         JP      NZ,DDERR        ; Create - ?DD Error
   0FED F1            [10] 2481         POP     AF              ; Locate - Get number of dim'ns
   0FEE 44            [ 4] 2482         LD      B,H             ; BC Points to array dim'ns
   0FEF 4D            [ 4] 2483         LD      C,L                              
   0FF0 CA 29 16      [10] 2484         JP      Z,POPHRT        ; Jump if array load/save
   0FF3 96            [ 7] 2485         SUB     (HL)            ; Same number of dimensions?
   0FF4 CA 5A 10      [10] 2486         JP      Z,FINDEL        ; Yes - Find element
   0FF7 1E 10         [ 7] 2487 BSERR:  LD      E,BS            ; ?BS Error
   0FF9 C3 2E 04      [10] 2488         JP      ERROR           ; Output error
                           2489 ;
   0FFC 11 04 00      [10] 2490 CREARY: LD      DE,4            ; 4 Bytes per entry
   0FFF F1            [10] 2491         POP     AF              ; Array to save or 0 dim'ns?
   1000 CA 25 09      [10] 2492         JP      Z,FCERR         ; Yes - ?FC Error
   1003 71            [ 7] 2493         LD      (HL),C          ; Save second byte of name
   1004 23            [ 6] 2494         INC     HL                              
   1005 70            [ 7] 2495         LD      (HL),B          ; Save first byte of name
   1006 23            [ 6] 2496         INC     HL                              
   1007 4F            [ 4] 2497         LD      C,A             ; Number of dimensions to C
   1008 CD C6 03      [17] 2498         CALL    CHKSTK          ; Check if enough memory
   100B 23            [ 6] 2499         INC     HL              ; Point to number of dimensions
   100C 23            [ 6] 2500         INC     HL                              
   100D 22 0A 81      [16] 2501         LD      (CUROPR),HL     ; Save address of pointer
   1010 71            [ 7] 2502         LD      (HL),C          ; Set number of dimensions
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 47
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1011 23            [ 6] 2503         INC     HL                              
   1012 3A F1 80      [13] 2504         LD      A,(LCRFLG)      ; Locate of Create?
   1015 17            [ 4] 2505         RLA                     ; Carry set = Create
   1016 79            [ 4] 2506         LD      A,C             ; Get number of dimensions
   1017 01 0B 00      [10] 2507 CRARLP: LD      BC,10+1         ; Default dimension size 10
   101A D2 1F 10      [10] 2508         JP      NC,DEFSIZ       ; Locate - Set default size
   101D C1            [10] 2509         POP     BC              ; Get specified dimension size
   101E 03            [ 6] 2510         INC     BC              ; Include zero element
   101F 71            [ 7] 2511 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
   1020 23            [ 6] 2512         INC     HL                              
   1021 70            [ 7] 2513         LD      (HL),B          ; Save MSB of dimension size
   1022 23            [ 6] 2514         INC     HL                              
   1023 F5            [11] 2515         PUSH    AF              ; Save num' of dim'ns an status
   1024 E5            [11] 2516         PUSH    HL              ; Save address of dim'n size
   1025 CD E1 17      [17] 2517         CALL    MLDEBC          ; Multiply DE by BC to find
   1028 EB            [ 4] 2518         EX      DE,HL           ; amount of mem needed (to DE)
   1029 E1            [10] 2519         POP     HL              ; Restore address of dimension
   102A F1            [10] 2520         POP     AF              ; Restore number of dimensions
   102B 3D            [ 4] 2521         DEC     A               ; Count them
   102C C2 17 10      [10] 2522         JP      NZ,CRARLP       ; Do next dimension if more
   102F F5            [11] 2523         PUSH    AF              ; Save locate/create flag
   1030 42            [ 4] 2524         LD      B,D             ; MSB of memory needed
   1031 4B            [ 4] 2525         LD      C,E             ; LSB of memory needed
   1032 EB            [ 4] 2526         EX      DE,HL                              
   1033 19            [11] 2527         ADD     HL,DE           ; Add bytes to array start
   1034 DA E5 03      [10] 2528         JP      C,OMERR         ; Too big - Error
   1037 CD D6 03      [17] 2529         CALL    ENFMEM          ; See if enough memory
   103A 22 1F 81      [16] 2530         LD      (ARREND),HL     ; Save new end of array
                           2531 ;
   103D 2B            [ 6] 2532 ZERARY: DEC     HL              ; Back through array data
   103E 36 00         [10] 2533         LD      (HL),0          ; Set array element to zero
   1040 CD D1 06      [17] 2534         CALL    CPDEHL          ; All elements zeroed?
   1043 C2 3D 10      [10] 2535         JP      NZ,ZERARY       ; No - Keep on going
   1046 03            [ 6] 2536         INC     BC              ; Number of bytes + 1
   1047 57            [ 4] 2537         LD      D,A             ; A=0
   1048 2A 0A 81      [16] 2538         LD      HL,(CUROPR)     ; Get address of array
   104B 5E            [ 7] 2539         LD      E,(HL)          ; Number of dimensions
   104C EB            [ 4] 2540         EX      DE,HL           ; To HL
   104D 29            [11] 2541         ADD     HL,HL           ; Two bytes per dimension size
   104E 09            [11] 2542         ADD     HL,BC           ; Add number of bytes
   104F EB            [ 4] 2543         EX      DE,HL           ; Bytes needed to DE
   1050 2B            [ 6] 2544         DEC     HL                              
   1051 2B            [ 6] 2545         DEC     HL                              
   1052 73            [ 7] 2546         LD      (HL),E          ; Save LSB of bytes needed
   1053 23            [ 6] 2547         INC     HL                              
   1054 72            [ 7] 2548         LD      (HL),D          ; Save MSB of bytes needed
   1055 23            [ 6] 2549         INC     HL                              
   1056 F1            [10] 2550         POP     AF              ; Locate / Create?
   1057 DA 84 10      [10] 2551         JP      C,ENDDIM        ; A is 0 , End if create
   105A 47            [ 4] 2552 FINDEL: LD      B,A             ; Find array element
   105B 4F            [ 4] 2553         LD      C,A                              
   105C 7E            [ 7] 2554         LD      A,(HL)          ; Number of dimensions
   105D 23            [ 6] 2555         INC     HL                              
   105E 16                 2556         .db     0x16            ; Skip 
   105F 50 4F 50 20 48 4C  2557         .ascii  "POP HL"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 48
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1065 E1            [10] 2558 FNDELP: POP     HL              ; Address of next dim' size
   1066 5E            [ 7] 2559         LD      E,(HL)          ; Get LSB of dim'n size
   1067 23            [ 6] 2560         INC     HL                              
   1068 56            [ 7] 2561         LD      D,(HL)          ; Get MSB of dim'n size
   1069 23            [ 6] 2562         INC     HL                              
   106A E3            [19] 2563         EX      (SP),HL         ; Save address - Get index
   106B F5            [11] 2564         PUSH    AF              ; Save number of dim'ns
   106C CD D1 06      [17] 2565         CALL    CPDEHL          ; Dimension too large?
   106F D2 F7 0F      [10] 2566         JP      NC,BSERR        ; Yes - ?BS Error
   1072 E5            [11] 2567         PUSH    HL              ; Save index
   1073 CD E1 17      [17] 2568         CALL    MLDEBC          ; Multiply previous by size
   1076 D1            [10] 2569         POP     DE              ; Index supplied to DE
   1077 19            [11] 2570         ADD     HL,DE           ; Add index to pointer
   1078 F1            [10] 2571         POP     AF              ; Number of dimensions
   1079 3D            [ 4] 2572         DEC     A               ; Count them
   107A 44            [ 4] 2573         LD      B,H             ; MSB of pointer
   107B 4D            [ 4] 2574         LD      C,L             ; LSB of pointer
   107C C2 65 10      [10] 2575         JP      NZ,FNDELP       ; More - Keep going
   107F 29            [11] 2576         ADD     HL,HL           ; 4 Bytes per element
   1080 29            [11] 2577         ADD     HL,HL                              
   1081 C1            [10] 2578         POP     BC              ; Start of array
   1082 09            [11] 2579         ADD     HL,BC           ; Point to element
   1083 EB            [ 4] 2580         EX      DE,HL           ; Address of element to DE
   1084 2A 15 81      [16] 2581 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
   1087 C9            [10] 2582         RET                                   
                           2583 ;
   1088 2A 1F 81      [16] 2584 FRE:    LD      HL,(ARREND)     ; Start of free memory
   108B EB            [ 4] 2585         EX      DE,HL           ; To DE
   108C 21 00 00      [10] 2586         LD      HL,0            ; End of free memory
   108F 39            [11] 2587         ADD     HL,SP           ; Current stack value
   1090 3A F2 80      [13] 2588         LD      A,(TYPE)        ; Dummy argument type
   1093 B7            [ 4] 2589         OR      A                              
   1094 CA A4 10      [10] 2590         JP      Z,FRENUM        ; Numeric - Free variable space
   1097 CD 0E 13      [17] 2591         CALL    GSTRCU          ; Current string to pool
   109A CD 0E 12      [17] 2592         CALL    GARBGE          ; Garbage collection
   109D 2A 9F 80      [16] 2593         LD      HL,(STRSPC)     ; Bottom of string space in use
   10A0 EB            [ 4] 2594         EX      DE,HL           ; To DE
   10A1 2A 08 81      [16] 2595         LD      HL,(STRBOT)     ; Bottom of string space
   10A4 7D            [ 4] 2596 FRENUM: LD      A,L             ; Get LSB of end
   10A5 93            [ 4] 2597         SUB     E               ; Subtract LSB of beginning
   10A6 4F            [ 4] 2598         LD      C,A             ; Save difference if C
   10A7 7C            [ 4] 2599         LD      A,H             ; Get MSB of end
   10A8 9A            [ 4] 2600         SBC     A,D             ; Subtract MSB of beginning
   10A9 41            [ 4] 2601 ACPASS: LD      B,C             ; Return integer AC
   10AA 50            [ 4] 2602 ABPASS: LD      D,B             ; Return integer AB
   10AB 1E 00         [ 7] 2603         LD      E,0                              
   10AD 21 F2 80      [10] 2604         LD      HL,TYPE         ; Point to type
   10B0 73            [ 7] 2605         LD      (HL),E          ; Set type to numeric
   10B1 06 90         [ 7] 2606         LD      B,0x80+16       ; 16 bit integer
   10B3 C3 0C 17      [10] 2607         JP      RETINT          ; Return the integr
                           2608 ;
   10B6 3A F0 80      [13] 2609 POS:    LD      A,(CURPOS)      ; Get cursor position
   10B9 47            [ 4] 2610 PASSA:  LD      B,A             ; Put A into AB
   10BA AF            [ 4] 2611         XOR     A               ; Zero A
   10BB C3 AA 10      [10] 2612         JP      ABPASS          ; Return integer AB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 49
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                           2613 ;
   10BE CD 43 11      [17] 2614 DEF:    CALL    CHEKFN          ; Get "FN" and name
   10C1 CD 35 11      [17] 2615         CALL    IDTEST          ; Test for illegal direct
   10C4 01 F9 09      [10] 2616         LD      BC,DATA         ; To get next statement
   10C7 C5            [11] 2617         PUSH    BC              ; Save address for RETurn
   10C8 D5            [11] 2618         PUSH    DE              ; Save address of function ptr
   10C9 CD D7 06      [17] 2619         CALL    CHKSYN          ; Make sure "(" follows
   10CC 28                 2620         .ascii  "("                              
   10CD CD CD 0E      [17] 2621         CALL    GETVAR          ; Get argument variable name
   10D0 E5            [11] 2622         PUSH    HL              ; Save code string address
   10D1 EB            [ 4] 2623         EX      DE,HL           ; Argument address to HL
   10D2 2B            [ 6] 2624         DEC     HL                              
   10D3 56            [ 7] 2625         LD      D,(HL)          ; Get first byte of arg name
   10D4 2B            [ 6] 2626         DEC     HL                              
   10D5 5E            [ 7] 2627         LD      E,(HL)          ; Get second byte of arg name
   10D6 E1            [10] 2628         POP     HL              ; Restore code string address
   10D7 CD DF 0C      [17] 2629         CALL    TSTNUM          ; Make sure numeric argument
   10DA CD D7 06      [17] 2630         CALL    CHKSYN          ; Make sure ")" follows
   10DD 29                 2631         .ascii  ")"                              
   10DE CD D7 06      [17] 2632         CALL    CHKSYN          ; Make sure "=" follows
   10E1 B4                 2633         .db     ZEQUAL          ; 
   10E2 3D                 2634         .ascii  "="                              
u  10E3 00                 2635         .db      token                              
   10E4 44            [ 4] 2636         LD      B,H             ; Code string address to BC
   10E5 4D            [ 4] 2637         LD      C,L                              
   10E6 E3            [19] 2638         EX      (SP),HL         ; Save code str , Get FN ptr
   10E7 71            [ 7] 2639         LD      (HL),C          ; Save LSB of FN code string
   10E8 23            [ 6] 2640         INC     HL                              
   10E9 70            [ 7] 2641         LD      (HL),B          ; Save MSB of FN code string
   10EA C3 85 11      [10] 2642         JP      SVSTAD          ; Save address and do function
                           2643 ;
   10ED CD 43 11      [17] 2644 DOFN:   CALL    CHEKFN          ; Make sure FN follows
   10F0 D5            [11] 2645         PUSH    DE              ; Save function pointer address
   10F1 CD A9 0D      [17] 2646         CALL    EVLPAR          ; Evaluate expression in "()"
   10F4 CD DF 0C      [17] 2647         CALL    TSTNUM          ; Make sure numeric result
   10F7 E3            [19] 2648         EX      (SP),HL         ; Save code str , Get FN ptr
   10F8 5E            [ 7] 2649         LD      E,(HL)          ; Get LSB of FN code string
   10F9 23            [ 6] 2650         INC     HL                              
   10FA 56            [ 7] 2651         LD      D,(HL)          ; Get MSB of FN code string
   10FB 23            [ 6] 2652         INC     HL                              
   10FC 7A            [ 4] 2653         LD      A,D             ; And function DEFined?
   10FD B3            [ 4] 2654         OR      E                              
   10FE CA 18 04      [10] 2655         JP      Z,UFERR         ; No - ?UF Error
   1101 7E            [ 7] 2656         LD      A,(HL)          ; Get LSB of argument address
   1102 23            [ 6] 2657         INC     HL                              
   1103 66            [ 7] 2658         LD      H,(HL)          ; Get MSB of argument address
   1104 6F            [ 4] 2659         LD      L,A             ; HL = Arg variable address
   1105 E5            [11] 2660         PUSH    HL              ; Save it
   1106 2A 23 81      [16] 2661         LD      HL,(FNRGNM)     ; Get old argument name
   1109 E3            [19] 2662         EX      (SP),HL         ;	; Save old , Get new
   110A 22 23 81      [16] 2663         LD      (FNRGNM),HL     ; Set new argument name
   110D 2A 27 81      [16] 2664         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
   1110 E5            [11] 2665         PUSH    HL              ; Save it
   1111 2A 25 81      [16] 2666         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
   1114 E5            [11] 2667         PUSH    HL              ; Save it
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 50
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1115 21 25 81      [10] 2668         LD      HL,FNARG        ; HL = Value of argument
   1118 D5            [11] 2669         PUSH    DE              ; Save FN code string address
   1119 CD 4D 17      [17] 2670         CALL    FPTHL           ; Move FPREG to argument
   111C E1            [10] 2671         POP     HL              ; Get FN code string address
   111D CD DC 0C      [17] 2672         CALL    GETNUM          ; Get value from function
   1120 2B            [ 6] 2673         DEC     HL              ; DEC 'cos GETCHR INCs
   1121 CD 5C 08      [17] 2674         CALL    GETCHR          ; Get next character
   1124 C2 F0 03      [10] 2675         JP      NZ,SNERR        ; Bad character in FN - Error
   1127 E1            [10] 2676         POP     HL              ; Get MSB,EXP of old arg
   1128 22 25 81      [16] 2677         LD      (FNARG),HL      ; Restore it
   112B E1            [10] 2678         POP     HL              ; Get LSB,NLSB of old arg
   112C 22 27 81      [16] 2679         LD      (FNARG+2),HL    ; Restore it
   112F E1            [10] 2680         POP     HL              ; Get name of old arg
   1130 22 23 81      [16] 2681         LD      (FNRGNM),HL     ; Restore it
   1133 E1            [10] 2682         POP     HL              ; Restore code string address
   1134 C9            [10] 2683         RET                                   
                           2684 ;
   1135 E5            [11] 2685 IDTEST: PUSH    HL              ; Save code string address
   1136 2A A1 80      [16] 2686         LD      HL,(LINEAT)     ; Get current line number
   1139 23            [ 6] 2687         INC     HL              ; -1 means direct statement
   113A 7C            [ 4] 2688         LD      A,H                              
   113B B5            [ 4] 2689         OR      L                              
   113C E1            [10] 2690         POP     HL              ; Restore code string address
   113D C0            [11] 2691         RET     NZ              ; Return if in program
   113E 1E 16         [ 7] 2692         LD      E,ID            ; ?ID Error
   1140 C3 2E 04      [10] 2693         JP      ERROR                              
                           2694 ;
   1143 CD D7 06      [17] 2695 CHEKFN: CALL    CHKSYN          ; Make sure FN follows
   1146 A7                 2696         .db     ZFN             ; 
   1147 46 4E              2697         .ascii  "FN"                              
u  1149 00                 2698         .db      token                              
   114A 3E 80         [ 7] 2699         LD      A,0x80                              
   114C 32 10 81      [13] 2700         LD      (FORFLG),A      ; Flag FN name to find
   114F B6            [ 7] 2701         OR      (HL)            ; FN name has bit 7 set
   1150 47            [ 4] 2702         LD      B,A             ; in first byte of name
   1151 CD D2 0E      [17] 2703         CALL    GTFNAM          ; Get FN name
   1154 C3 DF 0C      [10] 2704         JP      TSTNUM          ; Make sure numeric function
                           2705 ;
   1157 CD DF 0C      [17] 2706 STR:    CALL    TSTNUM          ; Make sure it's a number
   115A CD 8E 18      [17] 2707         CALL    NUMASC          ; Turn number into text
   115D CD 8B 11      [17] 2708 STR1:   CALL    CRTST           ; Create string entry for it
   1160 CD 0E 13      [17] 2709         CALL    GSTRCU          ; Current string to pool
   1163 01 69 13      [10] 2710         LD      BC,TOPOOL       ; Save in string pool
   1166 C5            [11] 2711         PUSH    BC              ; Save address on stack
                           2712 ;
   1167 7E            [ 7] 2713 SAVSTR: LD      A,(HL)          ; Get string length
   1168 23            [ 6] 2714         INC     HL                              
   1169 23            [ 6] 2715         INC     HL                              
   116A E5            [11] 2716         PUSH    HL              ; Save pointer to string
   116B CD E4 11      [17] 2717         CALL    TESTR           ; See if enough string space
   116E E1            [10] 2718         POP     HL              ; Restore pointer to string
   116F 4E            [ 7] 2719         LD      C,(HL)          ; Get LSB of address
   1170 23            [ 6] 2720         INC     HL                              
   1171 46            [ 7] 2721         LD      B,(HL)          ; Get MSB of address
   1172 CD 7F 11      [17] 2722         CALL    CRTMST          ; Create string entry
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 51
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1175 E5            [11] 2723         PUSH    HL              ; Save pointer to MSB of addr
   1176 6F            [ 4] 2724         LD      L,A             ; Length of string
   1177 CD 01 13      [17] 2725         CALL    TOSTRA          ; Move to string area
   117A D1            [10] 2726         POP     DE              ; Restore pointer to MSB
   117B C9            [10] 2727         RET                                   
                           2728 ;
   117C CD E4 11      [17] 2729 MKTMST: CALL    TESTR           ; See if enough string space
   117F 21 04 81      [10] 2730 CRTMST: LD      HL,TMPSTR       ; Temporary string
   1182 E5            [11] 2731         PUSH    HL              ; Save it
   1183 77            [ 7] 2732         LD      (HL),A          ; Save length of string
   1184 23            [ 6] 2733         INC     HL                              
   1185 23            [ 6] 2734 SVSTAD: INC     HL                              
   1186 73            [ 7] 2735         LD      (HL),E          ; Save LSB of address
   1187 23            [ 6] 2736         INC     HL                              
   1188 72            [ 7] 2737         LD      (HL),D          ; Save MSB of address
   1189 E1            [10] 2738         POP     HL              ; Restore pointer
   118A C9            [10] 2739         RET                                   
                           2740 ;
   118B 2B            [ 6] 2741 CRTST:  DEC     HL              ; DEC - INCed after
q  118C 06 22         [ 7] 2742 QTSTR:  LD      B,'"'           ; Terminating quote
   118E 50            [ 4] 2743         LD      D,B             ; Quote to D
   118F E5            [11] 2744 DTSTR:  PUSH    HL              ; Save start
   1190 0E FF         [ 7] 2745         LD      C,-1            ; Set counter to -1
   1192 23            [ 6] 2746 QTSTLP: INC     HL              ; Move on
   1193 7E            [ 7] 2747         LD      A,(HL)          ; Get byte
   1194 0C            [ 4] 2748         INC     C               ; Count bytes
   1195 B7            [ 4] 2749         OR      A               ; End of line?
   1196 CA A1 11      [10] 2750         JP      Z,CRTSTE        ; Yes - Create string entry
   1199 BA            [ 4] 2751         CP      D               ; Terminator D found?
   119A CA A1 11      [10] 2752         JP      Z,CRTSTE        ; Yes - Create string entry
   119D B8            [ 4] 2753         CP      B               ; Terminator B found?
   119E C2 92 11      [10] 2754         JP      NZ,QTSTLP       ; No - Keep looking
q  11A1                    2755 CRTSTE: CP      '"'             ; End with '"'?
   11A1 CC 5C 08      [17] 2756         CALL    Z,GETCHR        ; Yes - Get next character
   11A4 E3            [19] 2757         EX      (SP),HL         ; Starting quote
   11A5 23            [ 6] 2758         INC     HL              ; First byte of string
   11A6 EB            [ 4] 2759         EX      DE,HL           ; To DE
   11A7 79            [ 4] 2760         LD      A,C             ; Get length
   11A8 CD 7F 11      [17] 2761         CALL    CRTMST          ; Create string entry
   11AB 11 04 81      [10] 2762 TSTOPL: LD      DE,TMPSTR       ; Temporary string
   11AE 2A F6 80      [16] 2763         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   11B1 22 29 81      [16] 2764         LD      (FPREG),HL      ; Save address of string ptr
   11B4 3E 01         [ 7] 2765         LD      A,1                              
   11B6 32 F2 80      [13] 2766         LD      (TYPE),A        ; Set type to string
   11B9 CD 50 17      [17] 2767         CALL    DETHL4          ; Move string to pool
   11BC CD D1 06      [17] 2768         CALL    CPDEHL          ; Out of string pool?
   11BF 22 F6 80      [16] 2769         LD      (TMSTPT),HL     ; Save new pointer
   11C2 E1            [10] 2770         POP     HL              ; Restore code string address
   11C3 7E            [ 7] 2771         LD      A,(HL)          ; Get next code byte
   11C4 C0            [11] 2772         RET     NZ              ; Return if pool OK
   11C5 1E 1E         [ 7] 2773         LD      E,ST            ; ?ST Error
   11C7 C3 2E 04      [10] 2774         JP      ERROR           ; String pool overflow
                           2775 ;
   11CA 23            [ 6] 2776 PRNUMS: INC     HL              ; Skip leading space
   11CB CD 8B 11      [17] 2777 PRS:    CALL    CRTST           ; Create string entry for it
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 52
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   11CE CD 0E 13      [17] 2778 PRS1:   CALL    GSTRCU          ; Current string to pool
   11D1 CD 44 17      [17] 2779         CALL    LOADFP          ; Move string block to BCDE
   11D4 1C            [ 4] 2780         INC     E               ; Length + 1
   11D5 1D            [ 4] 2781 PRSLP:  DEC     E               ; Count characters
   11D6 C8            [11] 2782         RET     Z               ; End of string
   11D7 0A            [ 7] 2783         LD      A,(BC)          ; Get byte to output
   11D8 CD E2 06      [17] 2784         CALL    OUTC            ; Output character in A
   11DB FE 0D         [ 7] 2785         CP      CR              ; Return?
   11DD CC 20 0B      [17] 2786         CALL    Z,DONULL        ; Yes - Do nulls
   11E0 03            [ 6] 2787         INC     BC              ; Next byte in string
   11E1 C3 D5 11      [10] 2788         JP      PRSLP           ; More characters to output
                           2789 ;
   11E4 B7            [ 4] 2790 TESTR:  OR      A               ; Test if enough room
   11E5 0E                 2791         .db     0x0E            ; No garbage collection done
   11E6 F1            [10] 2792 GRBDON: POP     AF              ; Garbage collection done
   11E7 F5            [11] 2793         PUSH    AF              ; Save status
   11E8 2A 9F 80      [16] 2794         LD      HL,(STRSPC)     ; Bottom of string space in use
   11EB EB            [ 4] 2795         EX      DE,HL           ; To DE
   11EC 2A 08 81      [16] 2796         LD      HL,(STRBOT)     ; Bottom of string area
   11EF 2F            [ 4] 2797         CPL                     ; Negate length (Top down)
   11F0 4F            [ 4] 2798         LD      C,A             ; -Length to BC
   11F1 06 FF         [ 7] 2799         LD      B,-1            ; BC = -ve length of string
   11F3 09            [11] 2800         ADD     HL,BC           ; Add to bottom of space in use
   11F4 23            [ 6] 2801         INC     HL              ; Plus one for 2's complement
   11F5 CD D1 06      [17] 2802         CALL    CPDEHL          ; Below string RAM area?
   11F8 DA 02 12      [10] 2803         JP      C,TESTOS        ; Tidy up if not done else err
   11FB 22 08 81      [16] 2804         LD      (STRBOT),HL     ; Save new bottom of area
   11FE 23            [ 6] 2805         INC     HL              ; Point to first byte of string
   11FF EB            [ 4] 2806         EX      DE,HL           ; Address to DE
   1200 F1            [10] 2807 POPAF:  POP     AF              ; Throw away status push
   1201 C9            [10] 2808         RET                                   
                           2809 ;
   1202 F1            [10] 2810 TESTOS: POP     AF              ; Garbage collect been done?
   1203 1E 1A         [ 7] 2811         LD      E,OS            ; ?OS Error
   1205 CA 2E 04      [10] 2812         JP      Z,ERROR         ; Yes - Not enough string apace
   1208 BF            [ 4] 2813         CP      A               ; Flag garbage collect done
   1209 F5            [11] 2814         PUSH    AF              ; Save status
   120A 01 E6 11      [10] 2815         LD      BC,GRBDON       ; Garbage collection done
   120D C5            [11] 2816         PUSH    BC              ; Save for RETurn
   120E 2A F4 80      [16] 2817 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
   1211 22 08 81      [16] 2818 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
   1214 21 00 00      [10] 2819         LD      HL,0                              
   1217 E5            [11] 2820         PUSH    HL              ; Flag no string found
   1218 2A 9F 80      [16] 2821         LD      HL,(STRSPC)     ; Get bottom of string space
   121B E5            [11] 2822         PUSH    HL              ; Save bottom of string space
   121C 21 F8 80      [10] 2823         LD      HL,TMSTPL       ; Temporary string pool
   121F EB            [ 4] 2824 GRBLP:  EX      DE,HL                              
   1220 2A F6 80      [16] 2825         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   1223 EB            [ 4] 2826         EX      DE,HL                              
   1224 CD D1 06      [17] 2827         CALL    CPDEHL          ; Temporary string pool done?
   1227 01 1F 12      [10] 2828         LD      BC,GRBLP        ; Loop until string pool done
   122A C2 73 12      [10] 2829         JP      NZ,STPOOL       ; No - See if in string area
   122D 2A 1B 81      [16] 2830         LD      HL,(PROGND)     ; Start of simple variables
   1230 EB            [ 4] 2831 SMPVAR: EX      DE,HL                              
   1231 2A 1D 81      [16] 2832         LD      HL,(VAREND)     ; End of simple variables
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 53
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1234 EB            [ 4] 2833         EX      DE,HL                              
   1235 CD D1 06      [17] 2834         CALL    CPDEHL          ; All simple strings done?
   1238 CA 46 12      [10] 2835         JP      Z,ARRLP         ; Yes - Do string arrays
   123B 7E            [ 7] 2836         LD      A,(HL)          ; Get type of variable
   123C 23            [ 6] 2837         INC     HL                              
   123D 23            [ 6] 2838         INC     HL                              
   123E B7            [ 4] 2839         OR      A               ; "S" flag set if string
   123F CD 76 12      [17] 2840         CALL    STRADD          ; See if string in string area
   1242 C3 30 12      [10] 2841         JP      SMPVAR          ; Loop until simple ones done
                           2842 ;
   1245 C1            [10] 2843 GNXARY: POP     BC              ; Scrap address of this array
   1246 EB            [ 4] 2844 ARRLP:  EX      DE,HL                              
   1247 2A 1F 81      [16] 2845         LD      HL,(ARREND)     ; End of string arrays
   124A EB            [ 4] 2846         EX      DE,HL                              
   124B CD D1 06      [17] 2847         CALL    CPDEHL          ; All string arrays done?
   124E CA 9C 12      [10] 2848         JP      Z,SCNEND        ; Yes - Move string if found
   1251 CD 44 17      [17] 2849         CALL    LOADFP          ; Get array name to BCDE
   1254 7B            [ 4] 2850         LD      A,E             ; Get type of array	
   1255 E5            [11] 2851         PUSH    HL              ; Save address of num of dim'ns
   1256 09            [11] 2852         ADD     HL,BC           ; Start of next array
   1257 B7            [ 4] 2853         OR      A               ; Test type of array
   1258 F2 45 12      [10] 2854         JP      P,GNXARY        ; Numeric array - Ignore it
   125B 22 0A 81      [16] 2855         LD      (CUROPR),HL     ; Save address of next array
   125E E1            [10] 2856         POP     HL              ; Get address of num of dim'ns
   125F 4E            [ 7] 2857         LD      C,(HL)          ; BC = Number of dimensions
   1260 06 00         [ 7] 2858         LD      B,0                              
   1262 09            [11] 2859         ADD     HL,BC           ; Two bytes per dimension size
   1263 09            [11] 2860         ADD     HL,BC                              
   1264 23            [ 6] 2861         INC     HL              ; Plus one for number of dim'ns
   1265 EB            [ 4] 2862 GRBARY: EX      DE,HL                              
   1266 2A 0A 81      [16] 2863         LD      HL,(CUROPR)     ; Get address of next array
   1269 EB            [ 4] 2864         EX      DE,HL                              
   126A CD D1 06      [17] 2865         CALL    CPDEHL          ; Is this array finished?
   126D CA 46 12      [10] 2866         JP      Z,ARRLP         ; Yes - Get next one
   1270 01 65 12      [10] 2867         LD      BC,GRBARY       ; Loop until array all done
   1273 C5            [11] 2868 STPOOL: PUSH    BC              ; Save return address
   1274 F6 80         [ 7] 2869         OR      0x80            ; Flag string type
   1276 7E            [ 7] 2870 STRADD: LD      A,(HL)          ; Get string length
   1277 23            [ 6] 2871         INC     HL                              
   1278 23            [ 6] 2872         INC     HL                              
   1279 5E            [ 7] 2873         LD      E,(HL)          ; Get LSB of string address
   127A 23            [ 6] 2874         INC     HL                              
   127B 56            [ 7] 2875         LD      D,(HL)          ; Get MSB of string address
   127C 23            [ 6] 2876         INC     HL                              
   127D F0            [11] 2877         RET     P               ; Not a string - Return
   127E B7            [ 4] 2878         OR      A               ; Set flags on string length
   127F C8            [11] 2879         RET     Z               ; Null string - Return
   1280 44            [ 4] 2880         LD      B,H             ; Save variable pointer
   1281 4D            [ 4] 2881         LD      C,L                              
   1282 2A 08 81      [16] 2882         LD      HL,(STRBOT)     ; Bottom of new area
   1285 CD D1 06      [17] 2883         CALL    CPDEHL          ; String been done?
   1288 60            [ 4] 2884         LD      H,B             ; Restore variable pointer
   1289 69            [ 4] 2885         LD      L,C                              
   128A D8            [11] 2886         RET     C               ; String done - Ignore
   128B E1            [10] 2887         POP     HL              ; Return address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 54
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   128C E3            [19] 2888         EX      (SP),HL         ; Lowest available string area
   128D CD D1 06      [17] 2889         CALL    CPDEHL          ; String within string area?
   1290 E3            [19] 2890         EX      (SP),HL         ; Lowest available string area
   1291 E5            [11] 2891         PUSH    HL              ; Re-save return address
   1292 60            [ 4] 2892         LD      H,B             ; Restore variable pointer
   1293 69            [ 4] 2893         LD      L,C                              
   1294 D0            [11] 2894         RET     NC              ; Outside string area - Ignore
   1295 C1            [10] 2895         POP     BC              ; Get return , Throw 2 away
   1296 F1            [10] 2896         POP     AF              ; 
   1297 F1            [10] 2897         POP     AF              ; 
   1298 E5            [11] 2898         PUSH    HL              ; Save variable pointer
   1299 D5            [11] 2899         PUSH    DE              ; Save address of current
   129A C5            [11] 2900         PUSH    BC              ; Put back return address
   129B C9            [10] 2901         RET                     ; Go to it
                           2902 ;
   129C D1            [10] 2903 SCNEND: POP     DE              ; Addresses of strings
   129D E1            [10] 2904         POP     HL              ; 
   129E 7D            [ 4] 2905         LD      A,L             ; HL = 0 if no more to do
   129F B4            [ 4] 2906         OR      H                              
   12A0 C8            [11] 2907         RET     Z               ; No more to do - Return
   12A1 2B            [ 6] 2908         DEC     HL                              
   12A2 46            [ 7] 2909         LD      B,(HL)          ; MSB of address of string
   12A3 2B            [ 6] 2910         DEC     HL                              
   12A4 4E            [ 7] 2911         LD      C,(HL)          ; LSB of address of string
   12A5 E5            [11] 2912         PUSH    HL              ; Save variable address
   12A6 2B            [ 6] 2913         DEC     HL                              
   12A7 2B            [ 6] 2914         DEC     HL                              
   12A8 6E            [ 7] 2915         LD      L,(HL)          ; HL = Length of string
   12A9 26 00         [ 7] 2916         LD      H,0                              
   12AB 09            [11] 2917         ADD     HL,BC           ; Address of end of string+1
   12AC 50            [ 4] 2918         LD      D,B             ; String address to DE
   12AD 59            [ 4] 2919         LD      E,C                              
   12AE 2B            [ 6] 2920         DEC     HL              ; Last byte in string
   12AF 44            [ 4] 2921         LD      B,H             ; Address to BC
   12B0 4D            [ 4] 2922         LD      C,L                              
   12B1 2A 08 81      [16] 2923         LD      HL,(STRBOT)     ; Current bottom of string area
   12B4 CD B8 03      [17] 2924         CALL    MOVSTR          ; Move string to new address
   12B7 E1            [10] 2925         POP     HL              ; Restore variable address
   12B8 71            [ 7] 2926         LD      (HL),C          ; Save new LSB of address
   12B9 23            [ 6] 2927         INC     HL                              
   12BA 70            [ 7] 2928         LD      (HL),B          ; Save new MSB of address
   12BB 69            [ 4] 2929         LD      L,C             ; Next string area+1 to HL
   12BC 60            [ 4] 2930         LD      H,B                              
   12BD 2B            [ 6] 2931         DEC     HL              ; Next string area address
   12BE C3 11 12      [10] 2932         JP      GARBLP          ; Look for more strings
                           2933 ;
   12C1 C5            [11] 2934 CONCAT: PUSH    BC              ; Save prec' opr & code string
   12C2 E5            [11] 2935         PUSH    HL              ; 
   12C3 2A 29 81      [16] 2936         LD      HL,(FPREG)      ; Get first string
   12C6 E3            [19] 2937         EX      (SP),HL         ; Save first string
   12C7 CD 65 0D      [17] 2938         CALL    OPRND           ; Get second string
   12CA E3            [19] 2939         EX      (SP),HL         ; Restore first string
   12CB CD E0 0C      [17] 2940         CALL    TSTSTR          ; Make sure it's a string
   12CE 7E            [ 7] 2941         LD      A,(HL)          ; Get length of second string
   12CF E5            [11] 2942         PUSH    HL              ; Save first string
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 55
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   12D0 2A 29 81      [16] 2943         LD      HL,(FPREG)      ; Get second string
   12D3 E5            [11] 2944         PUSH    HL              ; Save second string
   12D4 86            [ 7] 2945         ADD     A,(HL)          ; Add length of second string
   12D5 1E 1C         [ 7] 2946         LD      E,LS            ; ?LS Error
   12D7 DA 2E 04      [10] 2947         JP      C,ERROR         ; String too long - Error
   12DA CD 7C 11      [17] 2948         CALL    MKTMST          ; Make temporary string
   12DD D1            [10] 2949         POP     DE              ; Get second string to DE
   12DE CD 12 13      [17] 2950         CALL    GSTRDE          ; Move to string pool if needed
   12E1 E3            [19] 2951         EX      (SP),HL         ; Get first string
   12E2 CD 11 13      [17] 2952         CALL    GSTRHL          ; Move to string pool if needed
   12E5 E5            [11] 2953         PUSH    HL              ; Save first string
   12E6 2A 06 81      [16] 2954         LD      HL,(TMPSTR+2)   ; Temporary string address
   12E9 EB            [ 4] 2955         EX      DE,HL           ; To DE
   12EA CD F8 12      [17] 2956         CALL    SSTSA           ; First string to string area
   12ED CD F8 12      [17] 2957         CALL    SSTSA           ; Second string to string area
   12F0 21 FA 0C      [10] 2958         LD      HL,EVAL2        ; Return to evaluation loop
   12F3 E3            [19] 2959         EX      (SP),HL         ; Save return,get code string
   12F4 E5            [11] 2960         PUSH    HL              ; Save code string address
   12F5 C3 AB 11      [10] 2961         JP      TSTOPL          ; To temporary string to pool
                           2962 ;
   12F8 E1            [10] 2963 SSTSA:  POP     HL              ; Return address
   12F9 E3            [19] 2964         EX      (SP),HL         ; Get string block,save return
   12FA 7E            [ 7] 2965         LD      A,(HL)          ; Get length of string
   12FB 23            [ 6] 2966         INC     HL                              
   12FC 23            [ 6] 2967         INC     HL                              
   12FD 4E            [ 7] 2968         LD      C,(HL)          ; Get LSB of string address
   12FE 23            [ 6] 2969         INC     HL                              
   12FF 46            [ 7] 2970         LD      B,(HL)          ; Get MSB of string address
   1300 6F            [ 4] 2971         LD      L,A             ; Length to L
   1301 2C            [ 4] 2972 TOSTRA: INC     L               ; INC - DECed after
   1302 2D            [ 4] 2973 TSALP:  DEC     L               ; Count bytes moved
   1303 C8            [11] 2974         RET     Z               ; End of string - Return
   1304 0A            [ 7] 2975         LD      A,(BC)          ; Get source
   1305 12            [ 7] 2976         LD      (DE),A          ; Save destination
   1306 03            [ 6] 2977         INC     BC              ; Next source
   1307 13            [ 6] 2978         INC     DE              ; Next destination
   1308 C3 02 13      [10] 2979         JP      TSALP           ; Loop until string moved
                           2980 ;
   130B CD E0 0C      [17] 2981 GETSTR: CALL    TSTSTR          ; Make sure it's a string
   130E 2A 29 81      [16] 2982 GSTRCU: LD      HL,(FPREG)      ; Get current string
   1311 EB            [ 4] 2983 GSTRHL: EX      DE,HL           ; Save DE
   1312 CD 2C 13      [17] 2984 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
   1315 EB            [ 4] 2985         EX      DE,HL           ; Restore DE
   1316 C0            [11] 2986         RET     NZ              ; No - Return
   1317 D5            [11] 2987         PUSH    DE              ; Save string
   1318 50            [ 4] 2988         LD      D,B             ; String block address to DE
   1319 59            [ 4] 2989         LD      E,C                              
   131A 1B            [ 6] 2990         DEC     DE              ; Point to length
   131B 4E            [ 7] 2991         LD      C,(HL)          ; Get string length
   131C 2A 08 81      [16] 2992         LD      HL,(STRBOT)     ; Current bottom of string area
   131F CD D1 06      [17] 2993         CALL    CPDEHL          ; Last one in string area?
   1322 C2 2A 13      [10] 2994         JP      NZ,POPHL        ; No - Return
   1325 47            [ 4] 2995         LD      B,A             ; Clear B (A=0)
   1326 09            [11] 2996         ADD     HL,BC           ; Remove string from str' area
   1327 22 08 81      [16] 2997         LD      (STRBOT),HL     ; Save new bottom of str' area
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 56
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   132A E1            [10] 2998 POPHL:  POP     HL              ; Restore string
   132B C9            [10] 2999         RET                                   
                           3000 ;
   132C 2A F6 80      [16] 3001 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
   132F 2B            [ 6] 3002         DEC     HL              ; Back
   1330 46            [ 7] 3003         LD      B,(HL)          ; Get MSB of address
   1331 2B            [ 6] 3004         DEC     HL              ; Back
   1332 4E            [ 7] 3005         LD      C,(HL)          ; Get LSB of address
   1333 2B            [ 6] 3006         DEC     HL              ; Back
   1334 2B            [ 6] 3007         DEC     HL              ; Back
   1335 CD D1 06      [17] 3008         CALL    CPDEHL          ; String last in string pool?
   1338 C0            [11] 3009         RET     NZ              ; Yes - Leave it
   1339 22 F6 80      [16] 3010         LD      (TMSTPT),HL     ; Save new string pool top
   133C C9            [10] 3011         RET                                   
                           3012 ;
   133D 01 B9 10      [10] 3013 LEN:    LD      BC,PASSA        ; To return integer A
   1340 C5            [11] 3014         PUSH    BC              ; Save address
   1341 CD 0B 13      [17] 3015 GETLEN: CALL    GETSTR          ; Get string and its length
   1344 AF            [ 4] 3016         XOR     A                              
   1345 57            [ 4] 3017         LD      D,A             ; Clear D
   1346 32 F2 80      [13] 3018         LD      (TYPE),A        ; Set type to numeric
   1349 7E            [ 7] 3019         LD      A,(HL)          ; Get length of string
   134A B7            [ 4] 3020         OR      A               ; Set status flags
   134B C9            [10] 3021         RET                                   
                           3022 ;
   134C 01 B9 10      [10] 3023 ASC:    LD      BC,PASSA        ; To return integer A
   134F C5            [11] 3024         PUSH    BC              ; Save address
   1350 CD 41 13      [17] 3025 GTFLNM: CALL    GETLEN          ; Get length of string
   1353 CA 25 09      [10] 3026         JP      Z,FCERR         ; Null string - Error
   1356 23            [ 6] 3027         INC     HL                              
   1357 23            [ 6] 3028         INC     HL                              
   1358 5E            [ 7] 3029         LD      E,(HL)          ; Get LSB of address
   1359 23            [ 6] 3030         INC     HL                              
   135A 56            [ 7] 3031         LD      D,(HL)          ; Get MSB of address
   135B 1A            [ 7] 3032         LD      A,(DE)          ; Get first byte of string
   135C C9            [10] 3033         RET                                   
                           3034 ;
   135D 3E 01         [ 7] 3035 CHR:    LD      A,1             ; One character string
   135F CD 7C 11      [17] 3036         CALL    MKTMST          ; Make a temporary string
   1362 CD 56 14      [17] 3037         CALL    MAKINT          ; Make it integer A
   1365 2A 06 81      [16] 3038         LD      HL,(TMPSTR+2)   ; Get address of string
   1368 73            [ 7] 3039         LD      (HL),E          ; Save character
   1369 C1            [10] 3040 TOPOOL: POP     BC              ; Clean up stack
   136A C3 AB 11      [10] 3041         JP      TSTOPL          ; Temporary string to pool
                           3042 ;
   136D CD 06 14      [17] 3043 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
   1370 AF            [ 4] 3044         XOR     A               ; Start at first byte in string
   1371 E3            [19] 3045 RIGHT1: EX      (SP),HL         ; Save code string,Get string
   1372 4F            [ 4] 3046         LD      C,A             ; Starting position in string
   1373 E5            [11] 3047 MID1:   PUSH    HL              ; Save string block address
   1374 7E            [ 7] 3048         LD      A,(HL)          ; Get length of string
   1375 B8            [ 4] 3049         CP      B               ; Compare with number given
   1376 DA 81 13      [10] 3050         JP      C,ALLFOL        ; All following bytes required
   1379 78            [ 4] 3051         LD      A,B             ; Get new length
   137A 11                 3052         .db     0x11            ; Skip 
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 57
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   137B 4C 44 20 43 2C 30  3053         .ascii  "LD C,0"                              
   1381 0E 00         [ 7] 3054 ALLFOL: LD      C,0             ; First byte of string
   1383 C5            [11] 3055         PUSH    BC              ; Save position in string
   1384 CD E4 11      [17] 3056         CALL    TESTR           ; See if enough string space
   1387 C1            [10] 3057         POP     BC              ; Get position in string
   1388 E1            [10] 3058         POP     HL              ; Restore string block address
   1389 E5            [11] 3059         PUSH    HL              ; And re-save it
   138A 23            [ 6] 3060         INC     HL                              
   138B 23            [ 6] 3061         INC     HL                              
   138C 46            [ 7] 3062         LD      B,(HL)          ; Get LSB of address
   138D 23            [ 6] 3063         INC     HL                              
   138E 66            [ 7] 3064         LD      H,(HL)          ; Get MSB of address
   138F 68            [ 4] 3065         LD      L,B             ; HL = address of string
   1390 06 00         [ 7] 3066         LD      B,0             ; BC = starting address
   1392 09            [11] 3067         ADD     HL,BC           ; Point to that byte
   1393 44            [ 4] 3068         LD      B,H             ; BC = source string
   1394 4D            [ 4] 3069         LD      C,L                              
   1395 CD 7F 11      [17] 3070         CALL    CRTMST          ; Create a string entry
   1398 6F            [ 4] 3071         LD      L,A             ; Length of new string
   1399 CD 01 13      [17] 3072         CALL    TOSTRA          ; Move string to string area
   139C D1            [10] 3073         POP     DE              ; Clear stack
   139D CD 12 13      [17] 3074         CALL    GSTRDE          ; Move to string pool if needed
   13A0 C3 AB 11      [10] 3075         JP      TSTOPL          ; Temporary string to pool
                           3076 ;
   13A3 CD 06 14      [17] 3077 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
   13A6 D1            [10] 3078         POP     DE              ; Get string length
   13A7 D5            [11] 3079         PUSH    DE              ; And re-save
   13A8 1A            [ 7] 3080         LD      A,(DE)          ; Get length
   13A9 90            [ 4] 3081         SUB     B               ; Move back N bytes
   13AA C3 71 13      [10] 3082         JP      RIGHT1          ; Go and get sub-string
                           3083 ;
   13AD EB            [ 4] 3084 MID:    EX      DE,HL           ; Get code string address
   13AE 7E            [ 7] 3085         LD      A,(HL)          ; Get next byte ',' or ")"
   13AF CD 0B 14      [17] 3086         CALL    MIDNUM          ; Get number supplied
   13B2 04            [ 4] 3087         INC     B               ; Is it character zero?
   13B3 05            [ 4] 3088         DEC     B                              
   13B4 CA 25 09      [10] 3089         JP      Z,FCERR         ; Yes - Error
   13B7 C5            [11] 3090         PUSH    BC              ; Save starting position
   13B8 1E FF         [ 7] 3091         LD      E,255           ; All of string
q  13BA                    3092         CP      ')'             ; Any length given?
   13BA CA C4 13      [10] 3093         JP      Z,RSTSTR        ; No - Rest of string
   13BD CD D7 06      [17] 3094         CALL    CHKSYN          ; Make sure ',' follows
q  13C0 2C                 3095         .db     ','                              
   13C1 CD 53 14      [17] 3096         CALL    GETINT          ; Get integer 0-255
   13C4 CD D7 06      [17] 3097 RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
   13C7 29                 3098         .ascii  ")"                              
   13C8 F1            [10] 3099         POP     AF              ; Restore starting position
   13C9 E3            [19] 3100         EX      (SP),HL         ; Get string,8ave code string
   13CA 01 73 13      [10] 3101         LD      BC,MID1         ; Continuation of MID$ routine
   13CD C5            [11] 3102         PUSH    BC              ; Save for return
   13CE 3D            [ 4] 3103         DEC     A               ; Starting position-1
   13CF BE            [ 7] 3104         CP      (HL)            ; Compare with length
   13D0 06 00         [ 7] 3105         LD      B,0             ; Zero bytes length
   13D2 D0            [11] 3106         RET     NC              ; Null string if start past end
   13D3 4F            [ 4] 3107         LD      C,A             ; Save starting position-1
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 58
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   13D4 7E            [ 7] 3108         LD      A,(HL)          ; Get length of string
   13D5 91            [ 4] 3109         SUB     C               ; Subtract start
   13D6 BB            [ 4] 3110         CP      E               ; Enough string for it?
   13D7 47            [ 4] 3111         LD      B,A             ; Save maximum length available
   13D8 D8            [11] 3112         RET     C               ; Truncate string if needed
   13D9 43            [ 4] 3113         LD      B,E             ; Set specified length
   13DA C9            [10] 3114         RET                     ; Go and create string
                           3115 ;
   13DB CD 41 13      [17] 3116 VAL:    CALL    GETLEN          ; Get length of string
   13DE CA 01 15      [10] 3117         JP      Z,RESZER        ; Result zero
   13E1 5F            [ 4] 3118         LD      E,A             ; Save length
   13E2 23            [ 6] 3119         INC     HL                              
   13E3 23            [ 6] 3120         INC     HL                              
   13E4 7E            [ 7] 3121         LD      A,(HL)          ; Get LSB of address
   13E5 23            [ 6] 3122         INC     HL                              
   13E6 66            [ 7] 3123         LD      H,(HL)          ; Get MSB of address
   13E7 6F            [ 4] 3124         LD      L,A             ; HL = String address
   13E8 E5            [11] 3125         PUSH    HL              ; Save string address
   13E9 19            [11] 3126         ADD     HL,DE                              
   13EA 46            [ 7] 3127         LD      B,(HL)          ; Get end of string+1 byte
   13EB 72            [ 7] 3128         LD      (HL),D          ; Zero it to terminate
   13EC E3            [19] 3129         EX      (SP),HL         ; Save string end,get start
   13ED C5            [11] 3130         PUSH    BC              ; Save end+1 byte
   13EE 7E            [ 7] 3131         LD      A,(HL)          ; Get starting byte
q  13EF                    3132         CP      '$'             ; Hex number indicated? [function added]
   13EF C2 F7 13      [10] 3133         JP      NZ,VAL1                              
u  13F2 CD 00 00      [17] 3134         CALL    HEXTFP          ; Convert Hex to FPREG
   13F5 18 0B         [12] 3135         JR      VAL3                              
q  13F7                    3136 VAL1:   CP      '%'             ; Binary number indicated? [function added]
   13F7 C2 FF 13      [10] 3137         JP      NZ,VAL2                              
   13FA CD 6E 1C      [17] 3138         CALL    BINTFP          ; Convert Bin to FPREG
   13FD 18 03         [12] 3139         JR      VAL3                              
   13FF CD FC 17      [17] 3140 VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
   1402 C1            [10] 3141 VAL3:   POP     BC              ; Restore end+1 byte
   1403 E1            [10] 3142         POP     HL              ; Restore end+1 address
   1404 70            [ 7] 3143         LD      (HL),B          ; Put back original byte
   1405 C9            [10] 3144         RET                                   
                           3145 ;
   1406 EB            [ 4] 3146 LFRGNM: EX      DE,HL           ; Code string address to HL
   1407 CD D7 06      [17] 3147         CALL    CHKSYN          ; Make sure ")" follows
   140A 29                 3148         .ascii  ")"                              
   140B C1            [10] 3149 MIDNUM: POP     BC              ; Get return address
   140C D1            [10] 3150         POP     DE              ; Get number supplied
   140D C5            [11] 3151         PUSH    BC              ; Re-save return address
   140E 43            [ 4] 3152         LD      B,E             ; Number to B
   140F C9            [10] 3153         RET                                   
                           3154 ;
   1410 CD 56 14      [17] 3155 INP:    CALL    MAKINT          ; Make it integer A
   1413 32 84 80      [13] 3156         LD      (INPORT),A      ; Set input port
   1416 CD 83 80      [17] 3157         CALL    INPSUB          ; Get input from port
   1419 C3 B9 10      [10] 3158         JP      PASSA           ; Return integer A
                           3159 ;
   141C CD 40 14      [17] 3160 POUT:   CALL    SETIO           ; Set up port number
   141F C3 4B 80      [10] 3161         JP      OUTSUB          ; Output data and return
                           3162 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 59
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1422 CD 40 14      [17] 3163 WAIT:   CALL    SETIO           ; Set up port number
   1425 F5            [11] 3164         PUSH    AF              ; Save AND mask
   1426 1E 00         [ 7] 3165         LD      E,0             ; Assume zero if none given
   1428 2B            [ 6] 3166         DEC     HL              ; DEC 'cos GETCHR INCs
   1429 CD 5C 08      [17] 3167         CALL    GETCHR          ; Get next character
   142C CA 36 14      [10] 3168         JP      Z,NOXOR         ; No XOR byte given
   142F CD D7 06      [17] 3169         CALL    CHKSYN          ; Make sure ',' follows
q  1432 2C                 3170         .db     ','                              
   1433 CD 53 14      [17] 3171         CALL    GETINT          ; Get integer 0-255 to XOR with
   1436 C1            [10] 3172 NOXOR:  POP     BC              ; Restore AND mask
   1437 CD 83 80      [17] 3173 WAITLP: CALL    INPSUB          ; Get input
   143A AB            [ 4] 3174         XOR     E               ; Flip selected bits
   143B A0            [ 4] 3175         AND     B               ; Result non-zero?
   143C CA 37 14      [10] 3176         JP      Z,WAITLP        ; No = keep waiting
   143F C9            [10] 3177         RET                                   
                           3178 ;
   1440 CD 53 14      [17] 3179 SETIO:  CALL    GETINT          ; Get integer 0-255
   1443 32 84 80      [13] 3180         LD      (INPORT),A      ; Set input port
   1446 32 4C 80      [13] 3181         LD      (OTPORT),A      ; Set output port
   1449 CD D7 06      [17] 3182         CALL    CHKSYN          ; Make sure ',' follows
q  144C 2C                 3183         .db     ','                              
   144D C3 53 14      [10] 3184         JP      GETINT          ; Get integer 0-255 and return
                           3185 ;
   1450 CD 5C 08      [17] 3186 FNDNUM: CALL    GETCHR          ; Get next character
   1453 CD DC 0C      [17] 3187 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
   1456 CD 0A 09      [17] 3188 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
   1459 7A            [ 4] 3189         LD      A,D             ; Get MSB of number
   145A B7            [ 4] 3190         OR      A               ; Zero?
   145B C2 25 09      [10] 3191         JP      NZ,FCERR        ; No - Error
   145E 2B            [ 6] 3192         DEC     HL              ; DEC 'cos GETCHR INCs
   145F CD 5C 08      [17] 3193         CALL    GETCHR          ; Get next character
   1462 7B            [ 4] 3194         LD      A,E             ; Get number to A
   1463 C9            [10] 3195         RET                                   
                           3196 ;
   1464 CD 10 09      [17] 3197 PEEK:   CALL    DEINT           ; Get memory address
   1467 1A            [ 7] 3198         LD      A,(DE)          ; Get byte in memory
   1468 C3 B9 10      [10] 3199         JP      PASSA           ; Return integer A
                           3200 ;
   146B CD DC 0C      [17] 3201 POKE:   CALL    GETNUM          ; Get memory address
   146E CD 10 09      [17] 3202         CALL    DEINT           ; Get integer -32768 to 3276
   1471 D5            [11] 3203         PUSH    DE              ; Save memory address
   1472 CD D7 06      [17] 3204         CALL    CHKSYN          ; Make sure ',' follows
q  1475 2C                 3205         .db     ','                              
   1476 CD 53 14      [17] 3206         CALL    GETINT          ; Get integer 0-255
   1479 D1            [10] 3207         POP     DE              ; Restore memory address
   147A 12            [ 7] 3208         LD      (DE),A          ; Load it into memory
   147B C9            [10] 3209         RET                                   
                           3210 ;
   147C 21 63 19      [10] 3211 ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
   147F CD 44 17      [17] 3212 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
   1482 C3 9B 14      [10] 3213         JP      FPADD           ; Add BCDE to FPREG
                           3214 ;
   1485 CD 44 17      [17] 3215 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
   1488 21                 3216         .db     0x21            ; Skip 
   1489 50 4F 50 20 42 43  3217         .ascii  "POP BC"                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 60
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



u  148F 00                 3218         .db      and                               
   1490 50 4F 50 20 44 45  3219         .ascii  "POP DE"                              
   1496 C1            [10] 3220 PSUB:   POP     BC              ; Get FP number from stack
   1497 D1            [10] 3221         POP     DE                              
   1498 CD 1E 17      [17] 3222 SUBCDE: CALL    INVSGN          ; Negate FPREG
   149B 78            [ 4] 3223 FPADD:  LD      A,B             ; Get FP exponent
   149C B7            [ 4] 3224         OR      A               ; Is number zero?
   149D C8            [11] 3225         RET     Z               ; Yes - Nothing to add
   149E 3A 2C 81      [13] 3226         LD      A,(FPEXP)       ; Get FPREG exponent
   14A1 B7            [ 4] 3227         OR      A               ; Is this number zero?
   14A2 CA 36 17      [10] 3228         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
   14A5 90            [ 4] 3229         SUB     B               ; BCDE number larger?
   14A6 D2 B5 14      [10] 3230         JP      NC,NOSWAP       ; No - Don't swap them
   14A9 2F            [ 4] 3231         CPL                     ; Two's complement
   14AA 3C            [ 4] 3232         INC     A               ;	FP exponent
   14AB EB            [ 4] 3233         EX      DE,HL                              
   14AC CD 26 17      [17] 3234         CALL    STAKFP          ; Put FPREG on stack
   14AF EB            [ 4] 3235         EX      DE,HL                              
   14B0 CD 36 17      [17] 3236         CALL    FPBCDE          ; Move BCDE to FPREG
   14B3 C1            [10] 3237         POP     BC              ; Restore number from stack
   14B4 D1            [10] 3238         POP     DE                              
   14B5 FE 19         [ 7] 3239 NOSWAP: CP      24+1            ; Second number insignificant?
   14B7 D0            [11] 3240         RET     NC              ; Yes - First number is result
   14B8 F5            [11] 3241         PUSH    AF              ; Save number of bits to scale
   14B9 CD 5B 17      [17] 3242         CALL    SIGNS           ; Set MSBs & sign of result
   14BC 67            [ 4] 3243         LD      H,A             ; Save sign of result
   14BD F1            [10] 3244         POP     AF              ; Restore scaling factor
   14BE CD 5E 15      [17] 3245         CALL    SCALE           ; Scale BCDE to same exponent
   14C1 B4            [ 4] 3246         OR      H               ; Result to be positive?
   14C2 21 29 81      [10] 3247         LD      HL,FPREG        ; Point to FPREG
   14C5 F2 DB 14      [10] 3248         JP      P,MINCDE        ; No - Subtract FPREG from CDE
   14C8 CD 3E 15      [17] 3249         CALL    PLUCDE          ; Add FPREG to CDE
   14CB D2 21 15      [10] 3250         JP      NC,RONDUP       ; No overflow - Round it up
   14CE 23            [ 6] 3251         INC     HL              ; Point to exponent
   14CF 34            [11] 3252         INC     (HL)            ; Increment it
   14D0 CA 22 04      [10] 3253         JP      Z,OVERR         ; Number overflowed - Error
   14D3 2E 01         [ 7] 3254         LD      L,1             ; 1 bit to shift right
   14D5 CD 74 15      [17] 3255         CALL    SHRT1           ; Shift result right
   14D8 C3 21 15      [10] 3256         JP      RONDUP          ; Round it up
                           3257 ;
   14DB AF            [ 4] 3258 MINCDE: XOR     A               ; Clear A and carry
   14DC 90            [ 4] 3259         SUB     B               ; Negate exponent
   14DD 47            [ 4] 3260         LD      B,A             ; Re-save exponent
   14DE 7E            [ 7] 3261         LD      A,(HL)          ; Get LSB of FPREG
   14DF 9B            [ 4] 3262         SBC     A,E             ; Subtract LSB of BCDE
   14E0 5F            [ 4] 3263         LD      E,A             ; Save LSB of BCDE
   14E1 23            [ 6] 3264         INC     HL                              
   14E2 7E            [ 7] 3265         LD      A,(HL)          ; Get NMSB of FPREG
   14E3 9A            [ 4] 3266         SBC     A,D             ; Subtract NMSB of BCDE
   14E4 57            [ 4] 3267         LD      D,A             ; Save NMSB of BCDE
   14E5 23            [ 6] 3268         INC     HL                              
   14E6 7E            [ 7] 3269         LD      A,(HL)          ; Get MSB of FPREG
   14E7 99            [ 4] 3270         SBC     A,C             ; Subtract MSB of BCDE
   14E8 4F            [ 4] 3271         LD      C,A             ; Save MSB of BCDE
   14E9 DC 4A 15      [17] 3272 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 61
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                           3273 ;
   14EC 68            [ 4] 3274 BNORM:  LD      L,B             ; L = Exponent
   14ED 63            [ 4] 3275         LD      H,E             ; H = LSB
   14EE AF            [ 4] 3276         XOR     A                              
   14EF 47            [ 4] 3277 BNRMLP: LD      B,A             ; Save bit count
   14F0 79            [ 4] 3278         LD      A,C             ; Get MSB
   14F1 B7            [ 4] 3279         OR      A               ; Is it zero?
   14F2 C2 0E 15      [10] 3280         JP      NZ,PNORM        ; No - Do it bit at a time
   14F5 4A            [ 4] 3281         LD      C,D             ; MSB = NMSB
   14F6 54            [ 4] 3282         LD      D,H             ; NMSB= LSB
   14F7 65            [ 4] 3283         LD      H,L             ; LSB = VLSB
   14F8 6F            [ 4] 3284         LD      L,A             ; VLSB= 0
   14F9 78            [ 4] 3285         LD      A,B             ; Get exponent
   14FA D6 08         [ 7] 3286         SUB     8               ; Count 8 bits
   14FC FE E0         [ 7] 3287         CP      0x0E0           ; -24-8 Was number zero?
   14FE C2 EF 14      [10] 3288         JP      NZ,BNRMLP       ; No - Keep normalising
   1501 AF            [ 4] 3289 RESZER: XOR     A               ; Result is zero
   1502 32 2C 81      [13] 3290 SAVEXP: LD      (FPEXP),A       ; Save result as zero
   1505 C9            [10] 3291         RET                                   
                           3292 ;
   1506 05            [ 4] 3293 NORMAL: DEC     B               ; Count bits
   1507 29            [11] 3294         ADD     HL,HL           ; Shift HL left
   1508 7A            [ 4] 3295         LD      A,D             ; Get NMSB
   1509 17            [ 4] 3296         RLA                     ; Shift left with last bit
   150A 57            [ 4] 3297         LD      D,A             ; Save NMSB
   150B 79            [ 4] 3298         LD      A,C             ; Get MSB
   150C 8F            [ 4] 3299         ADC     A,A             ; Shift left with last bit
   150D 4F            [ 4] 3300         LD      C,A             ; Save MSB
   150E F2 06 15      [10] 3301 PNORM:  JP      P,NORMAL        ; Not done - Keep going
   1511 78            [ 4] 3302         LD      A,B             ; Number of bits shifted
   1512 5C            [ 4] 3303         LD      E,H             ; Save HL in EB
   1513 45            [ 4] 3304         LD      B,L                              
   1514 B7            [ 4] 3305         OR      A               ; Any shifting done?
   1515 CA 21 15      [10] 3306         JP      Z,RONDUP        ; No - Round it up
   1518 21 2C 81      [10] 3307         LD      HL,FPEXP        ; Point to exponent
   151B 86            [ 7] 3308         ADD     A,(HL)          ; Add shifted bits
   151C 77            [ 7] 3309         LD      (HL),A          ; Re-save exponent
   151D D2 01 15      [10] 3310         JP      NC,RESZER       ; Underflow - Result is zero
   1520 C8            [11] 3311         RET     Z               ; Result is zero
   1521 78            [ 4] 3312 RONDUP: LD      A,B             ; Get VLSB of number
   1522 21 2C 81      [10] 3313 RONDB:  LD      HL,FPEXP        ; Point to exponent
   1525 B7            [ 4] 3314         OR      A               ; Any rounding?
   1526 FC 31 15      [17] 3315         CALL    M,FPROND        ; Yes - Round number up
   1529 46            [ 7] 3316         LD      B,(HL)          ; B = Exponent
   152A 23            [ 6] 3317         INC     HL                              
   152B 7E            [ 7] 3318         LD      A,(HL)          ; Get sign of result
kq 152C                    3319         AND     10000000B       ; Only bit 7 needed
   152C A9            [ 4] 3320         XOR     C               ; Set correct sign
   152D 4F            [ 4] 3321         LD      C,A             ; Save correct sign in number
   152E C3 36 17      [10] 3322         JP      FPBCDE          ; Move BCDE to FPREG
                           3323 ;
   1531 1C            [ 4] 3324 FPROND: INC     E               ; Round LSB
   1532 C0            [11] 3325         RET     NZ              ; Return if ok
   1533 14            [ 4] 3326         INC     D               ; Round NMSB
   1534 C0            [11] 3327         RET     NZ              ; Return if ok
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 62
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1535 0C            [ 4] 3328         INC     C               ; Round MSB
   1536 C0            [11] 3329         RET     NZ              ; Return if ok
   1537 0E 80         [ 7] 3330         LD      C,0x80          ; Set normal value
   1539 34            [11] 3331         INC     (HL)            ; Increment exponent
   153A C0            [11] 3332         RET     NZ              ; Return if ok
   153B C3 22 04      [10] 3333         JP      OVERR           ; Overflow error
                           3334 ;
   153E 7E            [ 7] 3335 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
   153F 83            [ 4] 3336         ADD     A,E             ; Add LSB of BCDE
   1540 5F            [ 4] 3337         LD      E,A             ; Save LSB of BCDE
   1541 23            [ 6] 3338         INC     HL                              
   1542 7E            [ 7] 3339         LD      A,(HL)          ; Get NMSB of FPREG
   1543 8A            [ 4] 3340         ADC     A,D             ; Add NMSB of BCDE
   1544 57            [ 4] 3341         LD      D,A             ; Save NMSB of BCDE
   1545 23            [ 6] 3342         INC     HL                              
   1546 7E            [ 7] 3343         LD      A,(HL)          ; Get MSB of FPREG
   1547 89            [ 4] 3344         ADC     A,C             ; Add MSB of BCDE
   1548 4F            [ 4] 3345         LD      C,A             ; Save MSB of BCDE
   1549 C9            [10] 3346         RET                                   
                           3347 ;
   154A 21 2D 81      [10] 3348 COMPL:  LD      HL,SGNRES       ; Sign of result
   154D 7E            [ 7] 3349         LD      A,(HL)          ; Get sign of result
   154E 2F            [ 4] 3350         CPL                     ; Negate it
   154F 77            [ 7] 3351         LD      (HL),A          ; Put it back
   1550 AF            [ 4] 3352         XOR     A                              
   1551 6F            [ 4] 3353         LD      L,A             ; Set L to zero
   1552 90            [ 4] 3354         SUB     B               ; Negate exponent,set carry
   1553 47            [ 4] 3355         LD      B,A             ; Re-save exponent
   1554 7D            [ 4] 3356         LD      A,L             ; Load zero
   1555 9B            [ 4] 3357         SBC     A,E             ; Negate LSB
   1556 5F            [ 4] 3358         LD      E,A             ; Re-save LSB
   1557 7D            [ 4] 3359         LD      A,L             ; Load zero
   1558 9A            [ 4] 3360         SBC     A,D             ; Negate NMSB
   1559 57            [ 4] 3361         LD      D,A             ; Re-save NMSB
   155A 7D            [ 4] 3362         LD      A,L             ; Load zero
   155B 99            [ 4] 3363         SBC     A,C             ; Negate MSB
   155C 4F            [ 4] 3364         LD      C,A             ; Re-save MSB
   155D C9            [10] 3365         RET                                   
                           3366 ;
   155E 06 00         [ 7] 3367 SCALE:  LD      B,0             ; Clear underflow
   1560 D6 08         [ 7] 3368 SCALLP: SUB     8               ; 8 bits (a whole byte)?
   1562 DA 6D 15      [10] 3369         JP      C,SHRITE        ; No - Shift right A bits
   1565 43            [ 4] 3370         LD      B,E             ; <- Shift
   1566 5A            [ 4] 3371         LD      E,D             ; <- right
   1567 51            [ 4] 3372         LD      D,C             ; <- eight
   1568 0E 00         [ 7] 3373         LD      C,0             ; <- bits
   156A C3 60 15      [10] 3374         JP      SCALLP          ; More bits to shift
                           3375 ;
   156D C6 09         [ 7] 3376 SHRITE: ADD     A,8+1           ; Adjust count
   156F 6F            [ 4] 3377         LD      L,A             ; Save bits to shift
   1570 AF            [ 4] 3378 SHRLP:  XOR     A               ; Flag for all done
   1571 2D            [ 4] 3379         DEC     L               ; All shifting done?
   1572 C8            [11] 3380         RET     Z               ; Yes - Return
   1573 79            [ 4] 3381         LD      A,C             ; Get MSB
   1574 1F            [ 4] 3382 SHRT1:  RRA                     ; Shift it right
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 63
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1575 4F            [ 4] 3383         LD      C,A             ; Re-save
   1576 7A            [ 4] 3384         LD      A,D             ; Get NMSB
   1577 1F            [ 4] 3385         RRA                     ; Shift right with last bit
   1578 57            [ 4] 3386         LD      D,A             ; Re-save it
   1579 7B            [ 4] 3387         LD      A,E             ; Get LSB
   157A 1F            [ 4] 3388         RRA                     ; Shift right with last bit
   157B 5F            [ 4] 3389         LD      E,A             ; Re-save it
   157C 78            [ 4] 3390         LD      A,B             ; Get underflow
   157D 1F            [ 4] 3391         RRA                     ; Shift right with last bit
   157E 47            [ 4] 3392         LD      B,A             ; Re-save underflow
   157F C3 70 15      [10] 3393         JP      SHRLP           ; More bits to do
                           3394 ;
q  1582 00 00 00           3395 UNITY:  .db     0x000,0x000,000H; 1.00000
                           3396 ;
   1585 03                 3397 LOGTAB: .db     3               ; Table used by LOG
q  1586 AA 56 13           3398         .db     0x0AA,0x056,019H; 0.59898
q  1589 F1 22 4C           3399         .db     0x0F1,0x022,076H; 0.96147
q  158C 45 AA 26           3400         .db     0x045,0x0AA,038H; 2.88539
                           3401 ;
   158F CD F5 16      [17] 3402 LOG:    CALL    TSTSGN          ; Test sign of value
   1592 B7            [ 4] 3403         OR      A                              
   1593 EA 25 09      [10] 3404         JP      PE,FCERR        ; ?FC Error if <= zero
   1596 21 2C 81      [10] 3405         LD      HL,FPEXP        ; Point to exponent
   1599 7E            [ 7] 3406         LD      A,(HL)          ; Get exponent
   159A 01 35 80      [10] 3407         LD      BC,0x8035       ; BCDE = SQR(1/2)
   159D 11 F3 04      [10] 3408         LD      DE,0x04F3                              
   15A0 90            [ 4] 3409         SUB     B               ; Scale value to be < 1
   15A1 F5            [11] 3410         PUSH    AF              ; Save scale factor
   15A2 70            [ 7] 3411         LD      (HL),B          ; Save new exponent
   15A3 D5            [11] 3412         PUSH    DE              ; Save SQR(1/2)
   15A4 C5            [11] 3413         PUSH    BC                              
   15A5 CD 9B 14      [17] 3414         CALL    FPADD           ; Add SQR(1/2) to value
   15A8 C1            [10] 3415         POP     BC              ; Restore SQR(1/2)
   15A9 D1            [10] 3416         POP     DE                              
   15AA 04            [ 4] 3417         INC     B               ; Make it SQR(2)
   15AB CD 3E 16      [17] 3418         CALL    DVBCDE          ; Divide by SQR(2)
   15AE 21 82 15      [10] 3419         LD      HL,UNITY        ; Point to 1.
   15B1 CD 85 14      [17] 3420         CALL    SUBPHL          ; Subtract FPREG from 1
   15B4 21 85 15      [10] 3421         LD      HL,LOGTAB       ; Coefficient table
   15B7 CD 22 1A      [17] 3422         CALL    SUMSER          ; Evaluate sum of series
   15BA 01 80 80      [10] 3423         LD      BC,0x8080       ; BCDE = -0.5
   15BD 11 00 00      [10] 3424         LD      DE,0x0000                              
   15C0 CD 9B 14      [17] 3425         CALL    FPADD           ; Subtract 0.5 from FPREG
   15C3 F1            [10] 3426         POP     AF              ; Restore scale factor
   15C4 CD 66 18      [17] 3427         CALL    RSCALE          ; Re-scale number
   15C7 01 31 80      [10] 3428 MULLN2: LD      BC,0x8031       ; BCDE = Ln(2)
   15CA 11 18 72      [10] 3429         LD      DE,0x7218                              
   15CD 21                 3430         .db     0x21            ; Skip 
   15CE 50 4F 50 20 42 43  3431         .ascii  "POP BC"                              
u  15D4 00                 3432         .db      and                               
   15D5 50 4F 50 20 44 45  3433         .ascii  "POP DE"                              
                           3434 ;
   15DB C1            [10] 3435 MULT:   POP     BC              ; Get number from stack
   15DC D1            [10] 3436         POP     DE                              
   15DD CD F5 16      [17] 3437 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 64
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   15E0 C8            [11] 3438         RET     Z               ; Return zero if zero
   15E1 2E 00         [ 7] 3439         LD      L,0             ; Flag add exponents
   15E3 CD B3 16      [17] 3440         CALL    ADDEXP          ; Add exponents
   15E6 79            [ 4] 3441         LD      A,C             ; Get MSB of multiplier
   15E7 32 3B 81      [13] 3442         LD      (MULVAL),A      ; Save MSB of multiplier
   15EA EB            [ 4] 3443         EX      DE,HL                              
   15EB 22 3C 81      [16] 3444         LD      (MULVAL+1),HL   ; Save rest of multiplier
   15EE 01 00 00      [10] 3445         LD      BC,0            ; Partial product (BCDE) = zero
   15F1 50            [ 4] 3446         LD      D,B                              
   15F2 58            [ 4] 3447         LD      E,B                              
   15F3 21 EC 14      [10] 3448         LD      HL,BNORM        ; Address of normalise
   15F6 E5            [11] 3449         PUSH    HL              ; Save for return
   15F7 21 FF 15      [10] 3450         LD      HL,MULT8        ; Address of 8 bit multiply
   15FA E5            [11] 3451         PUSH    HL              ; Save for NMSB,MSB
   15FB E5            [11] 3452         PUSH    HL              ; 
   15FC 21 29 81      [10] 3453         LD      HL,FPREG        ; Point to number
   15FF 7E            [ 7] 3454 MULT8:  LD      A,(HL)          ; Get LSB of number
   1600 23            [ 6] 3455         INC     HL              ; Point to NMSB
   1601 B7            [ 4] 3456         OR      A               ; Test LSB
   1602 CA 2B 16      [10] 3457         JP      Z,BYTSFT        ; Zero - shift to next byte
   1605 E5            [11] 3458         PUSH    HL              ; Save address of number
   1606 2E 08         [ 7] 3459         LD      L,8             ; 8 bits to multiply by
   1608 1F            [ 4] 3460 MUL8LP: RRA                     ; Shift LSB right
   1609 67            [ 4] 3461         LD      H,A             ; Save LSB
   160A 79            [ 4] 3462         LD      A,C             ; Get MSB
   160B D2 19 16      [10] 3463         JP      NC,NOMADD       ; Bit was zero - Don't add
   160E E5            [11] 3464         PUSH    HL              ; Save LSB and count
   160F 2A 3C 81      [16] 3465         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
   1612 19            [11] 3466         ADD     HL,DE           ; Add NMSB and LSB
   1613 EB            [ 4] 3467         EX      DE,HL           ; Leave sum in DE
   1614 E1            [10] 3468         POP     HL              ; Restore MSB and count
   1615 3A 3B 81      [13] 3469         LD      A,(MULVAL)      ; Get MSB of multiplier
   1618 89            [ 4] 3470         ADC     A,C             ; Add MSB
   1619 1F            [ 4] 3471 NOMADD: RRA                     ; Shift MSB right
   161A 4F            [ 4] 3472         LD      C,A             ; Re-save MSB
   161B 7A            [ 4] 3473         LD      A,D             ; Get NMSB
   161C 1F            [ 4] 3474         RRA                     ; Shift NMSB right
   161D 57            [ 4] 3475         LD      D,A             ; Re-save NMSB
   161E 7B            [ 4] 3476         LD      A,E             ; Get LSB
   161F 1F            [ 4] 3477         RRA                     ; Shift LSB right
   1620 5F            [ 4] 3478         LD      E,A             ; Re-save LSB
   1621 78            [ 4] 3479         LD      A,B             ; Get VLSB
   1622 1F            [ 4] 3480         RRA                     ; Shift VLSB right
   1623 47            [ 4] 3481         LD      B,A             ; Re-save VLSB
   1624 2D            [ 4] 3482         DEC     L               ; Count bits multiplied
   1625 7C            [ 4] 3483         LD      A,H             ; Get LSB of multiplier
   1626 C2 08 16      [10] 3484         JP      NZ,MUL8LP       ; More - Do it
   1629 E1            [10] 3485 POPHRT: POP     HL              ; Restore address of number
   162A C9            [10] 3486         RET                                   
                           3487 ;
   162B 43            [ 4] 3488 BYTSFT: LD      B,E             ; Shift partial product left
   162C 5A            [ 4] 3489         LD      E,D                              
   162D 51            [ 4] 3490         LD      D,C                              
   162E 4F            [ 4] 3491         LD      C,A                              
   162F C9            [10] 3492         RET                                   
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 65
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                           3493 ;
   1630 CD 26 17      [17] 3494 DIV10:  CALL    STAKFP          ; Save FPREG on stack
   1633 01 20 84      [10] 3495         LD      BC,0x8420       ; BCDE = 10.
   1636 11 00 00      [10] 3496         LD      DE,0x0000                              
   1639 CD 36 17      [17] 3497         CALL    FPBCDE          ; Move 10 to FPREG
                           3498 ;
   163C C1            [10] 3499 DIV:    POP     BC              ; Get number from stack
   163D D1            [10] 3500         POP     DE                              
   163E CD F5 16      [17] 3501 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
   1641 CA FA 03      [10] 3502         JP      Z,DZERR         ; Error if division by zero
   1644 2E FF         [ 7] 3503         LD      L,-1            ; Flag subtract exponents
   1646 CD B3 16      [17] 3504         CALL    ADDEXP          ; Subtract exponents
   1649 34            [11] 3505         INC     (HL)            ; Add 2 to exponent to adjust
   164A 34            [11] 3506         INC     (HL)                              
   164B 2B            [ 6] 3507         DEC     HL              ; Point to MSB
   164C 7E            [ 7] 3508         LD      A,(HL)          ; Get MSB of dividend
   164D 32 57 80      [13] 3509         LD      (DIV3),A        ; Save for subtraction
   1650 2B            [ 6] 3510         DEC     HL                              
   1651 7E            [ 7] 3511         LD      A,(HL)          ; Get NMSB of dividend
   1652 32 53 80      [13] 3512         LD      (DIV2),A        ; Save for subtraction
   1655 2B            [ 6] 3513         DEC     HL                              
   1656 7E            [ 7] 3514         LD      A,(HL)          ; Get MSB of dividend
   1657 32 4F 80      [13] 3515         LD      (DIV1),A        ; Save for subtraction
   165A 41            [ 4] 3516         LD      B,C             ; Get MSB
   165B EB            [ 4] 3517         EX      DE,HL           ; NMSB,LSB to HL
   165C AF            [ 4] 3518         XOR     A                              
   165D 4F            [ 4] 3519         LD      C,A             ; Clear MSB of quotient
   165E 57            [ 4] 3520         LD      D,A             ; Clear NMSB of quotient
   165F 5F            [ 4] 3521         LD      E,A             ; Clear LSB of quotient
   1660 32 5A 80      [13] 3522         LD      (DIV4),A        ; Clear overflow count
   1663 E5            [11] 3523 DIVLP:  PUSH    HL              ; Save divisor
   1664 C5            [11] 3524         PUSH    BC                              
   1665 7D            [ 4] 3525         LD      A,L             ; Get LSB of number
   1666 CD 4E 80      [17] 3526         CALL    DIVSUP          ; Subt' divisor from dividend
   1669 DE 00         [ 7] 3527         SBC     A,0             ; Count for overflows
   166B 3F            [ 4] 3528         CCF                                   
   166C D2 83 16      [10] 3529         JP      NC,RESDIV       ; Restore divisor if borrow
   166F 32 5A 80      [13] 3530         LD      (DIV4),A        ; Re-save overflow count
   1672 F1            [10] 3531         POP     AF              ; Scrap divisor
   1673 F1            [10] 3532         POP     AF                              
   1674 37            [ 4] 3533         SCF                     ; Set carry to
   1675 D2                 3534         .db     0x0D2           ; Skip 
   1676 50 4F 50 20 42 43  3535         .ascii  "POP BC"                              
u  167C 00                 3536         .db      and                               
   167D 50 4F 50 20 48 4C  3537         .ascii  "POP HL"                              
                           3538 ;
   1683 C1            [10] 3539 RESDIV: POP     BC              ; Restore divisor
   1684 E1            [10] 3540         POP     HL                              
   1685 79            [ 4] 3541         LD      A,C             ; Get MSB of quotient
   1686 3C            [ 4] 3542         INC     A                              
   1687 3D            [ 4] 3543         DEC     A                              
   1688 1F            [ 4] 3544         RRA                     ; Bit 0 to bit 7
   1689 FA 22 15      [10] 3545         JP      M,RONDB         ; Done - Normalise result
   168C 17            [ 4] 3546         RLA                     ; Restore carry
   168D 7B            [ 4] 3547         LD      A,E             ; Get LSB of quotient
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 66
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   168E 17            [ 4] 3548         RLA                     ; Double it
   168F 5F            [ 4] 3549         LD      E,A             ; Put it back
   1690 7A            [ 4] 3550         LD      A,D             ; Get NMSB of quotient
   1691 17            [ 4] 3551         RLA                     ; Double it
   1692 57            [ 4] 3552         LD      D,A             ; Put it back
   1693 79            [ 4] 3553         LD      A,C             ; Get MSB of quotient
   1694 17            [ 4] 3554         RLA                     ; Double it
   1695 4F            [ 4] 3555         LD      C,A             ; Put it back
   1696 29            [11] 3556         ADD     HL,HL           ; Double NMSB,LSB of divisor
   1697 78            [ 4] 3557         LD      A,B             ; Get MSB of divisor
   1698 17            [ 4] 3558         RLA                     ; Double it
   1699 47            [ 4] 3559         LD      B,A             ; Put it back
   169A 3A 5A 80      [13] 3560         LD      A,(DIV4)        ; Get VLSB of quotient
   169D 17            [ 4] 3561         RLA                     ; Double it
   169E 32 5A 80      [13] 3562         LD      (DIV4),A        ; Put it back
   16A1 79            [ 4] 3563         LD      A,C             ; Get MSB of quotient
   16A2 B2            [ 4] 3564         OR      D               ; Merge NMSB
   16A3 B3            [ 4] 3565         OR      E               ; Merge LSB
   16A4 C2 63 16      [10] 3566         JP      NZ,DIVLP        ; Not done - Keep dividing
   16A7 E5            [11] 3567         PUSH    HL              ; Save divisor
   16A8 21 2C 81      [10] 3568         LD      HL,FPEXP        ; Point to exponent
   16AB 35            [11] 3569         DEC     (HL)            ; Divide by 2
   16AC E1            [10] 3570         POP     HL              ; Restore divisor
   16AD C2 63 16      [10] 3571         JP      NZ,DIVLP        ; Ok - Keep going
   16B0 C3 22 04      [10] 3572         JP      OVERR           ; Overflow error
                           3573 ;
   16B3 78            [ 4] 3574 ADDEXP: LD      A,B             ; Get exponent of dividend
   16B4 B7            [ 4] 3575         OR      A               ; Test it
   16B5 CA D7 16      [10] 3576         JP      Z,OVTST3        ; Zero - Result zero
   16B8 7D            [ 4] 3577         LD      A,L             ; Get add/subtract flag
   16B9 21 2C 81      [10] 3578         LD      HL,FPEXP        ; Point to exponent
   16BC AE            [ 7] 3579         XOR     (HL)            ; Add or subtract it
   16BD 80            [ 4] 3580         ADD     A,B             ; Add the other exponent
   16BE 47            [ 4] 3581         LD      B,A             ; Save new exponent
   16BF 1F            [ 4] 3582         RRA                     ; Test exponent for overflow
   16C0 A8            [ 4] 3583         XOR     B                              
   16C1 78            [ 4] 3584         LD      A,B             ; Get exponent
   16C2 F2 D6 16      [10] 3585         JP      P,OVTST2        ; Positive - Test for overflow
   16C5 C6 80         [ 7] 3586         ADD     A,0x80          ; Add excess 128
   16C7 77            [ 7] 3587         LD      (HL),A          ; Save new exponent
   16C8 CA 29 16      [10] 3588         JP      Z,POPHRT        ; Zero - Result zero
   16CB CD 5B 17      [17] 3589         CALL    SIGNS           ; Set MSBs and sign of result
   16CE 77            [ 7] 3590         LD      (HL),A          ; Save new exponent
   16CF 2B            [ 6] 3591         DEC     HL              ; Point to MSB
   16D0 C9            [10] 3592         RET                                   
                           3593 ;
   16D1 CD F5 16      [17] 3594 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
   16D4 2F            [ 4] 3595         CPL                     ; Invert sign
   16D5 E1            [10] 3596         POP     HL              ; Clean up stack
   16D6 B7            [ 4] 3597 OVTST2: OR      A               ; Test if new exponent zero
   16D7 E1            [10] 3598 OVTST3: POP     HL              ; Clear off return address
   16D8 F2 01 15      [10] 3599         JP      P,RESZER        ; Result zero
   16DB C3 22 04      [10] 3600         JP      OVERR           ; Overflow error
                           3601 ;
   16DE CD 41 17      [17] 3602 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 67
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   16E1 78            [ 4] 3603         LD      A,B             ; Get exponent
   16E2 B7            [ 4] 3604         OR      A               ; Is it zero?
   16E3 C8            [11] 3605         RET     Z               ; Yes - Result is zero
   16E4 C6 02         [ 7] 3606         ADD     A,2             ; Multiply by 4
   16E6 DA 22 04      [10] 3607         JP      C,OVERR         ; Overflow - ?OV Error
   16E9 47            [ 4] 3608         LD      B,A             ; Re-save exponent
   16EA CD 9B 14      [17] 3609         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
   16ED 21 2C 81      [10] 3610         LD      HL,FPEXP        ; Point to exponent
   16F0 34            [11] 3611         INC     (HL)            ; Double number (Times 10)
   16F1 C0            [11] 3612         RET     NZ              ; Ok - Return
   16F2 C3 22 04      [10] 3613         JP      OVERR           ; Overflow error
                           3614 ;
   16F5 3A 2C 81      [13] 3615 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
   16F8 B7            [ 4] 3616         OR      A                              
   16F9 C8            [11] 3617         RET     Z               ; RETurn if number is zero
   16FA 3A 2B 81      [13] 3618         LD      A,(FPREG+2)     ; Get MSB of FPREG
   16FD FE                 3619         .db     0x0FE           ; Test sign
   16FE 2F            [ 4] 3620 RETREL: CPL                     ; Invert sign
   16FF 17            [ 4] 3621         RLA                     ; Sign bit to carry
   1700 9F            [ 4] 3622 FLGDIF: SBC     A,A             ; Carry to all bits of A
   1701 C0            [11] 3623         RET     NZ              ; Return -1 if negative
   1702 3C            [ 4] 3624         INC     A               ; Bump to +1
   1703 C9            [10] 3625         RET                     ; Positive - Return +1
                           3626 ;
   1704 CD F5 16      [17] 3627 SGN:    CALL    TSTSGN          ; Test sign of FPREG
   1707 06 88         [ 7] 3628 FLGREL: LD      B,0x80+8        ; 8 bit integer in exponent
   1709 11 00 00      [10] 3629         LD      DE,0            ; Zero NMSB and LSB
   170C 21 2C 81      [10] 3630 RETINT: LD      HL,FPEXP        ; Point to exponent
   170F 4F            [ 4] 3631         LD      C,A             ; CDE = MSB,NMSB and LSB
   1710 70            [ 7] 3632         LD      (HL),B          ; Save exponent
   1711 06 00         [ 7] 3633         LD      B,0             ; CDE = integer to normalise
   1713 23            [ 6] 3634         INC     HL              ; Point to sign of result
   1714 36 80         [10] 3635         LD      (HL),0x80       ; Set sign of result
   1716 17            [ 4] 3636         RLA                     ; Carry = sign of integer
   1717 C3 E9 14      [10] 3637         JP      CONPOS          ; Set sign of result
                           3638 ;
   171A CD F5 16      [17] 3639 ABS:    CALL    TSTSGN          ; Test sign of FPREG
   171D F0            [11] 3640         RET     P               ; Return if positive
   171E 21 2B 81      [10] 3641 INVSGN: LD      HL,FPREG+2      ; Point to MSB
   1721 7E            [ 7] 3642         LD      A,(HL)          ; Get sign of mantissa
   1722 EE 80         [ 7] 3643         XOR     0x80            ; Invert sign of mantissa
   1724 77            [ 7] 3644         LD      (HL),A          ; Re-save sign of mantissa
   1725 C9            [10] 3645         RET                                   
                           3646 ;
   1726 EB            [ 4] 3647 STAKFP: EX      DE,HL           ; Save code string address
   1727 2A 29 81      [16] 3648         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
   172A E3            [19] 3649         EX      (SP),HL         ; Stack them,get return
   172B E5            [11] 3650         PUSH    HL              ; Re-save return
   172C 2A 2B 81      [16] 3651         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
   172F E3            [19] 3652         EX      (SP),HL         ; Stack them,get return
   1730 E5            [11] 3653         PUSH    HL              ; Re-save return
   1731 EB            [ 4] 3654         EX      DE,HL           ; Restore code string address
   1732 C9            [10] 3655         RET                                   
                           3656 ;
   1733 CD 44 17      [17] 3657 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 68
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1736 EB            [ 4] 3658 FPBCDE: EX      DE,HL           ; Save code string address
   1737 22 29 81      [16] 3659         LD      (FPREG),HL      ; Save LSB,NLSB of number
   173A 60            [ 4] 3660         LD      H,B             ; Exponent of number
   173B 69            [ 4] 3661         LD      L,C             ; MSB of number
   173C 22 2B 81      [16] 3662         LD      (FPREG+2),HL    ; Save MSB and exponent
   173F EB            [ 4] 3663         EX      DE,HL           ; Restore code string address
   1740 C9            [10] 3664         RET                                   
                           3665 ;
   1741 21 29 81      [10] 3666 BCDEFP: LD      HL,FPREG        ; Point to FPREG
   1744 5E            [ 7] 3667 LOADFP: LD      E,(HL)          ; Get LSB of number
   1745 23            [ 6] 3668         INC     HL                              
   1746 56            [ 7] 3669         LD      D,(HL)          ; Get NMSB of number
   1747 23            [ 6] 3670         INC     HL                              
   1748 4E            [ 7] 3671         LD      C,(HL)          ; Get MSB of number
   1749 23            [ 6] 3672         INC     HL                              
   174A 46            [ 7] 3673         LD      B,(HL)          ; Get exponent of number
   174B 23            [ 6] 3674 INCHL:  INC     HL              ; Used for conditional "INC HL"
   174C C9            [10] 3675         RET                                   
                           3676 ;
   174D 11 29 81      [10] 3677 FPTHL:  LD      DE,FPREG        ; Point to FPREG
   1750 06 04         [ 7] 3678 DETHL4: LD      B,4             ; 4 bytes to move
   1752 1A            [ 7] 3679 DETHLB: LD      A,(DE)          ; Get source
   1753 77            [ 7] 3680         LD      (HL),A          ; Save destination
   1754 13            [ 6] 3681         INC     DE              ; Next source
   1755 23            [ 6] 3682         INC     HL              ; Next destination
   1756 05            [ 4] 3683         DEC     B               ; Count bytes
   1757 C2 52 17      [10] 3684         JP      NZ,DETHLB       ; Loop if more
   175A C9            [10] 3685         RET                                   
                           3686 ;
   175B 21 2B 81      [10] 3687 SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
   175E 7E            [ 7] 3688         LD      A,(HL)          ; Get MSB
   175F 07            [ 4] 3689         RLCA                    ; Old sign to carry
   1760 37            [ 4] 3690         SCF                     ; Set MSBit
   1761 1F            [ 4] 3691         RRA                     ; Set MSBit of MSB
   1762 77            [ 7] 3692         LD      (HL),A          ; Save new MSB
   1763 3F            [ 4] 3693         CCF                     ; Complement sign
   1764 1F            [ 4] 3694         RRA                     ; Old sign to carry
   1765 23            [ 6] 3695         INC     HL                              
   1766 23            [ 6] 3696         INC     HL                              
   1767 77            [ 7] 3697         LD      (HL),A          ; Set sign of result
   1768 79            [ 4] 3698         LD      A,C             ; Get MSB
   1769 07            [ 4] 3699         RLCA                    ; Old sign to carry
   176A 37            [ 4] 3700         SCF                     ; Set MSBit
   176B 1F            [ 4] 3701         RRA                     ; Set MSBit of MSB
   176C 4F            [ 4] 3702         LD      C,A             ; Save MSB
   176D 1F            [ 4] 3703         RRA                                   
   176E AE            [ 7] 3704         XOR     (HL)            ; New sign of result
   176F C9            [10] 3705         RET                                   
                           3706 ;
   1770 78            [ 4] 3707 CMPNUM: LD      A,B             ; Get exponent of number
   1771 B7            [ 4] 3708         OR      A                              
   1772 CA F5 16      [10] 3709         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
   1775 21 FE 16      [10] 3710         LD      HL,RETREL       ; Return relation routine
   1778 E5            [11] 3711         PUSH    HL              ; Save for return
   1779 CD F5 16      [17] 3712         CALL    TSTSGN          ; Test sign of FPREG
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 69
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   177C 79            [ 4] 3713         LD      A,C             ; Get MSB of number
   177D C8            [11] 3714         RET     Z               ; FPREG zero - Number's MSB
   177E 21 2B 81      [10] 3715         LD      HL,FPREG+2      ; MSB of FPREG
   1781 AE            [ 7] 3716         XOR     (HL)            ; Combine signs
   1782 79            [ 4] 3717         LD      A,C             ; Get MSB of number
   1783 F8            [11] 3718         RET     M               ; Exit if signs different
   1784 CD 8A 17      [17] 3719         CALL    CMPFP           ; Compare FP numbers
   1787 1F            [ 4] 3720         RRA                     ; Get carry to sign
   1788 A9            [ 4] 3721         XOR     C               ; Combine with MSB of number
   1789 C9            [10] 3722         RET                                   
                           3723 ;
   178A 23            [ 6] 3724 CMPFP:  INC     HL              ; Point to exponent
   178B 78            [ 4] 3725         LD      A,B             ; Get exponent
   178C BE            [ 7] 3726         CP      (HL)            ; Compare exponents
   178D C0            [11] 3727         RET     NZ              ; Different
   178E 2B            [ 6] 3728         DEC     HL              ; Point to MBS
   178F 79            [ 4] 3729         LD      A,C             ; Get MSB
   1790 BE            [ 7] 3730         CP      (HL)            ; Compare MSBs
   1791 C0            [11] 3731         RET     NZ              ; Different
   1792 2B            [ 6] 3732         DEC     HL              ; Point to NMSB
   1793 7A            [ 4] 3733         LD      A,D             ; Get NMSB
   1794 BE            [ 7] 3734         CP      (HL)            ; Compare NMSBs
   1795 C0            [11] 3735         RET     NZ              ; Different
   1796 2B            [ 6] 3736         DEC     HL              ; Point to LSB
   1797 7B            [ 4] 3737         LD      A,E             ; Get LSB
   1798 96            [ 7] 3738         SUB     (HL)            ; Compare LSBs
   1799 C0            [11] 3739         RET     NZ              ; Different
   179A E1            [10] 3740         POP     HL              ; Drop RETurn
   179B E1            [10] 3741         POP     HL              ; Drop another RETurn
   179C C9            [10] 3742         RET                                   
                           3743 ;
   179D 47            [ 4] 3744 FPINT:  LD      B,A             ; <- Move
   179E 4F            [ 4] 3745         LD      C,A             ; <- exponent
   179F 57            [ 4] 3746         LD      D,A             ; <- to all
   17A0 5F            [ 4] 3747         LD      E,A             ; <- bits
   17A1 B7            [ 4] 3748         OR      A               ; Test exponent
   17A2 C8            [11] 3749         RET     Z               ; Zero - Return zero
   17A3 E5            [11] 3750         PUSH    HL              ; Save pointer to number
   17A4 CD 41 17      [17] 3751         CALL    BCDEFP          ; Move FPREG to BCDE
   17A7 CD 5B 17      [17] 3752         CALL    SIGNS           ; Set MSBs & sign of result
   17AA AE            [ 7] 3753         XOR     (HL)            ; Combine with sign of FPREG
   17AB 67            [ 4] 3754         LD      H,A             ; Save combined signs
   17AC FC C1 17      [17] 3755         CALL    M,DCBCDE        ; Negative - Decrement BCDE
   17AF 3E 98         [ 7] 3756         LD      A,0x80+24       ; 24 bits
   17B1 90            [ 4] 3757         SUB     B               ; Bits to shift
   17B2 CD 5E 15      [17] 3758         CALL    SCALE           ; Shift BCDE
   17B5 7C            [ 4] 3759         LD      A,H             ; Get combined sign
   17B6 17            [ 4] 3760         RLA                     ; Sign to carry
   17B7 DC 31 15      [17] 3761         CALL    C,FPROND        ; Negative - Round number up
   17BA 06 00         [ 7] 3762         LD      B,0             ; Zero exponent
   17BC DC 4A 15      [17] 3763         CALL    C,COMPL         ; If negative make positive
   17BF E1            [10] 3764         POP     HL              ; Restore pointer to number
   17C0 C9            [10] 3765         RET                                   
                           3766 ;
   17C1 1B            [ 6] 3767 DCBCDE: DEC     DE              ; Decrement BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 70
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   17C2 7A            [ 4] 3768         LD      A,D             ; Test LSBs
   17C3 A3            [ 4] 3769         AND     E                              
   17C4 3C            [ 4] 3770         INC     A                              
   17C5 C0            [11] 3771         RET     NZ              ; Exit if LSBs not FFFF
   17C6 0B            [ 6] 3772         DEC     BC              ; Decrement MSBs
   17C7 C9            [10] 3773         RET                                   
                           3774 ;
   17C8 21 2C 81      [10] 3775 INT:    LD      HL,FPEXP        ; Point to exponent
   17CB 7E            [ 7] 3776         LD      A,(HL)          ; Get exponent
   17CC FE 98         [ 7] 3777         CP      0x80+24         ; Integer accuracy only?
   17CE 3A 29 81      [13] 3778         LD      A,(FPREG)       ; Get LSB
   17D1 D0            [11] 3779         RET     NC              ; Yes - Already integer
   17D2 7E            [ 7] 3780         LD      A,(HL)          ; Get exponent
   17D3 CD 9D 17      [17] 3781         CALL    FPINT           ; F.P to integer
   17D6 36 98         [10] 3782         LD      (HL),0x80+24    ; Save 24 bit integer
   17D8 7B            [ 4] 3783         LD      A,E             ; Get LSB of number
   17D9 F5            [11] 3784         PUSH    AF              ; Save LSB
   17DA 79            [ 4] 3785         LD      A,C             ; Get MSB of number
   17DB 17            [ 4] 3786         RLA                     ; Sign to carry
   17DC CD E9 14      [17] 3787         CALL    CONPOS          ; Set sign of result
   17DF F1            [10] 3788         POP     AF              ; Restore LSB of number
   17E0 C9            [10] 3789         RET                                   
                           3790 ;
   17E1 21 00 00      [10] 3791 MLDEBC: LD      HL,0            ; Clear partial product
   17E4 78            [ 4] 3792         LD      A,B             ; Test multiplier
   17E5 B1            [ 4] 3793         OR      C                              
   17E6 C8            [11] 3794         RET     Z               ; Return zero if zero
   17E7 3E 10         [ 7] 3795         LD      A,16            ; 16 bits
   17E9 29            [11] 3796 MLDBLP: ADD     HL,HL           ; Shift P.P left
   17EA DA F7 0F      [10] 3797         JP      C,BSERR         ; ?BS Error if overflow
   17ED EB            [ 4] 3798         EX      DE,HL                              
   17EE 29            [11] 3799         ADD     HL,HL           ; Shift multiplier left
   17EF EB            [ 4] 3800         EX      DE,HL                              
   17F0 D2 F7 17      [10] 3801         JP      NC,NOMLAD       ; Bit was zero - No add
   17F3 09            [11] 3802         ADD     HL,BC           ; Add multiplicand
   17F4 DA F7 0F      [10] 3803         JP      C,BSERR         ; ?BS Error if overflow
   17F7 3D            [ 4] 3804 NOMLAD: DEC     A               ; Count bits
   17F8 C2 E9 17      [10] 3805         JP      NZ,MLDBLP       ; More
   17FB C9            [10] 3806         RET                                   
                           3807 ;
q  17FC                    3808 ASCTFP: CP      '-'             ; Negative?
   17FC F5            [11] 3809         PUSH    AF              ; Save it and flags
   17FD CA 04 18      [10] 3810         JP      Z,CNVNUM        ; Yes - Convert number
q  1800                    3811         CP      '+'             ; Positive?
   1800 CA 04 18      [10] 3812         JP      Z,CNVNUM        ; Yes - Convert number
   1803 2B            [ 6] 3813         DEC     HL              ; DEC 'cos GETCHR INCs
   1804 CD 01 15      [17] 3814 CNVNUM: CALL    RESZER          ; Set result to zero
   1807 47            [ 4] 3815         LD      B,A             ; Digits after point counter
   1808 57            [ 4] 3816         LD      D,A             ; Sign of exponent
   1809 5F            [ 4] 3817         LD      E,A             ; Exponent of ten
   180A 2F            [ 4] 3818         CPL                                   
   180B 4F            [ 4] 3819         LD      C,A             ; Before or after point flag
   180C CD 5C 08      [17] 3820 MANLP:  CALL    GETCHR          ; Get next character
   180F DA 51 18      [10] 3821         JP      C,ADDIG         ; Digit - Add to number
q  1812                    3822         CP      '.'                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 71
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1812 CA 2C 18      [10] 3823         JP      Z,DPOINT        ; '.' - Flag point
q  1815                    3824         CP      'E'                              
   1815 C2 30 18      [10] 3825         JP      NZ,CONEXP       ; Not 'E' - Scale number
   1818 CD 5C 08      [17] 3826         CALL    GETCHR          ; Get next character
   181B CD 0B 0E      [17] 3827         CALL    SGNEXP          ; Get sign of exponent
   181E CD 5C 08      [17] 3828 EXPLP:  CALL    GETCHR          ; Get next character
   1821 DA 71 18      [10] 3829         JP      C,EDIGIT        ; Digit - Add to exponent
   1824 14            [ 4] 3830         INC     D               ; Is sign negative?
   1825 C2 30 18      [10] 3831         JP      NZ,CONEXP       ; No - Scale number
   1828 AF            [ 4] 3832         XOR     A                              
   1829 93            [ 4] 3833         SUB     E               ; Negate exponent
   182A 5F            [ 4] 3834         LD      E,A             ; And re-save it
   182B 0C            [ 4] 3835         INC     C               ; Flag end of number
   182C 0C            [ 4] 3836 DPOINT: INC     C               ; Flag point passed
   182D CA 0C 18      [10] 3837         JP      Z,MANLP         ; Zero - Get another digit
   1830 E5            [11] 3838 CONEXP: PUSH    HL              ; Save code string address
   1831 7B            [ 4] 3839         LD      A,E             ; Get exponent
   1832 90            [ 4] 3840         SUB     B               ; Subtract digits after point
   1833 F4 49 18      [17] 3841 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
   1836 F2 3F 18      [10] 3842         JP      P,ENDCON        ; Positive - All done
   1839 F5            [11] 3843         PUSH    AF              ; Save number of times to /10
   183A CD 30 16      [17] 3844         CALL    DIV10           ; Divide by 10
   183D F1            [10] 3845         POP     AF              ; Restore count
   183E 3C            [ 4] 3846         INC     A               ; Count divides
                           3847 ;
   183F C2 33 18      [10] 3848 ENDCON: JP      NZ,SCALMI       ; More to do
   1842 D1            [10] 3849         POP     DE              ; Restore code string address
   1843 F1            [10] 3850         POP     AF              ; Restore sign of number
   1844 CC 1E 17      [17] 3851         CALL    Z,INVSGN        ; Negative - Negate number
   1847 EB            [ 4] 3852         EX      DE,HL           ; Code string address to HL
   1848 C9            [10] 3853         RET                                   
                           3854 ;
   1849 C8            [11] 3855 SCALPL: RET     Z               ; Exit if no scaling needed
   184A F5            [11] 3856 MULTEN: PUSH    AF              ; Save count
   184B CD DE 16      [17] 3857         CALL    MLSP10          ; Multiply number by 10
   184E F1            [10] 3858         POP     AF              ; Restore count
   184F 3D            [ 4] 3859         DEC     A               ; Count multiplies
   1850 C9            [10] 3860         RET                                   
                           3861 ;
   1851 D5            [11] 3862 ADDIG:  PUSH    DE              ; Save sign of exponent
   1852 57            [ 4] 3863         LD      D,A             ; Save digit
   1853 78            [ 4] 3864         LD      A,B             ; Get digits after point
   1854 89            [ 4] 3865         ADC     A,C             ; Add one if after point
   1855 47            [ 4] 3866         LD      B,A             ; Re-save counter
   1856 C5            [11] 3867         PUSH    BC              ; Save point flags
   1857 E5            [11] 3868         PUSH    HL              ; Save code string address
   1858 D5            [11] 3869         PUSH    DE              ; Save digit
   1859 CD DE 16      [17] 3870         CALL    MLSP10          ; Multiply number by 10
   185C F1            [10] 3871         POP     AF              ; Restore digit
q  185D                    3872         SUB     '0'             ; Make it absolute
   185D CD 66 18      [17] 3873         CALL    RSCALE          ; Re-scale number
   1860 E1            [10] 3874         POP     HL              ; Restore code string address
   1861 C1            [10] 3875         POP     BC              ; Restore point flags
   1862 D1            [10] 3876         POP     DE              ; Restore sign of exponent
   1863 C3 0C 18      [10] 3877         JP      MANLP           ; Get another digit
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 72
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                           3878 ;
   1866 CD 26 17      [17] 3879 RSCALE: CALL    STAKFP          ; Put number on stack
   1869 CD 07 17      [17] 3880         CALL    FLGREL          ; Digit to add to FPREG
   186C C1            [10] 3881 PADD:   POP     BC              ; Restore number
   186D D1            [10] 3882         POP     DE                              
   186E C3 9B 14      [10] 3883         JP      FPADD           ; Add BCDE to FPREG and return
                           3884 ;
   1871 7B            [ 4] 3885 EDIGIT: LD      A,E             ; Get digit
   1872 07            [ 4] 3886         RLCA                    ; Times 2
   1873 07            [ 4] 3887         RLCA                    ; Times 4
   1874 83            [ 4] 3888         ADD     A,E             ; Times 5
   1875 07            [ 4] 3889         RLCA                    ; Times 10
   1876 86            [ 7] 3890         ADD     A,(HL)          ; Add next digit
q  1877                    3891         SUB     '0'             ; Make it absolute
   1877 5F            [ 4] 3892         LD      E,A             ; Save new digit
   1878 C3 1E 18      [10] 3893         JP      EXPLP           ; Look for another digit
                           3894 ;
   187B E5            [11] 3895 LINEIN: PUSH    HL              ; Save code string address
   187C 21 81 03      [10] 3896         LD      HL,INMSG        ; Output " in "
   187F CD CB 11      [17] 3897         CALL    PRS             ; Output string at HL
   1882 E1            [10] 3898         POP     HL              ; Restore code string address
   1883 EB            [ 4] 3899 PRNTHL: EX      DE,HL           ; Code string address to DE
   1884 AF            [ 4] 3900         XOR     A                              
   1885 06 98         [ 7] 3901         LD      B,0x80+24       ; 24 bits
   1887 CD 0C 17      [17] 3902         CALL    RETINT          ; Return the integer
   188A 21 CA 11      [10] 3903         LD      HL,PRNUMS       ; Print number string
   188D E5            [11] 3904         PUSH    HL              ; Save for return
   188E 21 2E 81      [10] 3905 NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
   1891 E5            [11] 3906         PUSH    HL              ; Save for return
   1892 CD F5 16      [17] 3907         CALL    TSTSGN          ; Test sign of FPREG
q  1895 36 20         [10] 3908         LD      (HL),' '        ; Space at start
   1897 F2 9C 18      [10] 3909         JP      P,SPCFST        ; Positive - Space to start
q  189A 36 2D         [10] 3910         LD      (HL),'-'        ; '-' sign at start
   189C 23            [ 6] 3911 SPCFST: INC     HL              ; First byte of number
q  189D 36 30         [10] 3912         LD      (HL),'0'        ; '0' if zero
   189F CA 4E 19      [10] 3913         JP      Z,JSTZER        ; Return '0' if zero
   18A2 E5            [11] 3914         PUSH    HL              ; Save buffer address
   18A3 FC 1E 17      [17] 3915         CALL    M,INVSGN        ; Negate FPREG if negative
   18A6 AF            [ 4] 3916         XOR     A               ; Zero A
   18A7 F5            [11] 3917         PUSH    AF              ; Save it
   18A8 CD 54 19      [17] 3918         CALL    RNGTST          ; Test number is in range
   18AB 01 43 91      [10] 3919 SIXDIG: LD      BC,0x9143       ; BCDE - 99999.9
   18AE 11 F8 4F      [10] 3920         LD      DE,0x4FF8                              
   18B1 CD 70 17      [17] 3921         CALL    CMPNUM          ; Compare numbers
   18B4 B7            [ 4] 3922         OR      A                              
   18B5 E2 C9 18      [10] 3923         JP      PO,INRNG        ; > 99999.9 - Sort it out
   18B8 F1            [10] 3924         POP     AF              ; Restore count
   18B9 CD 4A 18      [17] 3925         CALL    MULTEN          ; Multiply by ten
   18BC F5            [11] 3926         PUSH    AF              ; Re-save count
   18BD C3 AB 18      [10] 3927         JP      SIXDIG          ; Test it again
                           3928 ;
   18C0 CD 30 16      [17] 3929 GTSIXD: CALL    DIV10           ; Divide by 10
   18C3 F1            [10] 3930         POP     AF              ; Get count
   18C4 3C            [ 4] 3931         INC     A               ; Count divides
   18C5 F5            [11] 3932         PUSH    AF              ; Re-save count
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 73
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   18C6 CD 54 19      [17] 3933         CALL    RNGTST          ; Test number is in range
   18C9 CD 7C 14      [17] 3934 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
   18CC 3C            [ 4] 3935         INC     A                              
   18CD CD 9D 17      [17] 3936         CALL    FPINT           ; F.P to integer
   18D0 CD 36 17      [17] 3937         CALL    FPBCDE          ; Move BCDE to FPREG
   18D3 01 06 03      [10] 3938         LD      BC,0x0306       ; 1E+06 to 1E-03 range
   18D6 F1            [10] 3939         POP     AF              ; Restore count
   18D7 81            [ 4] 3940         ADD     A,C             ; 6 digits before point
   18D8 3C            [ 4] 3941         INC     A               ; Add one
   18D9 FA E5 18      [10] 3942         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
   18DC FE 08         [ 7] 3943         CP      6+1+1           ; More than 999999 ?
   18DE D2 E5 18      [10] 3944         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
   18E1 3C            [ 4] 3945         INC     A               ; Adjust for exponent
   18E2 47            [ 4] 3946         LD      B,A             ; Exponent of number
   18E3 3E 02         [ 7] 3947         LD      A,2             ; Make it zero after
                           3948 ;
   18E5 3D            [ 4] 3949 MAKNUM: DEC     A               ; Adjust for digits to do
   18E6 3D            [ 4] 3950         DEC     A                              
   18E7 E1            [10] 3951         POP     HL              ; Restore buffer address
   18E8 F5            [11] 3952         PUSH    AF              ; Save count
   18E9 11 66 19      [10] 3953         LD      DE,POWERS       ; Powers of ten
   18EC 05            [ 4] 3954         DEC     B               ; Count digits before point
   18ED C2 F6 18      [10] 3955         JP      NZ,DIGTXT       ; Not zero - Do number
q  18F0 36 2E         [10] 3956         LD      (HL),'.'        ; Save point
   18F2 23            [ 6] 3957         INC     HL              ; Move on
q  18F3 36 30         [10] 3958         LD      (HL),'0'        ; Save zero
   18F5 23            [ 6] 3959         INC     HL              ; Move on
   18F6 05            [ 4] 3960 DIGTXT: DEC     B               ; Count digits before point
q  18F7 36 2E         [10] 3961         LD      (HL),'.'        ; Save point in case
   18F9 CC 4B 17      [17] 3962         CALL    Z,INCHL         ; Last digit - move on
   18FC C5            [11] 3963         PUSH    BC              ; Save digits before point
   18FD E5            [11] 3964         PUSH    HL              ; Save buffer address
   18FE D5            [11] 3965         PUSH    DE              ; Save powers of ten
   18FF CD 41 17      [17] 3966         CALL    BCDEFP          ; Move FPREG to BCDE
   1902 E1            [10] 3967         POP     HL              ; Powers of ten table
q  1903 06 30         [ 7] 3968         LD      B,'0'-1         ; ASCII '0' - 1
   1905 04            [ 4] 3969 TRYAGN: INC     B               ; Count subtractions
   1906 7B            [ 4] 3970         LD      A,E             ; Get LSB
   1907 96            [ 7] 3971         SUB     (HL)            ; Subtract LSB
   1908 5F            [ 4] 3972         LD      E,A             ; Save LSB
   1909 23            [ 6] 3973         INC     HL                              
   190A 7A            [ 4] 3974         LD      A,D             ; Get NMSB
   190B 9E            [ 7] 3975         SBC     A,(HL)          ; Subtract NMSB
   190C 57            [ 4] 3976         LD      D,A             ; Save NMSB
   190D 23            [ 6] 3977         INC     HL                              
   190E 79            [ 4] 3978         LD      A,C             ; Get MSB
   190F 9E            [ 7] 3979         SBC     A,(HL)          ; Subtract MSB
   1910 4F            [ 4] 3980         LD      C,A             ; Save MSB
   1911 2B            [ 6] 3981         DEC     HL              ; Point back to start
   1912 2B            [ 6] 3982         DEC     HL                              
   1913 D2 05 19      [10] 3983         JP      NC,TRYAGN       ; No overflow - Try again
   1916 CD 3E 15      [17] 3984         CALL    PLUCDE          ; Restore number
   1919 23            [ 6] 3985         INC     HL              ; Start of next number
   191A CD 36 17      [17] 3986         CALL    FPBCDE          ; Move BCDE to FPREG
   191D EB            [ 4] 3987         EX      DE,HL           ; Save point in table
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 74
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   191E E1            [10] 3988         POP     HL              ; Restore buffer address
   191F 70            [ 7] 3989         LD      (HL),B          ; Save digit in buffer
   1920 23            [ 6] 3990         INC     HL              ; And move on
   1921 C1            [10] 3991         POP     BC              ; Restore digit count
   1922 0D            [ 4] 3992         DEC     C               ; Count digits
   1923 C2 F6 18      [10] 3993         JP      NZ,DIGTXT       ; More - Do them
   1926 05            [ 4] 3994         DEC     B               ; Any decimal part?
   1927 CA 32 19      [10] 3995         JP      Z,DOEBIT        ; No - Do 'E' bit
   192A 2B            [ 6] 3996 SUPTLZ: DEC     HL              ; Move back through buffer
   192B 7E            [ 7] 3997         LD      A,(HL)          ; Get character
q  192C                    3998         CP      '0'             ; '0' character?
   192C CA 2A 19      [10] 3999         JP      Z,SUPTLZ        ; Yes - Look back for more
q  192F                    4000         CP      '.'             ; A decimal point?
   192F C4 4B 17      [17] 4001         CALL    NZ,INCHL        ; Move back over digit
                           4002 ;
   1932 F1            [10] 4003 DOEBIT: POP     AF              ; Get 'E' flag
   1933 CA 51 19      [10] 4004         JP      Z,NOENED        ; No 'E' needed - End buffer
q  1936 36 45         [10] 4005         LD      (HL),'E'        ; Put 'E' in buffer
   1938 23            [ 6] 4006         INC     HL              ; And move on
q  1939 36 2B         [10] 4007         LD      (HL),'+'        ; Put '+' in buffer
   193B F2 42 19      [10] 4008         JP      P,OUTEXP        ; Positive - Output exponent
q  193E 36 2D         [10] 4009         LD      (HL),'-'        ; Put '-' in buffer
   1940 2F            [ 4] 4010         CPL                     ; Negate exponent
   1941 3C            [ 4] 4011         INC     A                              
q  1942 06 30         [ 7] 4012 OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
   1944 04            [ 4] 4013 EXPTEN: INC     B               ; Count subtractions
   1945 D6 0A         [ 7] 4014         SUB     10              ; Tens digit
   1947 D2 44 19      [10] 4015         JP      NC,EXPTEN       ; More to do
q  194A C6 30         [ 7] 4016         ADD     A,'0'+10        ; Restore and make ASCII
   194C 23            [ 6] 4017         INC     HL              ; Move on
   194D 70            [ 7] 4018         LD      (HL),B          ; Save MSB of exponent
   194E 23            [ 6] 4019 JSTZER: INC     HL              ;
   194F 77            [ 7] 4020         LD      (HL),A          ; Save LSB of exponent
   1950 23            [ 6] 4021         INC     HL                              
   1951 71            [ 7] 4022 NOENED: LD      (HL),C          ; Mark end of buffer
   1952 E1            [10] 4023         POP     HL              ; Restore code string address
   1953 C9            [10] 4024         RET                                   
                           4025 ;
   1954 01 74 94      [10] 4026 RNGTST: LD      BC,0x9474       ; BCDE = 999999.
   1957 11 F7 23      [10] 4027         LD      DE,0x23F7                              
   195A CD 70 17      [17] 4028         CALL    CMPNUM          ; Compare numbers
   195D B7            [ 4] 4029         OR      A                              
   195E E1            [10] 4030         POP     HL              ; Return address to HL
   195F E2 C0 18      [10] 4031         JP      PO,GTSIXD       ; Too big - Divide by ten
   1962 E9            [ 4] 4032         JP      (HL)            ; Otherwise return to caller
                           4033 ;
q  1963 00 00 00           4034 HALF:   .db     0x00,0x00,00H,80; 0.5
                           4035 ;
q  1966 A0 86 01           4036 POWERS: .db     0x0A0,0x086,001H; 100000
q  1969 10 27 00           4037         .db     0x010,0x027,000H; 10000
q  196C E8 03 00           4038         .db     0x0E8,0x003,000H; 1000
q  196F 64 00 00           4039         .db     0x064,0x000,000H; 100
q  1972 0A 00 00           4040         .db     0x00A,0x000,000H; 10
q  1975 01 00 00           4041         .db     0x001,0x000,000H; 1
                           4042 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 75
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1978 21 1E 17      [10] 4043 NEGAFT: LD      HL,INVSGN       ; Negate result
   197B E3            [19] 4044         EX      (SP),HL         ; To be done after caller
   197C E9            [ 4] 4045         JP      (HL)            ; Return to caller
                           4046 ;
   197D CD 26 17      [17] 4047 SQR:    CALL    STAKFP          ; Put value on stack
   1980 21 63 19      [10] 4048         LD      HL,HALF         ; Set power to 1/2
   1983 CD 33 17      [17] 4049         CALL    PHLTFP          ; Move 1/2 to FPREG
                           4050 ;
   1986 C1            [10] 4051 POWER:  POP     BC              ; Get base
   1987 D1            [10] 4052         POP     DE                              
   1988 CD F5 16      [17] 4053         CALL    TSTSGN          ; Test sign of power
   198B 78            [ 4] 4054         LD      A,B             ; Get exponent of base
   198C CA C9 19      [10] 4055         JP      Z,EXP           ; Make result 1 if zero
   198F F2 96 19      [10] 4056         JP      P,POWER1        ; Positive base - Ok
   1992 B7            [ 4] 4057         OR      A               ; Zero to negative power?
   1993 CA FA 03      [10] 4058         JP      Z,DZERR         ; Yes - ?/0 Error
   1996 B7            [ 4] 4059 POWER1: OR      A               ; Base zero?
   1997 CA 02 15      [10] 4060         JP      Z,SAVEXP        ; Yes - Return zero
   199A D5            [11] 4061         PUSH    DE              ; Save base
   199B C5            [11] 4062         PUSH    BC                              
   199C 79            [ 4] 4063         LD      A,C             ; Get MSB of base
kq 199D                    4064         OR      01111111B       ; Get sign status
   199D CD 41 17      [17] 4065         CALL    BCDEFP          ; Move power to BCDE
   19A0 F2 B1 19      [10] 4066         JP      P,POWER2        ; Positive base - Ok
   19A3 D5            [11] 4067         PUSH    DE              ; Save power
   19A4 C5            [11] 4068         PUSH    BC                              
   19A5 CD C8 17      [17] 4069         CALL    INT             ; Get integer of power
   19A8 C1            [10] 4070         POP     BC              ; Restore power
   19A9 D1            [10] 4071         POP     DE                              
   19AA F5            [11] 4072         PUSH    AF              ; MSB of base
   19AB CD 70 17      [17] 4073         CALL    CMPNUM          ; Power an integer?
   19AE E1            [10] 4074         POP     HL              ; Restore MSB of base
   19AF 7C            [ 4] 4075         LD      A,H             ; but don't affect flags
   19B0 1F            [ 4] 4076         RRA                     ; Exponent odd or even?
   19B1 E1            [10] 4077 POWER2: POP     HL              ; Restore MSB and exponent
   19B2 22 2B 81      [16] 4078         LD      (FPREG+2),HL    ; Save base in FPREG
   19B5 E1            [10] 4079         POP     HL              ; LSBs of base
   19B6 22 29 81      [16] 4080         LD      (FPREG),HL      ; Save in FPREG
   19B9 DC 78 19      [17] 4081         CALL    C,NEGAFT        ; Odd power - Negate result
   19BC CC 1E 17      [17] 4082         CALL    Z,INVSGN        ; Negative base - Negate it
   19BF D5            [11] 4083         PUSH    DE              ; Save power
   19C0 C5            [11] 4084         PUSH    BC                              
   19C1 CD 8F 15      [17] 4085         CALL    LOG             ; Get LOG of base
   19C4 C1            [10] 4086         POP     BC              ; Restore power
   19C5 D1            [10] 4087         POP     DE                              
   19C6 CD DD 15      [17] 4088         CALL    FPMULT          ; Multiply LOG by power
                           4089 ;
   19C9 CD 26 17      [17] 4090 EXP:    CALL    STAKFP          ; Put value on stack
   19CC 01 38 81      [10] 4091         LD      BC,0x08138      ; BCDE = 1/Ln(2)
   19CF 11 3B AA      [10] 4092         LD      DE,0x0AA3B                              
   19D2 CD DD 15      [17] 4093         CALL    FPMULT          ; Multiply value by 1/LN(2)
   19D5 3A 2C 81      [13] 4094         LD      A,(FPEXP)       ; Get exponent
   19D8 FE 88         [ 7] 4095         CP      0x80+8          ; Is it in range?
   19DA D2 D1 16      [10] 4096         JP      NC,OVTST1       ; No - Test for overflow
   19DD CD C8 17      [17] 4097         CALL    INT             ; Get INT of FPREG
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 76
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   19E0 C6 80         [ 7] 4098         ADD     A,0x80          ; For excess 128
   19E2 C6 02         [ 7] 4099         ADD     A,2             ; Exponent > 126?
   19E4 DA D1 16      [10] 4100         JP      C,OVTST1        ; Yes - Test for overflow
   19E7 F5            [11] 4101         PUSH    AF              ; Save scaling factor
   19E8 21 82 15      [10] 4102         LD      HL,UNITY        ; Point to 1.
   19EB CD 7F 14      [17] 4103         CALL    ADDPHL          ; Add 1 to FPREG
   19EE CD C7 15      [17] 4104         CALL    MULLN2          ; Multiply by LN(2)
   19F1 F1            [10] 4105         POP     AF              ; Restore scaling factor
   19F2 C1            [10] 4106         POP     BC              ; Restore exponent
   19F3 D1            [10] 4107         POP     DE                              
   19F4 F5            [11] 4108         PUSH    AF              ; Save scaling factor
   19F5 CD 98 14      [17] 4109         CALL    SUBCDE          ; Subtract exponent from FPREG
   19F8 CD 1E 17      [17] 4110         CALL    INVSGN          ; Negate result
   19FB 21 09 1A      [10] 4111         LD      HL,EXPTAB       ; Coefficient table
   19FE CD 31 1A      [17] 4112         CALL    SMSER1          ; Sum the series
   1A01 11 00 00      [10] 4113         LD      DE,0            ; Zero LSBs
   1A04 C1            [10] 4114         POP     BC              ; Scaling factor
   1A05 4A            [ 4] 4115         LD      C,D             ; Zero MSB
   1A06 C3 DD 15      [10] 4116         JP      FPMULT          ; Scale result to correct value
                           4117 ;
   1A09 08                 4118 EXPTAB: .db     8               ; Table used by EXP
q  1A0A 40 2E 5E           4119         .db     0x040,0x02E,094H; -1/7! (-1/5040)
kq 1A0D 70 4F 02           4120         .db     0x070,0x04F,02EH;  1/6! ( 1/720)
q  1A10 6E 02 58           4121         .db     0x06E,0x002,088H; -1/5! (-1/120)
kq 1A13 E6 A0 02           4122         .db     0x0E6,0x0A0,02AH;  1/4! ( 1/24)
kq 1A16 50 AA 00           4123         .db     0x050,0x0AA,0AAH; -1/3! (-1/6)
kq 1A19 FF FF 07           4124         .db     0x0FF,0x0FF,07FH;  1/2! ( 1/2)
q  1A1C 00 00 50           4125         .db     0x000,0x000,080H; -1/1! (-1/1)
q  1A1F 00 00 00           4126         .db     0x000,0x000,000H;  1/0! ( 1/1)
                           4127 ;
   1A22 CD 26 17      [17] 4128 SUMSER: CALL    STAKFP          ; Put FPREG on stack
   1A25 11 DB 15      [10] 4129         LD      DE,MULT         ; Multiply by "X"
   1A28 D5            [11] 4130         PUSH    DE              ; To be done after
   1A29 E5            [11] 4131         PUSH    HL              ; Save address of table
   1A2A CD 41 17      [17] 4132         CALL    BCDEFP          ; Move FPREG to BCDE
   1A2D CD DD 15      [17] 4133         CALL    FPMULT          ; Square the value
   1A30 E1            [10] 4134         POP     HL              ; Restore address of table
   1A31 CD 26 17      [17] 4135 SMSER1: CALL    STAKFP          ; Put value on stack
   1A34 7E            [ 7] 4136         LD      A,(HL)          ; Get number of coefficients
   1A35 23            [ 6] 4137         INC     HL              ; Point to start of table
   1A36 CD 33 17      [17] 4138         CALL    PHLTFP          ; Move coefficient to FPREG
   1A39 06                 4139         .db     0x06            ; Skip 
   1A3A 50 4F 50 20 41 46  4140         .ascii  "POP AF"                              
   1A40 F1            [10] 4141 SUMLP:  POP     AF              ; Restore count
   1A41 C1            [10] 4142         POP     BC              ; Restore number
   1A42 D1            [10] 4143         POP     DE                              
   1A43 3D            [ 4] 4144         DEC     A               ; Cont coefficients
   1A44 C8            [11] 4145         RET     Z               ; All done
   1A45 D5            [11] 4146         PUSH    DE              ; Save number
   1A46 C5            [11] 4147         PUSH    BC                              
   1A47 F5            [11] 4148         PUSH    AF              ; Save count
   1A48 E5            [11] 4149         PUSH    HL              ; Save address in table
   1A49 CD DD 15      [17] 4150         CALL    FPMULT          ; Multiply FPREG by BCDE
   1A4C E1            [10] 4151         POP     HL              ; Restore address in table
   1A4D CD 44 17      [17] 4152         CALL    LOADFP          ; Number at HL to BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 77
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1A50 E5            [11] 4153         PUSH    HL              ; Save address in table
   1A51 CD 9B 14      [17] 4154         CALL    FPADD           ; Add coefficient to FPREG
   1A54 E1            [10] 4155         POP     HL              ; Restore address in table
   1A55 C3 40 1A      [10] 4156         JP      SUMLP           ; More coefficients
                           4157 ;
   1A58 CD F5 16      [17] 4158 RND:    CALL    TSTSGN          ; Test sign of FPREG
   1A5B 21 5E 80      [10] 4159         LD      HL,SEED+2       ; Random number seed
   1A5E FA B3 1A      [10] 4160         JP      M,RESEED        ; Negative - Re-seed
   1A61 21 7F 80      [10] 4161         LD      HL,LSTRND       ; Last random number
   1A64 CD 33 17      [17] 4162         CALL    PHLTFP          ; Move last RND to FPREG
   1A67 21 5E 80      [10] 4163         LD      HL,SEED+2       ; Random number seed
   1A6A C8            [11] 4164         RET     Z               ; Return if RND(0)
   1A6B 86            [ 7] 4165         ADD     A,(HL)          ; Add (SEED)+2)
kq 1A6C                    4166         AND     00000111B       ; 0 to 7
   1A6C 06 00         [ 7] 4167         LD      B,0                              
   1A6E 77            [ 7] 4168         LD      (HL),A          ; Re-save seed
   1A6F 23            [ 6] 4169         INC     HL              ; Move to coefficient table
   1A70 87            [ 4] 4170         ADD     A,A             ; 4 bytes
   1A71 87            [ 4] 4171         ADD     A,A             ; per entry
   1A72 4F            [ 4] 4172         LD      C,A             ; BC = Offset into table
   1A73 09            [11] 4173         ADD     HL,BC           ; Point to coefficient
   1A74 CD 44 17      [17] 4174         CALL    LOADFP          ; Coefficient to BCDE
   1A77 CD DD 15      [17] 4175         CALL    FPMULT          ;	; Multiply FPREG by coefficient
   1A7A 3A 5D 80      [13] 4176         LD      A,(SEED+1)      ; Get (SEED+1)
   1A7D 3C            [ 4] 4177         INC     A               ; Add 1
kq 1A7E                    4178         AND     00000011B       ; 0 to 3
   1A7E 06 00         [ 7] 4179         LD      B,0                              
   1A80 FE 01         [ 7] 4180         CP      1               ; Is it zero?
   1A82 88            [ 4] 4181         ADC     A,B             ; Yes - Make it 1
   1A83 32 5D 80      [13] 4182         LD      (SEED+1),A      ; Re-save seed
   1A86 21 B7 1A      [10] 4183         LD      HL,RNDTAB-4     ; Addition table
   1A89 87            [ 4] 4184         ADD     A,A             ; 4 bytes
   1A8A 87            [ 4] 4185         ADD     A,A             ; per entry
   1A8B 4F            [ 4] 4186         LD      C,A             ; BC = Offset into table
   1A8C 09            [11] 4187         ADD     HL,BC           ; Point to value
   1A8D CD 7F 14      [17] 4188         CALL    ADDPHL          ; Add value to FPREG
   1A90 CD 41 17      [17] 4189 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
   1A93 7B            [ 4] 4190         LD      A,E             ; Get LSB
   1A94 59            [ 4] 4191         LD      E,C             ; LSB = MSB
kq 1A95                    4192         XOR     01001111B       ; Fiddle around
   1A95 4F            [ 4] 4193         LD      C,A             ; New MSB
   1A96 36 80         [10] 4194         LD      (HL),0x80       ; Set exponent
   1A98 2B            [ 6] 4195         DEC     HL              ; Point to MSB
   1A99 46            [ 7] 4196         LD      B,(HL)          ; Get MSB
   1A9A 36 80         [10] 4197         LD      (HL),0x80       ; Make value -0.5
   1A9C 21 5C 80      [10] 4198         LD      HL,SEED         ; Random number seed
   1A9F 34            [11] 4199         INC     (HL)            ; Count seed
   1AA0 7E            [ 7] 4200         LD      A,(HL)          ; Get seed
   1AA1 D6 AB         [ 7] 4201         SUB     171             ; Do it modulo 171
   1AA3 C2 AA 1A      [10] 4202         JP      NZ,RND2         ; Non-zero - Ok
   1AA6 77            [ 7] 4203         LD      (HL),A          ; Zero seed
   1AA7 0C            [ 4] 4204         INC     C               ; Fillde about
   1AA8 15            [ 4] 4205         DEC     D               ; with the
   1AA9 1C            [ 4] 4206         INC     E               ; number
   1AAA CD EC 14      [17] 4207 RND2:   CALL    BNORM           ; Normalise number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 78
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1AAD 21 7F 80      [10] 4208         LD      HL,LSTRND       ; Save random number
   1AB0 C3 4D 17      [10] 4209         JP      FPTHL           ; Move FPREG to last and return
                           4210 ;
   1AB3 77            [ 7] 4211 RESEED: LD      (HL),A          ; Re-seed random numbers
   1AB4 2B            [ 6] 4212         DEC     HL                              
   1AB5 77            [ 7] 4213         LD      (HL),A                              
   1AB6 2B            [ 6] 4214         DEC     HL                              
   1AB7 77            [ 7] 4215         LD      (HL),A                              
   1AB8 C3 90 1A      [10] 4216         JP      RND1            ; Return RND seed
                           4217 ;
q  1ABB 68 B1 2E           4218 RNDTAB: .db     0x068,0x0B1,046H; Table used by RND
q  1ABE 99 E9 5C           4219         .db     0x099,0x0E9,092H,069H                              
q  1AC1 10 D1 4B           4220         .db     0x010,0x0D1,075H,068H                              
                           4221 ;
   1AC4 21 0E 1B      [10] 4222 COS:    LD      HL,HALFPI       ; Point to PI/2
   1AC7 CD 7F 14      [17] 4223         CALL    ADDPHL          ; Add it to PPREG
   1ACA CD 26 17      [17] 4224 SIN:    CALL    STAKFP          ; Put angle on stack
   1ACD 01 49 83      [10] 4225         LD      BC,0x8349       ; BCDE = 2 PI
   1AD0 11 DB 0F      [10] 4226         LD      DE,0x0FDB                              
   1AD3 CD 36 17      [17] 4227         CALL    FPBCDE          ; Move 2 PI to FPREG
   1AD6 C1            [10] 4228         POP     BC              ; Restore angle
   1AD7 D1            [10] 4229         POP     DE                              
   1AD8 CD 3E 16      [17] 4230         CALL    DVBCDE          ; Divide angle by 2 PI
   1ADB CD 26 17      [17] 4231         CALL    STAKFP          ; Put it on stack
   1ADE CD C8 17      [17] 4232         CALL    INT             ; Get INT of result
   1AE1 C1            [10] 4233         POP     BC              ; Restore number
   1AE2 D1            [10] 4234         POP     DE                              
   1AE3 CD 98 14      [17] 4235         CALL    SUBCDE          ; Make it 0 <= value < 1
   1AE6 21 11 1B      [10] 4236         LD      HL,QUARTR       ; Point to 0.25
   1AE9 CD 85 14      [17] 4237         CALL    SUBPHL          ; Subtract value from 0.25
   1AEC CD F5 16      [17] 4238         CALL    TSTSGN          ; Test sign of value
   1AEF 37            [ 4] 4239         SCF                     ; Flag positive
   1AF0 F2 FA 1A      [10] 4240         JP      P,SIN1          ; Positive - Ok
   1AF3 CD 7C 14      [17] 4241         CALL    ROUND           ; Add 0.5 to value
   1AF6 CD F5 16      [17] 4242         CALL    TSTSGN          ; Test sign of value
   1AF9 B7            [ 4] 4243         OR      A               ; Flag negative
   1AFA F5            [11] 4244 SIN1:   PUSH    AF              ; Save sign
   1AFB F4 1E 17      [17] 4245         CALL    P,INVSGN        ; Negate value if positive
   1AFE 21 11 1B      [10] 4246         LD      HL,QUARTR       ; Point to 0.25
   1B01 CD 7F 14      [17] 4247         CALL    ADDPHL          ; Add 0.25 to value
   1B04 F1            [10] 4248         POP     AF              ; Restore sign
   1B05 D4 1E 17      [17] 4249         CALL    NC,INVSGN       ; Negative - Make positive
   1B08 21 14 1B      [10] 4250         LD      HL,SINTAB       ; Coefficient table
   1B0B C3 22 1A      [10] 4251         JP      SUMSER          ; Evaluate sum of series
                           4252 ;
q  1B0E DB 0F 31           4253 HALFPI: .db     0x0DB,0x00F,049H; 1.5708 (PI/2)
                           4254 ;
q  1B11 00 00 00           4255 QUARTR: .db     0x000,0x000,000H; 0.25
                           4256 ;
   1B14 05                 4257 SINTAB: .db     5               ; Table used by SIN
kq 1B15 BA D7 01           4258         .db     0x0BA,0x0D7,01EH; 39.711
q  1B18 64 26 63           4259         .db     0x064,0x026,099H;-76.575
q  1B1B 58 34 17           4260         .db     0x058,0x034,023H; 81.602
kq 1B1E E0 5D 00           4261         .db     0x0E0,0x05D,0A5H;-41.342
q  1B21 DA 0F 31           4262         .db     0x0DA,0x00F,049H; 6.2832
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 79
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



                           4263 ;
   1B24 CD 26 17      [17] 4264 TAN:    CALL    STAKFP          ; Put angle on stack
   1B27 CD CA 1A      [17] 4265         CALL    SIN             ; Get SIN of angle
   1B2A C1            [10] 4266         POP     BC              ; Restore angle
   1B2B E1            [10] 4267         POP     HL                              
   1B2C CD 26 17      [17] 4268         CALL    STAKFP          ; Save SIN of angle
   1B2F EB            [ 4] 4269         EX      DE,HL           ; BCDE = Angle
   1B30 CD 36 17      [17] 4270         CALL    FPBCDE          ; Angle to FPREG
   1B33 CD C4 1A      [17] 4271         CALL    COS             ; Get COS of angle
   1B36 C3 3C 16      [10] 4272         JP      DIV             ; TAN = SIN / COS
                           4273 ;
   1B39 CD F5 16      [17] 4274 ATN:    CALL    TSTSGN          ; Test sign of value
   1B3C FC 78 19      [17] 4275         CALL    M,NEGAFT        ; Negate result after if -ve
   1B3F FC 1E 17      [17] 4276         CALL    M,INVSGN        ; Negate value if -ve
   1B42 3A 2C 81      [13] 4277         LD      A,(FPEXP)       ; Get exponent
   1B45 FE 81         [ 7] 4278         CP      0x81            ; Number less than 1?
   1B47 DA 56 1B      [10] 4279         JP      C,ATN1          ; Yes - Get arc tangnt
   1B4A 01 00 81      [10] 4280         LD      BC,0x8100       ; BCDE = 1
   1B4D 51            [ 4] 4281         LD      D,C                              
   1B4E 59            [ 4] 4282         LD      E,C                              
   1B4F CD 3E 16      [17] 4283         CALL    DVBCDE          ; Get reciprocal of number
   1B52 21 85 14      [10] 4284         LD      HL,SUBPHL       ; Sub angle from PI/2
   1B55 E5            [11] 4285         PUSH    HL              ; Save for angle > 1
   1B56 21 60 1B      [10] 4286 ATN1:   LD      HL,ATNTAB       ; Coefficient table
   1B59 CD 22 1A      [17] 4287         CALL    SUMSER          ; Evaluate sum of series
   1B5C 21 0E 1B      [10] 4288         LD      HL,HALFPI       ; PI/2 - angle in case > 1
   1B5F C9            [10] 4289         RET                     ; Number > 1 - Sub from PI/2
                           4290 ;
   1B60 09                 4291 ATNTAB: .db     9               ; Table used by ATN
kq 1B61 4A D7 03           4292         .db     0x04A,0x0D7,03BH; 1/17
q  1B64 02 6E 54           4293         .db     0x002,0x06E,084H;-1/15
kq 1B67 FE C1 02           4294         .db     0x0FE,0x0C1,02FH; 1/13
kq 1B6A 74 31 09           4295         .db     0x074,0x031,09AH;-1/11
kq 1B6D 84 3D 05           4296         .db     0x084,0x03D,05AH; 1/9
q  1B70 C8 7F 5B           4297         .db     0x0C8,0x07F,091H;-1/7
kq 1B73 E4 BB 04           4298         .db     0x0E4,0x0BB,04CH; 1/5
kq 1B76 6C AA 00           4299         .db     0x06C,0x0AA,0AAH;-1/3
q  1B79 00 00 00           4300         .db     0x000,0x000,000H; 1/1
                           4301 ;
                           4302 
   1B7C C9            [10] 4303 ARET:   RET                     ; A RETurn instruction
                           4304 ;
   1B7D D7            [11] 4305 GETINP: RST     0x10            ;input a character
   1B7E C9            [10] 4306         RET                                   
                           4307 ;
   1B7F                    4308 CLS:                                          
   1B7F 3E 0C         [ 7] 4309         LD      A,CS            ; ASCII Clear screen
   1B81 C3 99 1C      [10] 4310         JP      MONOUT          ; Output character
                           4311 ;
   1B84 CD 53 14      [17] 4312 WIDTH:  CALL    GETINT          ; Get integer 0-255
   1B87 7B            [ 4] 4313         LD      A,E             ; Width to A
   1B88 32 87 80      [13] 4314         LD      (LWIDTH),A      ; Set width
   1B8B C9            [10] 4315         RET                                   
                           4316 ;
   1B8C CD DC 0C      [17] 4317 LINES:  CALL    GETNUM          ; Get a number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 80
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1B8F CD 10 09      [17] 4318         CALL    DEINT           ; Get integer -32768 to 32767
   1B92 ED 53 8B 80   [20] 4319         LD      (LINESC),DE     ; Set lines counter
   1B96 ED 53 8D 80   [20] 4320         LD      (LINESN),DE     ; Set lines number
   1B9A C9            [10] 4321         RET                                   
                           4322 ;
   1B9B CD 10 09      [17] 4323 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
   1B9E D5            [11] 4324         PUSH    DE              ; Save number
   1B9F E1            [10] 4325         POP     HL              ; Number to HL
   1BA0 46            [ 7] 4326         LD      B,(HL)          ; Get LSB of contents
   1BA1 23            [ 6] 4327         INC     HL                              
   1BA2 7E            [ 7] 4328         LD      A,(HL)          ; Get MSB of contents
   1BA3 C3 AA 10      [10] 4329         JP      ABPASS          ; Return integer AB
                           4330 ;
   1BA6 CD DC 0C      [17] 4331 DOKE:   CALL    GETNUM          ; Get a number
   1BA9 CD 10 09      [17] 4332         CALL    DEINT           ; Get integer -32768 to 32767
   1BAC D5            [11] 4333         PUSH    DE              ; Save address
   1BAD CD D7 06      [17] 4334         CALL    CHKSYN          ; Make sure ',' follows
q  1BB0 2C                 4335         .db     ','                              
   1BB1 CD DC 0C      [17] 4336         CALL    GETNUM          ; Get a number
   1BB4 CD 10 09      [17] 4337         CALL    DEINT           ; Get integer -32768 to 32767
   1BB7 E3            [19] 4338         EX      (SP),HL         ; Save value,get address
   1BB8 73            [ 7] 4339         LD      (HL),E          ; Save LSB of value
   1BB9 23            [ 6] 4340         INC     HL                              
   1BBA 72            [ 7] 4341         LD      (HL),D          ; Save MSB of value
   1BBB E1            [10] 4342         POP     HL              ; Restore code string address
   1BBC C9            [10] 4343         RET                                   
                           4344 ;
                           4345 
                           4346 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                           4347 ;
   1BBD CD DF 0C      [17] 4348 HEX:    CALL    TSTNUM          ; Verify it's a number
   1BC0 CD 10 09      [17] 4349         CALL    DEINT           ; Get integer -32768 to 32767
   1BC3 C5            [11] 4350         PUSH    BC              ; Save contents of BC
   1BC4 21 2E 81      [10] 4351         LD      HL,PBUFF                              
   1BC7 7A            [ 4] 4352         LD      A,D             ; Get high order into A
   1BC8 FE 00         [ 7] 4353         CP      0                              
   1BCA 28 0A         [12] 4354         JR      Z,HEX2          ; Skip output if both high digits are zero
u  1BCC CD 00 00      [17] 4355         CALL    BYT2ASC         ; Convert D to ASCII
   1BCF 78            [ 4] 4356         LD      A,B                              
q  1BD0                    4357         CP      '0'                              
   1BD0 28 02         [12] 4358         JR      Z,HEX1          ; Don't store high digit if zero
   1BD2 70            [ 7] 4359         LD      (HL),B          ; Store it to PBUFF
   1BD3 23            [ 6] 4360         INC     HL              ; Next location
   1BD4 71            [ 7] 4361 HEX1:   LD      (HL),C          ; Store C to PBUFF+1
   1BD5 23            [ 6] 4362         INC     HL              ; Next location
   1BD6 7B            [ 4] 4363 HEX2:   LD      A,E             ; Get lower byte
u  1BD7 CD 00 00      [17] 4364         CALL    BYT2ASC         ; Convert E to ASCII
   1BDA 7A            [ 4] 4365         LD      A,D                              
   1BDB FE 00         [ 7] 4366         CP      0                              
   1BDD 20 03         [12] 4367         JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
   1BDF 78            [ 4] 4368         LD      A,B                              
q  1BE0                    4369         CP      '0'             ; If high digit of lower byte is zero then don't print
   1BE0 28 02         [12] 4370         JR      Z,HEX4                              
   1BE2 70            [ 7] 4371 HEX3:   LD      (HL),B          ; to PBUFF+2
   1BE3 23            [ 6] 4372         INC     HL              ; Next location
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 81
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1BE4 71            [ 7] 4373 HEX4:   LD      (HL),C          ; to PBUFF+3
   1BE5 23            [ 6] 4374         INC     HL              ; PBUFF+4 to zero
   1BE6 AF            [ 4] 4375         XOR     A               ; Terminating character
   1BE7 77            [ 7] 4376         LD      (HL),A          ; Store zero to terminate
   1BE8 23            [ 6] 4377         INC     HL              ; Make sure PBUFF is terminated
   1BE9 77            [ 7] 4378         LD      (HL),A          ; Store the double zero there
   1BEA C1            [10] 4379         POP     BC              ; Get BC back
   1BEB 21 2E 81      [10] 4380         LD      HL,PBUFF        ; Reset to start of PBUFF
   1BEE C3 5D 11      [10] 4381         JP      STR1            ; Convert the PBUFF to a string and return it
                           4382 ;
o  1BF1                    4383 BYT2ASC LD      B,A             ; Save original value
   1BF1 E6 0F         [ 7] 4384         AND     0x0F            ; Strip off upper nybble
   1BF3 FE 0A         [ 7] 4385         CP      0x0A            ; 0-9?
u  1BF5 38 00         [12] 4386         JR      C,ADD30         ; If A-F, add 7 more
   1BF7 C6 07         [ 7] 4387         ADD     A,0x07          ; Bring value up to ASCII A-F
o  1BF9                    4388 ADD30   ADD     A,0x30          ; And make ASCII
   1BF9 4F            [ 4] 4389         LD      C,A             ; Save converted char to C
   1BFA 78            [ 4] 4390         LD      A,B             ; Retrieve original value
   1BFB 0F            [ 4] 4391         RRCA                    ; and Rotate it right
   1BFC 0F            [ 4] 4392         RRCA                                  
   1BFD 0F            [ 4] 4393         RRCA                                  
   1BFE 0F            [ 4] 4394         RRCA                                  
   1BFF E6 0F         [ 7] 4395         AND     0x0F            ; Mask off upper nybble
   1C01 FE 0A         [ 7] 4396         CP      0x0A            ; 0-9? < A hex?
u  1C03 38 00         [12] 4397         JR      C,ADD301        ; Skip Add 7
   1C05 C6 07         [ 7] 4398         ADD     A,0x07          ; Bring it up to ASCII A-F
o  1C07                    4399 ADD301  ADD     A,0x30          ; And make it full ASCII
   1C07 47            [ 4] 4400         LD      B,A             ; Store high order byte
   1C08 C9            [10] 4401         RET                                   
                           4402 ;
                           4403 ; Convert "&Hnnnn" to FPREG
                           4404 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                           4405 ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
o  1C09                    4406 HEXTFP  EX      DE,HL           ; Move code string pointer to DE
   1C09 21 00 00      [10] 4407         LD      HL,0x0000       ; Zero out the value
u  1C0C CD 00 00      [17] 4408         CALL    GETHEX          ; Check the number for valid hex
   1C0F DA 37 1C      [10] 4409         JP      C,HXERR         ; First value wasn't hex, HX error
u  1C12 18 00         [12] 4410         JR      HEXLP1          ; Convert first character
o  1C14                    4411 HEXLP   CALL    GETHEX          ; Get second and addtional characters
u  1C14 38 00         [12] 4412         JR      C,HEXIT         ; Exit if not a hex character
o  1C16                    4413 HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
   1C16 29            [11] 4414         ADD     HL,HL                              
   1C17 29            [11] 4415         ADD     HL,HL                              
   1C18 29            [11] 4416         ADD     HL,HL                              
   1C19 B5            [ 4] 4417         OR      L               ; Add in D0-D3 into L
   1C1A 6F            [ 4] 4418         LD      L,A             ; Save new value
u  1C1B 18 00         [12] 4419         JR      HEXLP           ; And continue until all hex characters are in
                           4420 ;
o  1C1D                    4421 GETHEX  INC     DE              ; Next location
   1C1D 1A            [ 7] 4422         LD      A,(DE)          ; Load character at pointer
q  1C1E                    4423         CP      ' '                              
u  1C1E CA 00 00      [10] 4424         JP      Z,GETHEX        ; Skip spaces
   1C21 D6 30         [ 7] 4425         SUB     0x30            ; Get absolute value
   1C23 D8            [11] 4426         RET     C               ; < "0", error
   1C24 FE 0A         [ 7] 4427         CP      0x0A                              
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 82
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



u  1C26 38 00         [12] 4428         JR      C,NOSUB7        ; Is already in the range 0-9
   1C28 D6 07         [ 7] 4429         SUB     0x07            ; Reduce to A-F
   1C2A FE 0A         [ 7] 4430         CP      0x0A            ; Value should be $0A-$0F at this point
   1C2C D8            [11] 4431         RET     C               ; CY set if was :		; < = > ? @
o  1C2D                    4432 NOSUB7  CP      0x10            ; > Greater than "F"?
   1C2D 3F            [ 4] 4433         CCF                                   
   1C2E C9            [10] 4434         RET                     ; CY set if it wasn't valid hex
                           4435                                               
o  1C2F                    4436 HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
   1C2F 7A            [ 4] 4437         LD      A,D             ; Load DE into AC
   1C30 4B            [ 4] 4438         LD      C,E             ; For prep to 
   1C31 E5            [11] 4439         PUSH    HL                              
   1C32 CD A9 10      [17] 4440         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
   1C35 E1            [10] 4441         POP     HL                              
   1C36 C9            [10] 4442         RET                                   
                           4443 ;
   1C37 1E 26         [ 7] 4444 HXERR:  LD      E,HX            ; ?HEX Error
   1C39 C3 2E 04      [10] 4445         JP      ERROR                              
                           4446 ;
                           4447 ; BIN$(NN) Convert integer to a 1-16 char binary string
   1C3C CD DF 0C      [17] 4448 BIN:    CALL    TSTNUM          ; Verify it's a number
   1C3F CD 10 09      [17] 4449         CALL    DEINT           ; Get integer -32768 to 32767
   1C42 C5            [11] 4450 BIN2:   PUSH    BC              ; Save contents of BC
   1C43 21 2E 81      [10] 4451         LD      HL,PBUFF                              
   1C46 06 11         [ 7] 4452         LD      B,17            ; One higher than max char count
   1C48                    4453 ZEROSUP:                        ; Suppress leading zeros
   1C48 05            [ 4] 4454         DEC     B               ; Max 16 chars
   1C49 78            [ 4] 4455         LD      A,B                              
   1C4A FE 01         [ 7] 4456         CP      0x01                              
   1C4C 28 08         [12] 4457         JR      Z,BITOUT        ; Always output at least one character
   1C4E CB 13         [ 8] 4458         RL      E                              
   1C50 CB 12         [ 8] 4459         RL      D                              
   1C52 30 F4         [12] 4460         JR      NC,ZEROSUP                              
   1C54 18 04         [12] 4461         JR      BITOUT2                              
   1C56                    4462 BITOUT:                                       
   1C56 CB 13         [ 8] 4463         RL      E                              
   1C58 CB 12         [ 8] 4464         RL      D               ; Top bit now in carry
   1C5A                    4465 BITOUT2:                                      
q  1C5A 3E 30         [ 7] 4466         LD      A,'0'           ; Char for '0'
   1C5C CE 00         [ 7] 4467         ADC     A,0             ; If carry set then '0' --> '1'
   1C5E 77            [ 7] 4468         LD      (HL),A                              
   1C5F 23            [ 6] 4469         INC     HL                              
   1C60 05            [ 4] 4470         DEC     B                              
   1C61 20 F3         [12] 4471         JR      NZ,BITOUT                              
   1C63 AF            [ 4] 4472         XOR     A               ; Terminating character
   1C64 77            [ 7] 4473         LD      (HL),A          ; Store zero to terminate
   1C65 23            [ 6] 4474         INC     HL              ; Make sure PBUFF is terminated
   1C66 77            [ 7] 4475         LD      (HL),A          ; Store the double zero there
   1C67 C1            [10] 4476         POP     BC                              
   1C68 21 2E 81      [10] 4477         LD      HL,PBUFF                              
   1C6B C3 5D 11      [10] 4478         JP      STR1                              
                           4479 ;
                           4480 ; Convert "&Bnnnn" to FPREG
                           4481 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
   1C6E EB            [ 4] 4482 BINTFP: EX      DE,HL           ; Move code string pointer to DE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 83
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025



   1C6F 21 00 00      [10] 4483         LD      HL,0x0000       ; Zero out the value
   1C72 CD 89 1C      [17] 4484         CALL    CHKBIN          ; Check the number for valid bin
   1C75 DA 91 1C      [10] 4485         JP      C,BINERR        ; First value wasn't bin, HX error
q  1C78                    4486 BINIT:  SUB     '0'                              
   1C78 29            [11] 4487         ADD     HL,HL           ; Rotate HL left
   1C79 B5            [ 4] 4488         OR      L                              
   1C7A 6F            [ 4] 4489         LD      L,A                              
   1C7B CD 89 1C      [17] 4490         CALL    CHKBIN          ; Get second and addtional characters
   1C7E 30 F8         [12] 4491         JR      NC,BINIT        ; Process if a bin character
   1C80 EB            [ 4] 4492         EX      DE,HL           ; Value into DE, Code string into HL
   1C81 7A            [ 4] 4493         LD      A,D             ; Load DE into AC
   1C82 4B            [ 4] 4494         LD      C,E             ; For prep to 
   1C83 E5            [11] 4495         PUSH    HL                              
   1C84 CD A9 10      [17] 4496         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
   1C87 E1            [10] 4497         POP     HL                              
   1C88 C9            [10] 4498         RET                                   
                           4499 ;
                           4500 ; Char is in A, NC if char is 0 or 1
   1C89 13            [ 6] 4501 CHKBIN: INC     DE                              
   1C8A 1A            [ 7] 4502         LD      A,(DE)                              
q  1C8B                    4503         CP      ' '                              
   1C8B CA 89 1C      [10] 4504         JP      Z,CHKBIN        ; Skip spaces
q  1C8E                    4505         CP      '0'             ; Set C if < '0'
   1C8E D8            [11] 4506         RET     C                              
q  1C8F                    4507         CP      '2'                              
   1C8F 3F            [ 4] 4508         CCF                     ; Set C if > '1'
   1C90 C9            [10] 4509         RET                                   
                           4510 ;
   1C91 1E 28         [ 7] 4511 BINERR: LD      E,BN            ; ?BIN Error
   1C93 C3 2E 04      [10] 4512         JP      ERROR                              
                           4513 ;
   1C96 C3 4D 00      [10] 4514 JJUMP1: JP      CSTART          ; Go and initialise
                           4515 ;
   1C99 C3 08 00      [10] 4516 MONOUT: JP      0x0008          ; output a char
                           4517 ;
   1C9C C3 00 00      [10] 4518 MONITR: JP      0x0000          ; Restart (Normally Monitor Start)
                           4519 ;
   1C9F 3E 00         [ 7] 4520 INITST: LD      A,0             ; Clear break flag
   1CA1 32 92 80      [13] 4521         LD      (BRKFLG),A                              
   1CA4 C3 54 00      [10] 4522         JP      INIT                              
                           4523 ;
   1CA7 F5            [11] 4524 TSTBIT: PUSH    AF              ; Save bit mask
   1CA8 A0            [ 4] 4525         AND     B               ; Get common bits
   1CA9 C1            [10] 4526         POP     BC              ; Restore bit mask
   1CAA B8            [ 4] 4527         CP      B               ; Same bit set?
   1CAB 3E 00         [ 7] 4528         LD      A,0             ; Return 0 in A
   1CAD C9            [10] 4529         RET                                   
                           4530 ;
   1CAE CD E2 06      [17] 4531 OUTNCR: CALL    OUTC            ; Output character in A
   1CB1 C3 16 0B      [10] 4532         JP      PRCRLF          ; Output CRLF
                           4533 ;
                           4534         END                                   
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 84
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Symbol Table

    $                  **** X   |     .__.$$$.       =   2710 L
    .__.ABS.       =   0000 G   |     .__.CPU.       =   0000 L
    .__.H$L.       =   0000 L   |   2 ABPASS             10AA R
  2 ABS                171A R   |   2 ACCSUM             08F3 R
  2 ACPASS             10A9 R   |     ADD30              **** X
    ADD301             **** X   |   2 ADDEXP             16B3 R
  2 ADDIG              1851 R   |   2 ADDPHL             147F R
  2 ALLFOL             1381 R   |   2 ANTVLU             0C06 R
  2 ARET               1B7C R   |   2 ARLDSV             0FBB R
    ARREND         =   811F     |   2 ARRLP              1246 R
  2 ASC                134C R   |   2 ASCTFP             17FC R
  2 ASPCS              0B61 R   |   2 ATN                1B39 R
  2 ATN1               1B56 R   |   2 ATNTAB             1B60 R
  2 ATOH               092A R   |   2 BADINP             0B86 R
  2 BAKSTK             0392 R   |   2 BAKTMP             132C R
    BASTXT         =   80A3     |   2 BCDEFP             1741 R
  2 BFREE              00CB R   |   2 BIN                1C3C R
  2 BIN2               1C42 R   |   2 BINERR             1C91 R
  2 BINIT              1C78 R   |   2 BINTFP             1C6E R
  2 BITOUT             1C56 R   |   2 BITOUT2            1C5A R
    BKSP           =   0008     |     BN             =   0028 
  2 BNORM              14EC R   |   2 BNRMLP             14EF R
    BRK                **** X   |     BRKFLG         =   8092 
    BRKLIN         =   8113     |   2 BRKMSG             038C R
  2 BRKRET             00BC R   |     BS             =   0010 
  2 BSERR              0FF7 R   |     BUFFER         =   80A6 
    BYT2ASC            **** X   |   2 BYTSFT             162B R
  2 CFEVAL             0F44 R   |   2 CHARTY             0EF6 R
  2 CHEKFN             1143 R   |   2 CHKBIN             1C89 R
  2 CHKLTR             0900 R   |   2 CHKSTK             03C6 R
    CHKSUM         =   808F     |   2 CHKSYN             06D7 R
  2 CHKTYP             0CE1 R   |   2 CHR                135D R
  2 CLEAR              094D R   |   2 CLOTST             070A R
  2 CLREG              0552 R   |   2 CLRPTR             052D R
  2 CLS                1B7F R   |   2 CMPFP              178A R
  2 CMPLG1             0E55 R   |   2 CMPLOG             0E53 R
  2 CMPNUM             1770 R   |   2 CMPRES             0E97 R
  2 CMPSTR             0E7F R   |     CN             =   0020 
  2 CNVNUM             1804 R   |   2 COLD               0040 R
    COMMAN         =   8088     |   2 COMPL              154A R
  2 CONCAT             12C1 R   |   2 CONEXP             1830 R
  2 CONPOS             14E9 R   |   2 CONT               08D8 R
    CONTAD         =   8119     |   2 CONVAR             0DC2 R
  2 COPY               005A R   |   2 COS                1AC4 R
  2 COUNT              0776 R   |   2 CPDEHL             06D1 R
  2 CPYLIT             060E R   |     CR             =   000D 
  2 CRARLP             1017 R   |   2 CREARY             0FFC R
  2 CRESTR             0A58 R   |   2 CRNCLP             0585 R
  2 CRTMST             117F R   |   2 CRTST              118B R
  2 CRTSTE             11A1 R   |   2 CRUNCH             057C R
    CS             =   000C     |   2 CSTART             004D R
    CTLOFG         =   808A     |     CTRLC          =   0003 
    CTRLG          =   0007     |     CTRLO          =   000F 
    CTRLQ          =   0011     |     CTRLR          =   0012 
    CTRLS          =   0013     |     CTRLU          =   0015 
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 85
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Symbol Table

    CUROPR         =   810A     |     CURPOS         =   80F0 
  2 DATA               09F9 R   |     DATFLG         =   80F3 
    DATLIN         =   810E     |   2 DATSNR             03EA R
  2 DCBCDE             17C1 R   |   2 DDERR              040E R
  2 DEEK               1B9B R   |   2 DEF                10BE R
  2 DEFSIZ             101F R   |   2 DEINT              0910 R
    DEL            =   007F     |   2 DELCHR             0643 R
  2 DEPINT             090A R   |   2 DETHL4             1750 R
  2 DETHLB             1752 R   |   2 DIGTXT             18F6 R
  2 DIM                0EC1 R   |   2 DIMRET             0EB8 R
  2 DINPOS             0704 R   |   2 DIV                163C R
    DIV1           =   804F     |   2 DIV10              1630 R
    DIV2           =   8053     |     DIV3           =   8057 
    DIV4           =   805A     |   2 DIVLP              1663 R
    DIVSUP         =   804E     |   2 DOAGN              056B R
  2 DOCOM              0B32 R   |   2 DODEL              061E R
  2 DOEBIT             1932 R   |   2 DOFN               10ED R
  2 DOKE               1BA6 R   |   2 DONULL             0B20 R
  2 DOSPC              0B5C R   |   2 DOTAB              0B49 R
  2 DPOINT             182C R   |   2 DTSTR              118F R
  2 DVBCDE             163E R   |     DZ             =   0014 
  2 DZERR              03FA R   |   2 ECHDEL             0637 R
  2 EDIGIT             1871 R   |   2 ENDBUF             0615 R
  2 ENDCON             183F R   |   2 ENDDIM             1084 R
  2 ENDINP             0B11 R   |   2 ENDNAM             0EEA R
  2 ENDPRG             08B4 R   |   2 ENFMEM             03D6 R
  2 ERRIN              044E R   |     ERRLIN         =   8117 
  2 ERRMSG             037A R   |   2 ERROR              042E R
  2 ERRORS             02F9 R   |     ESC            =   001B 
  2 EVAL               0CEE R   |   2 EVAL1              0CF1 R
  2 EVAL2              0CFA R   |   2 EVAL3              0CFD R
  2 EVLPAR             0DA9 R   |   2 EVNOT              0EA1 R
  2 EXCUTE             083C R   |   2 EXP                19C9 R
  2 EXPLP              181E R   |   2 EXPTAB             1A09 R
  2 EXPTEN             1944 R   |   2 EXTIG              0C5E R
  2 FANDT              0C88 R   |     FC             =   0008 
  2 FCERR              0925 R   |   2 FDTLP              0C6F R
  2 FINDEL             105A R   |   2 FLGDIF             1700 R
  2 FLGREL             1707 R   |     FNARG          =   8125 
  2 FNCTAB             0143 R   |   2 FNDARY             0FCA R
  2 FNDELP             1065 R   |   2 FNDEND             0500 R
  2 FNDNUM             1450 R   |   2 FNDTOK             0757 R
  2 FNDVAR             0F2B R   |   2 FNDWRD             05A7 R
  2 FNOFST             0DD3 R   |     FNRGNM         =   8123 
  2 FNTHR              0F39 R   |   2 FNVAL              0DFA R
  2 FOPRND             0D26 R   |   2 FOR                07A2 R
    FORFLG         =   8110     |   2 FORFND             07D2 R
  2 FORSLP             07B6 R   |   2 FPADD              149B R
  2 FPBCDE             1736 R   |     FPEXP          =   812C 
  2 FPINT              179D R   |   2 FPMULT             15DD R
    FPREG          =   8129     |   2 FPROND             1531 R
  2 FPSINT             0904 R   |   2 FPTHL              174D R
  2 FRE                1088 R   |   2 FRENUM             10A4 R
  2 FRMEVL             0DC5 R   |   2 GARBGE             120E R
  2 GARBLP             1211 R   |   2 GETCHR             085C R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 86
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Symbol Table

  2 GETCMD             0478 R   |     GETHEX             **** X
  2 GETINP             1B7D R   |   2 GETINT             1453 R
  2 GETLEN             1341 R   |   2 GETLIN             0654 R
  2 GETLN              092B R   |   2 GETNUM             0CDC R
  2 GETNXT             05BC R   |   2 GETSTR             130B R
  2 GETVAR             0ECD R   |   2 GNXARY             1245 R
  2 GOFUNC             0E02 R   |   2 GOSUB              099F R
  2 GOTO               09B0 R   |   2 GRBARY             1265 R
  2 GRBDON             11E6 R   |   2 GRBLP              121F R
  2 GSTRCU             130E R   |   2 GSTRDE             1312 R
  2 GSTRHL             1311 R   |   2 GTFLNM             1350 R
  2 GTFNAM             0ED2 R   |   2 GTLNLP             092E R
  2 GTSIXD             18C0 R   |   2 GTVLUS             0BE0 R
  2 HALF               1963 R   |   2 HALFPI             1B0E R
  2 HEX                1BBD R   |   2 HEX1               1BD4 R
  2 HEX2               1BD6 R   |   2 HEX3               1BE2 R
  2 HEX4               1BE4 R   |     HEXIT              **** X
    HEXLP              **** X   |     HEXLP1             **** X
    HEXTFP             **** X   |     HX             =   0026 
  2 HXERR              1C37 R   |     ID             =   0016 
  2 IDTEST             1135 R   |   2 IF                 0A91 R
  2 IFGO               0AA4 R   |   2 IFJMP              0843 R
  2 INCHL              174B R   |   2 INCLEN             0700 R
  2 INDFND             03AC R   |   2 INEWLN             04C8 R
  2 INIT               0054 R   |   2 INITAB             0323 R
  2 INITBE             037A R   |   2 INITST             1C9F R
  2 INMSG              0381 R   |   2 INP                1410 R
  2 INPBIN             0C2E R   |   2 INPBRK             08B3 R
    INPORT         =   8084     |     INPSUB         =   8083 
  2 INPUT              0B97 R   |   2 INRNG              18C9 R
  2 INT                17C8 R   |   2 INTVAR             053C R
  2 INVSGN             171E R   |   2 ITMSEP             0C1F R
  2 JJUMP1             1C96 R   |   2 JSTZER             194E R
  2 KBHIT              002A R   |   2 KILFOR             0CCE R
  2 KILIN              064E R   |     LCRFLG         =   80F1 
  2 LEFT               136D R   |   2 LEN                133D R
  2 LET                0A0E R   |   2 LETNUM             0A69 R
  2 LETSTR             0A2B R   |     LF             =   000A 
  2 LFRGNM             1406 R   |     LINEAT         =   80A1 
  2 LINEIN             187B R   |   2 LINES              1B8C R
    LINESC         =   808B     |     LINESN         =   808D 
  2 LINFND             04B1 R   |   2 LIST               0719 R
  2 LISTLP             0725 R   |   2 LOADFP             1744 R
  2 LOG                158F R   |   2 LOGTAB             1585 R
  2 LOKFOR             0396 R   |     LOOPST         =   810C 
    LS             =   001C     |     LSTBIN         =   8111 
  2 LSTLP2             0745 R   |   2 LSTLP3             0748 R
    LSTRAM         =   80F4     |     LSTRND         =   807F 
  2 LTSTND             0C39 R   |     LWIDTH         =   8087 
  2 MAKINT             1456 R   |   2 MAKNUM             18E5 R
  2 MANLP              180C R   |   2 MATCH              05E8 R
  2 MEMMSG             0111 R   |   2 MID                13AD R
  2 MID1               1373 R   |   2 MIDNUM             140B R
  2 MINCDE             14DB R   |   2 MINUS              0DB1 R
  2 MKTMST             117C R   |   2 MLDBLP             17E9 R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 87
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Symbol Table

  2 MLDEBC             17E1 R   |   2 MLOOP              0072 R
  2 MLSP10             16DE R   |     MO             =   0024 
  2 MONITR             1C9C R   |   2 MONOUT             1C99 R
  2 MORDT              0C43 R   |   2 MORINP             065D R
  2 MOVBUF             04E7 R   |   2 MOVDIR             05F0 R
  2 MOVLP              03BB R   |   2 MOVSTR             03B8 R
  2 MOVUP              03B5 R   |   2 MRPRNT             0AB6 R
  2 MSIZE              006F R   |   2 MUL8LP             1608 R
  2 MULLN2             15C7 R   |   2 MULT               15DB R
  2 MULT8              15FF R   |   2 MULTEN             184A R
    MULVAL         =   813B     |   2 MVSTPT             0A60 R
  2 NEDMOR             0BDC R   |   2 NEGAFT             1978 R
  2 NEMEM              00C2 R   |   2 NEW                052C R
  2 NEXITM             0B6C R   |   2 NEXT               0C93 R
  2 NEXT1              0C96 R   |     NF             =   0000 
  2 NFERR              0404 R   |     NMIFLG         =   8091 
  2 NOCHNG             05E0 R   |   2 NOENED             1951 R
  2 NOLIN              08C7 R   |   2 NOMADD             1619 R
  2 NOMLAD             17F7 R   |   2 NOPMPT             0BB6 R
  2 NORMAL             1506 R   |   2 NOSPC              05DB R
    NOSUB7             **** X   |   2 NOSWAP             14B5 R
  2 NOTAMP             0D8A R   |   2 NOTSTR             0F03 R
  2 NOXOR              1436 R   |   2 NSCFOR             0F11 R
    NULFLG         =   8089     |   2 NULL               08EB R
  2 NULLP              0B27 R   |     NULLS          =   8086 
  2 NUMASC             188E R   |   2 NXTARY             0FDE R
  2 NXTBYT             05CA R   |   2 NXTCHR             0605 R
    NXTDAT         =   8121     |   2 NXTDTA             09F8 R
  2 NXTITM             0BD4 R   |     NXTOPR         =   8115 
  2 NXTSTL             09FF R   |   2 NXTSTT             0A02 R
    OD             =   0006     |   2 OKMSG              0386 R
    OM             =   000C     |   2 OMERR              03E5 R
  2 ON                 0A70 R   |   2 ONGO               0A84 R
  2 ONGOLP             0A85 R   |   2 ONJMP              0844 R
  2 OPNPAR             0CEA R   |   2 OPRND              0D65 R
    OS             =   001A     |   2 OTKLN              064B R
    OTPORT         =   804C     |   2 OUTC               06E2 R
  2 OUTEXP             1942 R   |   2 OUTIT              06C3 R
  2 OUTNBS             06C9 R   |   2 OUTNCR             1CAE R
    OUTSUB         =   804B     |   2 OUTWRD             0761 R
    OV             =   000A     |   2 OVERR              0422 R
  2 OVTST1             16D1 R   |   2 OVTST2             16D6 R
  2 OVTST3             16D7 R   |   2 PADD               186C R
  2 PAND               0E1A R   |   2 PASSA              10B9 R
    PBUFF          =   812E     |   2 PEEK               1464 R
  2 PEND               08A2 R   |   2 PHLTFP             1733 R
  2 PLUCDE             153E R   |   2 PNORM              150E R
    POINT          =   8096     |   2 POKE               146B R
  2 POPAF              1200 R   |   2 POPHL              132A R
  2 POPHRT             1629 R   |   2 POPNOK             046A R
  2 POR                0E17 R   |   2 POR1               0E3C R
  2 POS                10B6 R   |   2 POSINT             0907 R
  2 POUT               141C R   |   2 POWER              1986 R
  2 POWER1             1996 R   |   2 POWER2             19B1 R
  2 POWERS             1966 R   |   2 PRCRLF             0B16 R
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 88
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Symbol Table

  2 PRINT              0ABA R   |   2 PRITAB             02E4 R
  2 PRNTHL             1883 R   |   2 PRNTLP             0ABD R
  2 PRNTNB             0AFE R   |   2 PRNTOK             046B R
  2 PRNTST             0B02 R   |   2 PRNUMS             11CA R
  2 PROCES             0676 R   |     PROGND         =   811B 
    PROGST         =   813E     |   2 PROMPT             056F R
  2 PRS                11CB R   |   2 PRS1               11CE R
  2 PRSLP              11D5 R   |     PSET           =   8099 
  2 PSUB               1496 R   |   2 PTRLP              04F4 R
  2 PUTBUF             06B1 R   |   2 PUTCTL             06B4 R
  2 PUTFID             081A R   |   2 QTSTLP             1192 R
  2 QTSTR              118C R   |   2 QUARTR             1B11 R
    RAMSIZ         =   1000     |     RAMTOP         =   8000 
    RD             =   0012     |   2 READ               0BCB R
    READFG         =   8112     |   2 REDO               0B73 R
  2 REM                09FB R   |   2 RESDIV             1683 R
  2 RESEED             1AB3 R   |     RESET          =   809C 
  2 RESTNL             087B R   |   2 RESTOR             0866 R
  2 RESZER             1501 R   |   2 RETADR             0F78 R
  2 RETINT             170C R   |   2 RETLIN             09ED R
  2 RETNAD             05EC R   |   2 RETNUL             0F7B R
  2 RETNUM             0DBD R   |   2 RETREL             16FE R
  2 RETURN             09CE R   |     RG             =   0004 
  2 RIGHT              13A3 R   |   2 RIGHT1             1371 R
    RINPUT         =   8093     |   2 RLTLP              0D0A R
  2 RND                1A58 R   |   2 RND1               1A90 R
  2 RND2               1AAA R   |   2 RNDTAB             1ABB R
  2 RNGTST             1954 R   |     ROMTOP         =   0000 
  2 RONDB              1522 R   |   2 RONDUP             1521 R
  2 ROUND              147C R   |   2 RSCALE             1866 R
  2 RSLNBK             0799 R   |   2 RSTSTR             13C4 R
  2 RUN                0993 R   |   2 RUNCNT             081E R
  2 RUNFST             0538 R   |   2 RUNLIN             09AF R
  2 RXA                001B R   |   2 SAVEXP             1502 R
  2 SAVSTP             0811 R   |   2 SAVSTR             1167 R
  2 SBSCPT             0F86 R   |   2 SCALE              155E R
  2 SCALLP             1560 R   |   2 SCALMI             1833 R
  2 SCALPL             1849 R   |   2 SCNEND             129C R
  2 SCPTLP             0F8C R   |   2 SEARCH             05BA R
    SEED           =   805C     |   2 SETIO              1440 R
  2 SETLIN             076D R   |   2 SETLIT             05FC R
  2 SETPTR             04EF R   |   2 SETTOP             0081 R
  2 SFTPRG             04B9 R   |   2 SGN                1704 R
  2 SGNEXP             0E0B R   |     SGNRES         =   812D 
  2 SHRITE             156D R   |   2 SHRLP              1570 R
  2 SHRT1              1574 R   |   2 SIGNON             00DA R
  2 SIGNS              175B R   |   2 SIN                1ACA R
  2 SIN1               1AFA R   |   2 SINIT              003D R
  2 SINTAB             1B14 R   |   2 SIXDIG             18AB R
  2 SMPVAR             1230 R   |   2 SMSER1             1A31 R
    SN             =   0002     |   2 SNERR              03F0 R
  2 SPCFST             189C R   |   2 SPCLP              0B65 R
  2 SQR                197D R   |   2 SRCHLN             050C R
  2 SRCHLP             050F R   |   2 SSTSA              12F8 R
    ST             =   001E     |     STACK          =   80AB 
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 89
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Symbol Table

  2 STAKFP             1726 R   |   2 STALL              088F R
  2 STARTB             0046 R   |   2 STKTHS             0D4E R
    STLOOK         =   81A2     |   2 STOP               089C R
  2 STORED             0970 R   |   2 STPOOL             1273 R
  2 STR                1157 R   |   2 STR1               115D R
  2 STRADD             1276 R   |     STRBOT         =   8108 
  2 STRENT             0C22 R   |     STRSPC         =   809F 
  2 STTLIN             0B09 R   |   2 SUBCDE             1498 R
  2 SUBPHL             1485 R   |   2 SUMLP              1A40 R
  2 SUMSER             1A22 R   |   2 SUPTLZ             192A R
  2 SVNAM2             0EE9 R   |   2 SVSTAD             1185 R
  2 TAN                1B24 R   |   2 TESTOS             1202 R
  2 TESTR              11E4 R   |     TM             =   0018 
  2 TMERR              042C R   |     TMPSTR         =   8104 
    TMSTPL         =   80F8     |     TMSTPT         =   80F6 
  2 TOPOOL             1369 R   |   2 TOSTRA             1301 R
  2 TRYAGN             1905 R   |   2 TSALP              1302 R
    TSTACK         =   80ED     |   2 TSTBIT             1CA7 R
  2 TSTBRK             0881 R   |   2 TSTNUM             0CDF R
  2 TSTOPL             11AB R   |   2 TSTRED             0E41 R
  2 TSTREM             05FF R   |   2 TSTSGN             16F5 R
  2 TSTSTR             0CE0 R   |   2 TTYLIN             0654 R
  2 TXA                0030 R   |   2 TXAST1             0031 R
    TYPE           =   80F2     |     UARTCR         =   E001 
    UARTDR         =   E000     |     UF             =   0022 
  2 UFERR              0418 R   |     UL             =   000E 
  2 ULERR              09C9 R   |   2 UNITY              1582 R
  2 UPDATA             087C R   |     USR            =   8048 
  2 VAL                13DB R   |   2 VAL1               13F7 R
  2 VAL2               13FF R   |   2 VAL3               1402 R
    VAREND         =   811D     |   2 WAIT               1422 R
  2 WAITLP             1437 R   |   2 WARM               0043 R
  2 WARMST             00B9 R   |   2 WIDTH              1B84 R
  2 WORDS              017B R   |   2 WORDTB             029A R
    WRKSPC         =   8045     |   2 XXXXX              00C8 R
    ZDATA          =   0083     |     ZDIV           =   00AF 
    ZEND           =   0080     |     ZEQUAL         =   00B4 
  2 ZERARY             103D R   |     ZERBYT         =   FFFF 
  2 ZEROLP             0F6A R   |   2 ZEROSUP            1C48 R
    ZFN            =   00A7     |     ZFOR           =   0081 
    ZGOSUB         =   008C     |     ZGOTO          =   0088 
    ZGTR           =   00B3     |     ZLEFT          =   00CF 
    ZLTH           =   00B5     |     ZMINUS         =   00AD 
    ZNEW           =   00A4     |     ZNOT           =   00AA 
  2 ZONELP             0B40 R   |     ZOR            =   00B2 
    ZPLUS          =   00AC     |     ZPOINT         =   00C7 
    ZPRINT         =   009E     |     ZREM           =   008E 
    ZSGN           =   00B6     |     ZSPC           =   00A8 
    ZSTEP          =   00AB     |     ZTAB           =   00A5 
    ZTHEN          =   00A9     |     ZTIMES         =   00AE 
    ZTO            =   00A6     |     and                **** X
    token              **** X   |     variable           **** X

ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 90
Hexadecimal [16-Bits]                                 Sun Mar  2 11:32:15 2025

Area Table

[_CSEG]
   0 _CODE            size    0   flags C080
   2 TEST             size 1CB4   flags  908
[_DSEG]
   1 _DATA            size    0   flags C0C0

