ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 1
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                              1         .area   TEST (ABS)
                              2 ;	EMUBASIC based on GRANT's BASIC
                              3 ;	TARGET: EMUZ80
                              4 ;	ASSEMBLER: ARCPIT XZ80.EXE
                              5 ;
                              6 ;	START UP ROUTINE
                              7 ;	VERSION 1.0, 2022/02/15
                              8 ;	WRITTEN by TETSUYA SUZUKI
                              9 ;
                             10 ;	MEMORY ASIGN
                     0000    11 ROMTOP  .equ    0x0000
                     8000    12 RAMTOP  .equ    0x8000
                     1000    13 RAMSIZ  .equ    0x1000
                     80ED    14 TSTACK  .equ    0x80ED
                             15 ;
                             16 ;	UART REGISTER ADDRESS
                     E000    17 UARTDR  .equ    0x0E000                       ; UART DATA REGISTOR
                     E001    18 UARTCR  .equ    0x0E001                       ; UART CONTROL REGISTOR
                             19 ;
                             20 ;	RESET (RST 00H)
   0000                      21         .org    ROMTOP
   0000 F3            [ 4]   22         DI
   0001 31 ED 80      [10]   23         LD      SP,TSTACK
   0004 C3 41 00      [10]   24         JP      SINIT
                             25 ;
                             26 ;	PUT 1CHAR (RST 08H)
   0008                      27         .org    ROMTOP+0x08
   0008 C3 34 00      [10]   28         JP      TXA
                             29 ;
                             30 ;	GET 1CHAR (RST 10H)
   0010                      31         .org    ROMTOP+0x10
   0010 C3 1B 00      [10]   32         JP      RXA
                             33 ;
                             34 ;	KBHIT (RST 18H)
   0018                      35         .org    ROMTOP+0x18
   0018 C3 2E 00      [10]   36         JP      KBHIT
                             37 ;
                             38 ;	UART -> A
   001B 3A 01 E0      [13]   39 RXA:    LD      A,(UARTCR)
   001E CB 47         [ 8]   40         BIT     0,A
   0020 28 F9         [12]   41         JR      Z,RXA
   0022 3A 00 E0      [13]   42         LD      A,(UARTDR)
   0025 FE 61         [ 7]   43         CP      'a
   0027 D8            [11]   44         RET     C
   0028 FE 7B         [ 7]   45         CP      'z+1
   002A D0            [11]   46         RET     NC
   002B E6 DF         [ 7]   47         AND     0x0DF
   002D C9            [10]   48         RET
                             49 ;
                             50 ;	CHECK RECEIVE STATUS
   002E 3A 01 E0      [13]   51 KBHIT:  LD      A,(UARTCR)
   0031 CB 47         [ 8]   52         BIT     0,A
   0033 C9            [10]   53         RET
                             54 ;
                             55 ;	A -> UART
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 2
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0034 F5            [11]   56 TXA:    PUSH    AF
   0035 3A 01 E0      [13]   57 TXAST1: LD      A,(UARTCR)
   0038 CB 4F         [ 8]   58         BIT     1,A
   003A 28 F9         [12]   59         JR      Z,TXAST1
   003C F1            [10]   60         POP     AF
   003D 32 00 E0      [13]   61         LD      (UARTDR),A
   0040 C9            [10]   62         RET
                             63 ;
                             64 ;
                             65 ;	SYSTEM INITIALIZE
   0041                      66 SINIT:
   0041 C3 44 00      [10]   67         JP      COLD
                             68 ;
                             69 ;==================================================================================
                             70 ; The updates to the original BASIC within this file are copyright Grant Searle
                             71 ;
                             72 ; You have permission to use this for NON COMMERCIAL USE ONLY
                             73 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                             74 ;
                             75 ; http://searle.hostei.com/grant/index.html
                             76 ;
                             77 ; eMail: home.micros01@btinternet.com
                             78 ;
                             79 ; If the above don't work, please perform an Internet search to see if I have
                             80 ; updated the web page hosting service.
                             81 ;
                             82 ;==================================================================================
                             83 ;
                             84 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                             85 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                             86 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                             87 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                             88 ; the original ROM code (checksum A934H). PA
                             89 ;
                             90 ; GENERAL EQUATES
                             91 ;
                     0003    92 CTRLC   .equ    0x03                          ; Control "C"
                     0007    93 CTRLG   .equ    0x07                          ; Control "G"
                     0008    94 BKSP    .equ    0x08                          ; Back space
                     000A    95 LF      .equ    0x0A                          ; Line feed
                     000C    96 CS      .equ    0x0C                          ; Clear screen
                     000D    97 CR      .equ    0x0D                          ; Carriage return
                     000F    98 CTRLO   .equ    0x0F                          ; Control "O"
                     0011    99 CTRLQ   .equ    0x11                          ; Control "Q"
                     0012   100 CTRLR   .equ    0x12                          ; Control "R"
                     0013   101 CTRLS   .equ    0x13                          ; Control "S"
                     0015   102 CTRLU   .equ    0x15                          ; Control "U"
                     001B   103 ESC     .equ    0x1B                          ; Escape
                     007F   104 DEL     .equ    0x7F                          ; Delete
                            105 ;
                            106 ; BASIC WORK SPACE LOCATIONS
                            107 ;
                     8045   108 WRKSPC  .equ    0x8045                        ; BASIC Work space
                     8048   109 USR     .equ    WRKSPC+0x3                    ; "USR (x)" jump
                     804B   110 OUTSUB  .equ    WRKSPC+0x6                    ; "OUT p,n"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 3
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                     804C   111 OTPORT  .equ    WRKSPC+0x7                    ; Port (p)
                     804E   112 DIVSUP  .equ    WRKSPC+0x9                    ; Division support routine
                     804F   113 DIV1    .equ    WRKSPC+0x0A                   ; <- Values
                     8053   114 DIV2    .equ    WRKSPC+0x0E                   ; <- to
                     8057   115 DIV3    .equ    WRKSPC+0x12                   ; <- be
                     805A   116 DIV4    .equ    WRKSPC+0x15                   ; <- inserted
                     805C   117 SEED    .equ    WRKSPC+0x17                   ; Random number seed
                     807F   118 LSTRND  .equ    WRKSPC+0x3A                   ; Last random number
                     8083   119 INPSUB  .equ    WRKSPC+0x3E                   ; #INP (x)" Routine
                     8084   120 INPORT  .equ    WRKSPC+0x3F                   ; PORT (x)
                     8086   121 NULLS   .equ    WRKSPC+0x41                   ; Number of nulls
                     8087   122 LWIDTH  .equ    WRKSPC+0x42                   ; Terminal width
                     8088   123 COMMAN  .equ    WRKSPC+0x43                   ; Width for commas
                     8089   124 NULFLG  .equ    WRKSPC+0x44                   ; Null after input byte flag
                     808A   125 CTLOFG  .equ    WRKSPC+0x45                   ; Control "O" flag
                     808B   126 LINESC  .equ    WRKSPC+0x46                   ; Lines counter
                     808D   127 LINESN  .equ    WRKSPC+0x48                   ; Lines number
                     808F   128 CHKSUM  .equ    WRKSPC+0x4A                   ; Array load/save check sum
                     8091   129 NMIFLG  .equ    WRKSPC+0x4C                   ; Flag for NMI break routine
                     8092   130 BRKFLG  .equ    WRKSPC+0x4D                   ; Break flag
                     8093   131 RINPUT  .equ    WRKSPC+0x4E                   ; Input reflection
                     8096   132 POINT   .equ    WRKSPC+0x51                   ; "POINT" reflection (unused)
                     8099   133 PSET    .equ    WRKSPC+0x54                   ; "SET"	reflection
                     809C   134 RESET   .equ    WRKSPC+0x57                   ; "RESET" reflection
                     809F   135 STRSPC  .equ    WRKSPC+0x5A                   ; Bottom of string space
                     80A1   136 LINEAT  .equ    WRKSPC+0x5C                   ; Current line number
                     80A3   137 BASTXT  .equ    WRKSPC+0x5E                   ; Pointer to start of program
                     80A6   138 BUFFER  .equ    WRKSPC+0x61                   ; Input buffer
                     80AB   139 STACK   .equ    WRKSPC+0x66                   ; Initial stack
                     80F0   140 CURPOS  .equ    WRKSPC+0x0AB                  ; Character position on line
                     80F1   141 LCRFLG  .equ    WRKSPC+0x0AC                  ; Locate/Create flag
                     80F2   142 TYPE    .equ    WRKSPC+0x0AD                  ; Data type flag
                     80F3   143 DATFLG  .equ    WRKSPC+0x0AE                  ; Literal statement flag
                     80F4   144 LSTRAM  .equ    WRKSPC+0x0AF                  ; Last available RAM
                     80F6   145 TMSTPT  .equ    WRKSPC+0x0B1                  ; Temporary string pointer
                     80F8   146 TMSTPL  .equ    WRKSPC+0x0B3                  ; Temporary string pool
                     8104   147 TMPSTR  .equ    WRKSPC+0x0BF                  ; Temporary string
                     8108   148 STRBOT  .equ    WRKSPC+0x0C3                  ; Bottom of string space
                     810A   149 CUROPR  .equ    WRKSPC+0x0C5                  ; Current operator in EVAL
                     810C   150 LOOPST  .equ    WRKSPC+0x0C7                  ; First statement of loop
                     810E   151 DATLIN  .equ    WRKSPC+0x0C9                  ; Line of current DATA item
                     8110   152 FORFLG  .equ    WRKSPC+0x0CB                  ; "FOR" loop flag
                     8111   153 LSTBIN  .equ    WRKSPC+0x0CC                  ; Last byte entered
                     8112   154 READFG  .equ    WRKSPC+0x0CD                  ; Read/Input flag
                     8113   155 BRKLIN  .equ    WRKSPC+0x0CE                  ; Line of break
                     8115   156 NXTOPR  .equ    WRKSPC+0x0D0                  ; Next operator in EVAL
                     8117   157 ERRLIN  .equ    WRKSPC+0x0D2                  ; Line of error
                     8119   158 CONTAD  .equ    WRKSPC+0x0D4                  ; Where to CONTinue
                     811B   159 PROGND  .equ    WRKSPC+0x0D6                  ; End of program
                     811D   160 VAREND  .equ    WRKSPC+0x0D8                  ; End of variables
                     811F   161 ARREND  .equ    WRKSPC+0x0DA                  ; End of arrays
                     8121   162 NXTDAT  .equ    WRKSPC+0x0DC                  ; Next data item
                     8123   163 FNRGNM  .equ    WRKSPC+0x0DE                  ; Name of FN argument
                     8125   164 FNARG   .equ    WRKSPC+0x0E0                  ; FN argument value
                     8129   165 FPREG   .equ    WRKSPC+0x0E4                  ; Floating point register
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 4
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                     812C   166 FPEXP   .equ    FPREG+3                       ; Floating point exponent
                     812D   167 SGNRES  .equ    WRKSPC+0x0E8                  ; Sign of result
                     812E   168 PBUFF   .equ    WRKSPC+0x0E9                  ; Number print buffer
                     813B   169 MULVAL  .equ    WRKSPC+0x0F6                  ; Multiplier
                     813E   170 PROGST  .equ    WRKSPC+0x0F9                  ; Start of program text area
                     81A2   171 STLOOK  .equ    WRKSPC+0x15D                  ; Start of memory test
                            172 ;
                            173 ; BASIC ERROR CODE VALUES
                            174 ;
                     0000   175 NF      .equ    0x00                          ; NEXT without FOR
                     0002   176 SN      .equ    0x02                          ; Syntax error
                     0004   177 RG      .equ    0x04                          ; RETURN without GOSUB
                     0006   178 OD      .equ    0x06                          ; Out of DATA
                     0008   179 FC      .equ    0x08                          ; Function call error
                     000A   180 OV      .equ    0x0A                          ; Overflow
                     000C   181 OM      .equ    0x0C                          ; Out of memory
                     000E   182 UL      .equ    0x0E                          ; Undefined line number
                     0010   183 BS      .equ    0x10                          ; Bad subscript
                     0012   184 RD      .equ    0x12                          ; Re-DIMensioned array
                     0014   185 DZ      .equ    0x14                          ; Division by zero (/0)
                     0016   186 ID      .equ    0x16                          ; Illegal direct
                     0018   187 TM      .equ    0x18                          ; Type miss-match
                     001A   188 OS      .equ    0x1A                          ; Out of string space
                     001C   189 LS      .equ    0x1C                          ; String too long
                     001E   190 ST      .equ    0x1E                          ; String formula too complex
                     0020   191 CN      .equ    0x20                          ; Can't CONTinue
                     0022   192 UF      .equ    0x22                          ; UnDEFined FN function
                     0024   193 MO      .equ    0x24                          ; Missing operand
                     0026   194 HX      .equ    0x26                          ; HEX error
                     0028   195 BN      .equ    0x28                          ; BIN error
                            196 ;
   0044 C3 4A 00      [10]  197 COLD:   JP      STARTB                        ; Jump for cold start
   0047 C3 BF 00      [10]  198 WARM:   JP      WARMST                        ; Jump for warm start
   004A C3 51 00      [10]  199 STARTB: JP      CSTART                        ; Jump to initialise
                            200 ;
   004D 80 08               201         .dw     DEINT                         ; Get integer -32768 to 32767
   004F F6 0F               202         .dw     ABPASS                        ; Return integer in AB
                            203 ;
   0051 21 45 80      [10]  204 CSTART: LD      HL,WRKSPC                     ; Start of workspace RAM
   0054 F9            [ 6]  205         LD      SP,HL                         ; Set up a temporary stack
   0055 C3 11 1C      [10]  206         JP      INITST                        ; Go to initialise
                            207 ;
   0058 11 A7 02      [10]  208 INIT:   LD      DE,INITAB                     ; Initialise workspace
   005B 06 63         [ 7]  209         LD      B,INITBE-INITAB+3             ; Bytes to copy
   005D 21 45 80      [10]  210         LD      HL,WRKSPC                     ; Into workspace RAM
   0060 1A            [ 7]  211 COPY:   LD      A,(DE)                        ; Get source
   0061 77            [ 7]  212         LD      (HL),A                        ; To destination
   0062 23            [ 6]  213         INC     HL                            ; Next destination
   0063 13            [ 6]  214         INC     DE                            ; Next source
   0064 05            [ 4]  215         DEC     B                             ; Count bytes
   0065 C2 60 00      [10]  216         JP      NZ,COPY                       ; More to move
   0068 F9            [ 6]  217         LD      SP,HL                         ; Temporary stack
   0069 CD A8 04      [17]  218         CALL    CLREG                         ; Clear registers and stack
   006C CD 76 0A      [17]  219         CALL    PRCRLF                        ; Output CRLF
   006F 32 EF 80      [13]  220         LD      (BUFFER+72+1),A               ; Mark end of buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 5
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0072 32 3E 81      [13]  221         LD      (PROGST),A                    ; Initialise program area
   0075 21 A2 81      [10]  222 MSIZE:  LD      HL,STLOOK                     ; Point to start of RAM
   0078 23            [ 6]  223 MLOOP:  INC     HL                            ; Next byte
   0079 7C            [ 4]  224         LD      A,H                           ; Above address FFFF ?
   007A B5            [ 4]  225         OR      L
   007B CA 87 00      [10]  226         JP      Z,SETTOP                      ; Yes - 64K RAM
   007E 7E            [ 7]  227         LD      A,(HL)                        ; Get contents
   007F 47            [ 4]  228         LD      B,A                           ; Save it
   0080 2F            [ 4]  229         CPL                                   ; Flip all bits
   0081 77            [ 7]  230         LD      (HL),A                        ; Put it back
   0082 BE            [ 7]  231         CP      (HL)                          ; RAM there if same
   0083 70            [ 7]  232         LD      (HL),B                        ; Restore old contents
   0084 CA 78 00      [10]  233         JP      Z,MLOOP                       ; If RAM - test next byte
                            234 ;
   0087 2B            [ 6]  235 SETTOP: DEC     HL                            ; Back one byte
   0088 11 A1 81      [10]  236         LD      DE,STLOOK-1                   ; See if enough RAM
   008B CD 3E 06      [17]  237         CALL    CPDEHL                        ; Compare DE with HL
   008E DA C8 00      [10]  238         JP      C,NEMEM                       ; If not enough RAM
   0091 11 CE FF      [10]  239         LD      DE,0-50                       ; 50 Bytes string space
   0094 22 F4 80      [16]  240         LD      (LSTRAM),HL                   ; Save last available RAM
   0097 19            [11]  241         ADD     HL,DE                         ; Allocate string space
   0098 22 9F 80      [16]  242         LD      (STRSPC),HL                   ; Save string space
   009B CD 83 04      [17]  243         CALL    CLRPTR                        ; Clear program area
   009E 2A 9F 80      [16]  244         LD      HL,(STRSPC)                   ; Get end of memory
   00A1 11 EF FF      [10]  245         LD      DE,0-17                       ; Offset for free bytes
   00A4 19            [11]  246         ADD     HL,DE                         ; Adjust HL
   00A5 11 3E 81      [10]  247         LD      DE,PROGST                     ; Start of program text
   00A8 7D            [ 4]  248         LD      A,L                           ; Get LSB
   00A9 93            [ 4]  249         SUB     E                             ; Adjust it
   00AA 6F            [ 4]  250         LD      L,A                           ; Re-save
   00AB 7C            [ 4]  251         LD      A,H                           ; Get MSB
   00AC 9A            [ 4]  252         SBC     A,D                           ; Adjust it
   00AD 67            [ 4]  253         LD      H,A                           ; Re-save
   00AE E5            [11]  254         PUSH    HL                            ; Save bytes free
   00AF 21 E0 00      [10]  255         LD      HL,SIGNON                     ; Sign-on message
   00B2 CD 14 11      [17]  256         CALL    PRS                           ; Output string
   00B5 E1            [10]  257         POP     HL                            ; Get bytes free back
   00B6 CD B7 17      [17]  258         CALL    PRNTHL                        ; Output amount of free memory
   00B9 21 D1 00      [10]  259         LD      HL,BFREE                      ; " Bytes free" message
   00BC CD 14 11      [17]  260         CALL    PRS                           ; Output string
                            261 ;
   00BF 31 AB 80      [10]  262 WARMST: LD      SP,STACK                      ; Temporary stack
   00C2 CD A8 04      [17]  263 BRKRET: CALL    CLREG                         ; Clear registers and stack
   00C5 C3 C1 03      [10]  264         JP      PRNTOK                        ; Go to get command line
                            265 ;
   00C8 21 17 01      [10]  266 NEMEM:  LD      HL,MEMMSG                     ; Memory size not enough
   00CB CD 14 11      [17]  267         CALL    PRS                           ; Print it
   00CE C3 CE 00      [10]  268 XXXXX:  JP      XXXXX                         ; Stop
                            269 ;
   00D1 20 42 79 74 65 73   270 BFREE:  .ascii  " Bytes free"
        20 66 72 65 65
   00DC 0D 0A 00 00         271         .db     CR,LF,0,0
                            272 ;
   00E0 5A 38 30 20 42 41   273 SIGNON: .ascii  "Z80 BASIC Ver 4.7b"
        53 49 43 20 56 65
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 6
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



        72 20 34 2E 37 62
   00F2 0D 0A               274         .db     CR,LF
   00F4 43 6F 70 79 72 69   275         .ascii  "Copyright "
        67 68 74 20
   00FE 28                  276         .db     40
   00FF 43                  277         .ascii  "C"
   0100 29                  278         .db     41
   0101 20 31 39 37 38 20   279         .ascii  " 1978 by Microsoft"
        62 79 20 4D 69 63
        72 6F 73 6F 66 74
   0113 0D 0A 00 00         280         .db     CR,LF,0,0
                            281 ;
   0117 4D 65 6D 6F 72 79   282 MEMMSG: .ascii  "Memory size not enough"
        20 73 69 7A 65 20
        6E 6F 74 20 65 6E
        6F 75 67 68
   012D 0D 0A               283         .db     CR,LF
   012F 54 68 65 20 73 79   284         .ascii  "The system is stopped."
        73 74 65 6D 20 69
        73 20 73 74 6F 70
        70 65 64 2E
   0145 0D 0A 00 00         285         .db     CR,LF,0,0
                            286 ;
                            287 ; FUNCTION ADDRESS TABLE
                            288 ;
   0149 2C 16               289 FNCTAB: .dw     SGN
   014B F0 16               290         .dw     INT
   014D 42 16               291         .dw     ABS
   014F 48 80               292         .dw     USR
   0151 D4 0F               293         .dw     FRE
   0153 59 13               294         .dw     INP
   0155 02 10               295         .dw     POS
   0157 B6 18               296         .dw     SQR
   0159 95 19               297         .dw     RND
   015B D1 14               298         .dw     LOG
   015D 04 19               299         .dw     EXP
   015F 0A 1A               300         .dw     COS
   0161 10 1A               301         .dw     SIN
   0163 71 1A               302         .dw     TAN
   0165 86 1A               303         .dw     ATN
   0167 AD 13               304         .dw     PEEK
   0169 F1 1A               305         .dw     DEEK
   016B 96 80               306         .dw     POINT
   016D 86 12               307         .dw     LEN
   016F 9E 10               308         .dw     STR
   0171 20 13               309         .dw     VAL
   0173 95 12               310         .dw     ASC
   0175 A6 12               311         .dw     CHR
   0177 13 1B               312         .dw     HEX
   0179 A6 1B               313         .dw     BIN
   017B B6 12               314         .dw     LEFT
   017D E6 12               315         .dw     RIGHT
   017F F0 12               316         .dw     MID
                            317 ;
                            318 ; RESERVED WORD LIST
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 7
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                            319 ;
q  0181 C5 4E               320 WORDS:  .db     0x0C5,"ND"
q  0183 C6 4F               321         .db     0x0C6,"OR"
q  0185 CE 45               322         .db     0x0CE,"EXT"
q  0187 C4 41               323         .db     0x0C4,"ATA"
q  0189 C9 4E               324         .db     0x0C9,"NPUT"
q  018B C4 49               325         .db     0x0C4,"IM"
q  018D D2 45               326         .db     0x0D2,"EAD"
q  018F CC 45               327         .db     0x0CC,"ET"
q  0191 C7 4F               328         .db     0x0C7,"OTO"
q  0193 D2 55               329         .db     0x0D2,"UN"
   0195 C9 46               330         .db     0x0C9,"F"
q  0197 D2 45               331         .db     0x0D2,"ESTORE"
q  0199 C7 4F               332         .db     0x0C7,"OSUB"
q  019B D2 45               333         .db     0x0D2,"ETURN"
q  019D D2 45               334         .db     0x0D2,"EM"
q  019F D3 54               335         .db     0x0D3,"TOP"
q  01A1 CF 55               336         .db     0x0CF,"UT"
   01A3 CF 4E               337         .db     0x0CF,"N"
q  01A5 CE 55               338         .db     0x0CE,"ULL"
q  01A7 D7 41               339         .db     0x0D7,"AIT"
q  01A9 C4 45               340         .db     0x0C4,"EF"
q  01AB D0 4F               341         .db     0x0D0,"OKE"
q  01AD C4 4F               342         .db     0x0C4,"OKE"
q  01AF D3 43               343         .db     0x0D3,"CREEN"
q  01B1 CC 49               344         .db     0x0CC,"INES"
q  01B3 C3 4C               345         .db     0x0C3,"LS"
q  01B5 D7 49               346         .db     0x0D7,"IDTH"
q  01B7 CD 4F               347         .db     0x0CD,"ONITOR"
q  01B9 D3 45               348         .db     0x0D3,"ET"
q  01BB D2 45               349         .db     0x0D2,"ESET"
q  01BD D0 52               350         .db     0x0D0,"RINT"
q  01BF C3 4F               351         .db     0x0C3,"ONT"
q  01C1 CC 49               352         .db     0x0CC,"IST"
q  01C3 C3 4C               353         .db     0x0C3,"LEAR"
q  01C5 C3 4C               354         .db     0x0C3,"LOAD"
q  01C7 C3 53               355         .db     0x0C3,"SAVE"
q  01C9 CE 45               356         .db     0x0CE,"EW"
                            357 ;
q  01CB D4 41               358         .db     0x0D4,"AB("
   01CD D4 4F               359         .db     0x0D4,"O"
   01CF C6 4E               360         .db     0x0C6,"N"
q  01D1 D3 50               361         .db     0x0D3,"PC("
q  01D3 D4 48               362         .db     0x0D4,"HEN"
q  01D5 CE 4F               363         .db     0x0CE,"OT"
q  01D7 D3 54               364         .db     0x0D3,"TEP"
                            365 ;
   01D9 AB                  366         .db     0x0AB
   01DA AD                  367         .db     0x0AD
   01DB AA                  368         .db     0x0AA
   01DC AF                  369         .db     0x0AF
   01DD DE                  370         .db     0x0DE
q  01DE C1 4E               371         .db     0x0C1,"ND"
   01E0 CF 52               372         .db     0x0CF,"R"
   01E2 BE                  373         .db     0x0BE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 8
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   01E3 BD                  374         .db     0x0BD
   01E4 BC                  375         .db     0x0BC
                            376 ;
q  01E5 D3 47               377         .db     0x0D3,"GN"
q  01E7 C9 4E               378         .db     0x0C9,"NT"
q  01E9 C1 42               379         .db     0x0C1,"BS"
q  01EB D5 53               380         .db     0x0D5,"SR"
q  01ED C6 52               381         .db     0x0C6,"RE"
q  01EF C9 4E               382         .db     0x0C9,"NP"
q  01F1 D0 4F               383         .db     0x0D0,"OS"
q  01F3 D3 51               384         .db     0x0D3,"QR"
q  01F5 D2 4E               385         .db     0x0D2,"ND"
q  01F7 CC 4F               386         .db     0x0CC,"OG"
q  01F9 C5 58               387         .db     0x0C5,"XP"
q  01FB C3 4F               388         .db     0x0C3,"OS"
q  01FD D3 49               389         .db     0x0D3,"IN"
q  01FF D4 41               390         .db     0x0D4,"AN"
q  0201 C1 54               391         .db     0x0C1,"TN"
q  0203 D0 45               392         .db     0x0D0,"EEK"
q  0205 C4 45               393         .db     0x0C4,"EEK"
q  0207 D0 4F               394         .db     0x0D0,"OINT"
q  0209 CC 45               395         .db     0x0CC,"EN"
q  020B D3 54               396         .db     0x0D3,"TR$"
q  020D D6 41               397         .db     0x0D6,"AL"
q  020F C1 53               398         .db     0x0C1,"SC"
q  0211 C3 48               399         .db     0x0C3,"HR$"
q  0213 C8 45               400         .db     0x0C8,"EX$"
q  0215 C2 49               401         .db     0x0C2,"IN$"
q  0217 CC 45               402         .db     0x0CC,"EFT$"
q  0219 D2 49               403         .db     0x0D2,"IGHT$"
q  021B CD 49               404         .db     0x0CD,"ID$"
   021D 80                  405         .db     0x80                          ; End of list marker
                            406 ;
                            407 ; KEYWORD ADDRESS TABLE
                            408 ;
   021E 18 08               409 WORDTB: .dw     PEND
   0220 15 07               410         .dw     FOR
   0222 F0 0B               411         .dw     NEXT
   0224 65 09               412         .dw     DATA
   0226 F7 0A               413         .dw     INPUT
   0228 2C 0E               414         .dw     DIM
   022A 26 0B               415         .dw     READ
   022C 7C 09               416         .dw     LET
   022E 22 09               417         .dw     GOTO
   0230 05 09               418         .dw     RUN
   0232 F4 09               419         .dw     IF
   0234 DE 07               420         .dw     RESTOR
   0236 11 09               421         .dw     GOSUB
   0238 40 09               422         .dw     RETURN
   023A 67 09               423         .dw     REM
   023C 16 08               424         .dw     STOP
   023E 65 13               425         .dw     POUT
   0240 D6 09               426         .dw     ON
   0242 57 08               427         .dw     NULL
   0244 6B 13               428         .dw     WAIT
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 9
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0246 0A 10               429         .dw     DEF
   0248 B4 13               430         .dw     POKE
   024A FC 1A               431         .dw     DOKE
   024C 67 09               432         .dw     REM
   024E E2 1A               433         .dw     LINES
   0250 D5 1A               434         .dw     CLS
   0252 DA 1A               435         .dw     WIDTH
   0254 0E 1C               436         .dw     MONITR
   0256 99 80               437         .dw     PSET
   0258 9C 80               438         .dw     RESET
   025A 18 0A               439         .dw     PRINT
   025C 44 08               440         .dw     CONT
   025E 8A 06               441         .dw     LIST
   0260 BF 08               442         .dw     CLEAR
   0262 67 09               443         .dw     REM
   0264 67 09               444         .dw     REM
   0266 82 04               445         .dw     NEW
                            446 ;
                            447 ; RESERVED WORD TOKEN VALUES
                            448 ;
                     0080   449 ZEND    .equ    0x080                         ; END
                     0081   450 ZFOR    .equ    0x081                         ; FOR
                     0083   451 ZDATA   .equ    0x083                         ; DATA
                     0088   452 ZGOTO   .equ    0x088                         ; GOTO
                     008C   453 ZGOSUB  .equ    0x08C                         ; GOSUB
                     008E   454 ZREM    .equ    0x08E                         ; REM
                     009E   455 ZPRINT  .equ    0x09E                         ; PRINT
                     00A4   456 ZNEW    .equ    0x0A4                         ; NEW
                            457 ;
                     00A5   458 ZTAB    .equ    0x0A5                         ; TAB
                     00A6   459 ZTO     .equ    0x0A6                         ; TO
                     00A7   460 ZFN     .equ    0x0A7                         ; FN
                     00A8   461 ZSPC    .equ    0x0A8                         ; SPC
                     00A9   462 ZTHEN   .equ    0x0A9                         ; THEN
                     00AA   463 ZNOT    .equ    0x0AA                         ; NOT
                     00AB   464 ZSTEP   .equ    0x0AB                         ; STEP
                            465 ;
                     00AC   466 ZPLUS   .equ    0x0AC                         ; +
                     00AD   467 ZMINUS  .equ    0x0AD                         ; -
                     00AE   468 ZTIMES  .equ    0x0AE                         ; *
                     00AF   469 ZDIV    .equ    0x0AF                         ; /
                     00B2   470 ZOR     .equ    0x0B2                         ; OR
                     00B3   471 ZGTR    .equ    0x0B3                         ; >
                     00B4   472 ZEQUAL  .equ    0x0B4                         ; M
                     00B5   473 ZLTH    .equ    0x0B5                         ; <
                     00B6   474 ZSGN    .equ    0x0B6                         ; SGN
                     00C7   475 ZPOINT  .equ    0x0C7                         ; POINT
                     00CF   476 ZLEFT   .equ    0x0CD+2                       ; LEFT.
                            477 ;
                            478 ; ARITHMETIC PRECEDENCE TABLE
                            479 ;
   0268 79                  480 PRITAB: .db     0x79                          ; Precedence value
   0269 9E 17               481         .dw     PADD                          ; FPREG = <last> + FPREG
                            482 ;
   026B 79                  483         .db     0x79                          ; Precedence value
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 10
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   026C D2 13               484         .dw     PSUB                          ; FPREG = <last> - FPREG
                            485 ;
   026E 7C                  486         .db     0x7C                          ; Precedence value
   026F 10 15               487         .dw     MULT                          ; PPREG = <last> * FPREG
                            488 ;
   0271 7C                  489         .db     0x7C                          ; Precedence value
   0272 71 15               490         .dw     DIV                           ; FPREG = <last> / FPREG
                            491 ;
   0274 7F                  492         .db     0x7F                          ; Precedence value
   0275 BF 18               493         .dw     POWER                         ; FPREG = <last> ^ FPREG
                            494 ;
   0277 50                  495         .db     0x50                          ; Precedence value
   0278 85 0D               496         .dw     PAND                          ; FPREG = <last> AND FPREG
                            497 ;
   027A 46                  498         .db     0x46                          ; Precedence value
   027B 84 0D               499         .dw     POR                           ; FPREG = <last> OR FPREG
                            500 ;
                            501 ; BASIC ERROR CODE LIST
                            502 ;
   027D 4E 46               503 ERRORS: .ascii  "NF"                              ; NEXT without FOR
   027F 53 4E               504         .ascii  "SN"                              ; Syntax error
   0281 52 47               505         .ascii  "RG"                              ; RETURN without GOSUB
   0283 4F 44               506         .ascii  "OD"                              ; Out of DATA
   0285 46 43               507         .ascii  "FC"                              ; Illegal function call
   0287 4F 56               508         .ascii  "OV"                              ; Overflow error
   0289 4F 4D               509         .ascii  "OM"                              ; Out of memory
   028B 55 4C               510         .ascii  "UL"                              ; Undefined line
   028D 42 53               511         .ascii  "BS"                              ; Bad subscript
   028F 44 44               512         .ascii  "DD"                              ; Re-DIMensioned array
   0291 2F 30               513         .ascii  "/0"                              ; Division by zero
   0293 49 44               514         .ascii  "ID"                              ; Illegal direct
   0295 54 4D               515         .ascii  "TM"                              ; Type mis-match
   0297 4F 53               516         .ascii  "OS"                              ; Out of string space
   0299 4C 53               517         .ascii  "LS"                              ; String too long
   029B 53 54               518         .ascii  "ST"                              ; String formula too complex
   029D 43 4E               519         .ascii  "CN"                              ; Can't CONTinue
   029F 55 46               520         .ascii  "UF"                              ; Undefined FN function
   02A1 4D 4F               521         .ascii  "MO"                              ; Missing operand
   02A3 48 58               522         .ascii  "HX"                              ; HEX error
   02A5 42 4E               523         .ascii  "BN"                              ; BIN error
                            524 ;
                            525 ; INITIALISATION TABLE -------------------------------------------------------
                            526 ;
   02A7 C3 BF 00      [10]  527 INITAB: JP      WARMST                        ; Warm start jump
   02AA C3 95 08      [10]  528         JP      FCERR                         ; "USR (X)" jump (Set to Error)
   02AD D3 00         [11]  529         OUT     (0),A                         ; "OUT p,n" skeleton
   02AF C9            [10]  530         RET
   02B0 D6 00         [ 7]  531         SUB     0                             ; Division support routine
   02B2 6F            [ 4]  532         LD      L,A
   02B3 7C            [ 4]  533         LD      A,H
   02B4 DE 00         [ 7]  534         SBC     A,0
   02B6 67            [ 4]  535         LD      H,A
   02B7 78            [ 4]  536         LD      A,B
   02B8 DE 00         [ 7]  537         SBC     A,0
   02BA 47            [ 4]  538         LD      B,A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 11
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   02BB 3E 00         [ 7]  539         LD      A,0
   02BD C9            [10]  540         RET
   02BE 00 00 00            541         .db     0,0,0                         ; Random number seed table used by RND
   02C1 35 4A CA 99         542         .db     0x035,0x04A,0x0CA,0x099       ;-2.65145E+07
   02C5 39 1C 76 98         543         .db     0x039,0x01C,0x076,0x098       ; 1.61291E+07
   02C9 22 95 B3 98         544         .db     0x022,0x095,0x0B3,0x098       ;-1.17691E+07
   02CD 0A DD 47 98         545         .db     0x00A,0x0DD,0x047,0x098       ; 1.30983E+07
   02D1 53 D1 99 99         546         .db     0x053,0x0D1,0x099,0x099       ;-2-01612E+07
   02D5 0A 1A 9F 98         547         .db     0x00A,0x01A,0x09F,0x098       ;-1.04269E+07
   02D9 65 BC CD 98         548         .db     0x065,0x0BC,0x0CD,0x098       ;-1.34831E+07
   02DD D6 77 3E 98         549         .db     0x0D6,0x077,0x03E,0x098       ; 1.24825E+07
   02E1 52 C7 4F 80         550         .db     0x052,0x0C7,0x04F,0x080       ; Last random number
   02E5 DB 00         [11]  551         IN      A,(0)                         ; INP (x) skeleton
   02E7 C9            [10]  552         RET
   02E8 01                  553         .db     1                             ; POS (x) number (1)
   02E9 FF                  554         .db     255                           ; Terminal width (255 = no auto CRLF)
   02EA 1C                  555         .db     28                            ; Width for commas (3 columns)
   02EB 00                  556         .db     0                             ; No nulls after input bytes
   02EC 00                  557         .db     0                             ; Output enabled (^O off)
   02ED 14 00               558         .dw     20                            ; Initial lines counter
   02EF 14 00               559         .dw     20                            ; Initial lines number
   02F1 00 00               560         .dw     0                             ; Array load/save check sum
   02F3 00                  561         .db     0                             ; Break not by NMI
   02F4 00                  562         .db     0                             ; Break flag
   02F5 C3 BB 05      [10]  563         JP      TTYLIN                        ; Input reflection (set to TTY)
   02F8 C3 00 00      [10]  564         JP      0x0000                        ; POINT reflection unused
   02FB C3 00 00      [10]  565         JP      0x0000                        ; SET reflection
   02FE C3 00 00      [10]  566         JP      0x0000                        ; RESET reflection
   0301 A2 81               567         .dw     STLOOK                        ; Temp string space
   0303 FE FF               568         .dw     -2                            ; Current line number (cold)
   0305 3F 81               569         .dw     PROGST+1                      ; Start of program text
   0307                     570 INITBE:
                            571 ;
                            572 ; END OF INITIALISATION TABLE ---------------------------------------------------
                            573 ;
   0307 20 45 72 72 6F 72   574 ERRMSG: .ascii  " Error"
   030D 00                  575         .db     0
   030E 20 69 6E 20         576 INMSG:  .ascii  " in "
   0312 00                  577         .db     0
                     0312   578 ZERBYT  .equ    .-1                           ; A zero byte
   0313 4F 6B               579 OKMSG:  .ascii  "Ok"
   0315 0D 0A 00 00         580         .db     CR,LF,0,0
   0319 42 72 65 61 6B      581 BRKMSG: .ascii  "Break"
   031E 00                  582         .db     0
                            583 ;
   031F 21 04 00      [10]  584 BAKSTK: LD      HL,4                          ; Look for "FOR" block with
   0322 39            [11]  585         ADD     HL,SP                         ; same index as specified
   0323 7E            [ 7]  586 LOKFOR: LD      A,(HL)                        ; Get block ID
   0324 23            [ 6]  587         INC     HL                            ; Point to index address
   0325 FE 81         [ 7]  588         CP      ZFOR                          ; Is it a "FOR" token
   0327 C0            [11]  589         RET     NZ                            ; No - exit
   0328 4E            [ 7]  590         LD      C,(HL)                        ; BC = Address of "FOR" index
   0329 23            [ 6]  591         INC     HL
   032A 46            [ 7]  592         LD      B,(HL)
   032B 23            [ 6]  593         INC     HL                            ; Point to sign of STEP
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 12
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   032C E5            [11]  594         PUSH    HL                            ; Save pointer to sign
   032D 69            [ 4]  595         LD      L,C                           ; HL = address of "FOR" index
   032E 60            [ 4]  596         LD      H,B
   032F 7A            [ 4]  597         LD      A,D                           ; See if an index was specified
   0330 B3            [ 4]  598         OR      E                             ; DE = 0 if no index specified
   0331 EB            [ 4]  599         EX      DE,HL                         ; Specified index into HL
   0332 CA 39 03      [10]  600         JP      Z,INDFND                      ; Skip if no index given
   0335 EB            [ 4]  601         EX      DE,HL                         ; Index back into DE
   0336 CD 3E 06      [17]  602         CALL    CPDEHL                        ; Compare index with one given
   0339 01 0D 00      [10]  603 INDFND: LD      BC,16-3                       ; Offset to next block
   033C E1            [10]  604         POP     HL                            ; Restore pointer to sign
   033D C8            [11]  605         RET     Z                             ; Return if block found
   033E 09            [11]  606         ADD     HL,BC                         ; Point to next block
   033F C3 23 03      [10]  607         JP      LOKFOR                        ; Keep on looking
                            608 ;
   0342 CD 5C 03      [17]  609 MOVUP:  CALL    ENFMEM                        ; See if enough memory
   0345 C5            [11]  610 MOVSTR: PUSH    BC                            ; Save end of source
   0346 E3            [19]  611         EX      (SP),HL                       ; Swap source and dest" end
   0347 C1            [10]  612         POP     BC                            ; Get end of destination
   0348 CD 3E 06      [17]  613 MOVLP:  CALL    CPDEHL                        ; See if list moved
   034B 7E            [ 7]  614         LD      A,(HL)                        ; Get byte
   034C 02            [ 7]  615         LD      (BC),A                        ; Move it
   034D C8            [11]  616         RET     Z                             ; Exit if all done
   034E 0B            [ 6]  617         DEC     BC                            ; Next byte to move to
   034F 2B            [ 6]  618         DEC     HL                            ; Next byte to move
   0350 C3 48 03      [10]  619         JP      MOVLP                         ; Loop until all bytes moved
                            620 ;
   0353 E5            [11]  621 CHKSTK: PUSH    HL                            ; Save code string address
   0354 2A 1F 81      [16]  622         LD      HL,(ARREND)                   ; Lowest free memory
   0357 06 00         [ 7]  623         LD      B,0                           ; BC = Number of levels to test
   0359 09            [11]  624         ADD     HL,BC                         ; 2 Bytes for 0xeac level
   035A 09            [11]  625         ADD     HL,BC
   035B 3E                  626         .db     0x3E                          ; Skip "PUSH HL"
   035C E5            [11]  627 ENFMEM: PUSH    HL                            ; Save code string address
   035D 3E D0         [ 7]  628         LD      A,0x0D0                       ; LOW -48; 48 Bytes minimum RAM
   035F 95            [ 4]  629         SUB     L
   0360 6F            [ 4]  630         LD      L,A
   0361 3E FF         [ 7]  631         LD      A,0x0FF                       ; HIGH (-48); 48 Bytes minimum RAM
   0363 9C            [ 4]  632         SBC     A,H
   0364 DA 6B 03      [10]  633         JP      C,OMERR                       ; Not enough - ?OM Error
   0367 67            [ 4]  634         LD      H,A
   0368 39            [11]  635         ADD     HL,SP                         ; Test if stack is overflowed
   0369 E1            [10]  636         POP     HL                            ; Restore code string address
   036A D8            [11]  637         RET     C                             ; Return if enough mmory
   036B 1E 0C         [ 7]  638 OMERR:  LD      E,OM                          ; ?OM Error
   036D C3 8A 03      [10]  639         JP      ERROR
                            640 ;
   0370 2A 0E 81      [16]  641 DATSNR: LD      HL,(DATLIN)                   ; Get line of current DATA item
   0373 22 A1 80      [16]  642         LD      (LINEAT),HL                   ; Save as current line
   0376 1E 02         [ 7]  643 SNERR:  LD      E,SN                          ; ?SN Error
   0378 01                  644         .db     0x01                          ; Skip "LD E,DZ"
   0379 1E 14         [ 7]  645 DZERR:  LD      E,DZ                          ; ?/0 Error
   037B 01                  646         .db     0x01                          ; Skip "LD E,NF"
   037C 1E 00         [ 7]  647 NFERR:  LD      E,NF                          ; ?NF Error
   037E 01                  648         .db     0x01                          ; Skip "LD E,RD"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 13
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   037F 1E 12         [ 7]  649 DDERR:  LD      E,RD                          ; ?DD Error
   0381 01                  650         .db     0x01                          ; Skip "LD E,UF"
   0382 1E 22         [ 7]  651 UFERR:  LD      E,UF                          ; ?UF Error
   0384 01                  652         .db     0x01                          ; Skip "LD E,OV"
   0385 1E 0A         [ 7]  653 OVERR:  LD      E,OV                          ; ?OV Error
   0387 01                  654         .db     0x01                          ; Skip "LD E,TM"
   0388 1E 18         [ 7]  655 TMERR:  LD      E,TM                          ; ?TM Error
                            656 ;
   038A CD A8 04      [17]  657 ERROR:  CALL    CLREG                         ; Clear registers and stack
   038D 32 8A 80      [13]  658         LD      (CTLOFG),A                    ; Enable output (A is 0)
   0390 CD 69 0A      [17]  659         CALL    STTLIN                        ; Start new line
   0393 21 7D 02      [10]  660         LD      HL,ERRORS                     ; Point to error codes
   0396 57            [ 4]  661         LD      D,A                           ; D = 0 (A is 0)
   0397 3E 3F         [ 7]  662         LD      A,'?
   0399 CD 4F 06      [17]  663         CALL    OUTC                          ; Output '?
   039C 19            [11]  664         ADD     HL,DE                         ; Offset to correct error code
   039D 7E            [ 7]  665         LD      A,(HL)                        ; First character
   039E CD 4F 06      [17]  666         CALL    OUTC                          ; Output it
   03A1 CD CE 07      [17]  667         CALL    GETCHR                        ; Get next character
   03A4 CD 4F 06      [17]  668         CALL    OUTC                          ; Output it
   03A7 21 07 03      [10]  669         LD      HL,ERRMSG                     ; "Error" message
   03AA CD 14 11      [17]  670 ERRIN:  CALL    PRS                           ; Output message
   03AD 2A A1 80      [16]  671         LD      HL,(LINEAT)                   ; Get line of error
   03B0 11 FE FF      [10]  672         LD      DE,-2                         ; Cold start error if -2
   03B3 CD 3E 06      [17]  673         CALL    CPDEHL                        ; See if cold start error
   03B6 CA 51 00      [10]  674         JP      Z,CSTART                      ; Cold start error - Restart
   03B9 7C            [ 4]  675         LD      A,H                           ; Was it a direct error?
   03BA A5            [ 4]  676         AND     L                             ; Line = -1 if direct error
   03BB 3C            [ 4]  677         INC     A
   03BC C4 AF 17      [17]  678         CALL    NZ,LINEIN                     ; No - output line of error
   03BF 3E                  679         .db     0x3E                          ; Skip "POP BC"
   03C0 C1            [10]  680 POPNOK: POP     BC                            ; Drop address in input buffer
                            681 ;
   03C1 AF            [ 4]  682 PRNTOK: XOR     A                             ; Output "Ok" and get command
   03C2 32 8A 80      [13]  683         LD      (CTLOFG),A                    ; Enable output
   03C5 CD 69 0A      [17]  684         CALL    STTLIN                        ; Start new line
   03C8 21 13 03      [10]  685         LD      HL,OKMSG                      ; "Ok" message
   03CB CD 14 11      [17]  686         CALL    PRS                           ; Output "Ok"
   03CE 21 FF FF      [10]  687 GETCMD: LD      HL,-1                         ; Flag direct mode
   03D1 22 A1 80      [16]  688         LD      (LINEAT),HL                   ; Save as current line
   03D4 CD BB 05      [17]  689         CALL    GETLIN                        ; Get an input line
   03D7 DA CE 03      [10]  690         JP      C,GETCMD                      ; Get line again if break
   03DA CD CE 07      [17]  691         CALL    GETCHR                        ; Get first character
   03DD 3C            [ 4]  692         INC     A                             ; Test if end of line
   03DE 3D            [ 4]  693         DEC     A                             ; Without affecting Carry
   03DF CA CE 03      [10]  694         JP      Z,GETCMD                      ; Nothing entered - Get another
   03E2 F5            [11]  695         PUSH    AF                            ; Save Carry status
   03E3 CD 9A 08      [17]  696         CALL    ATOH                          ; Get line number into DE
   03E6 D5            [11]  697         PUSH    DE                            ; Save line number
   03E7 CD D2 04      [17]  698         CALL    CRUNCH                        ; Tokenise rest of line
   03EA 47            [ 4]  699         LD      B,A                           ; Length of tokenised line
   03EB D1            [10]  700         POP     DE                            ; Restore line number
   03EC F1            [10]  701         POP     AF                            ; Restore Carry
   03ED D2 AE 07      [10]  702         JP      NC,EXCUTE                     ; No line number - Direct mode
   03F0 D5            [11]  703         PUSH    DE                            ; Save line number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 14
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   03F1 C5            [11]  704         PUSH    BC                            ; Save length of tokenised line
   03F2 AF            [ 4]  705         XOR     A
   03F3 32 11 81      [13]  706         LD      (LSTBIN),A                    ; Clear last byte input
   03F6 CD CE 07      [17]  707         CALL    GETCHR                        ; Get next character
   03F9 B7            [ 4]  708         OR      A                             ; Set flags
   03FA F5            [11]  709         PUSH    AF                            ; And save them
   03FB CD 62 04      [17]  710         CALL    SRCHLN                        ; Search for line number in DE
   03FE DA 07 04      [10]  711         JP      C,LINFND                      ; Jump if line found
   0401 F1            [10]  712         POP     AF                            ; Get status
   0402 F5            [11]  713         PUSH    AF                            ; And re-save
   0403 CA 3B 09      [10]  714         JP      Z,ULERR                       ; Nothing after number - Error
   0406 B7            [ 4]  715         OR      A                             ; Clear Carry
   0407 C5            [11]  716 LINFND: PUSH    BC                            ; Save address of line in prog
   0408 D2 1E 04      [10]  717         JP      NC,INEWLN                     ; Line not found - Insert new
   040B EB            [ 4]  718         EX      DE,HL                         ; Next line address in DE
   040C 2A 1B 81      [16]  719         LD      HL,(PROGND)                   ; End of program
   040F 1A            [ 7]  720 SFTPRG: LD      A,(DE)                        ; Shift rest of program down
   0410 02            [ 7]  721         LD      (BC),A
   0411 03            [ 6]  722         INC     BC                            ; Next destination
   0412 13            [ 6]  723         INC     DE                            ; Next source
   0413 CD 3E 06      [17]  724         CALL    CPDEHL                        ; All done?
   0416 C2 0F 04      [10]  725         JP      NZ,SFTPRG                     ; More to do
   0419 60            [ 4]  726         LD      H,B                           ; HL - New end of program
   041A 69            [ 4]  727         LD      L,C
   041B 22 1B 81      [16]  728         LD      (PROGND),HL                   ; Update end of program
                            729 ;
   041E D1            [10]  730 INEWLN: POP     DE                            ; Get address of line,
   041F F1            [10]  731         POP     AF                            ; Get status
   0420 CA 45 04      [10]  732         JP      Z,SETPTR                      ; No text - Set up pointers
   0423 2A 1B 81      [16]  733         LD      HL,(PROGND)                   ; Get end of program
   0426 E3            [19]  734         EX      (SP),HL                       ; Get length of input line
   0427 C1            [10]  735         POP     BC                            ; End of program to BC
   0428 09            [11]  736         ADD     HL,BC                         ; Find new end
   0429 E5            [11]  737         PUSH    HL                            ; Save new end
   042A CD 42 03      [17]  738         CALL    MOVUP                         ; Make space for line
   042D E1            [10]  739         POP     HL                            ; Restore new end
   042E 22 1B 81      [16]  740         LD      (PROGND),HL                   ; Update end of program pointer
   0431 EB            [ 4]  741         EX      DE,HL                         ; Get line to move up in HL
   0432 74            [ 7]  742         LD      (HL),H                        ; Save MSB
   0433 D1            [10]  743         POP     DE                            ; Get new line number
   0434 23            [ 6]  744         INC     HL                            ; Skip pointer
   0435 23            [ 6]  745         INC     HL
   0436 73            [ 7]  746         LD      (HL),E                        ; Save LSB of line number
   0437 23            [ 6]  747         INC     HL
   0438 72            [ 7]  748         LD      (HL),D                        ; Save MSB of line number
   0439 23            [ 6]  749         INC     HL                            ; To first byte in line
   043A 11 A6 80      [10]  750         LD      DE,BUFFER                     ; Copy buffer to program
   043D 1A            [ 7]  751 MOVBUF: LD      A,(DE)                        ; Get source
   043E 77            [ 7]  752         LD      (HL),A                        ; Save destinations
   043F 23            [ 6]  753         INC     HL                            ; Next source
   0440 13            [ 6]  754         INC     DE                            ; Next destination
   0441 B7            [ 4]  755         OR      A                             ; Done?
   0442 C2 3D 04      [10]  756         JP      NZ,MOVBUF                     ; No - Repeat
   0445 CD 8E 04      [17]  757 SETPTR: CALL    RUNFST                        ; Set line pointers
   0448 23            [ 6]  758         INC     HL                            ; To LSB of pointer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 15
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0449 EB            [ 4]  759         EX      DE,HL                         ; Address to DE
   044A 62            [ 4]  760 PTRLP:  LD      H,D                           ; Address to HL
   044B 6B            [ 4]  761         LD      L,E
   044C 7E            [ 7]  762         LD      A,(HL)                        ; Get LSB of pointer
   044D 23            [ 6]  763         INC     HL                            ; To MSB of pointer
   044E B6            [ 7]  764         OR      (HL)                          ; Compare with MSB pointer
   044F CA CE 03      [10]  765         JP      Z,GETCMD                      ; Get command line if end
   0452 23            [ 6]  766         INC     HL                            ; To LSB of line number
   0453 23            [ 6]  767         INC     HL                            ; Skip line number
   0454 23            [ 6]  768         INC     HL                            ; Point to first byte in line
   0455 AF            [ 4]  769         XOR     A                             ; Looking for 00 byte
   0456 BE            [ 7]  770 FNDEND: CP      (HL)                          ; Found end of line?
   0457 23            [ 6]  771         INC     HL                            ; Move to next byte
   0458 C2 56 04      [10]  772         JP      NZ,FNDEND                     ; No - Keep looking
   045B EB            [ 4]  773         EX      DE,HL                         ; Next line address to HL
   045C 73            [ 7]  774         LD      (HL),E                        ; Save LSB of pointer
   045D 23            [ 6]  775         INC     HL
   045E 72            [ 7]  776         LD      (HL),D                        ; Save MSB of pointer
   045F C3 4A 04      [10]  777         JP      PTRLP                         ; Do next line
                            778 ;
   0462 2A A3 80      [16]  779 SRCHLN: LD      HL,(BASTXT)                   ; Start of program text
   0465 44            [ 4]  780 SRCHLP: LD      B,H                           ; BC = Address to look at
   0466 4D            [ 4]  781         LD      C,L
   0467 7E            [ 7]  782         LD      A,(HL)                        ; Get address of next line
   0468 23            [ 6]  783         INC     HL
   0469 B6            [ 7]  784         OR      (HL)                          ; End of program found?
   046A 2B            [ 6]  785         DEC     HL
   046B C8            [11]  786         RET     Z                             ; Yes - Line not found
   046C 23            [ 6]  787         INC     HL
   046D 23            [ 6]  788         INC     HL
   046E 7E            [ 7]  789         LD      A,(HL)                        ; Get LSB of line number
   046F 23            [ 6]  790         INC     HL
   0470 66            [ 7]  791         LD      H,(HL)                        ; Get MSB of line number
   0471 6F            [ 4]  792         LD      L,A
   0472 CD 3E 06      [17]  793         CALL    CPDEHL                        ; Compare with line in DE
   0475 60            [ 4]  794         LD      H,B                           ; HL = Start of this line
   0476 69            [ 4]  795         LD      L,C
   0477 7E            [ 7]  796         LD      A,(HL)                        ; Get LSB of next line address
   0478 23            [ 6]  797         INC     HL
   0479 66            [ 7]  798         LD      H,(HL)                        ; Get MSB of next line address
   047A 6F            [ 4]  799         LD      L,A                           ; Next line to HL
   047B 3F            [ 4]  800         CCF
   047C C8            [11]  801         RET     Z                             ; Lines found - Exit
   047D 3F            [ 4]  802         CCF
   047E D0            [11]  803         RET     NC                            ; Line not found,at line after
   047F C3 65 04      [10]  804         JP      SRCHLP                        ; Keep looking
                            805 ;
   0482 C0            [11]  806 NEW:    RET     NZ                            ; Return if any more on line
   0483 2A A3 80      [16]  807 CLRPTR: LD      HL,(BASTXT)                   ; Point to start of program
   0486 AF            [ 4]  808         XOR     A                             ; Set program area to empty
   0487 77            [ 7]  809         LD      (HL),A                        ; Save LSB = 00
   0488 23            [ 6]  810         INC     HL
   0489 77            [ 7]  811         LD      (HL),A                        ; Save MSB = 00
   048A 23            [ 6]  812         INC     HL
   048B 22 1B 81      [16]  813         LD      (PROGND),HL                   ; Set program end
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 16
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                            814 ;
   048E 2A A3 80      [16]  815 RUNFST: LD      HL,(BASTXT)                   ; Clear all variables
   0491 2B            [ 6]  816         DEC     HL
                            817 ;
   0492 22 13 81      [16]  818 INTVAR: LD      (BRKLIN),HL                   ; Initialise RUN variables
   0495 2A F4 80      [16]  819         LD      HL,(LSTRAM)                   ; Get end of RAM
   0498 22 08 81      [16]  820         LD      (STRBOT),HL                   ; Clear string space
   049B AF            [ 4]  821         XOR     A
   049C CD DE 07      [17]  822         CALL    RESTOR                        ; Reset DATA pointers
   049F 2A 1B 81      [16]  823         LD      HL,(PROGND)                   ; Get end of program
   04A2 22 1D 81      [16]  824         LD      (VAREND),HL                   ; Clear variables
   04A5 22 1F 81      [16]  825         LD      (ARREND),HL                   ; Clear arrays
                            826 ;
   04A8 C1            [10]  827 CLREG:  POP     BC                            ; Save return address
   04A9 2A 9F 80      [16]  828         LD      HL,(STRSPC)                   ; Get end of working RAN
   04AC F9            [ 6]  829         LD      SP,HL                         ; Set stack
   04AD 21 F8 80      [10]  830         LD      HL,TMSTPL                     ; Temporary string pool
   04B0 22 F6 80      [16]  831         LD      (TMSTPT),HL                   ; Reset temporary string ptr
   04B3 AF            [ 4]  832         XOR     A                             ; A = 00
   04B4 6F            [ 4]  833         LD      L,A                           ; HL = 0000
   04B5 67            [ 4]  834         LD      H,A
   04B6 22 19 81      [16]  835         LD      (CONTAD),HL                   ; No CONTinue
   04B9 32 10 81      [13]  836         LD      (FORFLG),A                    ; Clear FOR flag
   04BC 22 23 81      [16]  837         LD      (FNRGNM),HL                   ; Clear FN argument
   04BF E5            [11]  838         PUSH    HL                            ; HL = 0000
   04C0 C5            [11]  839         PUSH    BC                            ; Put back return
   04C1 2A 13 81      [16]  840 DOAGN:  LD      HL,(BRKLIN)                   ; Get address of code to RUN
   04C4 C9            [10]  841         RET                                   ; Return to execution driver
                            842 ;
   04C5 3E 3F         [ 7]  843 PROMPT: LD      A,'?                          ; '?
   04C7 CD 4F 06      [17]  844         CALL    OUTC                          ; Output character
   04CA 3E 20         [ 7]  845         LD      A,0x20                        ; Space
   04CC CD 4F 06      [17]  846         CALL    OUTC                          ; Output character
   04CF C3 93 80      [10]  847         JP      RINPUT                        ; Get input line
                            848 ;
   04D2 AF            [ 4]  849 CRUNCH: XOR     A                             ; Tokenise line @ HL to BUFFER
   04D3 32 F3 80      [13]  850         LD      (DATFLG),A                    ; Reset literal flag
   04D6 0E 05         [ 7]  851         LD      C,2+3                         ; 2 byte number and 3 nulls
   04D8 11 A6 80      [10]  852         LD      DE,BUFFER                     ; Start of input buffer
   04DB 7E            [ 7]  853 CRNCLP: LD      A,(HL)                        ; Get byte
   04DC FE 20         [ 7]  854         CP      0x20                          ; Is it a space?
   04DE CA 5A 05      [10]  855         JP      Z,MOVDIR                      ; Yes - Copy direct
   04E1 47            [ 4]  856         LD      B,A                           ; Save character
   04E2 FE 22         [ 7]  857         CP      '"                            ; Is it a quote?
   04E4 CA 7A 05      [10]  858         JP      Z,CPYLIT                      ; Yes - Copy literal string
   04E7 B7            [ 4]  859         OR      A                             ; Is it end of buffer?
   04E8 CA 81 05      [10]  860         JP      Z,ENDBUF                      ; Yes - End buffer
   04EB 3A F3 80      [13]  861         LD      A,(DATFLG)                    ; Get data type
   04EE B7            [ 4]  862         OR      A                             ; Literal?
   04EF 7E            [ 7]  863         LD      A,(HL)                        ; Get byte to copy
   04F0 C2 5A 05      [10]  864         JP      NZ,MOVDIR                     ; Literal - Copy direct
   04F3 FE 3F         [ 7]  865         CP      '?                            ; Is it '? short for PRINT
   04F5 3E 9E         [ 7]  866         LD      A,ZPRINT                      ; "PRINT" token
   04F7 CA 5A 05      [10]  867         JP      Z,MOVDIR                      ; Yes - replace it
   04FA 7E            [ 7]  868         LD      A,(HL)                        ; Get byte again
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 17
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   04FB FE 30         [ 7]  869         CP      '0                            ; Is it less than '0
   04FD DA 05 05      [10]  870         JP      C,FNDWRD                      ; Yes - Look for reserved words
   0500 FE 3C         [ 7]  871         CP      60                            ; ";"+1; Is it "0123456789:;" ?
   0502 DA 5A 05      [10]  872         JP      C,MOVDIR                      ; Yes - copy it direct
   0505 D5            [11]  873 FNDWRD: PUSH    DE                            ; Look for reserved words
   0506 11 80 01      [10]  874         LD      DE,WORDS-1                    ; Point to table
   0509 C5            [11]  875         PUSH    BC                            ; Save count
   050A 01 56 05      [10]  876         LD      BC,RETNAD                     ; Where to return to
   050D C5            [11]  877         PUSH    BC                            ; Save return address
   050E 06 7F         [ 7]  878         LD      B,ZEND-1                      ; First token value -1
   0510 7E            [ 7]  879         LD      A,(HL)                        ; Get byte
   0511 FE 61         [ 7]  880         CP      'a                            ; Less than 'a ?
   0513 DA 1E 05      [10]  881         JP      C,SEARCH                      ; Yes - search for words
   0516 FE 7B         [ 7]  882         CP      'z+1                          ; Greater than 'z ?
   0518 D2 1E 05      [10]  883         JP      NC,SEARCH                     ; Yes - search for words
   051B E6 5F         [ 7]  884         AND     0b01011111                    ; Force upper case
   051D 77            [ 7]  885         LD      (HL),A                        ; Replace byte
   051E 4E            [ 7]  886 SEARCH: LD      C,(HL)                        ; Search for a word
   051F EB            [ 4]  887         EX      DE,HL
   0520 23            [ 6]  888 GETNXT: INC     HL                            ; Get next reserved word
   0521 B6            [ 7]  889         OR      (HL)                          ; Start of word?
   0522 F2 20 05      [10]  890         JP      P,GETNXT                      ; No - move on
   0525 04            [ 4]  891         INC     B                             ; Increment token value
   0526 7E            [ 7]  892         LD      A,(HL)                        ; Get byte from table
   0527 E6 7F         [ 7]  893         AND     0b01111111                    ; Strip bit 7
   0529 C8            [11]  894         RET     Z                             ; Return if end of list
   052A B9            [ 4]  895         CP      C                             ; Same character as in buffer?
   052B C2 20 05      [10]  896         JP      NZ,GETNXT                     ; No - get next word
   052E EB            [ 4]  897         EX      DE,HL
   052F E5            [11]  898         PUSH    HL                            ; Save start of word
                            899 ;
   0530 13            [ 6]  900 NXTBYT: INC     DE                            ; Look through rest of word
   0531 1A            [ 7]  901         LD      A,(DE)                        ; Get byte from table
   0532 B7            [ 4]  902         OR      A                             ; End of word ?
   0533 FA 52 05      [10]  903         JP      M,MATCH                       ; Yes - Match found
   0536 4F            [ 4]  904         LD      C,A                           ; Save it
   0537 78            [ 4]  905         LD      A,B                           ; Get token value
   0538 FE 88         [ 7]  906         CP      ZGOTO                         ; Is it "GOTO" token ?
   053A C2 41 05      [10]  907         JP      NZ,NOSPC                      ; No - Don't allow spaces
   053D CD CE 07      [17]  908         CALL    GETCHR                        ; Get next character
   0540 2B            [ 6]  909         DEC     HL                            ; Cancel increment from GETCHR
   0541 23            [ 6]  910 NOSPC:  INC     HL                            ; Next byte
   0542 7E            [ 7]  911         LD      A,(HL)                        ; Get byte
   0543 FE 61         [ 7]  912         CP      'a                            ; Less than 'a ?
   0545 DA 4A 05      [10]  913         JP      C,NOCHNG                      ; Yes - don't change
   0548 E6 5F         [ 7]  914         AND     0b01011111                    ; Make upper case
   054A B9            [ 4]  915 NOCHNG: CP      C                             ; Same as in buffer ?
   054B CA 30 05      [10]  916         JP      Z,NXTBYT                      ; Yes - keep testing
   054E E1            [10]  917         POP     HL                            ; Get back start of word
   054F C3 1E 05      [10]  918         JP      SEARCH                        ; Look at next word
                            919 ;
   0552 48            [ 4]  920 MATCH:  LD      C,B                           ; Word found - Save token value
   0553 F1            [10]  921         POP     AF                            ; Throw away return
   0554 EB            [ 4]  922         EX      DE,HL
   0555 C9            [10]  923         RET                                   ; Return to "RETNAD"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 18
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0556 EB            [ 4]  924 RETNAD: EX      DE,HL                         ; Get address in string
   0557 79            [ 4]  925         LD      A,C                           ; Get token value
   0558 C1            [10]  926         POP     BC                            ; Restore buffer length
   0559 D1            [10]  927         POP     DE                            ; Get destination address
   055A 23            [ 6]  928 MOVDIR: INC     HL                            ; Next source in buffer
   055B 12            [ 7]  929         LD      (DE),A                        ; Put byte in buffer
   055C 13            [ 6]  930         INC     DE                            ; Move up buffer
   055D 0C            [ 4]  931         INC     C                             ; Increment length of buffer
   055E D6 3A         [ 7]  932         SUB     ':                            ; End of statement?
   0560 CA 68 05      [10]  933         JP      Z,SETLIT                      ; Jump if multi-statement line
   0563 FE 49         [ 7]  934         CP      ZDATA-0x3A                    ; Is it DATA statement ?
   0565 C2 6B 05      [10]  935         JP      NZ,TSTREM                     ; No - see if REM
   0568 32 F3 80      [13]  936 SETLIT: LD      (DATFLG),A                    ; Set literal flag
   056B D6 54         [ 7]  937 TSTREM: SUB     ZREM-0x3A                     ; Is it REM?
   056D C2 DB 04      [10]  938         JP      NZ,CRNCLP                     ; No - Leave flag
   0570 47            [ 4]  939         LD      B,A                           ; Copy rest of buffer
   0571 7E            [ 7]  940 NXTCHR: LD      A,(HL)                        ; Get byte
   0572 B7            [ 4]  941         OR      A                             ; End of line ?
   0573 CA 81 05      [10]  942         JP      Z,ENDBUF                      ; Yes - Terminate buffer
   0576 B8            [ 4]  943         CP      B                             ; End of statement ?
   0577 CA 5A 05      [10]  944         JP      Z,MOVDIR                      ; Yes - Get next one
   057A 23            [ 6]  945 CPYLIT: INC     HL                            ; Move up source string
   057B 12            [ 7]  946         LD      (DE),A                        ; Save in destination
   057C 0C            [ 4]  947         INC     C                             ; Increment length
   057D 13            [ 6]  948         INC     DE                            ; Move up destination
   057E C3 71 05      [10]  949         JP      NXTCHR                        ; Repeat
                            950 ;
   0581 21 A5 80      [10]  951 ENDBUF: LD      HL,BUFFER-1                   ; Point to start of buffer
   0584 12            [ 7]  952         LD      (DE),A                        ; Mark end of buffer (A = 00)
   0585 13            [ 6]  953         INC     DE
   0586 12            [ 7]  954         LD      (DE),A                        ; A = 00
   0587 13            [ 6]  955         INC     DE
   0588 12            [ 7]  956         LD      (DE),A                        ; A = 00
   0589 C9            [10]  957         RET
                            958 ;
   058A 3A 89 80      [13]  959 DODEL:  LD      A,(NULFLG)                    ; Get null flag status
   058D B7            [ 4]  960         OR      A                             ; Is it zero?
   058E 3E 00         [ 7]  961         LD      A,0                           ; Zero A - Leave flags
   0590 32 89 80      [13]  962         LD      (NULFLG),A                    ; Zero null flag
   0593 C2 9E 05      [10]  963         JP      NZ,ECHDEL                     ; Set - Echo it
   0596 05            [ 4]  964         DEC     B                             ; Decrement length
   0597 CA BB 05      [10]  965         JP      Z,GETLIN                      ; Get line again if empty
   059A CD 4F 06      [17]  966         CALL    OUTC                          ; Output null character
   059D 3E                  967         .db     0x3E                          ; Skip "DEC B"
   059E 05            [ 4]  968 ECHDEL: DEC     B                             ; Count bytes in buffer
   059F 2B            [ 6]  969         DEC     HL                            ; Back space buffer
   05A0 CA B2 05      [10]  970         JP      Z,OTKLN                       ; No buffer - Try again
   05A3 7E            [ 7]  971         LD      A,(HL)                        ; Get deleted byte
   05A4 CD 4F 06      [17]  972         CALL    OUTC                          ; Echo it
   05A7 C3 C4 05      [10]  973         JP      MORINP                        ; Get more input
                            974 ;
   05AA 05            [ 4]  975 DELCHR: DEC     B                             ; Count bytes in buffer
   05AB 2B            [ 6]  976         DEC     HL                            ; Back space buffer
   05AC CD 4F 06      [17]  977         CALL    OUTC                          ; Output character in A
   05AF C2 C4 05      [10]  978         JP      NZ,MORINP                     ; Not end - Get more
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 19
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   05B2 CD 4F 06      [17]  979 OTKLN:  CALL    OUTC                          ; Output character in A
   05B5 CD 76 0A      [17]  980 KILIN:  CALL    PRCRLF                        ; Output CRLF
   05B8 C3 BB 05      [10]  981         JP      TTYLIN                        ; Get line again
                            982 ;
   05BB                     983 GETLIN:
   05BB 21 A6 80      [10]  984 TTYLIN: LD      HL,BUFFER                     ; Get a line by character
   05BE 06 01         [ 7]  985         LD      B,1                           ; Set buffer as empty
   05C0 AF            [ 4]  986         XOR     A
   05C1 32 89 80      [13]  987         LD      (NULFLG),A                    ; Clear null flag
   05C4 CD 79 06      [17]  988 MORINP: CALL    CLOTST                        ; Get character and test ^O
   05C7 4F            [ 4]  989         LD      C,A                           ; Save character in C
   05C8 FE 7F         [ 7]  990         CP      DEL                           ; Delete character?
   05CA CA 8A 05      [10]  991         JP      Z,DODEL                       ; Yes - Process it
   05CD 3A 89 80      [13]  992         LD      A,(NULFLG)                    ; Get null flag
   05D0 B7            [ 4]  993         OR      A                             ; Test null flag status
   05D1 CA DD 05      [10]  994         JP      Z,PROCES                      ; Reset - Process character
   05D4 3E 00         [ 7]  995         LD      A,0                           ; Set a null
   05D6 CD 4F 06      [17]  996         CALL    OUTC                          ; Output null
   05D9 AF            [ 4]  997         XOR     A                             ; Clear A
   05DA 32 89 80      [13]  998         LD      (NULFLG),A                    ; Reset null flag
   05DD 79            [ 4]  999 PROCES: LD      A,C                           ; Get character
   05DE FE 07         [ 7] 1000         CP      CTRLG                         ; Bell?
   05E0 CA 21 06      [10] 1001         JP      Z,PUTCTL                      ; Yes - Save it
   05E3 FE 03         [ 7] 1002         CP      CTRLC                         ; Is it control "C"?
   05E5 CC 76 0A      [17] 1003         CALL    Z,PRCRLF                      ; Yes - Output CRLF
   05E8 37            [ 4] 1004         SCF                                   ; Flag break
   05E9 C8            [11] 1005         RET     Z                             ; Return if control "C"
   05EA FE 0D         [ 7] 1006         CP      CR                            ; Is it enter?
   05EC CA 71 0A      [10] 1007         JP      Z,ENDINP                      ; Yes - Terminate input
   05EF FE 15         [ 7] 1008         CP      CTRLU                         ; Is it control "U"?
   05F1 CA B5 05      [10] 1009         JP      Z,KILIN                       ; Yes - Get another line
   05F4 FE 40         [ 7] 1010         CP      '@                            ; Is it "kill line"?
   05F6 CA B2 05      [10] 1011         JP      Z,OTKLN                       ; Yes - Kill line
   05F9 FE 5F         [ 7] 1012         CP      '_                            ; Is it delete?
   05FB CA AA 05      [10] 1013         JP      Z,DELCHR                      ; Yes - Delete character
   05FE FE 08         [ 7] 1014         CP      BKSP                          ; Is it backspace?
   0600 CA AA 05      [10] 1015         JP      Z,DELCHR                      ; Yes - Delete character
   0603 FE 12         [ 7] 1016         CP      CTRLR                         ; Is it control "R"?
   0605 C2 1C 06      [10] 1017         JP      NZ,PUTBUF                     ; No - Put in buffer
   0608 C5            [11] 1018         PUSH    BC                            ; Save buffer length
   0609 D5            [11] 1019         PUSH    DE                            ; Save DE
   060A E5            [11] 1020         PUSH    HL                            ; Save buffer address
   060B 36 00         [10] 1021         LD      (HL),0                        ; Mark end of buffer
   060D CD 20 1C      [17] 1022         CALL    OUTNCR                        ; Output and do CRLF
   0610 21 A6 80      [10] 1023         LD      HL,BUFFER                     ; Point to buffer start
   0613 CD 14 11      [17] 1024         CALL    PRS                           ; Output buffer
   0616 E1            [10] 1025         POP     HL                            ; Restore buffer address
   0617 D1            [10] 1026         POP     DE                            ; Restore DE
   0618 C1            [10] 1027         POP     BC                            ; Restore buffer length
   0619 C3 C4 05      [10] 1028         JP      MORINP                        ; Get another character
                           1029 ;
   061C FE 20         [ 7] 1030 PUTBUF: CP      0x20                          ; Is it a control code?
   061E DA C4 05      [10] 1031         JP      C,MORINP                      ; Yes - Ignore
   0621 78            [ 4] 1032 PUTCTL: LD      A,B                           ; Get number of bytes in buffer
   0622 FE 49         [ 7] 1033         CP      72+1                          ; Test for line overflow
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 20
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0624 3E 07         [ 7] 1034         LD      A,CTRLG                       ; Set a bell
   0626 D2 36 06      [10] 1035         JP      NC,OUTNBS                     ; Ring bell if buffer full
   0629 79            [ 4] 1036         LD      A,C                           ; Get character
   062A 71            [ 7] 1037         LD      (HL),C                        ; Save in buffer
   062B 32 11 81      [13] 1038         LD      (LSTBIN),A                    ; Save last input byte
   062E 23            [ 6] 1039         INC     HL                            ; Move up buffer
   062F 04            [ 4] 1040         INC     B                             ; Increment length
   0630 CD 4F 06      [17] 1041 OUTIT:  CALL    OUTC                          ; Output the character entered
   0633 C3 C4 05      [10] 1042         JP      MORINP                        ; Get another character
                           1043 ;
   0636 CD 4F 06      [17] 1044 OUTNBS: CALL    OUTC                          ; Output bell and back over it
   0639 3E 08         [ 7] 1045         LD      A,BKSP                        ; Set back space
   063B C3 30 06      [10] 1046         JP      OUTIT                         ; Output it and get more
                           1047 ;
   063E 7C            [ 4] 1048 CPDEHL: LD      A,H                           ; Get H
   063F 92            [ 4] 1049         SUB     D                             ; Compare with D
   0640 C0            [11] 1050         RET     NZ                            ; Different - Exit
   0641 7D            [ 4] 1051         LD      A,L                           ; Get L
   0642 93            [ 4] 1052         SUB     E                             ; Compare with E
   0643 C9            [10] 1053         RET                                   ; Return status
                           1054 ;
   0644 7E            [ 7] 1055 CHKSYN: LD      A,(HL)                        ; Check syntax of character
   0645 E3            [19] 1056         EX      (SP),HL                       ; Address of test byte
   0646 BE            [ 7] 1057         CP      (HL)                          ; Same as in code string?
   0647 23            [ 6] 1058         INC     HL                            ; Return address
   0648 E3            [19] 1059         EX      (SP),HL                       ; Put it back
   0649 CA CE 07      [10] 1060         JP      Z,GETCHR                      ; Yes - Get next character
   064C C3 76 03      [10] 1061         JP      SNERR                         ; Different - ?SN Error
                           1062 ;
   064F F5            [11] 1063 OUTC:   PUSH    AF                            ; Save character
   0650 3A 8A 80      [13] 1064         LD      A,(CTLOFG)                    ; Get control "O" flag
   0653 B7            [ 4] 1065         OR      A                             ; Is it set?
   0654 C2 49 11      [10] 1066         JP      NZ,POPAF                      ; Yes - don't output
   0657 F1            [10] 1067         POP     AF                            ; Restore character
   0658 C5            [11] 1068         PUSH    BC                            ; Save buffer length
   0659 F5            [11] 1069         PUSH    AF                            ; Save character
   065A FE 20         [ 7] 1070         CP      0x20                          ; Is it a control code?
   065C DA 73 06      [10] 1071         JP      C,DINPOS                      ; Yes - Don't INC POS(X)
   065F 3A 87 80      [13] 1072         LD      A,(LWIDTH)                    ; Get line width
   0662 47            [ 4] 1073         LD      B,A                           ; To B
   0663 3A F0 80      [13] 1074         LD      A,(CURPOS)                    ; Get cursor position
   0666 04            [ 4] 1075         INC     B                             ; Width 255?
   0667 CA 6F 06      [10] 1076         JP      Z,INCLEN                      ; Yes - No width limit
   066A 05            [ 4] 1077         DEC     B                             ; Restore width
   066B B8            [ 4] 1078         CP      B                             ; At end of line?
   066C CC 76 0A      [17] 1079         CALL    Z,PRCRLF                      ; Yes - output CRLF
   066F 3C            [ 4] 1080 INCLEN: INC     A                             ; Move on one character
   0670 32 F0 80      [13] 1081         LD      (CURPOS),A                    ; Save new position
   0673 F1            [10] 1082 DINPOS: POP     AF                            ; Restore character
   0674 C1            [10] 1083         POP     BC                            ; Restore buffer length
   0675 CD 0B 1C      [17] 1084         CALL    MONOUT                        ; Send it
   0678 C9            [10] 1085         RET
                           1086 ;
   0679 CD D3 1A      [17] 1087 CLOTST: CALL    GETINP                        ; Get input character
   067C E6 7F         [ 7] 1088         AND     0b01111111                    ; Strip bit 7
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 21
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   067E FE 0F         [ 7] 1089         CP      CTRLO                         ; Is it control "O"?
   0680 C0            [11] 1090         RET     NZ                            ; No don't flip flag
   0681 3A 8A 80      [13] 1091         LD      A,(CTLOFG)                    ; Get flag
   0684 2F            [ 4] 1092         CPL                                   ; Flip it
   0685 32 8A 80      [13] 1093         LD      (CTLOFG),A                    ; Put it back
   0688 AF            [ 4] 1094         XOR     A                             ; Null character
   0689 C9            [10] 1095         RET
                           1096 ;
   068A CD 9A 08      [17] 1097 LIST:   CALL    ATOH                          ; ASCII number to DE
   068D C0            [11] 1098         RET     NZ                            ; Return if anything extra
   068E C1            [10] 1099         POP     BC                            ; Rubbish - Not needed
   068F CD 62 04      [17] 1100         CALL    SRCHLN                        ; Search for line number in DE
   0692 C5            [11] 1101         PUSH    BC                            ; Save address of line
   0693 CD E0 06      [17] 1102         CALL    SETLIN                        ; Set up lines counter
   0696 E1            [10] 1103 LISTLP: POP     HL                            ; Restore address of line
   0697 4E            [ 7] 1104         LD      C,(HL)                        ; Get LSB of next line
   0698 23            [ 6] 1105         INC     HL
   0699 46            [ 7] 1106         LD      B,(HL)                        ; Get MSB of next line
   069A 23            [ 6] 1107         INC     HL
   069B 78            [ 4] 1108         LD      A,B                           ; BC = 0 (End of program)?
   069C B1            [ 4] 1109         OR      C
   069D CA C1 03      [10] 1110         JP      Z,PRNTOK                      ; Yes - Go to command mode
   06A0 CD E9 06      [17] 1111         CALL    COUNT                         ; Count lines
   06A3 CD F9 07      [17] 1112         CALL    TSTBRK                        ; Test for break key
   06A6 C5            [11] 1113         PUSH    BC                            ; Save address of next line
   06A7 CD 76 0A      [17] 1114         CALL    PRCRLF                        ; Output CRLF
   06AA 5E            [ 7] 1115         LD      E,(HL)                        ; Get LSB of line number
   06AB 23            [ 6] 1116         INC     HL
   06AC 56            [ 7] 1117         LD      D,(HL)                        ; Get MSB of line number
   06AD 23            [ 6] 1118         INC     HL
   06AE E5            [11] 1119         PUSH    HL                            ; Save address of line start
   06AF EB            [ 4] 1120         EX      DE,HL                         ; Line number to HL
   06B0 CD B7 17      [17] 1121         CALL    PRNTHL                        ; Output line number in decimal
   06B3 3E 20         [ 7] 1122         LD      A,0x20                        ; Space after line number
   06B5 E1            [10] 1123         POP     HL                            ; Restore start of line address
   06B6 CD 4F 06      [17] 1124 LSTLP2: CALL    OUTC                          ; Output character in A
   06B9 7E            [ 7] 1125 LSTLP3: LD      A,(HL)                        ; Get next byte in line
   06BA B7            [ 4] 1126         OR      A                             ; End of line?
   06BB 23            [ 6] 1127         INC     HL                            ; To next byte in line
   06BC CA 96 06      [10] 1128         JP      Z,LISTLP                      ; Yes - get next line
   06BF F2 B6 06      [10] 1129         JP      P,LSTLP2                      ; No token - output it
   06C2 D6 7F         [ 7] 1130         SUB     ZEND-1                        ; Find and output word
   06C4 4F            [ 4] 1131         LD      C,A                           ; Token offset+1 to C
   06C5 11 81 01      [10] 1132         LD      DE,WORDS                      ; Reserved word list
   06C8 1A            [ 7] 1133 FNDTOK: LD      A,(DE)                        ; Get character in list
   06C9 13            [ 6] 1134         INC     DE                            ; Move on to next
   06CA B7            [ 4] 1135         OR      A                             ; Is it start of word?
   06CB F2 C8 06      [10] 1136         JP      P,FNDTOK                      ; No - Keep looking for word
   06CE 0D            [ 4] 1137         DEC     C                             ; Count words
   06CF C2 C8 06      [10] 1138         JP      NZ,FNDTOK                     ; Not there - keep looking
   06D2 E6 7F         [ 7] 1139 OUTWRD: AND     0b01111111                    ; Strip bit 7
   06D4 CD 4F 06      [17] 1140         CALL    OUTC                          ; Output first character
   06D7 1A            [ 7] 1141         LD      A,(DE)                        ; Get next character
   06D8 13            [ 6] 1142         INC     DE                            ; Move on to next
   06D9 B7            [ 4] 1143         OR      A                             ; Is it end of word?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 22
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   06DA F2 D2 06      [10] 1144         JP      P,OUTWRD                      ; No - output the rest
   06DD C3 B9 06      [10] 1145         JP      LSTLP3                        ; Next byte in line
                           1146 ;
   06E0 E5            [11] 1147 SETLIN: PUSH    HL                            ; Set up LINES counter
   06E1 2A 8D 80      [16] 1148         LD      HL,(LINESN)                   ; Get LINES number
   06E4 22 8B 80      [16] 1149         LD      (LINESC),HL                   ; Save in LINES counter
   06E7 E1            [10] 1150         POP     HL
   06E8 C9            [10] 1151         RET
                           1152 ;
   06E9 E5            [11] 1153 COUNT:  PUSH    HL                            ; Save code string address
   06EA D5            [11] 1154         PUSH    DE
   06EB 2A 8B 80      [16] 1155         LD      HL,(LINESC)                   ; Get LINES counter
   06EE 11 FF FF      [10] 1156         LD      DE,-1
   06F1 ED 5A         [15] 1157         ADC     HL,DE                         ; Decrement
   06F3 22 8B 80      [16] 1158         LD      (LINESC),HL                   ; Put it back
   06F6 D1            [10] 1159         POP     DE
   06F7 E1            [10] 1160         POP     HL                            ; Restore code string address
   06F8 F0            [11] 1161         RET     P                             ; Return if more lines to go
   06F9 E5            [11] 1162         PUSH    HL                            ; Save code string address
   06FA 2A 8D 80      [16] 1163         LD      HL,(LINESN)                   ; Get LINES number
   06FD 22 8B 80      [16] 1164         LD      (LINESC),HL                   ; Reset LINES counter
   0700 CD D3 1A      [17] 1165         CALL    GETINP                        ; Get input character
   0703 FE 03         [ 7] 1166         CP      CTRLC                         ; Is it control "C"?
   0705 CA 0C 07      [10] 1167         JP      Z,RSLNBK                      ; Yes - Reset LINES and break
   0708 E1            [10] 1168         POP     HL                            ; Restore code string address
   0709 C3 E9 06      [10] 1169         JP      COUNT                         ; Keep on counting
                           1170 ;
   070C 2A 8D 80      [16] 1171 RSLNBK: LD      HL,(LINESN)                   ; Get LINES number
   070F 22 8B 80      [16] 1172         LD      (LINESC),HL                   ; Reset LINES counter
   0712 C3 C2 00      [10] 1173         JP      BRKRET                        ; Go and output "Break"
                           1174 ;
   0715 3E 64         [ 7] 1175 FOR:    LD      A,0x64                        ; Flag "FOR" assignment
   0717 32 10 81      [13] 1176         LD      (FORFLG),A                    ; Save "FOR" flag
   071A CD 7C 09      [17] 1177         CALL    LET                           ; Set up initial index
   071D C1            [10] 1178         POP     BC                            ; Drop RETurn address
   071E E5            [11] 1179         PUSH    HL                            ; Save code string address
   071F CD 65 09      [17] 1180         CALL    DATA                          ; Get next statement address
   0722 22 0C 81      [16] 1181         LD      (LOOPST),HL                   ; Save it for start of loop
   0725 21 02 00      [10] 1182         LD      HL,2                          ; Offset for "FOR" block
   0728 39            [11] 1183         ADD     HL,SP                         ; Point to it
   0729 CD 23 03      [17] 1184 FORSLP: CALL    LOKFOR                        ; Look for existing "FOR" block
   072C D1            [10] 1185         POP     DE                            ; Get code string address
   072D C2 45 07      [10] 1186         JP      NZ,FORFND                     ; No nesting found
   0730 09            [11] 1187         ADD     HL,BC                         ; Move into "FOR" block
   0731 D5            [11] 1188         PUSH    DE                            ; Save code string address
   0732 2B            [ 6] 1189         DEC     HL
   0733 56            [ 7] 1190         LD      D,(HL)                        ; Get MSB of loop statement
   0734 2B            [ 6] 1191         DEC     HL
   0735 5E            [ 7] 1192         LD      E,(HL)                        ; Get LSB of loop statement
   0736 23            [ 6] 1193         INC     HL
   0737 23            [ 6] 1194         INC     HL
   0738 E5            [11] 1195         PUSH    HL                            ; Save block address
   0739 2A 0C 81      [16] 1196         LD      HL,(LOOPST)                   ; Get address of loop statement
   073C CD 3E 06      [17] 1197         CALL    CPDEHL                        ; Compare the FOR loops
   073F E1            [10] 1198         POP     HL                            ; Restore block address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 23
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0740 C2 29 07      [10] 1199         JP      NZ,FORSLP                     ; Different FORs - Find another
   0743 D1            [10] 1200         POP     DE                            ; Restore code string address
   0744 F9            [ 6] 1201         LD      SP,HL                         ; Remove all nested loops
                           1202 ;
   0745 EB            [ 4] 1203 FORFND: EX      DE,HL                         ; Code string address to HL
   0746 0E 08         [ 7] 1204         LD      C,8
   0748 CD 53 03      [17] 1205         CALL    CHKSTK                        ; Check for 8 levels of stack
   074B E5            [11] 1206         PUSH    HL                            ; Save code string address
   074C 2A 0C 81      [16] 1207         LD      HL,(LOOPST)                   ; Get first statement of loop
   074F E3            [19] 1208         EX      (SP),HL                       ; Save and restore code string
   0750 E5            [11] 1209         PUSH    HL                            ; Re-save code string address
   0751 2A A1 80      [16] 1210         LD      HL,(LINEAT)                   ; Get current line number
   0754 E3            [19] 1211         EX      (SP),HL                       ; Save and restore code string
   0755 CD 3E 0C      [17] 1212         CALL    TSTNUM                        ; Make sure it's a number
   0758 CD 44 06      [17] 1213         CALL    CHKSYN                        ; Make sure "TO" is next
   075B A6                 1214         .db     ZTO                           ; "TO" token
   075C CD 3B 0C      [17] 1215         CALL    GETNUM                        ; Get "TO" expression value
   075F E5            [11] 1216         PUSH    HL                            ; Save code string address
   0760 CD 69 16      [17] 1217         CALL    BCDEFP                        ; Move "TO" value to BCDE
   0763 E1            [10] 1218         POP     HL                            ; Restore code string address
   0764 C5            [11] 1219         PUSH    BC                            ; Save "TO" value in block
   0765 D5            [11] 1220         PUSH    DE
   0766 01 00 81      [10] 1221         LD      BC,0x8100                     ; BCDE - 1 (default STEP)
   0769 51            [ 4] 1222         LD      D,C                           ; C=0
   076A 5A            [ 4] 1223         LD      E,D                           ; D=0
   076B 7E            [ 7] 1224         LD      A,(HL)                        ; Get next byte in code string
   076C FE AB         [ 7] 1225         CP      ZSTEP                         ; See if "STEP" is stated
   076E 3E 01         [ 7] 1226         LD      A,1                           ; Sign of step = 1
   0770 C2 81 07      [10] 1227         JP      NZ,SAVSTP                     ; No STEP given - Default to 1
   0773 CD CE 07      [17] 1228         CALL    GETCHR                        ; Jump over "STEP" token
   0776 CD 3B 0C      [17] 1229         CALL    GETNUM                        ; Get step value
   0779 E5            [11] 1230         PUSH    HL                            ; Save code string address
   077A CD 69 16      [17] 1231         CALL    BCDEFP                        ; Move STEP to BCDE
   077D CD 1D 16      [17] 1232         CALL    TSTSGN                        ; Test sign of FPREG
   0780 E1            [10] 1233         POP     HL                            ; Restore code string address
   0781 C5            [11] 1234 SAVSTP: PUSH    BC                            ; Save the STEP value in block
   0782 D5            [11] 1235         PUSH    DE
   0783 F5            [11] 1236         PUSH    AF                            ; Save sign of STEP
   0784 33            [ 6] 1237         INC     SP                            ; Don't save flags
   0785 E5            [11] 1238         PUSH    HL                            ; Save code string address
   0786 2A 13 81      [16] 1239         LD      HL,(BRKLIN)                   ; Get address of index variable
   0789 E3            [19] 1240         EX      (SP),HL                       ; Save and restore code string
   078A 06 81         [ 7] 1241 PUTFID: LD      B,ZFOR                        ; "FOR" block marker
   078C C5            [11] 1242         PUSH    BC                            ; Save it
   078D 33            [ 6] 1243         INC     SP                            ; Don't save C
                           1244 ;
   078E CD F9 07      [17] 1245 RUNCNT: CALL    TSTBRK                        ; Execution driver - Test break
   0791 22 13 81      [16] 1246         LD      (BRKLIN),HL                   ; Save code address for break
   0794 7E            [ 7] 1247         LD      A,(HL)                        ; Get next byte in code string
   0795 FE 3A         [ 7] 1248         CP      ':                            ; Multi statement line?
   0797 CA AE 07      [10] 1249         JP      Z,EXCUTE                      ; Yes - Execute it
   079A B7            [ 4] 1250         OR      A                             ; End of line?
   079B C2 76 03      [10] 1251         JP      NZ,SNERR                      ; No - Syntax error
   079E 23            [ 6] 1252         INC     HL                            ; Point to address of next line
   079F 7E            [ 7] 1253         LD      A,(HL)                        ; Get LSB of line pointer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 24
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   07A0 23            [ 6] 1254         INC     HL
   07A1 B6            [ 7] 1255         OR      (HL)                          ; Is it zero (End of prog)?
   07A2 CA 20 08      [10] 1256         JP      Z,ENDPRG                      ; Yes - Terminate execution
   07A5 23            [ 6] 1257         INC     HL                            ; Point to line number
   07A6 5E            [ 7] 1258         LD      E,(HL)                        ; Get LSB of line number
   07A7 23            [ 6] 1259         INC     HL
   07A8 56            [ 7] 1260         LD      D,(HL)                        ; Get MSB of line number
   07A9 EB            [ 4] 1261         EX      DE,HL                         ; Line number to HL
   07AA 22 A1 80      [16] 1262         LD      (LINEAT),HL                   ; Save as current line number
   07AD EB            [ 4] 1263         EX      DE,HL                         ; Line number back to DE
   07AE CD CE 07      [17] 1264 EXCUTE: CALL    GETCHR                        ; Get key word
   07B1 11 8E 07      [10] 1265         LD      DE,RUNCNT                     ; Where to RETurn to
   07B4 D5            [11] 1266         PUSH    DE                            ; Save for RETurn
   07B5 C8            [11] 1267 IFJMP:  RET     Z                             ; Go to RUNCNT if end of STMT
   07B6 D6 80         [ 7] 1268 ONJMP:  SUB     ZEND                          ; Is it a token?
   07B8 DA 7C 09      [10] 1269         JP      C,LET                         ; No - try to assign it
   07BB FE 25         [ 7] 1270         CP      ZNEW+1-ZEND                   ; END to NEW ?
   07BD D2 76 03      [10] 1271         JP      NC,SNERR                      ; Not a key word - ?SN Error
   07C0 07            [ 4] 1272         RLCA                                  ; Double it
   07C1 4F            [ 4] 1273         LD      C,A                           ; BC = Offset into table
   07C2 06 00         [ 7] 1274         LD      B,0
   07C4 EB            [ 4] 1275         EX      DE,HL                         ; Save code string address
   07C5 21 1E 02      [10] 1276         LD      HL,WORDTB                     ; Keyword address table
   07C8 09            [11] 1277         ADD     HL,BC                         ; Point to routine address
   07C9 4E            [ 7] 1278         LD      C,(HL)                        ; Get LSB of routine address
   07CA 23            [ 6] 1279         INC     HL
   07CB 46            [ 7] 1280         LD      B,(HL)                        ; Get MSB of routine address
   07CC C5            [11] 1281         PUSH    BC                            ; Save routine address
   07CD EB            [ 4] 1282         EX      DE,HL                         ; Restore code string address
                           1283 ;
   07CE 23            [ 6] 1284 GETCHR: INC     HL                            ; Point to next character
   07CF 7E            [ 7] 1285         LD      A,(HL)                        ; Get next code string byte
   07D0 FE 3A         [ 7] 1286         CP      ':                            ; Z if ':
   07D2 D0            [11] 1287         RET     NC                            ; NC if > "9"
   07D3 FE 20         [ 7] 1288         CP      0x20
   07D5 CA CE 07      [10] 1289         JP      Z,GETCHR                      ; Skip over spaces
   07D8 FE 30         [ 7] 1290         CP      '0
   07DA 3F            [ 4] 1291         CCF                                   ; NC if < '0
   07DB 3C            [ 4] 1292         INC     A                             ; Test for zero - Leave carry
   07DC 3D            [ 4] 1293         DEC     A                             ; Z if Null
   07DD C9            [10] 1294         RET
                           1295 ;
   07DE EB            [ 4] 1296 RESTOR: EX      DE,HL                         ; Save code string address
   07DF 2A A3 80      [16] 1297         LD      HL,(BASTXT)                   ; Point to start of program
   07E2 CA F3 07      [10] 1298         JP      Z,RESTNL                      ; Just RESTORE - reset pointer
   07E5 EB            [ 4] 1299         EX      DE,HL                         ; Restore code string address
   07E6 CD 9A 08      [17] 1300         CALL    ATOH                          ; Get line number to DE
   07E9 E5            [11] 1301         PUSH    HL                            ; Save code string address
   07EA CD 62 04      [17] 1302         CALL    SRCHLN                        ; Search for line number in DE
   07ED 60            [ 4] 1303         LD      H,B                           ; HL = Address of line
   07EE 69            [ 4] 1304         LD      L,C
   07EF D1            [10] 1305         POP     DE                            ; Restore code string address
   07F0 D2 3B 09      [10] 1306         JP      NC,ULERR                      ; ?UL Error if not found
   07F3 2B            [ 6] 1307 RESTNL: DEC     HL                            ; Byte before DATA statement
   07F4 22 21 81      [16] 1308 UPDATA: LD      (NXTDAT),HL                   ; Update DATA pointer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 25
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   07F7 EB            [ 4] 1309         EX      DE,HL                         ; Restore code string address
   07F8 C9            [10] 1310         RET
                           1311 ;
                           1312 
   07F9 DF            [11] 1313 TSTBRK: RST     0x18                          ; Check input status
   07FA C8            [11] 1314         RET     Z                             ; No key, go back
   07FB D7            [11] 1315         RST     0x10                          ; Get the key into A
   07FC FE 1B         [ 7] 1316         CP      ESC                           ; Escape key?
   07FE 28 11         [12] 1317         JR      Z,BRK                         ; Yes, break
   0800 FE 03         [ 7] 1318         CP      CTRLC                         ; <Ctrl-C>
   0802 28 0D         [12] 1319         JR      Z,BRK                         ; Yes, break
   0804 FE 13         [ 7] 1320         CP      CTRLS                         ; Stop scrolling?
   0806 C0            [11] 1321         RET     NZ                            ; Other key, ignore
                           1322 ;
                           1323 
   0807 D7            [11] 1324 STALL:  RST     0x10                          ; Wait for key
   0808 FE 11         [ 7] 1325         CP      CTRLQ                         ; Resume scrolling?
   080A C8            [11] 1326         RET     Z                             ; Release the chokehold
   080B FE 03         [ 7] 1327         CP      CTRLC                         ; Second break?
   080D 28 07         [12] 1328         JR      Z,STOP                        ; Break during hold exits prog
   080F 18 F6         [12] 1329         JR      STALL                         ; Loop until <Ctrl-Q> or <brk>
                           1330 ;
   0811 3E FF         [ 7] 1331 BRK:    LD      A,0x0FF                       ; Set BRKFLG
   0813 32 92 80      [13] 1332         LD      (BRKFLG),A                    ; Store it
                           1333 ;
                           1334 
   0816 C0            [11] 1335 STOP:   RET     NZ                            ; Exit if anything else
   0817 F6                 1336         .db     0x0F6                         ; Flag "STOP"
   0818 C0            [11] 1337 PEND:   RET     NZ                            ; Exit if anything else
   0819 22 13 81      [16] 1338         LD      (BRKLIN),HL                   ; Save point of break
   081C 21                 1339         .db     0x21                          ; Skip "OR 11111111B"
   081D F6 FF         [ 7] 1340 INPBRK: OR      0b11111111                    ; Flag "Break" wanted
   081F C1            [10] 1341         POP     BC                            ; Return not needed and more
   0820 2A A1 80      [16] 1342 ENDPRG: LD      HL,(LINEAT)                   ; Get current line number
   0823 F5            [11] 1343         PUSH    AF                            ; Save STOP / END status
   0824 7D            [ 4] 1344         LD      A,L                           ; Is it direct break?
   0825 A4            [ 4] 1345         AND     H
   0826 3C            [ 4] 1346         INC     A                             ; Line is -1 if direct break
   0827 CA 33 08      [10] 1347         JP      Z,NOLIN                       ; Yes - No line number
   082A 22 17 81      [16] 1348         LD      (ERRLIN),HL                   ; Save line of break
   082D 2A 13 81      [16] 1349         LD      HL,(BRKLIN)                   ; Get point of break
   0830 22 19 81      [16] 1350         LD      (CONTAD),HL                   ; Save point to CONTinue
   0833 AF            [ 4] 1351 NOLIN:  XOR     A
   0834 32 8A 80      [13] 1352         LD      (CTLOFG),A                    ; Enable output
   0837 CD 69 0A      [17] 1353         CALL    STTLIN                        ; Start a new line
   083A F1            [10] 1354         POP     AF                            ; Restore STOP / END status
   083B 21 19 03      [10] 1355         LD      HL,BRKMSG                     ; "Break" message
   083E C2 AA 03      [10] 1356         JP      NZ,ERRIN                      ; "in line" wanted?
   0841 C3 C1 03      [10] 1357         JP      PRNTOK                        ; Go to command mode
                           1358 ;
   0844 2A 19 81      [16] 1359 CONT:   LD      HL,(CONTAD)                   ; Get CONTinue address
   0847 7C            [ 4] 1360         LD      A,H                           ; Is it zero?
   0848 B5            [ 4] 1361         OR      L
   0849 1E 20         [ 7] 1362         LD      E,CN                          ; ?CN Error
   084B CA 8A 03      [10] 1363         JP      Z,ERROR                       ; Yes - output "?CN Error"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 26
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   084E EB            [ 4] 1364         EX      DE,HL                         ; Save code string address
   084F 2A 17 81      [16] 1365         LD      HL,(ERRLIN)                   ; Get line of last break
   0852 22 A1 80      [16] 1366         LD      (LINEAT),HL                   ; Set up current line number
   0855 EB            [ 4] 1367         EX      DE,HL                         ; Restore code string address
   0856 C9            [10] 1368         RET                                   ; CONTinue where left off
                           1369 ;
   0857 CD 9C 13      [17] 1370 NULL:   CALL    GETINT                        ; Get integer 0-255
   085A C0            [11] 1371         RET     NZ                            ; Return if bad value
   085B 32 86 80      [13] 1372         LD      (NULLS),A                     ; Set nulls number
   085E C9            [10] 1373         RET
                           1374 ;
                           1375 
   085F E5            [11] 1376 ACCSUM: PUSH    HL                            ; Save address in array
   0860 2A 8F 80      [16] 1377         LD      HL,(CHKSUM)                   ; Get check sum
   0863 06 00         [ 7] 1378         LD      B,0                           ; BC - Value of byte
   0865 4F            [ 4] 1379         LD      C,A
   0866 09            [11] 1380         ADD     HL,BC                         ; Add byte to check sum
   0867 22 8F 80      [16] 1381         LD      (CHKSUM),HL                   ; Re-save check sum
   086A E1            [10] 1382         POP     HL                            ; Restore address in array
   086B C9            [10] 1383         RET
                           1384 ;
   086C 7E            [ 7] 1385 CHKLTR: LD      A,(HL)                        ; Get byte
   086D FE 41         [ 7] 1386         CP      'A                            ; < 'a ?
   086F D8            [11] 1387         RET     C                             ; Carry set if not letter
   0870 FE 5B         [ 7] 1388         CP      'Z+1                          ; > 'z ?
   0872 3F            [ 4] 1389         CCF
   0873 C9            [10] 1390         RET                                   ; Carry set if not letter
                           1391 ;
   0874 CD CE 07      [17] 1392 FPSINT: CALL    GETCHR                        ; Get next character
   0877 CD 3B 0C      [17] 1393 POSINT: CALL    GETNUM                        ; Get integer 0 to 32767
   087A CD 1D 16      [17] 1394 DEPINT: CALL    TSTSGN                        ; Test sign of FPREG
   087D FA 95 08      [10] 1395         JP      M,FCERR                       ; Negative - ?FC Error
   0880 3A 2C 81      [13] 1396 DEINT:  LD      A,(FPEXP)                     ; Get integer value to DE
   0883 FE 90         [ 7] 1397         CP      0x80+16                       ; Exponent in range (16 bits)?
   0885 DA C5 16      [10] 1398         JP      C,FPINT                       ; Yes - convert it
   0888 01 80 90      [10] 1399         LD      BC,0x9080                     ; BCDE = -32768
   088B 11 00 00      [10] 1400         LD      DE,0000
   088E E5            [11] 1401         PUSH    HL                            ; Save code string address
   088F CD 98 16      [17] 1402         CALL    CMPNUM                        ; Compare FPREG with BCDE
   0892 E1            [10] 1403         POP     HL                            ; Restore code string address
   0893 51            [ 4] 1404         LD      D,C                           ; MSB to D
   0894 C8            [11] 1405         RET     Z                             ; Return if in range
   0895 1E 08         [ 7] 1406 FCERR:  LD      E,FC                          ; ?FC Error
   0897 C3 8A 03      [10] 1407         JP      ERROR                         ; Output error-
                           1408 ;
   089A 2B            [ 6] 1409 ATOH:   DEC     HL                            ; ASCII number to DE binary
   089B 11 00 00      [10] 1410 GETLN:  LD      DE,0                          ; Get number to DE
   089E CD CE 07      [17] 1411 GTLNLP: CALL    GETCHR                        ; Get next character
   08A1 D0            [11] 1412         RET     NC                            ; Exit if not a digit
   08A2 E5            [11] 1413         PUSH    HL                            ; Save code string address
   08A3 F5            [11] 1414         PUSH    AF                            ; Save digit
   08A4 21 98 19      [10] 1415         LD      HL,65529/10                   ; Largest number 65529
   08A7 CD 3E 06      [17] 1416         CALL    CPDEHL                        ; Number in range?
   08AA DA 76 03      [10] 1417         JP      C,SNERR                       ; No - ?SN Error
   08AD 62            [ 4] 1418         LD      H,D                           ; HL = Number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 27
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   08AE 6B            [ 4] 1419         LD      L,E
   08AF 19            [11] 1420         ADD     HL,DE                         ; Times 2
   08B0 29            [11] 1421         ADD     HL,HL                         ; Times 4
   08B1 19            [11] 1422         ADD     HL,DE                         ; Times 5
   08B2 29            [11] 1423         ADD     HL,HL                         ; Times 10
   08B3 F1            [10] 1424         POP     AF                            ; Restore digit
   08B4 D6 30         [ 7] 1425         SUB     '0                            ; Make it 0 to 9
   08B6 5F            [ 4] 1426         LD      E,A                           ; DE = Value of digit
   08B7 16 00         [ 7] 1427         LD      D,0
   08B9 19            [11] 1428         ADD     HL,DE                         ; Add to number
   08BA EB            [ 4] 1429         EX      DE,HL                         ; Number to DE
   08BB E1            [10] 1430         POP     HL                            ; Restore code string address
   08BC C3 9E 08      [10] 1431         JP      GTLNLP                        ; Go to next character
                           1432 ;
   08BF CA 92 04      [10] 1433 CLEAR:  JP      Z,INTVAR                      ; Just "CLEAR" Keep parameters
   08C2 CD 77 08      [17] 1434         CALL    POSINT                        ; Get integer 0 to 32767 to DE
   08C5 2B            [ 6] 1435         DEC     HL                            ; Cancel increment
   08C6 CD CE 07      [17] 1436         CALL    GETCHR                        ; Get next character
   08C9 E5            [11] 1437         PUSH    HL                            ; Save code string address
   08CA 2A F4 80      [16] 1438         LD      HL,(LSTRAM)                   ; Get end of RAM
   08CD CA E2 08      [10] 1439         JP      Z,STORED                      ; No value given - Use stored
   08D0 E1            [10] 1440         POP     HL                            ; Restore code string address
   08D1 CD 44 06      [17] 1441         CALL    CHKSYN                        ; Check for comma
   08D4 2C                 1442         .db     ',
   08D5 D5            [11] 1443         PUSH    DE                            ; Save number
   08D6 CD 77 08      [17] 1444         CALL    POSINT                        ; Get integer 0 to 32767
   08D9 2B            [ 6] 1445         DEC     HL                            ; Cancel increment
   08DA CD CE 07      [17] 1446         CALL    GETCHR                        ; Get next character
   08DD C2 76 03      [10] 1447         JP      NZ,SNERR                      ; ?SN Error if more on line
   08E0 E3            [19] 1448         EX      (SP),HL                       ; Save code string address
   08E1 EB            [ 4] 1449         EX      DE,HL                         ; Number to DE
   08E2 7D            [ 4] 1450 STORED: LD      A,L                           ; Get LSB of new RAM top
   08E3 93            [ 4] 1451         SUB     E                             ; Subtract LSB of string space
   08E4 5F            [ 4] 1452         LD      E,A                           ; Save LSB
   08E5 7C            [ 4] 1453         LD      A,H                           ; Get MSB of new RAM top
   08E6 9A            [ 4] 1454         SBC     A,D                           ; Subtract MSB of string space
   08E7 57            [ 4] 1455         LD      D,A                           ; Save MSB
   08E8 DA 6B 03      [10] 1456         JP      C,OMERR                       ; ?OM Error if not enough mem
   08EB E5            [11] 1457         PUSH    HL                            ; Save RAM top
   08EC 2A 1B 81      [16] 1458         LD      HL,(PROGND)                   ; Get program end
   08EF 01 28 00      [10] 1459         LD      BC,40                         ; 40 Bytes minimum working RAM
   08F2 09            [11] 1460         ADD     HL,BC                         ; Get lowest address
   08F3 CD 3E 06      [17] 1461         CALL    CPDEHL                        ; Enough memory?
   08F6 D2 6B 03      [10] 1462         JP      NC,OMERR                      ; No - ?OM Error
   08F9 EB            [ 4] 1463         EX      DE,HL                         ; RAM top to HL
   08FA 22 9F 80      [16] 1464         LD      (STRSPC),HL                   ; Set new string space
   08FD E1            [10] 1465         POP     HL                            ; End of memory to use
   08FE 22 F4 80      [16] 1466         LD      (LSTRAM),HL                   ; Set new top of RAM
   0901 E1            [10] 1467         POP     HL                            ; Restore code string address
   0902 C3 92 04      [10] 1468         JP      INTVAR                        ; Initialise variables
                           1469 ;
   0905 CA 8E 04      [10] 1470 RUN:    JP      Z,RUNFST                      ; RUN from start if just RUN
   0908 CD 92 04      [17] 1471         CALL    INTVAR                        ; Initialise variables
   090B 01 8E 07      [10] 1472         LD      BC,RUNCNT                     ; Execution driver loop
   090E C3 21 09      [10] 1473         JP      RUNLIN                        ; RUN from line number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 28
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                           1474 ;
   0911 0E 03         [ 7] 1475 GOSUB:  LD      C,3                           ; 3 Levels of stack needed
   0913 CD 53 03      [17] 1476         CALL    CHKSTK                        ; Check for 3 levels of stack
   0916 C1            [10] 1477         POP     BC                            ; Get return address
   0917 E5            [11] 1478         PUSH    HL                            ; Save code string for RETURN
   0918 E5            [11] 1479         PUSH    HL                            ; And for GOSUB routine
   0919 2A A1 80      [16] 1480         LD      HL,(LINEAT)                   ; Get current line
   091C E3            [19] 1481         EX      (SP),HL                       ; Into stack - Code string out
   091D 3E 8C         [ 7] 1482         LD      A,ZGOSUB                      ; "GOSUB" token
   091F F5            [11] 1483         PUSH    AF                            ; Save token
   0920 33            [ 6] 1484         INC     SP                            ; Don't save flags
                           1485 ;
   0921 C5            [11] 1486 RUNLIN: PUSH    BC                            ; Save return address
   0922 CD 9A 08      [17] 1487 GOTO:   CALL    ATOH                          ; ASCII number to DE binary
   0925 CD 67 09      [17] 1488         CALL    REM                           ; Get end of line
   0928 E5            [11] 1489         PUSH    HL                            ; Save end of line
   0929 2A A1 80      [16] 1490         LD      HL,(LINEAT)                   ; Get current line
   092C CD 3E 06      [17] 1491         CALL    CPDEHL                        ; Line after current?
   092F E1            [10] 1492         POP     HL                            ; Restore end of line
   0930 23            [ 6] 1493         INC     HL                            ; Start of next line
   0931 DC 65 04      [17] 1494         CALL    C,SRCHLP                      ; Line is after current line
   0934 D4 62 04      [17] 1495         CALL    NC,SRCHLN                     ; Line is before current line
   0937 60            [ 4] 1496         LD      H,B                           ; Set up code string address
   0938 69            [ 4] 1497         LD      L,C
   0939 2B            [ 6] 1498         DEC     HL                            ; Incremented after
   093A D8            [11] 1499         RET     C                             ; Line found
   093B 1E 0E         [ 7] 1500 ULERR:  LD      E,UL                          ; ?UL Error
   093D C3 8A 03      [10] 1501         JP      ERROR                         ; Output error message
                           1502 ;
   0940 C0            [11] 1503 RETURN: RET     NZ                            ; Return if not just RETURN
   0941 16 FF         [ 7] 1504         LD      D,-1                          ; Flag "GOSUB" search
   0943 CD 1F 03      [17] 1505         CALL    BAKSTK                        ; Look "GOSUB" block
   0946 F9            [ 6] 1506         LD      SP,HL                         ; Kill all FORs in subroutine
   0947 FE 8C         [ 7] 1507         CP      ZGOSUB                        ; Test for "GOSUB" token
   0949 1E 04         [ 7] 1508         LD      E,RG                          ; ?RG Error
   094B C2 8A 03      [10] 1509         JP      NZ,ERROR                      ; Error if no "GOSUB" found
   094E E1            [10] 1510         POP     HL                            ; Get RETURN line number
   094F 22 A1 80      [16] 1511         LD      (LINEAT),HL                   ; Save as current
   0952 23            [ 6] 1512         INC     HL                            ; Was it from direct statement?
   0953 7C            [ 4] 1513         LD      A,H
   0954 B5            [ 4] 1514         OR      L                             ; Return to line
   0955 C2 5F 09      [10] 1515         JP      NZ,RETLIN                     ; No - Return to line
   0958 3A 11 81      [13] 1516         LD      A,(LSTBIN)                    ; Any INPUT in subroutine?
   095B B7            [ 4] 1517         OR      A                             ; If so buffer is corrupted
   095C C2 C0 03      [10] 1518         JP      NZ,POPNOK                     ; Yes - Go to command mode
   095F 21 8E 07      [10] 1519 RETLIN: LD      HL,RUNCNT                     ; Execution driver loop
   0962 E3            [19] 1520         EX      (SP),HL                       ; Into stack - Code string out
   0963 3E                 1521         .db     0x3E                          ; Skip "POP HL"
   0964 E1            [10] 1522 NXTDTA: POP     HL                            ; Restore code string address
                           1523 ;
   0965 01 3A              1524 DATA:   .db     0x01,0x3A                     ; ': End of statement
   0967 0E 00         [ 7] 1525 REM:    LD      C,0                           ; 00	End of statement
   0969 06 00         [ 7] 1526         LD      B,0
   096B 79            [ 4] 1527 NXTSTL: LD      A,C                           ; Statement and byte
   096C 48            [ 4] 1528         LD      C,B
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 29
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   096D 47            [ 4] 1529         LD      B,A                           ; Statement end byte
   096E 7E            [ 7] 1530 NXTSTT: LD      A,(HL)                        ; Get byte
   096F B7            [ 4] 1531         OR      A                             ; End of line?
   0970 C8            [11] 1532         RET     Z                             ; Yes - Exit
   0971 B8            [ 4] 1533         CP      B                             ; End of statement?
   0972 C8            [11] 1534         RET     Z                             ; Yes - Exit
   0973 23            [ 6] 1535         INC     HL                            ; Next byte
   0974 FE 22         [ 7] 1536         CP      '"                            ; Literal string?
   0976 CA 6B 09      [10] 1537         JP      Z,NXTSTL                      ; Yes - Look for another '"
   0979 C3 6E 09      [10] 1538         JP      NXTSTT                        ; Keep looking
                           1539 ;
   097C CD 31 0E      [17] 1540 LET:    CALL    GETVAR                        ; Get variable name
   097F CD 44 06      [17] 1541         CALL    CHKSYN                        ; Make sure "=" follows
   0982 B4                 1542         .db     ZEQUAL                        ; "=" token
   0983 D5            [11] 1543         PUSH    DE                            ; Save address of variable
   0984 3A F2 80      [13] 1544         LD      A,(TYPE)                      ; Get data type
   0987 F5            [11] 1545         PUSH    AF                            ; Save type
   0988 CD 4D 0C      [17] 1546         CALL    EVAL                          ; Evaluate expression
   098B F1            [10] 1547         POP     AF                            ; Restore type
   098C E3            [19] 1548         EX      (SP),HL                       ; Save code - Get var addr
   098D 22 13 81      [16] 1549         LD      (BRKLIN),HL                   ; Save address of variable
   0990 1F            [ 4] 1550         RRA                                   ; Adjust type
   0991 CD 40 0C      [17] 1551         CALL    CHKTYP                        ; Check types are the same
   0994 CA CF 09      [10] 1552         JP      Z,LETNUM                      ; Numeric - Move value
   0997 E5            [11] 1553 LETSTR: PUSH    HL                            ; Save address of string var
   0998 2A 29 81      [16] 1554         LD      HL,(FPREG)                    ; Pointer to string entry
   099B E5            [11] 1555         PUSH    HL                            ; Save it on stack
   099C 23            [ 6] 1556         INC     HL                            ; Skip over length
   099D 23            [ 6] 1557         INC     HL
   099E 5E            [ 7] 1558         LD      E,(HL)                        ; LSB of string address
   099F 23            [ 6] 1559         INC     HL
   09A0 56            [ 7] 1560         LD      D,(HL)                        ; MSB of string address
   09A1 2A A3 80      [16] 1561         LD      HL,(BASTXT)                   ; Point to start of program
   09A4 CD 3E 06      [17] 1562         CALL    CPDEHL                        ; Is string before program?
   09A7 D2 BE 09      [10] 1563         JP      NC,CRESTR                     ; Yes - Create string entry
   09AA 2A 9F 80      [16] 1564         LD      HL,(STRSPC)                   ; Point to string space
   09AD CD 3E 06      [17] 1565         CALL    CPDEHL                        ; Is string literal in program?
   09B0 D1            [10] 1566         POP     DE                            ; Restore address of string
   09B1 D2 C6 09      [10] 1567         JP      NC,MVSTPT                     ; Yes - Set up pointer
   09B4 21 04 81      [10] 1568         LD      HL,TMPSTR                     ; Temporary string pool
   09B7 CD 3E 06      [17] 1569         CALL    CPDEHL                        ; Is string in temporary pool?
   09BA D2 C6 09      [10] 1570         JP      NC,MVSTPT                     ; No - Set up pointer
   09BD 3E                 1571         .db     0x3E                          ; Skip "POP DE"
   09BE D1            [10] 1572 CRESTR: POP     DE                            ; Restore address of string
   09BF CD 75 12      [17] 1573         CALL    BAKTMP                        ; Back to last tmp-str entry
   09C2 EB            [ 4] 1574         EX      DE,HL                         ; Address of string entry
   09C3 CD AE 10      [17] 1575         CALL    SAVSTR                        ; Save string in string area
   09C6 CD 75 12      [17] 1576 MVSTPT: CALL    BAKTMP                        ; Back to last tmp-str entry
   09C9 E1            [10] 1577         POP     HL                            ; Get string pointer
   09CA CD 78 16      [17] 1578         CALL    DETHL4                        ; Move string pointer to var
   09CD E1            [10] 1579         POP     HL                            ; Restore code string address
   09CE C9            [10] 1580         RET
                           1581 ;
   09CF E5            [11] 1582 LETNUM: PUSH    HL                            ; Save address of variable
   09D0 CD 75 16      [17] 1583         CALL    FPTHL                         ; Move value to variable
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 30
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   09D3 D1            [10] 1584         POP     DE                            ; Restore address of variable
   09D4 E1            [10] 1585         POP     HL                            ; Restore code string address
   09D5 C9            [10] 1586         RET
                           1587 ;
   09D6 CD 9C 13      [17] 1588 ON:     CALL    GETINT                        ; Get integer 0-255
   09D9 7E            [ 7] 1589         LD      A,(HL)                        ; Get "GOTO" or "GOSUB" token
   09DA 47            [ 4] 1590         LD      B,A                           ; Save in B
   09DB FE 8C         [ 7] 1591         CP      ZGOSUB                        ; "GOSUB" token?
   09DD CA E5 09      [10] 1592         JP      Z,ONGO                        ; Yes - Find line number
   09E0 CD 44 06      [17] 1593         CALL    CHKSYN                        ; Make sure it's "GOTO"
   09E3 88                 1594         .db     ZGOTO                         ; "GOTO" token
   09E4 2B            [ 6] 1595         DEC     HL                            ; Cancel increment
   09E5 4B            [ 4] 1596 ONGO:   LD      C,E                           ; Integer of branch value
   09E6 0D            [ 4] 1597 ONGOLP: DEC     C                             ; Count branches
   09E7 78            [ 4] 1598         LD      A,B                           ; Get "GOTO" or "GOSUB" token
   09E8 CA B6 07      [10] 1599         JP      Z,ONJMP                       ; Go to that line if right one
   09EB CD 9B 08      [17] 1600         CALL    GETLN                         ; Get line number to DE
   09EE FE 2C         [ 7] 1601         CP      ',                            ; Another line number?
   09F0 C0            [11] 1602         RET     NZ                            ; No - Drop through
   09F1 C3 E6 09      [10] 1603         JP      ONGOLP                        ; Yes - loop
                           1604 ;
   09F4 CD 4D 0C      [17] 1605 IF:     CALL    EVAL                          ; Evaluate expression
   09F7 7E            [ 7] 1606         LD      A,(HL)                        ; Get token
   09F8 FE 88         [ 7] 1607         CP      ZGOTO                         ; "GOTO" token?
   09FA CA 02 0A      [10] 1608         JP      Z,IFGO                        ; Yes - Get line
   09FD CD 44 06      [17] 1609         CALL    CHKSYN                        ; Make sure it's "THEN"
   0A00 A9                 1610         .db     ZTHEN                         ; "THEN" token
   0A01 2B            [ 6] 1611         DEC     HL                            ; Cancel increment
   0A02 CD 3E 0C      [17] 1612 IFGO:   CALL    TSTNUM                        ; Make sure it's numeric
   0A05 CD 1D 16      [17] 1613         CALL    TSTSGN                        ; Test state of expression
   0A08 CA 67 09      [10] 1614         JP      Z,REM                         ; False - Drop through
   0A0B CD CE 07      [17] 1615         CALL    GETCHR                        ; Get next character
   0A0E DA 22 09      [10] 1616         JP      C,GOTO                        ; Number - GOTO that line
   0A11 C3 B5 07      [10] 1617         JP      IFJMP                         ; Otherwise do statement
                           1618 ;
   0A14 2B            [ 6] 1619 MRPRNT: DEC     HL                            ; DEC 'cos GETCHR INCs
   0A15 CD CE 07      [17] 1620         CALL    GETCHR                        ; Get next character
   0A18 CA 76 0A      [10] 1621 PRINT:  JP      Z,PRCRLF                      ; CRLF if just PRINT
   0A1B C8            [11] 1622 PRNTLP: RET     Z                             ; End of list - Exit
   0A1C FE A5         [ 7] 1623         CP      ZTAB                          ; "TAB(" token?
   0A1E CA A9 0A      [10] 1624         JP      Z,DOTAB                       ; Yes - Do TAB routine
   0A21 FE A8         [ 7] 1625         CP      ZSPC                          ; "SPC(" token?
   0A23 CA A9 0A      [10] 1626         JP      Z,DOTAB                       ; Yes - Do SPC routine
   0A26 E5            [11] 1627         PUSH    HL                            ; Save code string address
   0A27 FE 2C         [ 7] 1628         CP      ',                            ; Comma?
   0A29 CA 92 0A      [10] 1629         JP      Z,DOCOM                       ; Yes - Move to next zone
   0A2C FE 3B         [ 7] 1630         CP      59                            ;";"		; Semi-colon?
   0A2E CA CC 0A      [10] 1631         JP      Z,NEXITM                      ; Do semi-colon routine
   0A31 C1            [10] 1632         POP     BC                            ; Code string address to BC
   0A32 CD 4D 0C      [17] 1633         CALL    EVAL                          ; Evaluate expression
   0A35 E5            [11] 1634         PUSH    HL                            ; Save code string address
   0A36 3A F2 80      [13] 1635         LD      A,(TYPE)                      ; Get variable type
   0A39 B7            [ 4] 1636         OR      A                             ; Is it a string variable?
   0A3A C2 62 0A      [10] 1637         JP      NZ,PRNTST                     ; Yes - Output string contents
   0A3D CD C2 17      [17] 1638         CALL    NUMASC                        ; Convert number to text
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 31
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0A40 CD D2 10      [17] 1639         CALL    CRTST                         ; Create temporary string
   0A43 36 20         [10] 1640         LD      (HL),0x20                     ; Followed by a space
   0A45 2A 29 81      [16] 1641         LD      HL,(FPREG)                    ; Get length of output
   0A48 34            [11] 1642         INC     (HL)                          ; Plus 1 for the space
   0A49 2A 29 81      [16] 1643         LD      HL,(FPREG)                    ; < Not needed >
   0A4C 3A 87 80      [13] 1644         LD      A,(LWIDTH)                    ; Get width of line
   0A4F 47            [ 4] 1645         LD      B,A                           ; To B
   0A50 04            [ 4] 1646         INC     B                             ; Width 255 (No limit)?
   0A51 CA 5E 0A      [10] 1647         JP      Z,PRNTNB                      ; Yes - Output number string
   0A54 04            [ 4] 1648         INC     B                             ; Adjust it
   0A55 3A F0 80      [13] 1649         LD      A,(CURPOS)                    ; Get cursor position
   0A58 86            [ 7] 1650         ADD     A,(HL)                        ; Add length of string
   0A59 3D            [ 4] 1651         DEC     A                             ; Adjust it
   0A5A B8            [ 4] 1652         CP      B                             ; Will output fit on this line?
   0A5B D4 76 0A      [17] 1653         CALL    NC,PRCRLF                     ; No - CRLF first
   0A5E CD 17 11      [17] 1654 PRNTNB: CALL    PRS1                          ; Output string at (HL)
   0A61 AF            [ 4] 1655         XOR     A                             ; Skip CALL by setting 'z flag
   0A62 C4 17 11      [17] 1656 PRNTST: CALL    NZ,PRS1                       ; Output string at (HL)
   0A65 E1            [10] 1657         POP     HL                            ; Restore code string address
   0A66 C3 14 0A      [10] 1658         JP      MRPRNT                        ; See if more to PRINT
                           1659 ;
   0A69 3A F0 80      [13] 1660 STTLIN: LD      A,(CURPOS)                    ; Make sure on new line
   0A6C B7            [ 4] 1661         OR      A                             ; Already at start?
   0A6D C8            [11] 1662         RET     Z                             ; Yes - Do nothing
   0A6E C3 76 0A      [10] 1663         JP      PRCRLF                        ; Start a new line
                           1664 ;
   0A71 36 00         [10] 1665 ENDINP: LD      (HL),0                        ; Mark end of buffer
   0A73 21 A5 80      [10] 1666         LD      HL,BUFFER-1                   ; Point to buffer
   0A76 3E 0D         [ 7] 1667 PRCRLF: LD      A,CR                          ; Load a CR
   0A78 CD 4F 06      [17] 1668         CALL    OUTC                          ; Output character
   0A7B 3E 0A         [ 7] 1669         LD      A,LF                          ; Load a LF
   0A7D CD 4F 06      [17] 1670         CALL    OUTC                          ; Output character
   0A80 AF            [ 4] 1671 DONULL: XOR     A                             ; Set to position 0
   0A81 32 F0 80      [13] 1672         LD      (CURPOS),A                    ; Store it
   0A84 3A 86 80      [13] 1673         LD      A,(NULLS)                     ; Get number of nulls
   0A87 3D            [ 4] 1674 NULLP:  DEC     A                             ; Count them
   0A88 C8            [11] 1675         RET     Z                             ; Return if done
   0A89 F5            [11] 1676         PUSH    AF                            ; Save count
   0A8A AF            [ 4] 1677         XOR     A                             ; Load a null
   0A8B CD 4F 06      [17] 1678         CALL    OUTC                          ; Output it
   0A8E F1            [10] 1679         POP     AF                            ; Restore count
   0A8F C3 87 0A      [10] 1680         JP      NULLP                         ; Keep counting
                           1681 ;
   0A92 3A 88 80      [13] 1682 DOCOM:  LD      A,(COMMAN)                    ; Get comma width
   0A95 47            [ 4] 1683         LD      B,A                           ; Save in B
   0A96 3A F0 80      [13] 1684         LD      A,(CURPOS)                    ; Get current position
   0A99 B8            [ 4] 1685         CP      B                             ; Within the limit?
   0A9A D4 76 0A      [17] 1686         CALL    NC,PRCRLF                     ; No - output CRLF
   0A9D D2 CC 0A      [10] 1687         JP      NC,NEXITM                     ; Get next item
   0AA0 D6 0E         [ 7] 1688 ZONELP: SUB     14                            ; Next zone of 14 characters
   0AA2 D2 A0 0A      [10] 1689         JP      NC,ZONELP                     ; Repeat if more zones
   0AA5 2F            [ 4] 1690         CPL                                   ; Number of spaces to output
   0AA6 C3 C1 0A      [10] 1691         JP      ASPCS                         ; Output them
                           1692 ;
   0AA9 F5            [11] 1693 DOTAB:  PUSH    AF                            ; Save token
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 32
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0AAA CD 99 13      [17] 1694         CALL    FNDNUM                        ; Evaluate expression
   0AAD CD 44 06      [17] 1695         CALL    CHKSYN                        ; Make sure ")" follows
   0AB0 29                 1696         .ascii  ")"
   0AB1 2B            [ 6] 1697         DEC     HL                            ; Back space on to ")"
   0AB2 F1            [10] 1698         POP     AF                            ; Restore token
   0AB3 D6 A8         [ 7] 1699         SUB     ZSPC                          ; Was it "SPC(" ?
   0AB5 E5            [11] 1700         PUSH    HL                            ; Save code string address
   0AB6 CA BC 0A      [10] 1701         JP      Z,DOSPC                       ; Yes - Do 'E spaces
   0AB9 3A F0 80      [13] 1702         LD      A,(CURPOS)                    ; Get current position
   0ABC 2F            [ 4] 1703 DOSPC:  CPL                                   ; Number of spaces to print to
   0ABD 83            [ 4] 1704         ADD     A,E                           ; Total number to print
   0ABE D2 CC 0A      [10] 1705         JP      NC,NEXITM                     ; TAB < Current POS(X)
   0AC1 3C            [ 4] 1706 ASPCS:  INC     A                             ; Output A spaces
   0AC2 47            [ 4] 1707         LD      B,A                           ; Save number to print
   0AC3 3E 20         [ 7] 1708         LD      A,0x20                        ; Space
   0AC5 CD 4F 06      [17] 1709 SPCLP:  CALL    OUTC                          ; Output character in A
   0AC8 05            [ 4] 1710         DEC     B                             ; Count them
   0AC9 C2 C5 0A      [10] 1711         JP      NZ,SPCLP                      ; Repeat if more
   0ACC E1            [10] 1712 NEXITM: POP     HL                            ; Restore code string address
   0ACD CD CE 07      [17] 1713         CALL    GETCHR                        ; Get next character
   0AD0 C3 1B 0A      [10] 1714         JP      PRNTLP                        ; More to print
                           1715 ;
   0AD3 3F 52 65 64 6F 20  1716 REDO:   .ascii  "?Redo from start"
        66 72 6F 6D 20 73
        74 61 72 74
   0AE3 0D 0A 00           1717         .db     CR,LF,0
                           1718 ;
   0AE6 3A 12 81      [13] 1719 BADINP: LD      A,(READFG)                    ; READ or INPUT?
   0AE9 B7            [ 4] 1720         OR      A
   0AEA C2 70 03      [10] 1721         JP      NZ,DATSNR                     ; READ - ?SN Error
   0AED C1            [10] 1722         POP     BC                            ; Throw away code string addr
   0AEE 21 D3 0A      [10] 1723         LD      HL,REDO                       ; "Redo from start" message
   0AF1 CD 14 11      [17] 1724         CALL    PRS                           ; Output string
   0AF4 C3 C1 04      [10] 1725         JP      DOAGN                         ; Do last INPUT again
                           1726 ;
   0AF7 CD 7F 10      [17] 1727 INPUT:  CALL    IDTEST                        ; Test for illegal direct
   0AFA 7E            [ 7] 1728         LD      A,(HL)                        ; Get character after "INPUT"
   0AFB FE 22         [ 7] 1729         CP      '"                            ; Is there a prompt string?
   0AFD 3E 00         [ 7] 1730         LD      A,0                           ; Clear A and leave flags
   0AFF 32 8A 80      [13] 1731         LD      (CTLOFG),A                    ; Enable output
   0B02 C2 11 0B      [10] 1732         JP      NZ,NOPMPT                     ; No prompt - get input
   0B05 CD D3 10      [17] 1733         CALL    QTSTR                         ; Get string terminated by '"
   0B08 CD 44 06      [17] 1734         CALL    CHKSYN                        ; Check for '; after prompt
   0B0B 3B                 1735         .db     ';
   0B0C E5            [11] 1736         PUSH    HL                            ; Save code string address
   0B0D CD 17 11      [17] 1737         CALL    PRS1                          ; Output prompt string
   0B10 3E                 1738         .db     0x3E                          ; Skip "PUSH HL"
   0B11 E5            [11] 1739 NOPMPT: PUSH    HL                            ; Save code string address
   0B12 CD C5 04      [17] 1740         CALL    PROMPT                        ; Get input with "? " prompt
   0B15 C1            [10] 1741         POP     BC                            ; Restore code string address
   0B16 DA 1D 08      [10] 1742         JP      C,INPBRK                      ; Break pressed - Exit
   0B19 23            [ 6] 1743         INC     HL                            ; Next byte
   0B1A 7E            [ 7] 1744         LD      A,(HL)                        ; Get it
   0B1B B7            [ 4] 1745         OR      A                             ; End of line?
   0B1C 2B            [ 6] 1746         DEC     HL                            ; Back again
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 33
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0B1D C5            [11] 1747         PUSH    BC                            ; Re-save code string address
   0B1E CA 64 09      [10] 1748         JP      Z,NXTDTA                      ; Yes - Find next DATA stmt
   0B21 36 2C         [10] 1749         LD      (HL),',                       ; Store comma as separator
   0B23 C3 2B 0B      [10] 1750         JP      NXTITM                        ; Get next item
                           1751 ;
   0B26 E5            [11] 1752 READ:   PUSH    HL                            ; Save code string address
   0B27 2A 21 81      [16] 1753         LD      HL,(NXTDAT)                   ; Next DATA statement
   0B2A F6                 1754         .db     0x0F6                         ; Flag "READ"
   0B2B AF            [ 4] 1755 NXTITM: XOR     A                             ; Flag "INPUT"
   0B2C 32 12 81      [13] 1756         LD      (READFG),A                    ; Save "READ"/"INPUT" flag
   0B2F E3            [19] 1757         EX      (SP),HL                       ; Get code str' , Save pointer
   0B30 C3 37 0B      [10] 1758         JP      GTVLUS                        ; Get values
                           1759 ;
   0B33 CD 44 06      [17] 1760 NEDMOR: CALL    CHKSYN                        ; Check for comma between items
   0B36 2C                 1761         .db     ',
   0B37 CD 31 0E      [17] 1762 GTVLUS: CALL    GETVAR                        ; Get variable name
   0B3A E3            [19] 1763         EX      (SP),HL                       ; Save code str" , Get pointer
   0B3B D5            [11] 1764         PUSH    DE                            ; Save variable address
   0B3C 7E            [ 7] 1765         LD      A,(HL)                        ; Get next "INPUT"/"DATA" byte
   0B3D FE 2C         [ 7] 1766         CP      ',                            ; Comma?
   0B3F CA 5F 0B      [10] 1767         JP      Z,ANTVLU                      ; Yes - Get another value
   0B42 3A 12 81      [13] 1768         LD      A,(READFG)                    ; Is it READ?
   0B45 B7            [ 4] 1769         OR      A
   0B46 C2 CC 0B      [10] 1770         JP      NZ,FDTLP                      ; Yes - Find next DATA stmt
   0B49 3E 3F         [ 7] 1771         LD      A,'?                          ; More INPUT needed
   0B4B CD 4F 06      [17] 1772         CALL    OUTC                          ; Output character
   0B4E CD C5 04      [17] 1773         CALL    PROMPT                        ; Get INPUT with prompt
   0B51 D1            [10] 1774         POP     DE                            ; Variable address
   0B52 C1            [10] 1775         POP     BC                            ; Code string address
   0B53 DA 1D 08      [10] 1776         JP      C,INPBRK                      ; Break pressed
   0B56 23            [ 6] 1777         INC     HL                            ; Point to next DATA byte
   0B57 7E            [ 7] 1778         LD      A,(HL)                        ; Get byte
   0B58 B7            [ 4] 1779         OR      A                             ; Is it zero (No input) ?
   0B59 2B            [ 6] 1780         DEC     HL                            ; Back space INPUT pointer
   0B5A C5            [11] 1781         PUSH    BC                            ; Save code string address
   0B5B CA 64 09      [10] 1782         JP      Z,NXTDTA                      ; Find end of buffer
   0B5E D5            [11] 1783         PUSH    DE                            ; Save variable address
   0B5F 3A F2 80      [13] 1784 ANTVLU: LD      A,(TYPE)                      ; Check data type
   0B62 B7            [ 4] 1785         OR      A                             ; Is it numeric?
   0B63 CA 89 0B      [10] 1786         JP      Z,INPBIN                      ; Yes - Convert to binary
   0B66 CD CE 07      [17] 1787         CALL    GETCHR                        ; Get next character
   0B69 57            [ 4] 1788         LD      D,A                           ; Save input character
   0B6A 47            [ 4] 1789         LD      B,A                           ; Again
   0B6B FE 22         [ 7] 1790         CP      '"                            ; Start of literal sting?
   0B6D CA 7D 0B      [10] 1791         JP      Z,STRENT                      ; Yes - Create string entry
   0B70 3A 12 81      [13] 1792         LD      A,(READFG)                    ; "READ" or "INPUT" ?
   0B73 B7            [ 4] 1793         OR      A
   0B74 57            [ 4] 1794         LD      D,A                           ; Save 00 if "INPUT"
   0B75 CA 7A 0B      [10] 1795         JP      Z,ITMSEP                      ; "INPUT" - End with 00
   0B78 16 3A         [ 7] 1796         LD      D,':                          ; "DATA" - End with 00 or ':
   0B7A 06 2C         [ 7] 1797 ITMSEP: LD      B,',                          ; Item separator
   0B7C 2B            [ 6] 1798         DEC     HL                            ; Back space for DTSTR
   0B7D CD D6 10      [17] 1799 STRENT: CALL    DTSTR                         ; Get string terminated by D
   0B80 EB            [ 4] 1800         EX      DE,HL                         ; String address to DE
   0B81 21 94 0B      [10] 1801         LD      HL,LTSTND                     ; Where to go after LETSTR
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 34
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0B84 E3            [19] 1802         EX      (SP),HL                       ; Save HL , get input pointer
   0B85 D5            [11] 1803         PUSH    DE                            ; Save address of string
   0B86 C3 97 09      [10] 1804         JP      LETSTR                        ; Assign string to variable
                           1805 ;
   0B89 CD CE 07      [17] 1806 INPBIN: CALL    GETCHR                        ; Get next character
   0B8C CD 24 17      [17] 1807         CALL    ASCTFP                        ; Convert ASCII to FP number
   0B8F E3            [19] 1808         EX      (SP),HL                       ; Save input ptr, Get var addr
   0B90 CD 75 16      [17] 1809         CALL    FPTHL                         ; Move FPREG to variable
   0B93 E1            [10] 1810         POP     HL                            ; Restore input pointer
   0B94 2B            [ 6] 1811 LTSTND: DEC     HL                            ; DEC 'cos GETCHR INCs
   0B95 CD CE 07      [17] 1812         CALL    GETCHR                        ; Get next character
   0B98 CA A0 0B      [10] 1813         JP      Z,MORDT                       ; End of line - More needed?
   0B9B FE 2C         [ 7] 1814         CP      ',                            ; Another value?
   0B9D C2 E6 0A      [10] 1815         JP      NZ,BADINP                     ; No - Bad input
   0BA0 E3            [19] 1816 MORDT:  EX      (SP),HL                       ; Get code string address
   0BA1 2B            [ 6] 1817         DEC     HL                            ; DEC 'cos GETCHR INCs
   0BA2 CD CE 07      [17] 1818         CALL    GETCHR                        ; Get next character
   0BA5 C2 33 0B      [10] 1819         JP      NZ,NEDMOR                     ; More needed - Get it
   0BA8 D1            [10] 1820         POP     DE                            ; Restore DATA pointer
   0BA9 3A 12 81      [13] 1821         LD      A,(READFG)                    ; "READ" or "INPUT" ?
   0BAC B7            [ 4] 1822         OR      A
   0BAD EB            [ 4] 1823         EX      DE,HL                         ; DATA pointer to HL
   0BAE C2 F4 07      [10] 1824         JP      NZ,UPDATA                     ; Update DATA pointer if "READ"
   0BB1 D5            [11] 1825         PUSH    DE                            ; Save code string address
   0BB2 B6            [ 7] 1826         OR      (HL)                          ; More input given?
   0BB3 21 BB 0B      [10] 1827         LD      HL,EXTIG                      ; "?Extra ignored" message
   0BB6 C4 14 11      [17] 1828         CALL    NZ,PRS                        ; Output string if extra given
   0BB9 E1            [10] 1829         POP     HL                            ; Restore code string address
   0BBA C9            [10] 1830         RET
                           1831 ;
   0BBB 3F 45 78 74 72 61  1832 EXTIG:  .ascii  "?Extra ignored"
        20 69 67 6E 6F 72
        65 64
   0BC9 0D 0A 00           1833         .db     CR,LF,0
                           1834 ;
   0BCC CD 65 09      [17] 1835 FDTLP:  CALL    DATA                          ; Get next statement
   0BCF B7            [ 4] 1836         OR      A                             ; End of line?
   0BD0 C2 E5 0B      [10] 1837         JP      NZ,FANDT                      ; No - See if DATA statement
   0BD3 23            [ 6] 1838         INC     HL
   0BD4 7E            [ 7] 1839         LD      A,(HL)                        ; End of program?
   0BD5 23            [ 6] 1840         INC     HL
   0BD6 B6            [ 7] 1841         OR      (HL)                          ; 00 00 Ends program
   0BD7 1E 06         [ 7] 1842         LD      E,OD                          ; ?OD Error
   0BD9 CA 8A 03      [10] 1843         JP      Z,ERROR                       ; Yes - Out of DATA
   0BDC 23            [ 6] 1844         INC     HL
   0BDD 5E            [ 7] 1845         LD      E,(HL)                        ; LSB of line number
   0BDE 23            [ 6] 1846         INC     HL
   0BDF 56            [ 7] 1847         LD      D,(HL)                        ; MSB of line number
   0BE0 EB            [ 4] 1848         EX      DE,HL
   0BE1 22 0E 81      [16] 1849         LD      (DATLIN),HL                   ; Set line of current DATA item
   0BE4 EB            [ 4] 1850         EX      DE,HL
   0BE5 CD CE 07      [17] 1851 FANDT:  CALL    GETCHR                        ; Get next character
   0BE8 FE 83         [ 7] 1852         CP      ZDATA                         ; "DATA" token
   0BEA C2 CC 0B      [10] 1853         JP      NZ,FDTLP                      ; No "DATA" - Keep looking
   0BED C3 5F 0B      [10] 1854         JP      ANTVLU                        ; Found - Convert input
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 35
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                           1855 ;
   0BF0 11 00 00      [10] 1856 NEXT:   LD      DE,0                          ; In case no index given
   0BF3 C4 31 0E      [17] 1857 NEXT1:  CALL    NZ,GETVAR                     ; Get index address
   0BF6 22 13 81      [16] 1858         LD      (BRKLIN),HL                   ; Save code string address
   0BF9 CD 1F 03      [17] 1859         CALL    BAKSTK                        ; Look for "FOR" block
   0BFC C2 7C 03      [10] 1860         JP      NZ,NFERR                      ; No "FOR" - ?NF Error
   0BFF F9            [ 6] 1861         LD      SP,HL                         ; Clear nested loops
   0C00 D5            [11] 1862         PUSH    DE                            ; Save index address
   0C01 7E            [ 7] 1863         LD      A,(HL)                        ; Get sign of STEP
   0C02 23            [ 6] 1864         INC     HL
   0C03 F5            [11] 1865         PUSH    AF                            ; Save sign of STEP
   0C04 D5            [11] 1866         PUSH    DE                            ; Save index address
   0C05 CD 5B 16      [17] 1867         CALL    PHLTFP                        ; Move index value to FPREG
   0C08 E3            [19] 1868         EX      (SP),HL                       ; Save address of TO value
   0C09 E5            [11] 1869         PUSH    HL                            ; Save address of index
   0C0A CD C8 13      [17] 1870         CALL    ADDPHL                        ; Add STEP to index value
   0C0D E1            [10] 1871         POP     HL                            ; Restore address of index
   0C0E CD 75 16      [17] 1872         CALL    FPTHL                         ; Move value to index variable
   0C11 E1            [10] 1873         POP     HL                            ; Restore address of TO value
   0C12 CD 6C 16      [17] 1874         CALL    LOADFP                        ; Move TO value to BCDE
   0C15 E5            [11] 1875         PUSH    HL                            ; Save address of line of FOR
   0C16 CD 98 16      [17] 1876         CALL    CMPNUM                        ; Compare index with TO value
   0C19 E1            [10] 1877         POP     HL                            ; Restore address of line num
   0C1A C1            [10] 1878         POP     BC                            ; Address of sign of STEP
   0C1B 90            [ 4] 1879         SUB     B                             ; Compare with expected sign
   0C1C CD 6C 16      [17] 1880         CALL    LOADFP                        ; BC = Loop stmt,DE = Line num
   0C1F CA 2B 0C      [10] 1881         JP      Z,KILFOR                      ; Loop finished - Terminate it
   0C22 EB            [ 4] 1882         EX      DE,HL                         ; Loop statement line number
   0C23 22 A1 80      [16] 1883         LD      (LINEAT),HL                   ; Set loop line number
   0C26 69            [ 4] 1884         LD      L,C                           ; Set code string to loop
   0C27 60            [ 4] 1885         LD      H,B
   0C28 C3 8A 07      [10] 1886         JP      PUTFID                        ; Put back "FOR" and continue
                           1887 ;
   0C2B F9            [ 6] 1888 KILFOR: LD      SP,HL                         ; Remove "FOR" block
   0C2C 2A 13 81      [16] 1889         LD      HL,(BRKLIN)                   ; Code string after "NEXT"
   0C2F 7E            [ 7] 1890         LD      A,(HL)                        ; Get next byte in code string
   0C30 FE 2C         [ 7] 1891         CP      ',                            ; More NEXTs ?
   0C32 C2 8E 07      [10] 1892         JP      NZ,RUNCNT                     ; No - Do next statement
   0C35 CD CE 07      [17] 1893         CALL    GETCHR                        ; Position to index name
   0C38 CD F3 0B      [17] 1894         CALL    NEXT1                         ; Re-enter NEXT routine
                           1895 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1896 ;
   0C3B CD 4D 0C      [17] 1897 GETNUM: CALL    EVAL                          ; Get a numeric expression
   0C3E F6                 1898 TSTNUM: .db     0x0F6                         ; Clear carry (numeric)
   0C3F 37            [ 4] 1899 TSTSTR: SCF                                   ; Set carry (string)
   0C40 3A F2 80      [13] 1900 CHKTYP: LD      A,(TYPE)                      ; Check types match
   0C43 8F            [ 4] 1901         ADC     A,A                           ; Expected + actual
   0C44 B7            [ 4] 1902         OR      A                             ; Clear carry , set parity
   0C45 E8            [11] 1903         RET     PE                            ; Even parity - Types match
   0C46 C3 88 03      [10] 1904         JP      TMERR                         ; Different types - Error
                           1905 ;
   0C49 CD 44 06      [17] 1906 OPNPAR: CALL    CHKSYN                        ; Make sure "(" follows
   0C4C 28                 1907         .ascii  "("
   0C4D 2B            [ 6] 1908 EVAL:   DEC     HL                            ; Evaluate expression & save
   0C4E 16 00         [ 7] 1909         LD      D,0                           ; Precedence value
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 36
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0C50 D5            [11] 1910 EVAL1:  PUSH    DE                            ; Save precedence
   0C51 0E 01         [ 7] 1911         LD      C,1
   0C53 CD 53 03      [17] 1912         CALL    CHKSTK                        ; Check for 1 level of stack
   0C56 CD C4 0C      [17] 1913         CALL    OPRND                         ; Get next expression value
   0C59 22 15 81      [16] 1914 EVAL2:  LD      (NXTOPR),HL                   ; Save address of next operator
   0C5C 2A 15 81      [16] 1915 EVAL3:  LD      HL,(NXTOPR)                   ; Restore address of next opr
   0C5F C1            [10] 1916         POP     BC                            ; Precedence value and operator
   0C60 78            [ 4] 1917         LD      A,B                           ; Get precedence value
   0C61 FE 78         [ 7] 1918         CP      0x78                          ; "AND" or "OR" ?
   0C63 D4 3E 0C      [17] 1919         CALL    NC,TSTNUM                     ; No - Make sure it's a number
   0C66 7E            [ 7] 1920         LD      A,(HL)                        ; Get next operator / function
   0C67 16 00         [ 7] 1921         LD      D,0                           ; Clear Last relation
   0C69 D6 B3         [ 7] 1922 RLTLP:  SUB     ZGTR                          ; ">" Token
   0C6B DA 85 0C      [10] 1923         JP      C,FOPRND                      ; + - * / ^ AND OR - Test it
   0C6E FE 03         [ 7] 1924         CP      ZLTH+1-ZGTR                   ; < = >
   0C70 D2 85 0C      [10] 1925         JP      NC,FOPRND                     ; Function - Call it
   0C73 FE 01         [ 7] 1926         CP      ZEQUAL-ZGTR                   ; "="
   0C75 17            [ 4] 1927         RLA                                   ; <- Test for legal
   0C76 AA            [ 4] 1928         XOR     D                             ; <- combinations of < = >
   0C77 BA            [ 4] 1929         CP      D                             ; <- by combining last token
   0C78 57            [ 4] 1930         LD      D,A                           ; <- with current one
   0C79 DA 76 03      [10] 1931         JP      C,SNERR                       ; Error if "<<' '==" or ">>"
   0C7C 22 0A 81      [16] 1932         LD      (CUROPR),HL                   ; Save address of current token
   0C7F CD CE 07      [17] 1933         CALL    GETCHR                        ; Get next character
   0C82 C3 69 0C      [10] 1934         JP      RLTLP                         ; Treat the two as one
                           1935 ;
   0C85 7A            [ 4] 1936 FOPRND: LD      A,D                           ; < = > found ?
   0C86 B7            [ 4] 1937         OR      A
   0C87 C2 AC 0D      [10] 1938         JP      NZ,TSTRED                     ; Yes - Test for reduction
   0C8A 7E            [ 7] 1939         LD      A,(HL)                        ; Get operator token
   0C8B 22 0A 81      [16] 1940         LD      (CUROPR),HL                   ; Save operator address
   0C8E D6 AC         [ 7] 1941         SUB     ZPLUS                         ; Operator or function?
   0C90 D8            [11] 1942         RET     C                             ; Neither - Exit
   0C91 FE 07         [ 7] 1943         CP      ZOR+1-ZPLUS                   ; Is it + - * / ^ AND OR ?
   0C93 D0            [11] 1944         RET     NC                            ; No - Exit
   0C94 5F            [ 4] 1945         LD      E,A                           ; Coded operator
   0C95 3A F2 80      [13] 1946         LD      A,(TYPE)                      ; Get data type
   0C98 3D            [ 4] 1947         DEC     A                             ; FF = numeric , 00 = string
   0C99 B3            [ 4] 1948         OR      E                             ; Combine with coded operator
   0C9A 7B            [ 4] 1949         LD      A,E                           ; Get coded operator
   0C9B CA 0A 12      [10] 1950         JP      Z,CONCAT                      ; String concatenation
   0C9E 07            [ 4] 1951         RLCA                                  ; Times 2
   0C9F 83            [ 4] 1952         ADD     A,E                           ; Times 3
   0CA0 5F            [ 4] 1953         LD      E,A                           ; To DE (D is 0)
   0CA1 21 68 02      [10] 1954         LD      HL,PRITAB                     ; Precedence table
   0CA4 19            [11] 1955         ADD     HL,DE                         ; To the operator concerned
   0CA5 78            [ 4] 1956         LD      A,B                           ; Last operator precedence
   0CA6 56            [ 7] 1957         LD      D,(HL)                        ; Get evaluation precedence
   0CA7 BA            [ 4] 1958         CP      D                             ; Compare with eval precedence
   0CA8 D0            [11] 1959         RET     NC                            ; Exit if higher precedence
   0CA9 23            [ 6] 1960         INC     HL                            ; Point to routine address
   0CAA CD 3E 0C      [17] 1961         CALL    TSTNUM                        ; Make sure it's a number
                           1962 ;
   0CAD C5            [11] 1963 STKTHS: PUSH    BC                            ; Save last precedence & token
   0CAE 01 5C 0C      [10] 1964         LD      BC,EVAL3                      ; Where to go on prec' break
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 37
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0CB1 C5            [11] 1965         PUSH    BC                            ; Save on stack for return
   0CB2 43            [ 4] 1966         LD      B,E                           ; Save operator
   0CB3 4A            [ 4] 1967         LD      C,D                           ; Save precedence
   0CB4 CD 4E 16      [17] 1968         CALL    STAKFP                        ; Move value to stack
   0CB7 58            [ 4] 1969         LD      E,B                           ; Restore operator
   0CB8 51            [ 4] 1970         LD      D,C                           ; Restore precedence
   0CB9 4E            [ 7] 1971         LD      C,(HL)                        ; Get LSB of routine address
   0CBA 23            [ 6] 1972         INC     HL
   0CBB 46            [ 7] 1973         LD      B,(HL)                        ; Get MSB of routine address
   0CBC 23            [ 6] 1974         INC     HL
   0CBD C5            [11] 1975         PUSH    BC                            ; Save routine address
   0CBE 2A 0A 81      [16] 1976         LD      HL,(CUROPR)                   ; Address of current operator
   0CC1 C3 50 0C      [10] 1977         JP      EVAL1                         ; Loop until prec' break
                           1978 ;
   0CC4 AF            [ 4] 1979 OPRND:  XOR     A                             ; Get operand routine
   0CC5 32 F2 80      [13] 1980         LD      (TYPE),A                      ; Set numeric expected
   0CC8 CD CE 07      [17] 1981         CALL    GETCHR                        ; Get next character
   0CCB 1E 24         [ 7] 1982         LD      E,MO                          ; ?MO Error
   0CCD CA 8A 03      [10] 1983         JP      Z,ERROR                       ; No operand - Error
   0CD0 DA 24 17      [10] 1984         JP      C,ASCTFP                      ; Number - Get value
   0CD3 CD 6C 08      [17] 1985         CALL    CHKLTR                        ; See if a letter
   0CD6 D2 2B 0D      [10] 1986         JP      NC,CONVAR                     ; Letter - Find variable
   0CD9 FE 26         [ 7] 1987         CP      '&                            ; &H = HEX, &B = BINARY
   0CDB 20 12         [12] 1988         JR      NZ,NOTAMP
   0CDD CD CE 07      [17] 1989         CALL    GETCHR                        ; Get next character
   0CE0 FE 48         [ 7] 1990         CP      'H                            ; Hex number indicated? [function added]
   0CE2 CA 68 1B      [10] 1991         JP      Z,HEXTFP                      ; Convert Hex to FPREG
   0CE5 FE 42         [ 7] 1992         CP      'B                            ; Binary number indicated? [function added]
   0CE7 CA D8 1B      [10] 1993         JP      Z,BINTFP                      ; Convert Bin to FPREG
   0CEA 1E 02         [ 7] 1994         LD      E,SN                          ; If neither then a ?SN Error
   0CEC CA 8A 03      [10] 1995         JP      Z,ERROR
   0CEF FE AC         [ 7] 1996 NOTAMP: CP      ZPLUS                         ; '+ Token ?
   0CF1 CA C4 0C      [10] 1997         JP      Z,OPRND                       ; Yes - Look for operand
   0CF4 FE 2E         [ 7] 1998         CP      '.                            ; '. ?
   0CF6 CA 24 17      [10] 1999         JP      Z,ASCTFP                      ; Yes - Create FP number
   0CF9 FE AD         [ 7] 2000         CP      ZMINUS                        ; '- Token ?
   0CFB CA 1A 0D      [10] 2001         JP      Z,MINUS                       ; Yes - Do minus
   0CFE FE 22         [ 7] 2002         CP      '"                            ; Literal string ?
   0D00 CA D3 10      [10] 2003         JP      Z,QTSTR                       ; Get string terminated by '"
   0D03 FE AA         [ 7] 2004         CP      ZNOT                          ; "NOT" Token ?
   0D05 CA 0C 0E      [10] 2005         JP      Z,EVNOT                       ; Yes - Eval NOT expression
   0D08 FE A7         [ 7] 2006         CP      ZFN                           ; "FN" Token ?
   0D0A CA 37 10      [10] 2007         JP      Z,DOFN                        ; Yes - Do FN routine
   0D0D D6 B6         [ 7] 2008         SUB     ZSGN                          ; Is it a function?
   0D0F D2 3C 0D      [10] 2009         JP      NC,FNOFST                     ; Yes - Evaluate function
   0D12 CD 49 0C      [17] 2010 EVLPAR: CALL    OPNPAR                        ; Evaluate expression in "()"
   0D15 CD 44 06      [17] 2011         CALL    CHKSYN                        ; Make sure ")" follows
   0D18 29                 2012         .ascii  ")"
   0D19 C9            [10] 2013         RET
                           2014 ;
   0D1A 16 7D         [ 7] 2015 MINUS:  LD      D,0x7D                        ; '- precedence
   0D1C CD 50 0C      [17] 2016         CALL    EVAL1                         ; Evaluate until prec' break
   0D1F 2A 15 81      [16] 2017         LD      HL,(NXTOPR)                   ; Get next operator address
   0D22 E5            [11] 2018         PUSH    HL                            ; Save next operator address
   0D23 CD 46 16      [17] 2019         CALL    INVSGN                        ; Negate value
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 38
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0D26 CD 3E 0C      [17] 2020 RETNUM: CALL    TSTNUM                        ; Make sure it's a number
   0D29 E1            [10] 2021         POP     HL                            ; Restore next operator address
   0D2A C9            [10] 2022         RET
                           2023 ;
   0D2B CD 31 0E      [17] 2024 CONVAR: CALL    GETVAR                        ; Get variable address to DE
   0D2E E5            [11] 2025 FRMEVL: PUSH    HL                            ; Save code string address
   0D2F EB            [ 4] 2026         EX      DE,HL                         ; Variable address to HL
   0D30 22 29 81      [16] 2027         LD      (FPREG),HL                    ; Save address of variable
   0D33 3A F2 80      [13] 2028         LD      A,(TYPE)                      ; Get type
   0D36 B7            [ 4] 2029         OR      A                             ; Numeric?
   0D37 CC 5B 16      [17] 2030         CALL    Z,PHLTFP                      ; Yes - Move contents to FPREG
   0D3A E1            [10] 2031         POP     HL                            ; Restore code string address
   0D3B C9            [10] 2032         RET
                           2033 ;
   0D3C 06 00         [ 7] 2034 FNOFST: LD      B,0                           ; Get address of function
   0D3E 07            [ 4] 2035         RLCA                                  ; Double function offset
   0D3F 4F            [ 4] 2036         LD      C,A                           ; BC = Offset in function table
   0D40 C5            [11] 2037         PUSH    BC                            ; Save adjusted token value
   0D41 CD CE 07      [17] 2038         CALL    GETCHR                        ; Get next character
   0D44 79            [ 4] 2039         LD      A,C                           ; Get adjusted token value
   0D45 FE 31         [ 7] 2040         CP      2*(ZLEFT-ZSGN)-1              ; Adj' LEFT$,RIGHT$ or MID$ ?
   0D47 DA 63 0D      [10] 2041         JP      C,FNVAL                       ; No - Do function
   0D4A CD 49 0C      [17] 2042         CALL    OPNPAR                        ; Evaluate expression	(X,...
   0D4D CD 44 06      [17] 2043         CALL    CHKSYN                        ; Make sure ', follows
   0D50 2C                 2044         .db     ',
   0D51 CD 3F 0C      [17] 2045         CALL    TSTSTR                        ; Make sure it's a string
   0D54 EB            [ 4] 2046         EX      DE,HL                         ; Save code string address
   0D55 2A 29 81      [16] 2047         LD      HL,(FPREG)                    ; Get address of string
   0D58 E3            [19] 2048         EX      (SP),HL                       ; Save address of string
   0D59 E5            [11] 2049         PUSH    HL                            ; Save adjusted token value
   0D5A EB            [ 4] 2050         EX      DE,HL                         ; Restore code string address
   0D5B CD 9C 13      [17] 2051         CALL    GETINT                        ; Get integer 0-255
   0D5E EB            [ 4] 2052         EX      DE,HL                         ; Save code string address
   0D5F E3            [19] 2053         EX      (SP),HL                       ; Save integer,HL = adj' token
   0D60 C3 6B 0D      [10] 2054         JP      GOFUNC                        ; Jump to string function
                           2055 ;
   0D63 CD 12 0D      [17] 2056 FNVAL:  CALL    EVLPAR                        ; Evaluate expression
   0D66 E3            [19] 2057         EX      (SP),HL                       ; HL = Adjusted token value
   0D67 11 26 0D      [10] 2058         LD      DE,RETNUM                     ; Return number from function
   0D6A D5            [11] 2059         PUSH    DE                            ; Save on stack
   0D6B 01 49 01      [10] 2060 GOFUNC: LD      BC,FNCTAB                     ; Function routine addresses
   0D6E 09            [11] 2061         ADD     HL,BC                         ; Point to right address
   0D6F 4E            [ 7] 2062         LD      C,(HL)                        ; Get LSB of address
   0D70 23            [ 6] 2063         INC     HL                            ;
   0D71 66            [ 7] 2064         LD      H,(HL)                        ; Get MSB of address
   0D72 69            [ 4] 2065         LD      L,C                           ; Address to HL
   0D73 E9            [ 4] 2066         JP      (HL)                          ; Jump to function
                           2067 ;
   0D74 15            [ 4] 2068 SGNEXP: DEC     D                             ; Dee to flag negative exponent
   0D75 FE AD         [ 7] 2069         CP      ZMINUS                        ; '- token ?
   0D77 C8            [11] 2070         RET     Z                             ; Yes - Return
   0D78 FE 2D         [ 7] 2071         CP      '-                            ; '- ASCII ?
   0D7A C8            [11] 2072         RET     Z                             ; Yes - Return
   0D7B 14            [ 4] 2073         INC     D                             ; Inc to flag positive exponent
   0D7C FE 2B         [ 7] 2074         CP      '+                            ; '+ ASCII ?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 39
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0D7E C8            [11] 2075         RET     Z                             ; Yes - Return
   0D7F FE AC         [ 7] 2076         CP      ZPLUS                         ; '+ token ?
   0D81 C8            [11] 2077         RET     Z                             ; Yes - Return
   0D82 2B            [ 6] 2078         DEC     HL                            ; DEC 'cos GETCHR INCs
   0D83 C9            [10] 2079         RET                                   ; Return "NZ"
                           2080 ;
   0D84 F6                 2081 POR:    .db     0x0F6                         ; Flag "OR"
   0D85 AF            [ 4] 2082 PAND:   XOR     A                             ; Flag "AND"
   0D86 F5            [11] 2083         PUSH    AF                            ; Save "AND" / "OR" flag
   0D87 CD 3E 0C      [17] 2084         CALL    TSTNUM                        ; Make sure it's a number
   0D8A CD 80 08      [17] 2085         CALL    DEINT                         ; Get integer -32768 to 32767
   0D8D F1            [10] 2086         POP     AF                            ; Restore "AND" / "OR" flag
   0D8E EB            [ 4] 2087         EX      DE,HL                         ; <- Get last
   0D8F C1            [10] 2088         POP     BC                            ; <- value
   0D90 E3            [19] 2089         EX      (SP),HL                       ; <- from
   0D91 EB            [ 4] 2090         EX      DE,HL                         ; <- stack
   0D92 CD 5E 16      [17] 2091         CALL    FPBCDE                        ; Move last value to FPREG
   0D95 F5            [11] 2092         PUSH    AF                            ; Save "AND" / "OR" flag
   0D96 CD 80 08      [17] 2093         CALL    DEINT                         ; Get integer -32768 to 32767
   0D99 F1            [10] 2094         POP     AF                            ; Restore "AND" / "OR" flag
   0D9A C1            [10] 2095         POP     BC                            ; Get value
   0D9B 79            [ 4] 2096         LD      A,C                           ; Get LSB
   0D9C 21 F5 0F      [10] 2097         LD      HL,ACPASS                     ; Address of save AC as current
   0D9F C2 A7 0D      [10] 2098         JP      NZ,POR1                       ; Jump if OR
   0DA2 A3            [ 4] 2099         AND     E                             ; "AND" LSBs
   0DA3 4F            [ 4] 2100         LD      C,A                           ; Save LSB
   0DA4 78            [ 4] 2101         LD      A,B                           ; Get MBS
   0DA5 A2            [ 4] 2102         AND     D                             ; "AND" MSBs
   0DA6 E9            [ 4] 2103         JP      (HL)                          ; Save AC as current (ACPASS)
                           2104 ;
   0DA7 B3            [ 4] 2105 POR1:   OR      E                             ; "OR" LSBs
   0DA8 4F            [ 4] 2106         LD      C,A                           ; Save LSB
   0DA9 78            [ 4] 2107         LD      A,B                           ; Get MSB
   0DAA B2            [ 4] 2108         OR      D                             ; "OR" MSBs
   0DAB E9            [ 4] 2109         JP      (HL)                          ; Save AC as current (ACPASS)
                           2110 ;
   0DAC 21 BE 0D      [10] 2111 TSTRED: LD      HL,CMPLOG                     ; Logical compare routine
   0DAF 3A F2 80      [13] 2112         LD      A,(TYPE)                      ; Get data type
   0DB2 1F            [ 4] 2113         RRA                                   ; Carry set = string
   0DB3 7A            [ 4] 2114         LD      A,D                           ; Get last precedence value
   0DB4 17            [ 4] 2115         RLA                                   ; Times 2 plus carry
   0DB5 5F            [ 4] 2116         LD      E,A                           ; To E
   0DB6 16 64         [ 7] 2117         LD      D,0x64                        ; Relational precedence
   0DB8 78            [ 4] 2118         LD      A,B                           ; Get current precedence
   0DB9 BA            [ 4] 2119         CP      D                             ; Compare with last
   0DBA D0            [11] 2120         RET     NC                            ; Eval if last was rel' or log'
   0DBB C3 AD 0C      [10] 2121         JP      STKTHS                        ; Stack this one and get next
                           2122 ;
   0DBE C0 0D              2123 CMPLOG: .dw     CMPLG1                        ; Compare two values / strings
   0DC0 79            [ 4] 2124 CMPLG1: LD      A,C                           ; Get data type
   0DC1 B7            [ 4] 2125         OR      A
   0DC2 1F            [ 4] 2126         RRA
   0DC3 C1            [10] 2127         POP     BC                            ; Get last expression to BCDE
   0DC4 D1            [10] 2128         POP     DE
   0DC5 F5            [11] 2129         PUSH    AF                            ; Save status
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 40
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0DC6 CD 40 0C      [17] 2130         CALL    CHKTYP                        ; Check that types match
   0DC9 21 02 0E      [10] 2131         LD      HL,CMPRES                     ; Result to comparison
   0DCC E5            [11] 2132         PUSH    HL                            ; Save for RETurn
   0DCD CA 98 16      [10] 2133         JP      Z,CMPNUM                      ; Compare values if numeric
   0DD0 AF            [ 4] 2134         XOR     A                             ; Compare two strings
   0DD1 32 F2 80      [13] 2135         LD      (TYPE),A                      ; Set type to numeric
   0DD4 D5            [11] 2136         PUSH    DE                            ; Save string name
   0DD5 CD 57 12      [17] 2137         CALL    GSTRCU                        ; Get current string
   0DD8 7E            [ 7] 2138         LD      A,(HL)                        ; Get length of string
   0DD9 23            [ 6] 2139         INC     HL
   0DDA 23            [ 6] 2140         INC     HL
   0DDB 4E            [ 7] 2141         LD      C,(HL)                        ; Get LSB of address
   0DDC 23            [ 6] 2142         INC     HL
   0DDD 46            [ 7] 2143         LD      B,(HL)                        ; Get MSB of address
   0DDE D1            [10] 2144         POP     DE                            ; Restore string name
   0DDF C5            [11] 2145         PUSH    BC                            ; Save address of string
   0DE0 F5            [11] 2146         PUSH    AF                            ; Save length of string
   0DE1 CD 5B 12      [17] 2147         CALL    GSTRDE                        ; Get second string
   0DE4 CD 6C 16      [17] 2148         CALL    LOADFP                        ; Get address of second string
   0DE7 F1            [10] 2149         POP     AF                            ; Restore length of string 1
   0DE8 57            [ 4] 2150         LD      D,A                           ; Length to D
   0DE9 E1            [10] 2151         POP     HL                            ; Restore address of string 1
   0DEA 7B            [ 4] 2152 CMPSTR: LD      A,E                           ; Bytes of string 2 to do
   0DEB B2            [ 4] 2153         OR      D                             ; Bytes of string 1 to do
   0DEC C8            [11] 2154         RET     Z                             ; Exit if all bytes compared
   0DED 7A            [ 4] 2155         LD      A,D                           ; Get bytes of string 1 to do
   0DEE D6 01         [ 7] 2156         SUB     1
   0DF0 D8            [11] 2157         RET     C                             ; Exit if end of string 1
   0DF1 AF            [ 4] 2158         XOR     A
   0DF2 BB            [ 4] 2159         CP      E                             ; Bytes of string 2 to do
   0DF3 3C            [ 4] 2160         INC     A
   0DF4 D0            [11] 2161         RET     NC                            ; Exit if end of string 2
   0DF5 15            [ 4] 2162         DEC     D                             ; Count bytes in string 1
   0DF6 1D            [ 4] 2163         DEC     E                             ; Count bytes in string 2
   0DF7 0A            [ 7] 2164         LD      A,(BC)                        ; Byte in string 2
   0DF8 BE            [ 7] 2165         CP      (HL)                          ; Compare to byte in string 1
   0DF9 23            [ 6] 2166         INC     HL                            ; Move up string 1
   0DFA 03            [ 6] 2167         INC     BC                            ; Move up string 2
   0DFB CA EA 0D      [10] 2168         JP      Z,CMPSTR                      ; Same - Try next bytes
   0DFE 3F            [ 4] 2169         CCF                                   ; Flag difference (">" or "<")
   0DFF C3 28 16      [10] 2170         JP      FLGDIF                        ; "<" gives -1 , ">" gives +1
                           2171 ;
   0E02 3C            [ 4] 2172 CMPRES: INC     A                             ; Increment current value
   0E03 8F            [ 4] 2173         ADC     A,A                           ; Double plus carry
   0E04 C1            [10] 2174         POP     BC                            ; Get other value
   0E05 A0            [ 4] 2175         AND     B                             ; Combine them
   0E06 C6 FF         [ 7] 2176         ADD     A,-1                          ; Carry set if different
   0E08 9F            [ 4] 2177         SBC     A,A                           ; 00 - Equal , FF - Different
   0E09 C3 2F 16      [10] 2178         JP      FLGREL                        ; Set current value & continue
                           2179 ;
   0E0C 16 5A         [ 7] 2180 EVNOT:  LD      D,0x5A                        ; Precedence value for "NOT"
   0E0E CD 50 0C      [17] 2181         CALL    EVAL1                         ; Eval until precedence break
   0E11 CD 3E 0C      [17] 2182         CALL    TSTNUM                        ; Make sure it's a number
   0E14 CD 80 08      [17] 2183         CALL    DEINT                         ; Get integer -32768 - 32767
   0E17 7B            [ 4] 2184         LD      A,E                           ; Get LSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 41
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0E18 2F            [ 4] 2185         CPL                                   ; Invert LSB
   0E19 4F            [ 4] 2186         LD      C,A                           ; Save "NOT" of LSB
   0E1A 7A            [ 4] 2187         LD      A,D                           ; Get MSB
   0E1B 2F            [ 4] 2188         CPL                                   ; Invert MSB
   0E1C CD F5 0F      [17] 2189         CALL    ACPASS                        ; Save AC as current
   0E1F C1            [10] 2190         POP     BC                            ; Clean up stack
   0E20 C3 5C 0C      [10] 2191         JP      EVAL3                         ; Continue evaluation
                           2192 ;
   0E23 2B            [ 6] 2193 DIMRET: DEC     HL                            ; DEC 'cos GETCHR INCs
   0E24 CD CE 07      [17] 2194         CALL    GETCHR                        ; Get next character
   0E27 C8            [11] 2195         RET     Z                             ; End of DIM statement
   0E28 CD 44 06      [17] 2196         CALL    CHKSYN                        ; Make sure ', follows
   0E2B 2C                 2197         .db     ',
   0E2C 01 23 0E      [10] 2198 DIM:    LD      BC,DIMRET                     ; Return to "DIMRET"
   0E2F C5            [11] 2199         PUSH    BC                            ; Save on stack
   0E30 F6                 2200         .db     0x0F6                         ; Flag "Create" variable
   0E31 AF            [ 4] 2201 GETVAR: XOR     A                             ; Find variable address,to DE
   0E32 32 F1 80      [13] 2202         LD      (LCRFLG),A                    ; Set locate / create flag
   0E35 46            [ 7] 2203         LD      B,(HL)                        ; Get First byte of name
   0E36 CD 6C 08      [17] 2204 GTFNAM: CALL    CHKLTR                        ; See if a letter
   0E39 DA 76 03      [10] 2205         JP      C,SNERR                       ; ?SN Error if not a letter
   0E3C AF            [ 4] 2206         XOR     A
   0E3D 4F            [ 4] 2207         LD      C,A                           ; Clear second byte of name
   0E3E 32 F2 80      [13] 2208         LD      (TYPE),A                      ; Set type to numeric
   0E41 CD CE 07      [17] 2209         CALL    GETCHR                        ; Get next character
   0E44 DA 4D 0E      [10] 2210         JP      C,SVNAM2                      ; Numeric - Save in name
   0E47 CD 6C 08      [17] 2211         CALL    CHKLTR                        ; See if a letter
   0E4A DA 5A 0E      [10] 2212         JP      C,CHARTY                      ; Not a letter - Check type
   0E4D 4F            [ 4] 2213 SVNAM2: LD      C,A                           ; Save second byte of name
   0E4E CD CE 07      [17] 2214 ENDNAM: CALL    GETCHR                        ; Get next character
   0E51 DA 4E 0E      [10] 2215         JP      C,ENDNAM                      ; Numeric - Get another
   0E54 CD 6C 08      [17] 2216         CALL    CHKLTR                        ; See if a letter
   0E57 D2 4E 0E      [10] 2217         JP      NC,ENDNAM                     ; Letter - Get another
   0E5A D6 24         [ 7] 2218 CHARTY: SUB     '$                            ; String variable?
   0E5C C2 69 0E      [10] 2219         JP      NZ,NOTSTR                     ; No - Numeric variable
   0E5F 3C            [ 4] 2220         INC     A                             ; A = 1 (string type)
   0E60 32 F2 80      [13] 2221         LD      (TYPE),A                      ; Set type to string
   0E63 0F            [ 4] 2222         RRCA                                  ; A = 0x80 , Flag for string
   0E64 81            [ 4] 2223         ADD     A,C                           ; 2nd byte of name has bit 7 on
   0E65 4F            [ 4] 2224         LD      C,A                           ; Resave second byte on name
   0E66 CD CE 07      [17] 2225         CALL    GETCHR                        ; Get next character
   0E69 3A 10 81      [13] 2226 NOTSTR: LD      A,(FORFLG)                    ; Array name needed ?
   0E6C 3D            [ 4] 2227         DEC     A
   0E6D CA 16 0F      [10] 2228         JP      Z,ARLDSV                      ; Yes - Get array name
   0E70 F2 79 0E      [10] 2229         JP      P,NSCFOR                      ; No array with "FOR" or "FN"
   0E73 7E            [ 7] 2230         LD      A,(HL)                        ; Get byte again
   0E74 D6 28         [ 7] 2231         SUB     '(                            ; Subscripted variable?
   0E76 CA EE 0E      [10] 2232         JP      Z,SBSCPT                      ; Yes - Sort out subscript
                           2233 ;
   0E79 AF            [ 4] 2234 NSCFOR: XOR     A                             ; Simple variable
   0E7A 32 10 81      [13] 2235         LD      (FORFLG),A                    ; Clear "FOR" flag
   0E7D E5            [11] 2236         PUSH    HL                            ; Save code string address
   0E7E 50            [ 4] 2237         LD      D,B                           ; DE = Variable name to find
   0E7F 59            [ 4] 2238         LD      E,C
   0E80 2A 23 81      [16] 2239         LD      HL,(FNRGNM)                   ; FN argument name
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 42
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0E83 CD 3E 06      [17] 2240         CALL    CPDEHL                        ; Is it the FN argument?
   0E86 11 25 81      [10] 2241         LD      DE,FNARG                      ; Point to argument value
   0E89 CA 5E 15      [10] 2242         JP      Z,POPHRT                      ; Yes - Return FN argument value
   0E8C 2A 1D 81      [16] 2243         LD      HL,(VAREND)                   ; End of variables
   0E8F EB            [ 4] 2244         EX      DE,HL                         ; Address of end of search
   0E90 2A 1B 81      [16] 2245         LD      HL,(PROGND)                   ; Start of variables address
   0E93 CD 3E 06      [17] 2246 FNDVAR: CALL    CPDEHL                        ; End of variable list table?
   0E96 CA AC 0E      [10] 2247         JP      Z,CFEVAL                      ; Yes - Called from EVAL?
   0E99 79            [ 4] 2248         LD      A,C                           ; Get second byte of name
   0E9A 96            [ 7] 2249         SUB     (HL)                          ; Compare with name in list
   0E9B 23            [ 6] 2250         INC     HL                            ; Move on to first byte
   0E9C C2 A1 0E      [10] 2251         JP      NZ,FNTHR                      ; Different - Find another
   0E9F 78            [ 4] 2252         LD      A,B                           ; Get first byte of name
   0EA0 96            [ 7] 2253         SUB     (HL)                          ; Compare with name in list
   0EA1 23            [ 6] 2254 FNTHR:  INC     HL                            ; Move on to LSB of value
   0EA2 CA E0 0E      [10] 2255         JP      Z,RETADR                      ; Found - Return address
   0EA5 23            [ 6] 2256         INC     HL                            ; <- Skip
   0EA6 23            [ 6] 2257         INC     HL                            ; <- over
   0EA7 23            [ 6] 2258         INC     HL                            ; <- F.P.
   0EA8 23            [ 6] 2259         INC     HL                            ; <- value
   0EA9 C3 93 0E      [10] 2260         JP      FNDVAR                        ; Keep looking
                           2261 ;
   0EAC E1            [10] 2262 CFEVAL: POP     HL                            ; Restore code string address
   0EAD E3            [19] 2263         EX      (SP),HL                       ; Get return address
   0EAE D5            [11] 2264         PUSH    DE                            ; Save address of variable
   0EAF 11 2E 0D      [10] 2265         LD      DE,FRMEVL                     ; Return address in EVAL
   0EB2 CD 3E 06      [17] 2266         CALL    CPDEHL                        ; Called from EVAL ?
   0EB5 D1            [10] 2267         POP     DE                            ; Restore address of variable
   0EB6 CA E3 0E      [10] 2268         JP      Z,RETNUL                      ; Yes - Return null variable
   0EB9 E3            [19] 2269         EX      (SP),HL                       ; Put back return
   0EBA E5            [11] 2270         PUSH    HL                            ; Save code string address
   0EBB C5            [11] 2271         PUSH    BC                            ; Save variable name
   0EBC 01 06 00      [10] 2272         LD      BC,6                          ; 2 byte name plus 4 byte data
   0EBF 2A 1F 81      [16] 2273         LD      HL,(ARREND)                   ; End of arrays
   0EC2 E5            [11] 2274         PUSH    HL                            ; Save end of arrays
   0EC3 09            [11] 2275         ADD     HL,BC                         ; Move up 6 bytes
   0EC4 C1            [10] 2276         POP     BC                            ; Source address in BC
   0EC5 E5            [11] 2277         PUSH    HL                            ; Save new end address
   0EC6 CD 42 03      [17] 2278         CALL    MOVUP                         ; Move arrays up
   0EC9 E1            [10] 2279         POP     HL                            ; Restore new end address
   0ECA 22 1F 81      [16] 2280         LD      (ARREND),HL                   ; Set new end address
   0ECD 60            [ 4] 2281         LD      H,B                           ; End of variables to HL
   0ECE 69            [ 4] 2282         LD      L,C
   0ECF 22 1D 81      [16] 2283         LD      (VAREND),HL                   ; Set new end address
                           2284 ;
   0ED2 2B            [ 6] 2285 ZEROLP: DEC     HL                            ; Back through to zero variable
   0ED3 36 00         [10] 2286         LD      (HL),0                        ; Zero byte in variable
   0ED5 CD 3E 06      [17] 2287         CALL    CPDEHL                        ; Done them all?
   0ED8 C2 D2 0E      [10] 2288         JP      NZ,ZEROLP                     ; No - Keep on going
   0EDB D1            [10] 2289         POP     DE                            ; Get variable name
   0EDC 73            [ 7] 2290         LD      (HL),E                        ; Store second character
   0EDD 23            [ 6] 2291         INC     HL
   0EDE 72            [ 7] 2292         LD      (HL),D                        ; Store first character
   0EDF 23            [ 6] 2293         INC     HL
   0EE0 EB            [ 4] 2294 RETADR: EX      DE,HL                         ; Address of variable in DE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 43
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0EE1 E1            [10] 2295         POP     HL                            ; Restore code string address
   0EE2 C9            [10] 2296         RET
                           2297 ;
   0EE3 32 2C 81      [13] 2298 RETNUL: LD      (FPEXP),A                     ; Set result to zero
   0EE6 21 12 03      [10] 2299         LD      HL,ZERBYT                     ; Also set a null string
   0EE9 22 29 81      [16] 2300         LD      (FPREG),HL                    ; Save for EVAL
   0EEC E1            [10] 2301         POP     HL                            ; Restore code string address
   0EED C9            [10] 2302         RET
                           2303 ;
   0EEE E5            [11] 2304 SBSCPT: PUSH    HL                            ; Save code string address
   0EEF 2A F1 80      [16] 2305         LD      HL,(LCRFLG)                   ; Locate/Create and Type
   0EF2 E3            [19] 2306         EX      (SP),HL                       ; Save and get code string
   0EF3 57            [ 4] 2307         LD      D,A                           ; Zero number of dimensions
   0EF4 D5            [11] 2308 SCPTLP: PUSH    DE                            ; Save number of dimensions
   0EF5 C5            [11] 2309         PUSH    BC                            ; Save array name
   0EF6 CD 74 08      [17] 2310         CALL    FPSINT                        ; Get subscript (0-32767)
   0EF9 C1            [10] 2311         POP     BC                            ; Restore array name
   0EFA F1            [10] 2312         POP     AF                            ; Get number of dimensions
   0EFB EB            [ 4] 2313         EX      DE,HL
   0EFC E3            [19] 2314         EX      (SP),HL                       ; Save subscript value
   0EFD E5            [11] 2315         PUSH    HL                            ; Save LCRFLG and TYPE
   0EFE EB            [ 4] 2316         EX      DE,HL
   0EFF 3C            [ 4] 2317         INC     A                             ; Count dimensions
   0F00 57            [ 4] 2318         LD      D,A                           ; Save in D
   0F01 7E            [ 7] 2319         LD      A,(HL)                        ; Get next byte in code string
   0F02 FE 2C         [ 7] 2320         CP      ',                            ; Comma (more to come)?
   0F04 CA F4 0E      [10] 2321         JP      Z,SCPTLP                      ; Yes - More subscripts
   0F07 CD 44 06      [17] 2322         CALL    CHKSYN                        ; Make sure ")" follows
   0F0A 29                 2323         .ascii  ")"
   0F0B 22 15 81      [16] 2324         LD      (NXTOPR),HL                   ; Save code string address
   0F0E E1            [10] 2325         POP     HL                            ; Get LCRFLG and TYPE
   0F0F 22 F1 80      [16] 2326         LD      (LCRFLG),HL                   ; Restore Locate/create & type
   0F12 1E 00         [ 7] 2327         LD      E,0                           ; Flag not CSAVE* or CLOAD*
   0F14 D5            [11] 2328         PUSH    DE                            ; Save number of dimensions (D)
   0F15 11                 2329         .db     0x11                          ; Skip "PUSH HL" and "PUSH AF"
                           2330 ;
   0F16 E5            [11] 2331 ARLDSV: PUSH    HL                            ; Save code string address
   0F17 F5            [11] 2332         PUSH    AF                            ; A = 00 , Flags set = Z,N
   0F18 2A 1D 81      [16] 2333         LD      HL,(VAREND)                   ; Start of arrays
   0F1B 3E                 2334         .db     0x3E                          ; Skip "ADD HL,DE"
   0F1C 19            [11] 2335 FNDARY: ADD     HL,DE                         ; Move to next array start
   0F1D EB            [ 4] 2336         EX      DE,HL
   0F1E 2A 1F 81      [16] 2337         LD      HL,(ARREND)                   ; End of arrays
   0F21 EB            [ 4] 2338         EX      DE,HL                         ; Current array pointer
   0F22 CD 3E 06      [17] 2339         CALL    CPDEHL                        ; End of arrays found?
   0F25 CA 4E 0F      [10] 2340         JP      Z,CREARY                      ; Yes - Create array
   0F28 7E            [ 7] 2341         LD      A,(HL)                        ; Get second byte of name
   0F29 B9            [ 4] 2342         CP      C                             ; Compare with name given
   0F2A 23            [ 6] 2343         INC     HL                            ; Move on
   0F2B C2 30 0F      [10] 2344         JP      NZ,NXTARY                     ; Different - Find next array
   0F2E 7E            [ 7] 2345         LD      A,(HL)                        ; Get first byte of name
   0F2F B8            [ 4] 2346         CP      B                             ; Compare with name given
   0F30 23            [ 6] 2347 NXTARY: INC     HL                            ; Move on
   0F31 5E            [ 7] 2348         LD      E,(HL)                        ; Get LSB of next array address
   0F32 23            [ 6] 2349         INC     HL
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 44
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0F33 56            [ 7] 2350         LD      D,(HL)                        ; Get MSB of next array address
   0F34 23            [ 6] 2351         INC     HL
   0F35 C2 1C 0F      [10] 2352         JP      NZ,FNDARY                     ; Not found - Keep looking
   0F38 3A F1 80      [13] 2353         LD      A,(LCRFLG)                    ; Found Locate or Create it?
   0F3B B7            [ 4] 2354         OR      A
   0F3C C2 7F 03      [10] 2355         JP      NZ,DDERR                      ; Create - ?DD Error
   0F3F F1            [10] 2356         POP     AF                            ; Locate - Get number of dim'ns
   0F40 44            [ 4] 2357         LD      B,H                           ; BC Points to array dim'ns
   0F41 4D            [ 4] 2358         LD      C,L
   0F42 CA 5E 15      [10] 2359         JP      Z,POPHRT                      ; Jump if array load/save
   0F45 96            [ 7] 2360         SUB     (HL)                          ; Same number of dimensions?
   0F46 CA AC 0F      [10] 2361         JP      Z,FINDEL                      ; Yes - Find element
   0F49 1E 10         [ 7] 2362 BSERR:  LD      E,BS                          ; ?BS Error
   0F4B C3 8A 03      [10] 2363         JP      ERROR                         ; Output error
                           2364 ;
   0F4E 11 04 00      [10] 2365 CREARY: LD      DE,4                          ; 4 Bytes per entry
   0F51 F1            [10] 2366         POP     AF                            ; Array to save or 0 dim'ns?
   0F52 CA 95 08      [10] 2367         JP      Z,FCERR                       ; Yes - ?FC Error
   0F55 71            [ 7] 2368         LD      (HL),C                        ; Save second byte of name
   0F56 23            [ 6] 2369         INC     HL
   0F57 70            [ 7] 2370         LD      (HL),B                        ; Save first byte of name
   0F58 23            [ 6] 2371         INC     HL
   0F59 4F            [ 4] 2372         LD      C,A                           ; Number of dimensions to C
   0F5A CD 53 03      [17] 2373         CALL    CHKSTK                        ; Check if enough memory
   0F5D 23            [ 6] 2374         INC     HL                            ; Point to number of dimensions
   0F5E 23            [ 6] 2375         INC     HL
   0F5F 22 0A 81      [16] 2376         LD      (CUROPR),HL                   ; Save address of pointer
   0F62 71            [ 7] 2377         LD      (HL),C                        ; Set number of dimensions
   0F63 23            [ 6] 2378         INC     HL
   0F64 3A F1 80      [13] 2379         LD      A,(LCRFLG)                    ; Locate of Create?
   0F67 17            [ 4] 2380         RLA                                   ; Carry set = Create
   0F68 79            [ 4] 2381         LD      A,C                           ; Get number of dimensions
   0F69 01 0B 00      [10] 2382 CRARLP: LD      BC,10+1                       ; Default dimension size 10
   0F6C D2 71 0F      [10] 2383         JP      NC,DEFSIZ                     ; Locate - Set default size
   0F6F C1            [10] 2384         POP     BC                            ; Get specified dimension size
   0F70 03            [ 6] 2385         INC     BC                            ; Include zero element
   0F71 71            [ 7] 2386 DEFSIZ: LD      (HL),C                        ; Save LSB of dimension size
   0F72 23            [ 6] 2387         INC     HL
   0F73 70            [ 7] 2388         LD      (HL),B                        ; Save MSB of dimension size
   0F74 23            [ 6] 2389         INC     HL
   0F75 F5            [11] 2390         PUSH    AF                            ; Save num' of dim'ns an status
   0F76 E5            [11] 2391         PUSH    HL                            ; Save address of dim'n size
   0F77 CD 09 17      [17] 2392         CALL    MLDEBC                        ; Multiply DE by BC to find
   0F7A EB            [ 4] 2393         EX      DE,HL                         ; amount of mem needed (to DE)
   0F7B E1            [10] 2394         POP     HL                            ; Restore address of dimension
   0F7C F1            [10] 2395         POP     AF                            ; Restore number of dimensions
   0F7D 3D            [ 4] 2396         DEC     A                             ; Count them
   0F7E C2 69 0F      [10] 2397         JP      NZ,CRARLP                     ; Do next dimension if more
   0F81 F5            [11] 2398         PUSH    AF                            ; Save locate/create flag
   0F82 42            [ 4] 2399         LD      B,D                           ; MSB of memory needed
   0F83 4B            [ 4] 2400         LD      C,E                           ; LSB of memory needed
   0F84 EB            [ 4] 2401         EX      DE,HL
   0F85 19            [11] 2402         ADD     HL,DE                         ; Add bytes to array start
   0F86 DA 6B 03      [10] 2403         JP      C,OMERR                       ; Too big - Error
   0F89 CD 5C 03      [17] 2404         CALL    ENFMEM                        ; See if enough memory
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 45
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0F8C 22 1F 81      [16] 2405         LD      (ARREND),HL                   ; Save new end of array
                           2406 ;
   0F8F 2B            [ 6] 2407 ZERARY: DEC     HL                            ; Back through array data
   0F90 36 00         [10] 2408         LD      (HL),0                        ; Set array element to zero
   0F92 CD 3E 06      [17] 2409         CALL    CPDEHL                        ; All elements zeroed?
   0F95 C2 8F 0F      [10] 2410         JP      NZ,ZERARY                     ; No - Keep on going
   0F98 03            [ 6] 2411         INC     BC                            ; Number of bytes + 1
   0F99 57            [ 4] 2412         LD      D,A                           ; A=0
   0F9A 2A 0A 81      [16] 2413         LD      HL,(CUROPR)                   ; Get address of array
   0F9D 5E            [ 7] 2414         LD      E,(HL)                        ; Number of dimensions
   0F9E EB            [ 4] 2415         EX      DE,HL                         ; To HL
   0F9F 29            [11] 2416         ADD     HL,HL                         ; Two bytes per dimension size
   0FA0 09            [11] 2417         ADD     HL,BC                         ; Add number of bytes
   0FA1 EB            [ 4] 2418         EX      DE,HL                         ; Bytes needed to DE
   0FA2 2B            [ 6] 2419         DEC     HL
   0FA3 2B            [ 6] 2420         DEC     HL
   0FA4 73            [ 7] 2421         LD      (HL),E                        ; Save LSB of bytes needed
   0FA5 23            [ 6] 2422         INC     HL
   0FA6 72            [ 7] 2423         LD      (HL),D                        ; Save MSB of bytes needed
   0FA7 23            [ 6] 2424         INC     HL
   0FA8 F1            [10] 2425         POP     AF                            ; Locate / Create?
   0FA9 DA D0 0F      [10] 2426         JP      C,ENDDIM                      ; A is 0 , End if create
   0FAC 47            [ 4] 2427 FINDEL: LD      B,A                           ; Find array element
   0FAD 4F            [ 4] 2428         LD      C,A
   0FAE 7E            [ 7] 2429         LD      A,(HL)                        ; Number of dimensions
   0FAF 23            [ 6] 2430         INC     HL
   0FB0 16                 2431         .db     0x16                          ; Skip "POP HL"
   0FB1 E1            [10] 2432 FNDELP: POP     HL                            ; Address of next dim' size
   0FB2 5E            [ 7] 2433         LD      E,(HL)                        ; Get LSB of dim'n size
   0FB3 23            [ 6] 2434         INC     HL
   0FB4 56            [ 7] 2435         LD      D,(HL)                        ; Get MSB of dim'n size
   0FB5 23            [ 6] 2436         INC     HL
   0FB6 E3            [19] 2437         EX      (SP),HL                       ; Save address - Get index
   0FB7 F5            [11] 2438         PUSH    AF                            ; Save number of dim'ns
   0FB8 CD 3E 06      [17] 2439         CALL    CPDEHL                        ; Dimension too large?
   0FBB D2 49 0F      [10] 2440         JP      NC,BSERR                      ; Yes - ?BS Error
   0FBE E5            [11] 2441         PUSH    HL                            ; Save index
   0FBF CD 09 17      [17] 2442         CALL    MLDEBC                        ; Multiply previous by size
   0FC2 D1            [10] 2443         POP     DE                            ; Index supplied to DE
   0FC3 19            [11] 2444         ADD     HL,DE                         ; Add index to pointer
   0FC4 F1            [10] 2445         POP     AF                            ; Number of dimensions
   0FC5 3D            [ 4] 2446         DEC     A                             ; Count them
   0FC6 44            [ 4] 2447         LD      B,H                           ; MSB of pointer
   0FC7 4D            [ 4] 2448         LD      C,L                           ; LSB of pointer
   0FC8 C2 B1 0F      [10] 2449         JP      NZ,FNDELP                     ; More - Keep going
   0FCB 29            [11] 2450         ADD     HL,HL                         ; 4 Bytes per element
   0FCC 29            [11] 2451         ADD     HL,HL
   0FCD C1            [10] 2452         POP     BC                            ; Start of array
   0FCE 09            [11] 2453         ADD     HL,BC                         ; Point to element
   0FCF EB            [ 4] 2454         EX      DE,HL                         ; Address of element to DE
   0FD0 2A 15 81      [16] 2455 ENDDIM: LD      HL,(NXTOPR)                   ; Got code string address
   0FD3 C9            [10] 2456         RET
                           2457 ;
   0FD4 2A 1F 81      [16] 2458 FRE:    LD      HL,(ARREND)                   ; Start of free memory
   0FD7 EB            [ 4] 2459         EX      DE,HL                         ; To DE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 46
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   0FD8 21 00 00      [10] 2460         LD      HL,0                          ; End of free memory
   0FDB 39            [11] 2461         ADD     HL,SP                         ; Current stack value
   0FDC 3A F2 80      [13] 2462         LD      A,(TYPE)                      ; Dummy argument type
   0FDF B7            [ 4] 2463         OR      A
   0FE0 CA F0 0F      [10] 2464         JP      Z,FRENUM                      ; Numeric - Free variable space
   0FE3 CD 57 12      [17] 2465         CALL    GSTRCU                        ; Current string to pool
   0FE6 CD 57 11      [17] 2466         CALL    GARBGE                        ; Garbage collection
   0FE9 2A 9F 80      [16] 2467         LD      HL,(STRSPC)                   ; Bottom of string space in use
   0FEC EB            [ 4] 2468         EX      DE,HL                         ; To DE
   0FED 2A 08 81      [16] 2469         LD      HL,(STRBOT)                   ; Bottom of string space
   0FF0 7D            [ 4] 2470 FRENUM: LD      A,L                           ; Get LSB of end
   0FF1 93            [ 4] 2471         SUB     E                             ; Subtract LSB of beginning
   0FF2 4F            [ 4] 2472         LD      C,A                           ; Save difference if C
   0FF3 7C            [ 4] 2473         LD      A,H                           ; Get MSB of end
   0FF4 9A            [ 4] 2474         SBC     A,D                           ; Subtract MSB of beginning
   0FF5 41            [ 4] 2475 ACPASS: LD      B,C                           ; Return integer AC
   0FF6 50            [ 4] 2476 ABPASS: LD      D,B                           ; Return integer AB
   0FF7 1E 00         [ 7] 2477         LD      E,0
   0FF9 21 F2 80      [10] 2478         LD      HL,TYPE                       ; Point to type
   0FFC 73            [ 7] 2479         LD      (HL),E                        ; Set type to numeric
   0FFD 06 90         [ 7] 2480         LD      B,0x80+16                     ; 16 bit integer
   0FFF C3 34 16      [10] 2481         JP      RETINT                        ; Return the integr
                           2482 ;
   1002 3A F0 80      [13] 2483 POS:    LD      A,(CURPOS)                    ; Get cursor position
   1005 47            [ 4] 2484 PASSA:  LD      B,A                           ; Put A into AB
   1006 AF            [ 4] 2485         XOR     A                             ; Zero A
   1007 C3 F6 0F      [10] 2486         JP      ABPASS                        ; Return integer AB
                           2487 ;
   100A CD 8D 10      [17] 2488 DEF:    CALL    CHEKFN                        ; Get "FN" and name
   100D CD 7F 10      [17] 2489         CALL    IDTEST                        ; Test for illegal direct
   1010 01 65 09      [10] 2490         LD      BC,DATA                       ; To get next statement
   1013 C5            [11] 2491         PUSH    BC                            ; Save address for RETurn
   1014 D5            [11] 2492         PUSH    DE                            ; Save address of function ptr
   1015 CD 44 06      [17] 2493         CALL    CHKSYN                        ; Make sure "(" follows
   1018 28                 2494         .ascii  "("
   1019 CD 31 0E      [17] 2495         CALL    GETVAR                        ; Get argument variable name
   101C E5            [11] 2496         PUSH    HL                            ; Save code string address
   101D EB            [ 4] 2497         EX      DE,HL                         ; Argument address to HL
   101E 2B            [ 6] 2498         DEC     HL
   101F 56            [ 7] 2499         LD      D,(HL)                        ; Get first byte of arg name
   1020 2B            [ 6] 2500         DEC     HL
   1021 5E            [ 7] 2501         LD      E,(HL)                        ; Get second byte of arg name
   1022 E1            [10] 2502         POP     HL                            ; Restore code string address
   1023 CD 3E 0C      [17] 2503         CALL    TSTNUM                        ; Make sure numeric argument
   1026 CD 44 06      [17] 2504         CALL    CHKSYN                        ; Make sure ")" follows
   1029 29                 2505         .ascii  ")"
   102A CD 44 06      [17] 2506         CALL    CHKSYN                        ; Make sure "=" follows
   102D B4                 2507         .db     ZEQUAL                        ; "=" token
   102E 44            [ 4] 2508         LD      B,H                           ; Code string address to BC
   102F 4D            [ 4] 2509         LD      C,L
   1030 E3            [19] 2510         EX      (SP),HL                       ; Save code str , Get FN ptr
   1031 71            [ 7] 2511         LD      (HL),C                        ; Save LSB of FN code string
   1032 23            [ 6] 2512         INC     HL
   1033 70            [ 7] 2513         LD      (HL),B                        ; Save MSB of FN code string
   1034 C3 CC 10      [10] 2514         JP      SVSTAD                        ; Save address and do function
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 47
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                           2515 ;
   1037 CD 8D 10      [17] 2516 DOFN:   CALL    CHEKFN                        ; Make sure FN follows
   103A D5            [11] 2517         PUSH    DE                            ; Save function pointer address
   103B CD 12 0D      [17] 2518         CALL    EVLPAR                        ; Evaluate expression in "()"
   103E CD 3E 0C      [17] 2519         CALL    TSTNUM                        ; Make sure numeric result
   1041 E3            [19] 2520         EX      (SP),HL                       ; Save code str , Get FN ptr
   1042 5E            [ 7] 2521         LD      E,(HL)                        ; Get LSB of FN code string
   1043 23            [ 6] 2522         INC     HL
   1044 56            [ 7] 2523         LD      D,(HL)                        ; Get MSB of FN code string
   1045 23            [ 6] 2524         INC     HL
   1046 7A            [ 4] 2525         LD      A,D                           ; And function DEFined?
   1047 B3            [ 4] 2526         OR      E
   1048 CA 82 03      [10] 2527         JP      Z,UFERR                       ; No - ?UF Error
   104B 7E            [ 7] 2528         LD      A,(HL)                        ; Get LSB of argument address
   104C 23            [ 6] 2529         INC     HL
   104D 66            [ 7] 2530         LD      H,(HL)                        ; Get MSB of argument address
   104E 6F            [ 4] 2531         LD      L,A                           ; HL = Arg variable address
   104F E5            [11] 2532         PUSH    HL                            ; Save it
   1050 2A 23 81      [16] 2533         LD      HL,(FNRGNM)                   ; Get old argument name
   1053 E3            [19] 2534         EX      (SP),HL                       ;	; Save old , Get new
   1054 22 23 81      [16] 2535         LD      (FNRGNM),HL                   ; Set new argument name
   1057 2A 27 81      [16] 2536         LD      HL,(FNARG+2)                  ; Get LSB,NLSB of old arg value
   105A E5            [11] 2537         PUSH    HL                            ; Save it
   105B 2A 25 81      [16] 2538         LD      HL,(FNARG)                    ; Get MSB,EXP of old arg value
   105E E5            [11] 2539         PUSH    HL                            ; Save it
   105F 21 25 81      [10] 2540         LD      HL,FNARG                      ; HL = Value of argument
   1062 D5            [11] 2541         PUSH    DE                            ; Save FN code string address
   1063 CD 75 16      [17] 2542         CALL    FPTHL                         ; Move FPREG to argument
   1066 E1            [10] 2543         POP     HL                            ; Get FN code string address
   1067 CD 3B 0C      [17] 2544         CALL    GETNUM                        ; Get value from function
   106A 2B            [ 6] 2545         DEC     HL                            ; DEC 'cos GETCHR INCs
   106B CD CE 07      [17] 2546         CALL    GETCHR                        ; Get next character
   106E C2 76 03      [10] 2547         JP      NZ,SNERR                      ; Bad character in FN - Error
   1071 E1            [10] 2548         POP     HL                            ; Get MSB,EXP of old arg
   1072 22 25 81      [16] 2549         LD      (FNARG),HL                    ; Restore it
   1075 E1            [10] 2550         POP     HL                            ; Get LSB,NLSB of old arg
   1076 22 27 81      [16] 2551         LD      (FNARG+2),HL                  ; Restore it
   1079 E1            [10] 2552         POP     HL                            ; Get name of old arg
   107A 22 23 81      [16] 2553         LD      (FNRGNM),HL                   ; Restore it
   107D E1            [10] 2554         POP     HL                            ; Restore code string address
   107E C9            [10] 2555         RET
                           2556 ;
   107F E5            [11] 2557 IDTEST: PUSH    HL                            ; Save code string address
   1080 2A A1 80      [16] 2558         LD      HL,(LINEAT)                   ; Get current line number
   1083 23            [ 6] 2559         INC     HL                            ; -1 means direct statement
   1084 7C            [ 4] 2560         LD      A,H
   1085 B5            [ 4] 2561         OR      L
   1086 E1            [10] 2562         POP     HL                            ; Restore code string address
   1087 C0            [11] 2563         RET     NZ                            ; Return if in program
   1088 1E 16         [ 7] 2564         LD      E,ID                          ; ?ID Error
   108A C3 8A 03      [10] 2565         JP      ERROR
                           2566 ;
   108D CD 44 06      [17] 2567 CHEKFN: CALL    CHKSYN                        ; Make sure FN follows
   1090 A7                 2568         .db     ZFN                           ; "FN" token
   1091 3E 80         [ 7] 2569         LD      A,0x80
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 48
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1093 32 10 81      [13] 2570         LD      (FORFLG),A                    ; Flag FN name to find
   1096 B6            [ 7] 2571         OR      (HL)                          ; FN name has bit 7 set
   1097 47            [ 4] 2572         LD      B,A                           ; in first byte of name
   1098 CD 36 0E      [17] 2573         CALL    GTFNAM                        ; Get FN name
   109B C3 3E 0C      [10] 2574         JP      TSTNUM                        ; Make sure numeric function
                           2575 ;
   109E CD 3E 0C      [17] 2576 STR:    CALL    TSTNUM                        ; Make sure it's a number
   10A1 CD C2 17      [17] 2577         CALL    NUMASC                        ; Turn number into text
   10A4 CD D2 10      [17] 2578 STR1:   CALL    CRTST                         ; Create string entry for it
   10A7 CD 57 12      [17] 2579         CALL    GSTRCU                        ; Current string to pool
   10AA 01 B2 12      [10] 2580         LD      BC,TOPOOL                     ; Save in string pool
   10AD C5            [11] 2581         PUSH    BC                            ; Save address on stack
                           2582 ;
   10AE 7E            [ 7] 2583 SAVSTR: LD      A,(HL)                        ; Get string length
   10AF 23            [ 6] 2584         INC     HL
   10B0 23            [ 6] 2585         INC     HL
   10B1 E5            [11] 2586         PUSH    HL                            ; Save pointer to string
   10B2 CD 2D 11      [17] 2587         CALL    TESTR                         ; See if enough string space
   10B5 E1            [10] 2588         POP     HL                            ; Restore pointer to string
   10B6 4E            [ 7] 2589         LD      C,(HL)                        ; Get LSB of address
   10B7 23            [ 6] 2590         INC     HL
   10B8 46            [ 7] 2591         LD      B,(HL)                        ; Get MSB of address
   10B9 CD C6 10      [17] 2592         CALL    CRTMST                        ; Create string entry
   10BC E5            [11] 2593         PUSH    HL                            ; Save pointer to MSB of addr
   10BD 6F            [ 4] 2594         LD      L,A                           ; Length of string
   10BE CD 4A 12      [17] 2595         CALL    TOSTRA                        ; Move to string area
   10C1 D1            [10] 2596         POP     DE                            ; Restore pointer to MSB
   10C2 C9            [10] 2597         RET
                           2598 ;
   10C3 CD 2D 11      [17] 2599 MKTMST: CALL    TESTR                         ; See if enough string space
   10C6 21 04 81      [10] 2600 CRTMST: LD      HL,TMPSTR                     ; Temporary string
   10C9 E5            [11] 2601         PUSH    HL                            ; Save it
   10CA 77            [ 7] 2602         LD      (HL),A                        ; Save length of string
   10CB 23            [ 6] 2603         INC     HL
   10CC 23            [ 6] 2604 SVSTAD: INC     HL
   10CD 73            [ 7] 2605         LD      (HL),E                        ; Save LSB of address
   10CE 23            [ 6] 2606         INC     HL
   10CF 72            [ 7] 2607         LD      (HL),D                        ; Save MSB of address
   10D0 E1            [10] 2608         POP     HL                            ; Restore pointer
   10D1 C9            [10] 2609         RET
                           2610 ;
   10D2 2B            [ 6] 2611 CRTST:  DEC     HL                            ; DEC - INCed after
   10D3 06 22         [ 7] 2612 QTSTR:  LD      B,'"                          ; Terminating quote
   10D5 50            [ 4] 2613         LD      D,B                           ; Quote to D
   10D6 E5            [11] 2614 DTSTR:  PUSH    HL                            ; Save start
   10D7 0E FF         [ 7] 2615         LD      C,-1                          ; Set counter to -1
   10D9 23            [ 6] 2616 QTSTLP: INC     HL                            ; Move on
   10DA 7E            [ 7] 2617         LD      A,(HL)                        ; Get byte
   10DB 0C            [ 4] 2618         INC     C                             ; Count bytes
   10DC B7            [ 4] 2619         OR      A                             ; End of line?
   10DD CA E8 10      [10] 2620         JP      Z,CRTSTE                      ; Yes - Create string entry
   10E0 BA            [ 4] 2621         CP      D                             ; Terminator D found?
   10E1 CA E8 10      [10] 2622         JP      Z,CRTSTE                      ; Yes - Create string entry
   10E4 B8            [ 4] 2623         CP      B                             ; Terminator B found?
   10E5 C2 D9 10      [10] 2624         JP      NZ,QTSTLP                     ; No - Keep looking
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 49
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   10E8 FE 22         [ 7] 2625 CRTSTE: CP      '"                            ; End with '"'?
   10EA CC CE 07      [17] 2626         CALL    Z,GETCHR                      ; Yes - Get next character
   10ED E3            [19] 2627         EX      (SP),HL                       ; Starting quote
   10EE 23            [ 6] 2628         INC     HL                            ; First byte of string
   10EF EB            [ 4] 2629         EX      DE,HL                         ; To DE
   10F0 79            [ 4] 2630         LD      A,C                           ; Get length
   10F1 CD C6 10      [17] 2631         CALL    CRTMST                        ; Create string entry
   10F4 11 04 81      [10] 2632 TSTOPL: LD      DE,TMPSTR                     ; Temporary string
   10F7 2A F6 80      [16] 2633         LD      HL,(TMSTPT)                   ; Temporary string pool pointer
   10FA 22 29 81      [16] 2634         LD      (FPREG),HL                    ; Save address of string ptr
   10FD 3E 01         [ 7] 2635         LD      A,1
   10FF 32 F2 80      [13] 2636         LD      (TYPE),A                      ; Set type to string
   1102 CD 78 16      [17] 2637         CALL    DETHL4                        ; Move string to pool
   1105 CD 3E 06      [17] 2638         CALL    CPDEHL                        ; Out of string pool?
   1108 22 F6 80      [16] 2639         LD      (TMSTPT),HL                   ; Save new pointer
   110B E1            [10] 2640         POP     HL                            ; Restore code string address
   110C 7E            [ 7] 2641         LD      A,(HL)                        ; Get next code byte
   110D C0            [11] 2642         RET     NZ                            ; Return if pool OK
   110E 1E 1E         [ 7] 2643         LD      E,ST                          ; ?ST Error
   1110 C3 8A 03      [10] 2644         JP      ERROR                         ; String pool overflow
                           2645 ;
   1113 23            [ 6] 2646 PRNUMS: INC     HL                            ; Skip leading space
   1114 CD D2 10      [17] 2647 PRS:    CALL    CRTST                         ; Create string entry for it
   1117 CD 57 12      [17] 2648 PRS1:   CALL    GSTRCU                        ; Current string to pool
   111A CD 6C 16      [17] 2649         CALL    LOADFP                        ; Move string block to BCDE
   111D 1C            [ 4] 2650         INC     E                             ; Length + 1
   111E 1D            [ 4] 2651 PRSLP:  DEC     E                             ; Count characters
   111F C8            [11] 2652         RET     Z                             ; End of string
   1120 0A            [ 7] 2653         LD      A,(BC)                        ; Get byte to output
   1121 CD 4F 06      [17] 2654         CALL    OUTC                          ; Output character in A
   1124 FE 0D         [ 7] 2655         CP      CR                            ; Return?
   1126 CC 80 0A      [17] 2656         CALL    Z,DONULL                      ; Yes - Do nulls
   1129 03            [ 6] 2657         INC     BC                            ; Next byte in string
   112A C3 1E 11      [10] 2658         JP      PRSLP                         ; More characters to output
                           2659 ;
   112D B7            [ 4] 2660 TESTR:  OR      A                             ; Test if enough room
   112E 0E                 2661         .db     0x0E                          ; No garbage collection done
   112F F1            [10] 2662 GRBDON: POP     AF                            ; Garbage collection done
   1130 F5            [11] 2663         PUSH    AF                            ; Save status
   1131 2A 9F 80      [16] 2664         LD      HL,(STRSPC)                   ; Bottom of string space in use
   1134 EB            [ 4] 2665         EX      DE,HL                         ; To DE
   1135 2A 08 81      [16] 2666         LD      HL,(STRBOT)                   ; Bottom of string area
   1138 2F            [ 4] 2667         CPL                                   ; Negate length (Top down)
   1139 4F            [ 4] 2668         LD      C,A                           ; -Length to BC
   113A 06 FF         [ 7] 2669         LD      B,-1                          ; BC = -ve length of string
   113C 09            [11] 2670         ADD     HL,BC                         ; Add to bottom of space in use
   113D 23            [ 6] 2671         INC     HL                            ; Plus one for 2's complement
   113E CD 3E 06      [17] 2672         CALL    CPDEHL                        ; Below string RAM area?
   1141 DA 4B 11      [10] 2673         JP      C,TESTOS                      ; Tidy up if not done else err
   1144 22 08 81      [16] 2674         LD      (STRBOT),HL                   ; Save new bottom of area
   1147 23            [ 6] 2675         INC     HL                            ; Point to first byte of string
   1148 EB            [ 4] 2676         EX      DE,HL                         ; Address to DE
   1149 F1            [10] 2677 POPAF:  POP     AF                            ; Throw away status push
   114A C9            [10] 2678         RET
                           2679 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 50
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   114B F1            [10] 2680 TESTOS: POP     AF                            ; Garbage collect been done?
   114C 1E 1A         [ 7] 2681         LD      E,OS                          ; ?OS Error
   114E CA 8A 03      [10] 2682         JP      Z,ERROR                       ; Yes - Not enough string apace
   1151 BF            [ 4] 2683         CP      A                             ; Flag garbage collect done
   1152 F5            [11] 2684         PUSH    AF                            ; Save status
   1153 01 2F 11      [10] 2685         LD      BC,GRBDON                     ; Garbage collection done
   1156 C5            [11] 2686         PUSH    BC                            ; Save for RETurn
   1157 2A F4 80      [16] 2687 GARBGE: LD      HL,(LSTRAM)                   ; Get end of RAM pointer
   115A 22 08 81      [16] 2688 GARBLP: LD      (STRBOT),HL                   ; Reset string pointer
   115D 21 00 00      [10] 2689         LD      HL,0
   1160 E5            [11] 2690         PUSH    HL                            ; Flag no string found
   1161 2A 9F 80      [16] 2691         LD      HL,(STRSPC)                   ; Get bottom of string space
   1164 E5            [11] 2692         PUSH    HL                            ; Save bottom of string space
   1165 21 F8 80      [10] 2693         LD      HL,TMSTPL                     ; Temporary string pool
   1168 EB            [ 4] 2694 GRBLP:  EX      DE,HL
   1169 2A F6 80      [16] 2695         LD      HL,(TMSTPT)                   ; Temporary string pool pointer
   116C EB            [ 4] 2696         EX      DE,HL
   116D CD 3E 06      [17] 2697         CALL    CPDEHL                        ; Temporary string pool done?
   1170 01 68 11      [10] 2698         LD      BC,GRBLP                      ; Loop until string pool done
   1173 C2 BC 11      [10] 2699         JP      NZ,STPOOL                     ; No - See if in string area
   1176 2A 1B 81      [16] 2700         LD      HL,(PROGND)                   ; Start of simple variables
   1179 EB            [ 4] 2701 SMPVAR: EX      DE,HL
   117A 2A 1D 81      [16] 2702         LD      HL,(VAREND)                   ; End of simple variables
   117D EB            [ 4] 2703         EX      DE,HL
   117E CD 3E 06      [17] 2704         CALL    CPDEHL                        ; All simple strings done?
   1181 CA 8F 11      [10] 2705         JP      Z,ARRLP                       ; Yes - Do string arrays
   1184 7E            [ 7] 2706         LD      A,(HL)                        ; Get type of variable
   1185 23            [ 6] 2707         INC     HL
   1186 23            [ 6] 2708         INC     HL
   1187 B7            [ 4] 2709         OR      A                             ; "S" flag set if string
   1188 CD BF 11      [17] 2710         CALL    STRADD                        ; See if string in string area
   118B C3 79 11      [10] 2711         JP      SMPVAR                        ; Loop until simple ones done
                           2712 ;
   118E C1            [10] 2713 GNXARY: POP     BC                            ; Scrap address of this array
   118F EB            [ 4] 2714 ARRLP:  EX      DE,HL
   1190 2A 1F 81      [16] 2715         LD      HL,(ARREND)                   ; End of string arrays
   1193 EB            [ 4] 2716         EX      DE,HL
   1194 CD 3E 06      [17] 2717         CALL    CPDEHL                        ; All string arrays done?
   1197 CA E5 11      [10] 2718         JP      Z,SCNEND                      ; Yes - Move string if found
   119A CD 6C 16      [17] 2719         CALL    LOADFP                        ; Get array name to BCDE
   119D 7B            [ 4] 2720         LD      A,E                           ; Get type of array
   119E E5            [11] 2721         PUSH    HL                            ; Save address of num of dim'ns
   119F 09            [11] 2722         ADD     HL,BC                         ; Start of next array
   11A0 B7            [ 4] 2723         OR      A                             ; Test type of array
   11A1 F2 8E 11      [10] 2724         JP      P,GNXARY                      ; Numeric array - Ignore it
   11A4 22 0A 81      [16] 2725         LD      (CUROPR),HL                   ; Save address of next array
   11A7 E1            [10] 2726         POP     HL                            ; Get address of num of dim'ns
   11A8 4E            [ 7] 2727         LD      C,(HL)                        ; BC = Number of dimensions
   11A9 06 00         [ 7] 2728         LD      B,0
   11AB 09            [11] 2729         ADD     HL,BC                         ; Two bytes per dimension size
   11AC 09            [11] 2730         ADD     HL,BC
   11AD 23            [ 6] 2731         INC     HL                            ; Plus one for number of dim'ns
   11AE EB            [ 4] 2732 GRBARY: EX      DE,HL
   11AF 2A 0A 81      [16] 2733         LD      HL,(CUROPR)                   ; Get address of next array
   11B2 EB            [ 4] 2734         EX      DE,HL
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 51
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   11B3 CD 3E 06      [17] 2735         CALL    CPDEHL                        ; Is this array finished?
   11B6 CA 8F 11      [10] 2736         JP      Z,ARRLP                       ; Yes - Get next one
   11B9 01 AE 11      [10] 2737         LD      BC,GRBARY                     ; Loop until array all done
   11BC C5            [11] 2738 STPOOL: PUSH    BC                            ; Save return address
   11BD F6 80         [ 7] 2739         OR      0x80                          ; Flag string type
   11BF 7E            [ 7] 2740 STRADD: LD      A,(HL)                        ; Get string length
   11C0 23            [ 6] 2741         INC     HL
   11C1 23            [ 6] 2742         INC     HL
   11C2 5E            [ 7] 2743         LD      E,(HL)                        ; Get LSB of string address
   11C3 23            [ 6] 2744         INC     HL
   11C4 56            [ 7] 2745         LD      D,(HL)                        ; Get MSB of string address
   11C5 23            [ 6] 2746         INC     HL
   11C6 F0            [11] 2747         RET     P                             ; Not a string - Return
   11C7 B7            [ 4] 2748         OR      A                             ; Set flags on string length
   11C8 C8            [11] 2749         RET     Z                             ; Null string - Return
   11C9 44            [ 4] 2750         LD      B,H                           ; Save variable pointer
   11CA 4D            [ 4] 2751         LD      C,L
   11CB 2A 08 81      [16] 2752         LD      HL,(STRBOT)                   ; Bottom of new area
   11CE CD 3E 06      [17] 2753         CALL    CPDEHL                        ; String been done?
   11D1 60            [ 4] 2754         LD      H,B                           ; Restore variable pointer
   11D2 69            [ 4] 2755         LD      L,C
   11D3 D8            [11] 2756         RET     C                             ; String done - Ignore
   11D4 E1            [10] 2757         POP     HL                            ; Return address
   11D5 E3            [19] 2758         EX      (SP),HL                       ; Lowest available string area
   11D6 CD 3E 06      [17] 2759         CALL    CPDEHL                        ; String within string area?
   11D9 E3            [19] 2760         EX      (SP),HL                       ; Lowest available string area
   11DA E5            [11] 2761         PUSH    HL                            ; Re-save return address
   11DB 60            [ 4] 2762         LD      H,B                           ; Restore variable pointer
   11DC 69            [ 4] 2763         LD      L,C
   11DD D0            [11] 2764         RET     NC                            ; Outside string area - Ignore
   11DE C1            [10] 2765         POP     BC                            ; Get return , Throw 2 away
   11DF F1            [10] 2766         POP     AF                            ;
   11E0 F1            [10] 2767         POP     AF                            ;
   11E1 E5            [11] 2768         PUSH    HL                            ; Save variable pointer
   11E2 D5            [11] 2769         PUSH    DE                            ; Save address of current
   11E3 C5            [11] 2770         PUSH    BC                            ; Put back return address
   11E4 C9            [10] 2771         RET                                   ; Go to it
                           2772 ;
   11E5 D1            [10] 2773 SCNEND: POP     DE                            ; Addresses of strings
   11E6 E1            [10] 2774         POP     HL                            ;
   11E7 7D            [ 4] 2775         LD      A,L                           ; HL = 0 if no more to do
   11E8 B4            [ 4] 2776         OR      H
   11E9 C8            [11] 2777         RET     Z                             ; No more to do - Return
   11EA 2B            [ 6] 2778         DEC     HL
   11EB 46            [ 7] 2779         LD      B,(HL)                        ; MSB of address of string
   11EC 2B            [ 6] 2780         DEC     HL
   11ED 4E            [ 7] 2781         LD      C,(HL)                        ; LSB of address of string
   11EE E5            [11] 2782         PUSH    HL                            ; Save variable address
   11EF 2B            [ 6] 2783         DEC     HL
   11F0 2B            [ 6] 2784         DEC     HL
   11F1 6E            [ 7] 2785         LD      L,(HL)                        ; HL = Length of string
   11F2 26 00         [ 7] 2786         LD      H,0
   11F4 09            [11] 2787         ADD     HL,BC                         ; Address of end of string+1
   11F5 50            [ 4] 2788         LD      D,B                           ; String address to DE
   11F6 59            [ 4] 2789         LD      E,C
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 52
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   11F7 2B            [ 6] 2790         DEC     HL                            ; Last byte in string
   11F8 44            [ 4] 2791         LD      B,H                           ; Address to BC
   11F9 4D            [ 4] 2792         LD      C,L
   11FA 2A 08 81      [16] 2793         LD      HL,(STRBOT)                   ; Current bottom of string area
   11FD CD 45 03      [17] 2794         CALL    MOVSTR                        ; Move string to new address
   1200 E1            [10] 2795         POP     HL                            ; Restore variable address
   1201 71            [ 7] 2796         LD      (HL),C                        ; Save new LSB of address
   1202 23            [ 6] 2797         INC     HL
   1203 70            [ 7] 2798         LD      (HL),B                        ; Save new MSB of address
   1204 69            [ 4] 2799         LD      L,C                           ; Next string area+1 to HL
   1205 60            [ 4] 2800         LD      H,B
   1206 2B            [ 6] 2801         DEC     HL                            ; Next string area address
   1207 C3 5A 11      [10] 2802         JP      GARBLP                        ; Look for more strings
                           2803 ;
   120A C5            [11] 2804 CONCAT: PUSH    BC                            ; Save prec' opr & code string
   120B E5            [11] 2805         PUSH    HL                            ;
   120C 2A 29 81      [16] 2806         LD      HL,(FPREG)                    ; Get first string
   120F E3            [19] 2807         EX      (SP),HL                       ; Save first string
   1210 CD C4 0C      [17] 2808         CALL    OPRND                         ; Get second string
   1213 E3            [19] 2809         EX      (SP),HL                       ; Restore first string
   1214 CD 3F 0C      [17] 2810         CALL    TSTSTR                        ; Make sure it's a string
   1217 7E            [ 7] 2811         LD      A,(HL)                        ; Get length of second string
   1218 E5            [11] 2812         PUSH    HL                            ; Save first string
   1219 2A 29 81      [16] 2813         LD      HL,(FPREG)                    ; Get second string
   121C E5            [11] 2814         PUSH    HL                            ; Save second string
   121D 86            [ 7] 2815         ADD     A,(HL)                        ; Add length of second string
   121E 1E 1C         [ 7] 2816         LD      E,LS                          ; ?LS Error
   1220 DA 8A 03      [10] 2817         JP      C,ERROR                       ; String too long - Error
   1223 CD C3 10      [17] 2818         CALL    MKTMST                        ; Make temporary string
   1226 D1            [10] 2819         POP     DE                            ; Get second string to DE
   1227 CD 5B 12      [17] 2820         CALL    GSTRDE                        ; Move to string pool if needed
   122A E3            [19] 2821         EX      (SP),HL                       ; Get first string
   122B CD 5A 12      [17] 2822         CALL    GSTRHL                        ; Move to string pool if needed
   122E E5            [11] 2823         PUSH    HL                            ; Save first string
   122F 2A 06 81      [16] 2824         LD      HL,(TMPSTR+2)                 ; Temporary string address
   1232 EB            [ 4] 2825         EX      DE,HL                         ; To DE
   1233 CD 41 12      [17] 2826         CALL    SSTSA                         ; First string to string area
   1236 CD 41 12      [17] 2827         CALL    SSTSA                         ; Second string to string area
   1239 21 59 0C      [10] 2828         LD      HL,EVAL2                      ; Return to evaluation loop
   123C E3            [19] 2829         EX      (SP),HL                       ; Save return,get code string
   123D E5            [11] 2830         PUSH    HL                            ; Save code string address
   123E C3 F4 10      [10] 2831         JP      TSTOPL                        ; To temporary string to pool
                           2832 ;
   1241 E1            [10] 2833 SSTSA:  POP     HL                            ; Return address
   1242 E3            [19] 2834         EX      (SP),HL                       ; Get string block,save return
   1243 7E            [ 7] 2835         LD      A,(HL)                        ; Get length of string
   1244 23            [ 6] 2836         INC     HL
   1245 23            [ 6] 2837         INC     HL
   1246 4E            [ 7] 2838         LD      C,(HL)                        ; Get LSB of string address
   1247 23            [ 6] 2839         INC     HL
   1248 46            [ 7] 2840         LD      B,(HL)                        ; Get MSB of string address
   1249 6F            [ 4] 2841         LD      L,A                           ; Length to L
   124A 2C            [ 4] 2842 TOSTRA: INC     L                             ; INC - DECed after
   124B 2D            [ 4] 2843 TSALP:  DEC     L                             ; Count bytes moved
   124C C8            [11] 2844         RET     Z                             ; End of string - Return
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 53
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   124D 0A            [ 7] 2845         LD      A,(BC)                        ; Get source
   124E 12            [ 7] 2846         LD      (DE),A                        ; Save destination
   124F 03            [ 6] 2847         INC     BC                            ; Next source
   1250 13            [ 6] 2848         INC     DE                            ; Next destination
   1251 C3 4B 12      [10] 2849         JP      TSALP                         ; Loop until string moved
                           2850 ;
   1254 CD 3F 0C      [17] 2851 GETSTR: CALL    TSTSTR                        ; Make sure it's a string
   1257 2A 29 81      [16] 2852 GSTRCU: LD      HL,(FPREG)                    ; Get current string
   125A EB            [ 4] 2853 GSTRHL: EX      DE,HL                         ; Save DE
   125B CD 75 12      [17] 2854 GSTRDE: CALL    BAKTMP                        ; Was it last tmp-str?
   125E EB            [ 4] 2855         EX      DE,HL                         ; Restore DE
   125F C0            [11] 2856         RET     NZ                            ; No - Return
   1260 D5            [11] 2857         PUSH    DE                            ; Save string
   1261 50            [ 4] 2858         LD      D,B                           ; String block address to DE
   1262 59            [ 4] 2859         LD      E,C
   1263 1B            [ 6] 2860         DEC     DE                            ; Point to length
   1264 4E            [ 7] 2861         LD      C,(HL)                        ; Get string length
   1265 2A 08 81      [16] 2862         LD      HL,(STRBOT)                   ; Current bottom of string area
   1268 CD 3E 06      [17] 2863         CALL    CPDEHL                        ; Last one in string area?
   126B C2 73 12      [10] 2864         JP      NZ,POPHL                      ; No - Return
   126E 47            [ 4] 2865         LD      B,A                           ; Clear B (A=0)
   126F 09            [11] 2866         ADD     HL,BC                         ; Remove string from str' area
   1270 22 08 81      [16] 2867         LD      (STRBOT),HL                   ; Save new bottom of str' area
   1273 E1            [10] 2868 POPHL:  POP     HL                            ; Restore string
   1274 C9            [10] 2869         RET
                           2870 ;
   1275 2A F6 80      [16] 2871 BAKTMP: LD      HL,(TMSTPT)                   ; Get temporary string pool top
   1278 2B            [ 6] 2872         DEC     HL                            ; Back
   1279 46            [ 7] 2873         LD      B,(HL)                        ; Get MSB of address
   127A 2B            [ 6] 2874         DEC     HL                            ; Back
   127B 4E            [ 7] 2875         LD      C,(HL)                        ; Get LSB of address
   127C 2B            [ 6] 2876         DEC     HL                            ; Back
   127D 2B            [ 6] 2877         DEC     HL                            ; Back
   127E CD 3E 06      [17] 2878         CALL    CPDEHL                        ; String last in string pool?
   1281 C0            [11] 2879         RET     NZ                            ; Yes - Leave it
   1282 22 F6 80      [16] 2880         LD      (TMSTPT),HL                   ; Save new string pool top
   1285 C9            [10] 2881         RET
                           2882 ;
   1286 01 05 10      [10] 2883 LEN:    LD      BC,PASSA                      ; To return integer A
   1289 C5            [11] 2884         PUSH    BC                            ; Save address
   128A CD 54 12      [17] 2885 GETLEN: CALL    GETSTR                        ; Get string and its length
   128D AF            [ 4] 2886         XOR     A
   128E 57            [ 4] 2887         LD      D,A                           ; Clear D
   128F 32 F2 80      [13] 2888         LD      (TYPE),A                      ; Set type to numeric
   1292 7E            [ 7] 2889         LD      A,(HL)                        ; Get length of string
   1293 B7            [ 4] 2890         OR      A                             ; Set status flags
   1294 C9            [10] 2891         RET
                           2892 ;
   1295 01 05 10      [10] 2893 ASC:    LD      BC,PASSA                      ; To return integer A
   1298 C5            [11] 2894         PUSH    BC                            ; Save address
   1299 CD 8A 12      [17] 2895 GTFLNM: CALL    GETLEN                        ; Get length of string
   129C CA 95 08      [10] 2896         JP      Z,FCERR                       ; Null string - Error
   129F 23            [ 6] 2897         INC     HL
   12A0 23            [ 6] 2898         INC     HL
   12A1 5E            [ 7] 2899         LD      E,(HL)                        ; Get LSB of address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 54
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   12A2 23            [ 6] 2900         INC     HL
   12A3 56            [ 7] 2901         LD      D,(HL)                        ; Get MSB of address
   12A4 1A            [ 7] 2902         LD      A,(DE)                        ; Get first byte of string
   12A5 C9            [10] 2903         RET
                           2904 ;
   12A6 3E 01         [ 7] 2905 CHR:    LD      A,1                           ; One character string
   12A8 CD C3 10      [17] 2906         CALL    MKTMST                        ; Make a temporary string
   12AB CD 9F 13      [17] 2907         CALL    MAKINT                        ; Make it integer A
   12AE 2A 06 81      [16] 2908         LD      HL,(TMPSTR+2)                 ; Get address of string
   12B1 73            [ 7] 2909         LD      (HL),E                        ; Save character
   12B2 C1            [10] 2910 TOPOOL: POP     BC                            ; Clean up stack
   12B3 C3 F4 10      [10] 2911         JP      TSTOPL                        ; Temporary string to pool
                           2912 ;
   12B6 CD 4F 13      [17] 2913 LEFT:   CALL    LFRGNM                        ; Get number and ending ")"
   12B9 AF            [ 4] 2914         XOR     A                             ; Start at first byte in string
   12BA E3            [19] 2915 RIGHT1: EX      (SP),HL                       ; Save code string,Get string
   12BB 4F            [ 4] 2916         LD      C,A                           ; Starting position in string
   12BC E5            [11] 2917 MID1:   PUSH    HL                            ; Save string block address
   12BD 7E            [ 7] 2918         LD      A,(HL)                        ; Get length of string
   12BE B8            [ 4] 2919         CP      B                             ; Compare with number given
   12BF DA C4 12      [10] 2920         JP      C,ALLFOL                      ; All following bytes required
   12C2 78            [ 4] 2921         LD      A,B                           ; Get new length
   12C3 11                 2922         .db     0x11                          ; Skip "LD C,0"
   12C4 0E 00         [ 7] 2923 ALLFOL: LD      C,0                           ; First byte of string
   12C6 C5            [11] 2924         PUSH    BC                            ; Save position in string
   12C7 CD 2D 11      [17] 2925         CALL    TESTR                         ; See if enough string space
   12CA C1            [10] 2926         POP     BC                            ; Get position in string
   12CB E1            [10] 2927         POP     HL                            ; Restore string block address
   12CC E5            [11] 2928         PUSH    HL                            ; And re-save it
   12CD 23            [ 6] 2929         INC     HL
   12CE 23            [ 6] 2930         INC     HL
   12CF 46            [ 7] 2931         LD      B,(HL)                        ; Get LSB of address
   12D0 23            [ 6] 2932         INC     HL
   12D1 66            [ 7] 2933         LD      H,(HL)                        ; Get MSB of address
   12D2 68            [ 4] 2934         LD      L,B                           ; HL = address of string
   12D3 06 00         [ 7] 2935         LD      B,0                           ; BC = starting address
   12D5 09            [11] 2936         ADD     HL,BC                         ; Point to that byte
   12D6 44            [ 4] 2937         LD      B,H                           ; BC = source string
   12D7 4D            [ 4] 2938         LD      C,L
   12D8 CD C6 10      [17] 2939         CALL    CRTMST                        ; Create a string entry
   12DB 6F            [ 4] 2940         LD      L,A                           ; Length of new string
   12DC CD 4A 12      [17] 2941         CALL    TOSTRA                        ; Move string to string area
   12DF D1            [10] 2942         POP     DE                            ; Clear stack
   12E0 CD 5B 12      [17] 2943         CALL    GSTRDE                        ; Move to string pool if needed
   12E3 C3 F4 10      [10] 2944         JP      TSTOPL                        ; Temporary string to pool
                           2945 ;
   12E6 CD 4F 13      [17] 2946 RIGHT:  CALL    LFRGNM                        ; Get number and ending ")"
   12E9 D1            [10] 2947         POP     DE                            ; Get string length
   12EA D5            [11] 2948         PUSH    DE                            ; And re-save
   12EB 1A            [ 7] 2949         LD      A,(DE)                        ; Get length
   12EC 90            [ 4] 2950         SUB     B                             ; Move back N bytes
   12ED C3 BA 12      [10] 2951         JP      RIGHT1                        ; Go and get sub-string
                           2952 ;
   12F0 EB            [ 4] 2953 MID:    EX      DE,HL                         ; Get code string address
   12F1 7E            [ 7] 2954         LD      A,(HL)                        ; Get next byte ', or ")"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 55
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   12F2 CD 54 13      [17] 2955         CALL    MIDNUM                        ; Get number supplied
   12F5 04            [ 4] 2956         INC     B                             ; Is it character zero?
   12F6 05            [ 4] 2957         DEC     B
   12F7 CA 95 08      [10] 2958         JP      Z,FCERR                       ; Yes - Error
   12FA C5            [11] 2959         PUSH    BC                            ; Save starting position
   12FB 1E FF         [ 7] 2960         LD      E,255                         ; All of string
   12FD FE 29         [ 7] 2961         CP      ')                            ; Any length given?
   12FF CA 09 13      [10] 2962         JP      Z,RSTSTR                      ; No - Rest of string
   1302 CD 44 06      [17] 2963         CALL    CHKSYN                        ; Make sure ', follows
   1305 2C                 2964         .db     ',
   1306 CD 9C 13      [17] 2965         CALL    GETINT                        ; Get integer 0-255
   1309 CD 44 06      [17] 2966 RSTSTR: CALL    CHKSYN                        ; Make sure ")" follows
   130C 29                 2967         .ascii  ")"
   130D F1            [10] 2968         POP     AF                            ; Restore starting position
   130E E3            [19] 2969         EX      (SP),HL                       ; Get string,8ave code string
   130F 01 BC 12      [10] 2970         LD      BC,MID1                       ; Continuation of MID$ routine
   1312 C5            [11] 2971         PUSH    BC                            ; Save for return
   1313 3D            [ 4] 2972         DEC     A                             ; Starting position-1
   1314 BE            [ 7] 2973         CP      (HL)                          ; Compare with length
   1315 06 00         [ 7] 2974         LD      B,0                           ; Zero bytes length
   1317 D0            [11] 2975         RET     NC                            ; Null string if start past end
   1318 4F            [ 4] 2976         LD      C,A                           ; Save starting position-1
   1319 7E            [ 7] 2977         LD      A,(HL)                        ; Get length of string
   131A 91            [ 4] 2978         SUB     C                             ; Subtract start
   131B BB            [ 4] 2979         CP      E                             ; Enough string for it?
   131C 47            [ 4] 2980         LD      B,A                           ; Save maximum length available
   131D D8            [11] 2981         RET     C                             ; Truncate string if needed
   131E 43            [ 4] 2982         LD      B,E                           ; Set specified length
   131F C9            [10] 2983         RET                                   ; Go and create string
                           2984 ;
   1320 CD 8A 12      [17] 2985 VAL:    CALL    GETLEN                        ; Get length of string
   1323 CA 3D 14      [10] 2986         JP      Z,RESZER                      ; Result zero
   1326 5F            [ 4] 2987         LD      E,A                           ; Save length
   1327 23            [ 6] 2988         INC     HL
   1328 23            [ 6] 2989         INC     HL
   1329 7E            [ 7] 2990         LD      A,(HL)                        ; Get LSB of address
   132A 23            [ 6] 2991         INC     HL
   132B 66            [ 7] 2992         LD      H,(HL)                        ; Get MSB of address
   132C 6F            [ 4] 2993         LD      L,A                           ; HL = String address
   132D E5            [11] 2994         PUSH    HL                            ; Save string address
   132E 19            [11] 2995         ADD     HL,DE
   132F 46            [ 7] 2996         LD      B,(HL)                        ; Get end of string+1 byte
   1330 72            [ 7] 2997         LD      (HL),D                        ; Zero it to terminate
   1331 E3            [19] 2998         EX      (SP),HL                       ; Save string end,get start
   1332 C5            [11] 2999         PUSH    BC                            ; Save end+1 byte
   1333 7E            [ 7] 3000         LD      A,(HL)                        ; Get starting byte
   1334 FE 24         [ 7] 3001         CP      '$                            ; Hex number indicated? [function added]
   1336 C2 3E 13      [10] 3002         JP      NZ,VAL1
   1339 CD 68 1B      [17] 3003         CALL    HEXTFP                        ; Convert Hex to FPREG
   133C 18 0D         [12] 3004         JR      VAL3
   133E FE 25         [ 7] 3005 VAL1:   CP      '%                            ; Binary number indicated? [function added]
   1340 C2 48 13      [10] 3006         JP      NZ,VAL2
   1343 CD D8 1B      [17] 3007         CALL    BINTFP                        ; Convert Bin to FPREG
   1346 18 03         [12] 3008         JR      VAL3
   1348 CD 24 17      [17] 3009 VAL2:   CALL    ASCTFP                        ; Convert ASCII string to FP
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 56
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   134B C1            [10] 3010 VAL3:   POP     BC                            ; Restore end+1 byte
   134C E1            [10] 3011         POP     HL                            ; Restore end+1 address
   134D 70            [ 7] 3012         LD      (HL),B                        ; Put back original byte
   134E C9            [10] 3013         RET
                           3014 ;
   134F EB            [ 4] 3015 LFRGNM: EX      DE,HL                         ; Code string address to HL
   1350 CD 44 06      [17] 3016         CALL    CHKSYN                        ; Make sure ")" follows
   1353 29                 3017         .ascii  ")"
   1354 C1            [10] 3018 MIDNUM: POP     BC                            ; Get return address
   1355 D1            [10] 3019         POP     DE                            ; Get number supplied
   1356 C5            [11] 3020         PUSH    BC                            ; Re-save return address
   1357 43            [ 4] 3021         LD      B,E                           ; Number to B
   1358 C9            [10] 3022         RET
                           3023 ;
   1359 CD 9F 13      [17] 3024 INP:    CALL    MAKINT                        ; Make it integer A
   135C 32 84 80      [13] 3025         LD      (INPORT),A                    ; Set input port
   135F CD 83 80      [17] 3026         CALL    INPSUB                        ; Get input from port
   1362 C3 05 10      [10] 3027         JP      PASSA                         ; Return integer A
                           3028 ;
   1365 CD 89 13      [17] 3029 POUT:   CALL    SETIO                         ; Set up port number
   1368 C3 4B 80      [10] 3030         JP      OUTSUB                        ; Output data and return
                           3031 ;
   136B CD 89 13      [17] 3032 WAIT:   CALL    SETIO                         ; Set up port number
   136E F5            [11] 3033         PUSH    AF                            ; Save AND mask
   136F 1E 00         [ 7] 3034         LD      E,0                           ; Assume zero if none given
   1371 2B            [ 6] 3035         DEC     HL                            ; DEC 'cos GETCHR INCs
   1372 CD CE 07      [17] 3036         CALL    GETCHR                        ; Get next character
   1375 CA 7F 13      [10] 3037         JP      Z,NOXOR                       ; No XOR byte given
   1378 CD 44 06      [17] 3038         CALL    CHKSYN                        ; Make sure ', follows
   137B 2C                 3039         .db     ',
   137C CD 9C 13      [17] 3040         CALL    GETINT                        ; Get integer 0-255 to XOR with
   137F C1            [10] 3041 NOXOR:  POP     BC                            ; Restore AND mask
   1380 CD 83 80      [17] 3042 WAITLP: CALL    INPSUB                        ; Get input
   1383 AB            [ 4] 3043         XOR     E                             ; Flip selected bits
   1384 A0            [ 4] 3044         AND     B                             ; Result non-zero?
   1385 CA 80 13      [10] 3045         JP      Z,WAITLP                      ; No = keep waiting
   1388 C9            [10] 3046         RET
                           3047 ;
   1389 CD 9C 13      [17] 3048 SETIO:  CALL    GETINT                        ; Get integer 0-255
   138C 32 84 80      [13] 3049         LD      (INPORT),A                    ; Set input port
   138F 32 4C 80      [13] 3050         LD      (OTPORT),A                    ; Set output port
   1392 CD 44 06      [17] 3051         CALL    CHKSYN                        ; Make sure ', follows
   1395 2C                 3052         .db     ',
   1396 C3 9C 13      [10] 3053         JP      GETINT                        ; Get integer 0-255 and return
                           3054 ;
   1399 CD CE 07      [17] 3055 FNDNUM: CALL    GETCHR                        ; Get next character
   139C CD 3B 0C      [17] 3056 GETINT: CALL    GETNUM                        ; Get a number from 0 to 255
   139F CD 7A 08      [17] 3057 MAKINT: CALL    DEPINT                        ; Make sure value 0 - 255
   13A2 7A            [ 4] 3058         LD      A,D                           ; Get MSB of number
   13A3 B7            [ 4] 3059         OR      A                             ; Zero?
   13A4 C2 95 08      [10] 3060         JP      NZ,FCERR                      ; No - Error
   13A7 2B            [ 6] 3061         DEC     HL                            ; DEC 'cos GETCHR INCs
   13A8 CD CE 07      [17] 3062         CALL    GETCHR                        ; Get next character
   13AB 7B            [ 4] 3063         LD      A,E                           ; Get number to A
   13AC C9            [10] 3064         RET
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 57
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



                           3065 ;
   13AD CD 80 08      [17] 3066 PEEK:   CALL    DEINT                         ; Get memory address
   13B0 1A            [ 7] 3067         LD      A,(DE)                        ; Get byte in memory
   13B1 C3 05 10      [10] 3068         JP      PASSA                         ; Return integer A
                           3069 ;
   13B4 CD 3B 0C      [17] 3070 POKE:   CALL    GETNUM                        ; Get memory address
   13B7 CD 80 08      [17] 3071         CALL    DEINT                         ; Get integer -32768 to 3276
   13BA D5            [11] 3072         PUSH    DE                            ; Save memory address
   13BB CD 44 06      [17] 3073         CALL    CHKSYN                        ; Make sure ', follows
   13BE 2C                 3074         .db     ',
   13BF CD 9C 13      [17] 3075         CALL    GETINT                        ; Get integer 0-255
   13C2 D1            [10] 3076         POP     DE                            ; Restore memory address
   13C3 12            [ 7] 3077         LD      (DE),A                        ; Load it into memory
   13C4 C9            [10] 3078         RET
                           3079 ;
   13C5 21 9B 18      [10] 3080 ROUND:  LD      HL,HALF                       ; Add 0.5 to FPREG
   13C8 CD 6C 16      [17] 3081 ADDPHL: CALL    LOADFP                        ; Load FP at (HL) to BCDE
   13CB C3 D7 13      [10] 3082         JP      FPADD                         ; Add BCDE to FPREG
                           3083 ;
   13CE CD 6C 16      [17] 3084 SUBPHL: CALL    LOADFP                        ; FPREG = -FPREG + number at HL
   13D1 21                 3085         .db     0x21                          ; Skip "POP BC" and "POP DE"
   13D2 C1            [10] 3086 PSUB:   POP     BC                            ; Get FP number from stack
   13D3 D1            [10] 3087         POP     DE
   13D4 CD 46 16      [17] 3088 SUBCDE: CALL    INVSGN                        ; Negate FPREG
   13D7 78            [ 4] 3089 FPADD:  LD      A,B                           ; Get FP exponent
   13D8 B7            [ 4] 3090         OR      A                             ; Is number zero?
   13D9 C8            [11] 3091         RET     Z                             ; Yes - Nothing to add
   13DA 3A 2C 81      [13] 3092         LD      A,(FPEXP)                     ; Get FPREG exponent
   13DD B7            [ 4] 3093         OR      A                             ; Is this number zero?
   13DE CA 5E 16      [10] 3094         JP      Z,FPBCDE                      ; Yes - Move BCDE to FPREG
   13E1 90            [ 4] 3095         SUB     B                             ; BCDE number larger?
   13E2 D2 F1 13      [10] 3096         JP      NC,NOSWAP                     ; No - Don't swap them
   13E5 2F            [ 4] 3097         CPL                                   ; Two's complement
   13E6 3C            [ 4] 3098         INC     A                             ;	FP exponent
   13E7 EB            [ 4] 3099         EX      DE,HL
   13E8 CD 4E 16      [17] 3100         CALL    STAKFP                        ; Put FPREG on stack
   13EB EB            [ 4] 3101         EX      DE,HL
   13EC CD 5E 16      [17] 3102         CALL    FPBCDE                        ; Move BCDE to FPREG
   13EF C1            [10] 3103         POP     BC                            ; Restore number from stack
   13F0 D1            [10] 3104         POP     DE
   13F1 FE 19         [ 7] 3105 NOSWAP: CP      24+1                          ; Second number insignificant?
   13F3 D0            [11] 3106         RET     NC                            ; Yes - First number is result
   13F4 F5            [11] 3107         PUSH    AF                            ; Save number of bits to scale
   13F5 CD 83 16      [17] 3108         CALL    SIGNS                         ; Set MSBs & sign of result
   13F8 67            [ 4] 3109         LD      H,A                           ; Save sign of result
   13F9 F1            [10] 3110         POP     AF                            ; Restore scaling factor
   13FA CD 9C 14      [17] 3111         CALL    SCALE                         ; Scale BCDE to same exponent
   13FD B4            [ 4] 3112         OR      H                             ; Result to be positive?
   13FE 21 29 81      [10] 3113         LD      HL,FPREG                      ; Point to FPREG
   1401 F2 17 14      [10] 3114         JP      P,MINCDE                      ; No - Subtract FPREG from CDE
   1404 CD 7C 14      [17] 3115         CALL    PLUCDE                        ; Add FPREG to CDE
   1407 D2 5D 14      [10] 3116         JP      NC,RONDUP                     ; No overflow - Round it up
   140A 23            [ 6] 3117         INC     HL                            ; Point to exponent
   140B 34            [11] 3118         INC     (HL)                          ; Increment it
   140C CA 85 03      [10] 3119         JP      Z,OVERR                       ; Number overflowed - Error
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 58
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   140F 2E 01         [ 7] 3120         LD      L,1                           ; 1 bit to shift right
   1411 CD B2 14      [17] 3121         CALL    SHRT1                         ; Shift result right
   1414 C3 5D 14      [10] 3122         JP      RONDUP                        ; Round it up
                           3123 ;
   1417 AF            [ 4] 3124 MINCDE: XOR     A                             ; Clear A and carry
   1418 90            [ 4] 3125         SUB     B                             ; Negate exponent
   1419 47            [ 4] 3126         LD      B,A                           ; Re-save exponent
   141A 7E            [ 7] 3127         LD      A,(HL)                        ; Get LSB of FPREG
   141B 9B            [ 4] 3128         SBC     A,E                           ; Subtract LSB of BCDE
   141C 5F            [ 4] 3129         LD      E,A                           ; Save LSB of BCDE
   141D 23            [ 6] 3130         INC     HL
   141E 7E            [ 7] 3131         LD      A,(HL)                        ; Get NMSB of FPREG
   141F 9A            [ 4] 3132         SBC     A,D                           ; Subtract NMSB of BCDE
   1420 57            [ 4] 3133         LD      D,A                           ; Save NMSB of BCDE
   1421 23            [ 6] 3134         INC     HL
   1422 7E            [ 7] 3135         LD      A,(HL)                        ; Get MSB of FPREG
   1423 99            [ 4] 3136         SBC     A,C                           ; Subtract MSB of BCDE
   1424 4F            [ 4] 3137         LD      C,A                           ; Save MSB of BCDE
   1425 DC 88 14      [17] 3138 CONPOS: CALL    C,COMPL                       ; Overflow - Make it positive
                           3139 ;
   1428 68            [ 4] 3140 BNORM:  LD      L,B                           ; L = Exponent
   1429 63            [ 4] 3141         LD      H,E                           ; H = LSB
   142A AF            [ 4] 3142         XOR     A
   142B 47            [ 4] 3143 BNRMLP: LD      B,A                           ; Save bit count
   142C 79            [ 4] 3144         LD      A,C                           ; Get MSB
   142D B7            [ 4] 3145         OR      A                             ; Is it zero?
   142E C2 4A 14      [10] 3146         JP      NZ,PNORM                      ; No - Do it bit at a time
   1431 4A            [ 4] 3147         LD      C,D                           ; MSB = NMSB
   1432 54            [ 4] 3148         LD      D,H                           ; NMSB= LSB
   1433 65            [ 4] 3149         LD      H,L                           ; LSB = VLSB
   1434 6F            [ 4] 3150         LD      L,A                           ; VLSB= 0
   1435 78            [ 4] 3151         LD      A,B                           ; Get exponent
   1436 D6 08         [ 7] 3152         SUB     8                             ; Count 8 bits
   1438 FE E0         [ 7] 3153         CP      0x0E0                         ; -24-8 Was number zero?
   143A C2 2B 14      [10] 3154         JP      NZ,BNRMLP                     ; No - Keep normalising
   143D AF            [ 4] 3155 RESZER: XOR     A                             ; Result is zero
   143E 32 2C 81      [13] 3156 SAVEXP: LD      (FPEXP),A                     ; Save result as zero
   1441 C9            [10] 3157         RET
                           3158 ;
   1442 05            [ 4] 3159 NORMAL: DEC     B                             ; Count bits
   1443 29            [11] 3160         ADD     HL,HL                         ; Shift HL left
   1444 7A            [ 4] 3161         LD      A,D                           ; Get NMSB
   1445 17            [ 4] 3162         RLA                                   ; Shift left with last bit
   1446 57            [ 4] 3163         LD      D,A                           ; Save NMSB
   1447 79            [ 4] 3164         LD      A,C                           ; Get MSB
   1448 8F            [ 4] 3165         ADC     A,A                           ; Shift left with last bit
   1449 4F            [ 4] 3166         LD      C,A                           ; Save MSB
   144A F2 42 14      [10] 3167 PNORM:  JP      P,NORMAL                      ; Not done - Keep going
   144D 78            [ 4] 3168         LD      A,B                           ; Number of bits shifted
   144E 5C            [ 4] 3169         LD      E,H                           ; Save HL in EB
   144F 45            [ 4] 3170         LD      B,L
   1450 B7            [ 4] 3171         OR      A                             ; Any shifting done?
   1451 CA 5D 14      [10] 3172         JP      Z,RONDUP                      ; No - Round it up
   1454 21 2C 81      [10] 3173         LD      HL,FPEXP                      ; Point to exponent
   1457 86            [ 7] 3174         ADD     A,(HL)                        ; Add shifted bits
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 59
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1458 77            [ 7] 3175         LD      (HL),A                        ; Re-save exponent
   1459 D2 3D 14      [10] 3176         JP      NC,RESZER                     ; Underflow - Result is zero
   145C C8            [11] 3177         RET     Z                             ; Result is zero
   145D 78            [ 4] 3178 RONDUP: LD      A,B                           ; Get VLSB of number
   145E 21 2C 81      [10] 3179 RONDB:  LD      HL,FPEXP                      ; Point to exponent
   1461 B7            [ 4] 3180         OR      A                             ; Any rounding?
   1462 FC 6F 14      [17] 3181         CALL    M,FPROND                      ; Yes - Round number up
   1465 46            [ 7] 3182         LD      B,(HL)                        ; B = Exponent
   1466 23            [ 6] 3183         INC     HL
   1467 7E            [ 7] 3184         LD      A,(HL)                        ; Get sign of result
   1468 E6 80         [ 7] 3185         AND     0b10000000                    ; Only bit 7 needed
   146A A9            [ 4] 3186         XOR     C                             ; Set correct sign
   146B 4F            [ 4] 3187         LD      C,A                           ; Save correct sign in number
   146C C3 5E 16      [10] 3188         JP      FPBCDE                        ; Move BCDE to FPREG
                           3189 ;
   146F 1C            [ 4] 3190 FPROND: INC     E                             ; Round LSB
   1470 C0            [11] 3191         RET     NZ                            ; Return if ok
   1471 14            [ 4] 3192         INC     D                             ; Round NMSB
   1472 C0            [11] 3193         RET     NZ                            ; Return if ok
   1473 0C            [ 4] 3194         INC     C                             ; Round MSB
   1474 C0            [11] 3195         RET     NZ                            ; Return if ok
   1475 0E 80         [ 7] 3196         LD      C,0x80                        ; Set normal value
   1477 34            [11] 3197         INC     (HL)                          ; Increment exponent
   1478 C0            [11] 3198         RET     NZ                            ; Return if ok
   1479 C3 85 03      [10] 3199         JP      OVERR                         ; Overflow error
                           3200 ;
   147C 7E            [ 7] 3201 PLUCDE: LD      A,(HL)                        ; Get LSB of FPREG
   147D 83            [ 4] 3202         ADD     A,E                           ; Add LSB of BCDE
   147E 5F            [ 4] 3203         LD      E,A                           ; Save LSB of BCDE
   147F 23            [ 6] 3204         INC     HL
   1480 7E            [ 7] 3205         LD      A,(HL)                        ; Get NMSB of FPREG
   1481 8A            [ 4] 3206         ADC     A,D                           ; Add NMSB of BCDE
   1482 57            [ 4] 3207         LD      D,A                           ; Save NMSB of BCDE
   1483 23            [ 6] 3208         INC     HL
   1484 7E            [ 7] 3209         LD      A,(HL)                        ; Get MSB of FPREG
   1485 89            [ 4] 3210         ADC     A,C                           ; Add MSB of BCDE
   1486 4F            [ 4] 3211         LD      C,A                           ; Save MSB of BCDE
   1487 C9            [10] 3212         RET
                           3213 ;
   1488 21 2D 81      [10] 3214 COMPL:  LD      HL,SGNRES                     ; Sign of result
   148B 7E            [ 7] 3215         LD      A,(HL)                        ; Get sign of result
   148C 2F            [ 4] 3216         CPL                                   ; Negate it
   148D 77            [ 7] 3217         LD      (HL),A                        ; Put it back
   148E AF            [ 4] 3218         XOR     A
   148F 6F            [ 4] 3219         LD      L,A                           ; Set L to zero
   1490 90            [ 4] 3220         SUB     B                             ; Negate exponent,set carry
   1491 47            [ 4] 3221         LD      B,A                           ; Re-save exponent
   1492 7D            [ 4] 3222         LD      A,L                           ; Load zero
   1493 9B            [ 4] 3223         SBC     A,E                           ; Negate LSB
   1494 5F            [ 4] 3224         LD      E,A                           ; Re-save LSB
   1495 7D            [ 4] 3225         LD      A,L                           ; Load zero
   1496 9A            [ 4] 3226         SBC     A,D                           ; Negate NMSB
   1497 57            [ 4] 3227         LD      D,A                           ; Re-save NMSB
   1498 7D            [ 4] 3228         LD      A,L                           ; Load zero
   1499 99            [ 4] 3229         SBC     A,C                           ; Negate MSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 60
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   149A 4F            [ 4] 3230         LD      C,A                           ; Re-save MSB
   149B C9            [10] 3231         RET
                           3232 ;
   149C 06 00         [ 7] 3233 SCALE:  LD      B,0                           ; Clear underflow
   149E D6 08         [ 7] 3234 SCALLP: SUB     8                             ; 8 bits (a whole byte)?
   14A0 DA AB 14      [10] 3235         JP      C,SHRITE                      ; No - Shift right A bits
   14A3 43            [ 4] 3236         LD      B,E                           ; <- Shift
   14A4 5A            [ 4] 3237         LD      E,D                           ; <- right
   14A5 51            [ 4] 3238         LD      D,C                           ; <- eight
   14A6 0E 00         [ 7] 3239         LD      C,0                           ; <- bits
   14A8 C3 9E 14      [10] 3240         JP      SCALLP                        ; More bits to shift
                           3241 ;
   14AB C6 09         [ 7] 3242 SHRITE: ADD     A,8+1                         ; Adjust count
   14AD 6F            [ 4] 3243         LD      L,A                           ; Save bits to shift
   14AE AF            [ 4] 3244 SHRLP:  XOR     A                             ; Flag for all done
   14AF 2D            [ 4] 3245         DEC     L                             ; All shifting done?
   14B0 C8            [11] 3246         RET     Z                             ; Yes - Return
   14B1 79            [ 4] 3247         LD      A,C                           ; Get MSB
   14B2 1F            [ 4] 3248 SHRT1:  RRA                                   ; Shift it right
   14B3 4F            [ 4] 3249         LD      C,A                           ; Re-save
   14B4 7A            [ 4] 3250         LD      A,D                           ; Get NMSB
   14B5 1F            [ 4] 3251         RRA                                   ; Shift right with last bit
   14B6 57            [ 4] 3252         LD      D,A                           ; Re-save it
   14B7 7B            [ 4] 3253         LD      A,E                           ; Get LSB
   14B8 1F            [ 4] 3254         RRA                                   ; Shift right with last bit
   14B9 5F            [ 4] 3255         LD      E,A                           ; Re-save it
   14BA 78            [ 4] 3256         LD      A,B                           ; Get underflow
   14BB 1F            [ 4] 3257         RRA                                   ; Shift right with last bit
   14BC 47            [ 4] 3258         LD      B,A                           ; Re-save underflow
   14BD C3 AE 14      [10] 3259         JP      SHRLP                         ; More bits to do
                           3260 ;
   14C0 00 00 00 81        3261 UNITY:  .db     0x000,0x000,0x000,0x081       ; 1.00000
                           3262 ;
   14C4 03                 3263 LOGTAB: .db     3                             ; Table used by LOG
   14C5 AA 56 19 80        3264         .db     0x0AA,0x056,0x019,0x080       ; 0.59898
   14C9 F1 22 76 80        3265         .db     0x0F1,0x022,0x076,0x080       ; 0.96147
   14CD 45 AA 38 82        3266         .db     0x045,0x0AA,0x038,0x082       ; 2.88539
                           3267 ;
   14D1 CD 1D 16      [17] 3268 LOG:    CALL    TSTSGN                        ; Test sign of value
   14D4 B7            [ 4] 3269         OR      A
   14D5 EA 95 08      [10] 3270         JP      PE,FCERR                      ; ?FC Error if <= zero
   14D8 21 2C 81      [10] 3271         LD      HL,FPEXP                      ; Point to exponent
   14DB 7E            [ 7] 3272         LD      A,(HL)                        ; Get exponent
   14DC 01 35 80      [10] 3273         LD      BC,0x8035                     ; BCDE = SQR(1/2)
   14DF 11 F3 04      [10] 3274         LD      DE,0x04F3
   14E2 90            [ 4] 3275         SUB     B                             ; Scale value to be < 1
   14E3 F5            [11] 3276         PUSH    AF                            ; Save scale factor
   14E4 70            [ 7] 3277         LD      (HL),B                        ; Save new exponent
   14E5 D5            [11] 3278         PUSH    DE                            ; Save SQR(1/2)
   14E6 C5            [11] 3279         PUSH    BC
   14E7 CD D7 13      [17] 3280         CALL    FPADD                         ; Add SQR(1/2) to value
   14EA C1            [10] 3281         POP     BC                            ; Restore SQR(1/2)
   14EB D1            [10] 3282         POP     DE
   14EC 04            [ 4] 3283         INC     B                             ; Make it SQR(2)
   14ED CD 73 15      [17] 3284         CALL    DVBCDE                        ; Divide by SQR(2)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 61
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   14F0 21 C0 14      [10] 3285         LD      HL,UNITY                      ; Point to 1.
   14F3 CD CE 13      [17] 3286         CALL    SUBPHL                        ; Subtract FPREG from 1
   14F6 21 C4 14      [10] 3287         LD      HL,LOGTAB                     ; Coefficient table
   14F9 CD 65 19      [17] 3288         CALL    SUMSER                        ; Evaluate sum of series
   14FC 01 80 80      [10] 3289         LD      BC,0x8080                     ; BCDE = -0.5
   14FF 11 00 00      [10] 3290         LD      DE,0x0000
   1502 CD D7 13      [17] 3291         CALL    FPADD                         ; Subtract 0.5 from FPREG
   1505 F1            [10] 3292         POP     AF                            ; Restore scale factor
   1506 CD 98 17      [17] 3293         CALL    RSCALE                        ; Re-scale number
   1509 01 31 80      [10] 3294 MULLN2: LD      BC,0x8031                     ; BCDE = Ln(2)
   150C 11 18 72      [10] 3295         LD      DE,0x7218
   150F 21                 3296         .db     0x21                          ; Skip "POP BC" and "POP DE"
                           3297 ;
   1510 C1            [10] 3298 MULT:   POP     BC                            ; Get number from stack
   1511 D1            [10] 3299         POP     DE
   1512 CD 1D 16      [17] 3300 FPMULT: CALL    TSTSGN                        ; Test sign of FPREG
   1515 C8            [11] 3301         RET     Z                             ; Return zero if zero
   1516 2E 00         [ 7] 3302         LD      L,0                           ; Flag add exponents
   1518 CD DB 15      [17] 3303         CALL    ADDEXP                        ; Add exponents
   151B 79            [ 4] 3304         LD      A,C                           ; Get MSB of multiplier
   151C 32 3B 81      [13] 3305         LD      (MULVAL),A                    ; Save MSB of multiplier
   151F EB            [ 4] 3306         EX      DE,HL
   1520 22 3C 81      [16] 3307         LD      (MULVAL+1),HL                 ; Save rest of multiplier
   1523 01 00 00      [10] 3308         LD      BC,0                          ; Partial product (BCDE) = zero
   1526 50            [ 4] 3309         LD      D,B
   1527 58            [ 4] 3310         LD      E,B
   1528 21 28 14      [10] 3311         LD      HL,BNORM                      ; Address of normalise
   152B E5            [11] 3312         PUSH    HL                            ; Save for return
   152C 21 34 15      [10] 3313         LD      HL,MULT8                      ; Address of 8 bit multiply
   152F E5            [11] 3314         PUSH    HL                            ; Save for NMSB,MSB
   1530 E5            [11] 3315         PUSH    HL                            ;
   1531 21 29 81      [10] 3316         LD      HL,FPREG                      ; Point to number
   1534 7E            [ 7] 3317 MULT8:  LD      A,(HL)                        ; Get LSB of number
   1535 23            [ 6] 3318         INC     HL                            ; Point to NMSB
   1536 B7            [ 4] 3319         OR      A                             ; Test LSB
   1537 CA 60 15      [10] 3320         JP      Z,BYTSFT                      ; Zero - shift to next byte
   153A E5            [11] 3321         PUSH    HL                            ; Save address of number
   153B 2E 08         [ 7] 3322         LD      L,8                           ; 8 bits to multiply by
   153D 1F            [ 4] 3323 MUL8LP: RRA                                   ; Shift LSB right
   153E 67            [ 4] 3324         LD      H,A                           ; Save LSB
   153F 79            [ 4] 3325         LD      A,C                           ; Get MSB
   1540 D2 4E 15      [10] 3326         JP      NC,NOMADD                     ; Bit was zero - Don't add
   1543 E5            [11] 3327         PUSH    HL                            ; Save LSB and count
   1544 2A 3C 81      [16] 3328         LD      HL,(MULVAL+1)                 ; Get LSB and NMSB
   1547 19            [11] 3329         ADD     HL,DE                         ; Add NMSB and LSB
   1548 EB            [ 4] 3330         EX      DE,HL                         ; Leave sum in DE
   1549 E1            [10] 3331         POP     HL                            ; Restore MSB and count
   154A 3A 3B 81      [13] 3332         LD      A,(MULVAL)                    ; Get MSB of multiplier
   154D 89            [ 4] 3333         ADC     A,C                           ; Add MSB
   154E 1F            [ 4] 3334 NOMADD: RRA                                   ; Shift MSB right
   154F 4F            [ 4] 3335         LD      C,A                           ; Re-save MSB
   1550 7A            [ 4] 3336         LD      A,D                           ; Get NMSB
   1551 1F            [ 4] 3337         RRA                                   ; Shift NMSB right
   1552 57            [ 4] 3338         LD      D,A                           ; Re-save NMSB
   1553 7B            [ 4] 3339         LD      A,E                           ; Get LSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 62
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1554 1F            [ 4] 3340         RRA                                   ; Shift LSB right
   1555 5F            [ 4] 3341         LD      E,A                           ; Re-save LSB
   1556 78            [ 4] 3342         LD      A,B                           ; Get VLSB
   1557 1F            [ 4] 3343         RRA                                   ; Shift VLSB right
   1558 47            [ 4] 3344         LD      B,A                           ; Re-save VLSB
   1559 2D            [ 4] 3345         DEC     L                             ; Count bits multiplied
   155A 7C            [ 4] 3346         LD      A,H                           ; Get LSB of multiplier
   155B C2 3D 15      [10] 3347         JP      NZ,MUL8LP                     ; More - Do it
   155E E1            [10] 3348 POPHRT: POP     HL                            ; Restore address of number
   155F C9            [10] 3349         RET
                           3350 ;
   1560 43            [ 4] 3351 BYTSFT: LD      B,E                           ; Shift partial product left
   1561 5A            [ 4] 3352         LD      E,D
   1562 51            [ 4] 3353         LD      D,C
   1563 4F            [ 4] 3354         LD      C,A
   1564 C9            [10] 3355         RET
                           3356 ;
   1565 CD 4E 16      [17] 3357 DIV10:  CALL    STAKFP                        ; Save FPREG on stack
   1568 01 20 84      [10] 3358         LD      BC,0x8420                     ; BCDE = 10.
   156B 11 00 00      [10] 3359         LD      DE,0x0000
   156E CD 5E 16      [17] 3360         CALL    FPBCDE                        ; Move 10 to FPREG
                           3361 ;
   1571 C1            [10] 3362 DIV:    POP     BC                            ; Get number from stack
   1572 D1            [10] 3363         POP     DE
   1573 CD 1D 16      [17] 3364 DVBCDE: CALL    TSTSGN                        ; Test sign of FPREG
   1576 CA 79 03      [10] 3365         JP      Z,DZERR                       ; Error if division by zero
   1579 2E FF         [ 7] 3366         LD      L,-1                          ; Flag subtract exponents
   157B CD DB 15      [17] 3367         CALL    ADDEXP                        ; Subtract exponents
   157E 34            [11] 3368         INC     (HL)                          ; Add 2 to exponent to adjust
   157F 34            [11] 3369         INC     (HL)
   1580 2B            [ 6] 3370         DEC     HL                            ; Point to MSB
   1581 7E            [ 7] 3371         LD      A,(HL)                        ; Get MSB of dividend
   1582 32 57 80      [13] 3372         LD      (DIV3),A                      ; Save for subtraction
   1585 2B            [ 6] 3373         DEC     HL
   1586 7E            [ 7] 3374         LD      A,(HL)                        ; Get NMSB of dividend
   1587 32 53 80      [13] 3375         LD      (DIV2),A                      ; Save for subtraction
   158A 2B            [ 6] 3376         DEC     HL
   158B 7E            [ 7] 3377         LD      A,(HL)                        ; Get MSB of dividend
   158C 32 4F 80      [13] 3378         LD      (DIV1),A                      ; Save for subtraction
   158F 41            [ 4] 3379         LD      B,C                           ; Get MSB
   1590 EB            [ 4] 3380         EX      DE,HL                         ; NMSB,LSB to HL
   1591 AF            [ 4] 3381         XOR     A
   1592 4F            [ 4] 3382         LD      C,A                           ; Clear MSB of quotient
   1593 57            [ 4] 3383         LD      D,A                           ; Clear NMSB of quotient
   1594 5F            [ 4] 3384         LD      E,A                           ; Clear LSB of quotient
   1595 32 5A 80      [13] 3385         LD      (DIV4),A                      ; Clear overflow count
   1598 E5            [11] 3386 DIVLP:  PUSH    HL                            ; Save divisor
   1599 C5            [11] 3387         PUSH    BC
   159A 7D            [ 4] 3388         LD      A,L                           ; Get LSB of number
   159B CD 4E 80      [17] 3389         CALL    DIVSUP                        ; Subt' divisor from dividend
   159E DE 00         [ 7] 3390         SBC     A,0                           ; Count for overflows
   15A0 3F            [ 4] 3391         CCF
   15A1 D2 AB 15      [10] 3392         JP      NC,RESDIV                     ; Restore divisor if borrow
   15A4 32 5A 80      [13] 3393         LD      (DIV4),A                      ; Re-save overflow count
   15A7 F1            [10] 3394         POP     AF                            ; Scrap divisor
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 63
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   15A8 F1            [10] 3395         POP     AF
   15A9 37            [ 4] 3396         SCF                                   ; Set carry to
   15AA D2                 3397         .db     0x0D2                         ; Skip "POP BC" and "POP HL"
                           3398 ;
   15AB C1            [10] 3399 RESDIV: POP     BC                            ; Restore divisor
   15AC E1            [10] 3400         POP     HL
   15AD 79            [ 4] 3401         LD      A,C                           ; Get MSB of quotient
   15AE 3C            [ 4] 3402         INC     A
   15AF 3D            [ 4] 3403         DEC     A
   15B0 1F            [ 4] 3404         RRA                                   ; Bit 0 to bit 7
   15B1 FA 5E 14      [10] 3405         JP      M,RONDB                       ; Done - Normalise result
   15B4 17            [ 4] 3406         RLA                                   ; Restore carry
   15B5 7B            [ 4] 3407         LD      A,E                           ; Get LSB of quotient
   15B6 17            [ 4] 3408         RLA                                   ; Double it
   15B7 5F            [ 4] 3409         LD      E,A                           ; Put it back
   15B8 7A            [ 4] 3410         LD      A,D                           ; Get NMSB of quotient
   15B9 17            [ 4] 3411         RLA                                   ; Double it
   15BA 57            [ 4] 3412         LD      D,A                           ; Put it back
   15BB 79            [ 4] 3413         LD      A,C                           ; Get MSB of quotient
   15BC 17            [ 4] 3414         RLA                                   ; Double it
   15BD 4F            [ 4] 3415         LD      C,A                           ; Put it back
   15BE 29            [11] 3416         ADD     HL,HL                         ; Double NMSB,LSB of divisor
   15BF 78            [ 4] 3417         LD      A,B                           ; Get MSB of divisor
   15C0 17            [ 4] 3418         RLA                                   ; Double it
   15C1 47            [ 4] 3419         LD      B,A                           ; Put it back
   15C2 3A 5A 80      [13] 3420         LD      A,(DIV4)                      ; Get VLSB of quotient
   15C5 17            [ 4] 3421         RLA                                   ; Double it
   15C6 32 5A 80      [13] 3422         LD      (DIV4),A                      ; Put it back
   15C9 79            [ 4] 3423         LD      A,C                           ; Get MSB of quotient
   15CA B2            [ 4] 3424         OR      D                             ; Merge NMSB
   15CB B3            [ 4] 3425         OR      E                             ; Merge LSB
   15CC C2 98 15      [10] 3426         JP      NZ,DIVLP                      ; Not done - Keep dividing
   15CF E5            [11] 3427         PUSH    HL                            ; Save divisor
   15D0 21 2C 81      [10] 3428         LD      HL,FPEXP                      ; Point to exponent
   15D3 35            [11] 3429         DEC     (HL)                          ; Divide by 2
   15D4 E1            [10] 3430         POP     HL                            ; Restore divisor
   15D5 C2 98 15      [10] 3431         JP      NZ,DIVLP                      ; Ok - Keep going
   15D8 C3 85 03      [10] 3432         JP      OVERR                         ; Overflow error
                           3433 ;
   15DB 78            [ 4] 3434 ADDEXP: LD      A,B                           ; Get exponent of dividend
   15DC B7            [ 4] 3435         OR      A                             ; Test it
   15DD CA FF 15      [10] 3436         JP      Z,OVTST3                      ; Zero - Result zero
   15E0 7D            [ 4] 3437         LD      A,L                           ; Get add/subtract flag
   15E1 21 2C 81      [10] 3438         LD      HL,FPEXP                      ; Point to exponent
   15E4 AE            [ 7] 3439         XOR     (HL)                          ; Add or subtract it
   15E5 80            [ 4] 3440         ADD     A,B                           ; Add the other exponent
   15E6 47            [ 4] 3441         LD      B,A                           ; Save new exponent
   15E7 1F            [ 4] 3442         RRA                                   ; Test exponent for overflow
   15E8 A8            [ 4] 3443         XOR     B
   15E9 78            [ 4] 3444         LD      A,B                           ; Get exponent
   15EA F2 FE 15      [10] 3445         JP      P,OVTST2                      ; Positive - Test for overflow
   15ED C6 80         [ 7] 3446         ADD     A,0x80                        ; Add excess 128
   15EF 77            [ 7] 3447         LD      (HL),A                        ; Save new exponent
   15F0 CA 5E 15      [10] 3448         JP      Z,POPHRT                      ; Zero - Result zero
   15F3 CD 83 16      [17] 3449         CALL    SIGNS                         ; Set MSBs and sign of result
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 64
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   15F6 77            [ 7] 3450         LD      (HL),A                        ; Save new exponent
   15F7 2B            [ 6] 3451         DEC     HL                            ; Point to MSB
   15F8 C9            [10] 3452         RET
                           3453 ;
   15F9 CD 1D 16      [17] 3454 OVTST1: CALL    TSTSGN                        ; Test sign of FPREG
   15FC 2F            [ 4] 3455         CPL                                   ; Invert sign
   15FD E1            [10] 3456         POP     HL                            ; Clean up stack
   15FE B7            [ 4] 3457 OVTST2: OR      A                             ; Test if new exponent zero
   15FF E1            [10] 3458 OVTST3: POP     HL                            ; Clear off return address
   1600 F2 3D 14      [10] 3459         JP      P,RESZER                      ; Result zero
   1603 C3 85 03      [10] 3460         JP      OVERR                         ; Overflow error
                           3461 ;
   1606 CD 69 16      [17] 3462 MLSP10: CALL    BCDEFP                        ; Move FPREG to BCDE
   1609 78            [ 4] 3463         LD      A,B                           ; Get exponent
   160A B7            [ 4] 3464         OR      A                             ; Is it zero?
   160B C8            [11] 3465         RET     Z                             ; Yes - Result is zero
   160C C6 02         [ 7] 3466         ADD     A,2                           ; Multiply by 4
   160E DA 85 03      [10] 3467         JP      C,OVERR                       ; Overflow - ?OV Error
   1611 47            [ 4] 3468         LD      B,A                           ; Re-save exponent
   1612 CD D7 13      [17] 3469         CALL    FPADD                         ; Add BCDE to FPREG (Times 5)
   1615 21 2C 81      [10] 3470         LD      HL,FPEXP                      ; Point to exponent
   1618 34            [11] 3471         INC     (HL)                          ; Double number (Times 10)
   1619 C0            [11] 3472         RET     NZ                            ; Ok - Return
   161A C3 85 03      [10] 3473         JP      OVERR                         ; Overflow error
                           3474 ;
   161D 3A 2C 81      [13] 3475 TSTSGN: LD      A,(FPEXP)                     ; Get sign of FPREG
   1620 B7            [ 4] 3476         OR      A
   1621 C8            [11] 3477         RET     Z                             ; RETurn if number is zero
   1622 3A 2B 81      [13] 3478         LD      A,(FPREG+2)                   ; Get MSB of FPREG
   1625 FE                 3479         .db     0x0FE                         ; Test sign
   1626 2F            [ 4] 3480 RETREL: CPL                                   ; Invert sign
   1627 17            [ 4] 3481         RLA                                   ; Sign bit to carry
   1628 9F            [ 4] 3482 FLGDIF: SBC     A,A                           ; Carry to all bits of A
   1629 C0            [11] 3483         RET     NZ                            ; Return -1 if negative
   162A 3C            [ 4] 3484         INC     A                             ; Bump to +1
   162B C9            [10] 3485         RET                                   ; Positive - Return +1
                           3486 ;
   162C CD 1D 16      [17] 3487 SGN:    CALL    TSTSGN                        ; Test sign of FPREG
   162F 06 88         [ 7] 3488 FLGREL: LD      B,0x80+8                      ; 8 bit integer in exponent
   1631 11 00 00      [10] 3489         LD      DE,0                          ; Zero NMSB and LSB
   1634 21 2C 81      [10] 3490 RETINT: LD      HL,FPEXP                      ; Point to exponent
   1637 4F            [ 4] 3491         LD      C,A                           ; CDE = MSB,NMSB and LSB
   1638 70            [ 7] 3492         LD      (HL),B                        ; Save exponent
   1639 06 00         [ 7] 3493         LD      B,0                           ; CDE = integer to normalise
   163B 23            [ 6] 3494         INC     HL                            ; Point to sign of result
   163C 36 80         [10] 3495         LD      (HL),0x80                     ; Set sign of result
   163E 17            [ 4] 3496         RLA                                   ; Carry = sign of integer
   163F C3 25 14      [10] 3497         JP      CONPOS                        ; Set sign of result
                           3498 ;
   1642 CD 1D 16      [17] 3499 ABS:    CALL    TSTSGN                        ; Test sign of FPREG
   1645 F0            [11] 3500         RET     P                             ; Return if positive
   1646 21 2B 81      [10] 3501 INVSGN: LD      HL,FPREG+2                    ; Point to MSB
   1649 7E            [ 7] 3502         LD      A,(HL)                        ; Get sign of mantissa
   164A EE 80         [ 7] 3503         XOR     0x80                          ; Invert sign of mantissa
   164C 77            [ 7] 3504         LD      (HL),A                        ; Re-save sign of mantissa
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 65
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   164D C9            [10] 3505         RET
                           3506 ;
   164E EB            [ 4] 3507 STAKFP: EX      DE,HL                         ; Save code string address
   164F 2A 29 81      [16] 3508         LD      HL,(FPREG)                    ; LSB,NLSB of FPREG
   1652 E3            [19] 3509         EX      (SP),HL                       ; Stack them,get return
   1653 E5            [11] 3510         PUSH    HL                            ; Re-save return
   1654 2A 2B 81      [16] 3511         LD      HL,(FPREG+2)                  ; MSB and exponent of FPREG
   1657 E3            [19] 3512         EX      (SP),HL                       ; Stack them,get return
   1658 E5            [11] 3513         PUSH    HL                            ; Re-save return
   1659 EB            [ 4] 3514         EX      DE,HL                         ; Restore code string address
   165A C9            [10] 3515         RET
                           3516 ;
   165B CD 6C 16      [17] 3517 PHLTFP: CALL    LOADFP                        ; Number at HL to BCDE
   165E EB            [ 4] 3518 FPBCDE: EX      DE,HL                         ; Save code string address
   165F 22 29 81      [16] 3519         LD      (FPREG),HL                    ; Save LSB,NLSB of number
   1662 60            [ 4] 3520         LD      H,B                           ; Exponent of number
   1663 69            [ 4] 3521         LD      L,C                           ; MSB of number
   1664 22 2B 81      [16] 3522         LD      (FPREG+2),HL                  ; Save MSB and exponent
   1667 EB            [ 4] 3523         EX      DE,HL                         ; Restore code string address
   1668 C9            [10] 3524         RET
                           3525 ;
   1669 21 29 81      [10] 3526 BCDEFP: LD      HL,FPREG                      ; Point to FPREG
   166C 5E            [ 7] 3527 LOADFP: LD      E,(HL)                        ; Get LSB of number
   166D 23            [ 6] 3528         INC     HL
   166E 56            [ 7] 3529         LD      D,(HL)                        ; Get NMSB of number
   166F 23            [ 6] 3530         INC     HL
   1670 4E            [ 7] 3531         LD      C,(HL)                        ; Get MSB of number
   1671 23            [ 6] 3532         INC     HL
   1672 46            [ 7] 3533         LD      B,(HL)                        ; Get exponent of number
   1673 23            [ 6] 3534 INCHL:  INC     HL                            ; Used for conditional "INC HL"
   1674 C9            [10] 3535         RET
                           3536 ;
   1675 11 29 81      [10] 3537 FPTHL:  LD      DE,FPREG                      ; Point to FPREG
   1678 06 04         [ 7] 3538 DETHL4: LD      B,4                           ; 4 bytes to move
   167A 1A            [ 7] 3539 DETHLB: LD      A,(DE)                        ; Get source
   167B 77            [ 7] 3540         LD      (HL),A                        ; Save destination
   167C 13            [ 6] 3541         INC     DE                            ; Next source
   167D 23            [ 6] 3542         INC     HL                            ; Next destination
   167E 05            [ 4] 3543         DEC     B                             ; Count bytes
   167F C2 7A 16      [10] 3544         JP      NZ,DETHLB                     ; Loop if more
   1682 C9            [10] 3545         RET
                           3546 ;
   1683 21 2B 81      [10] 3547 SIGNS:  LD      HL,FPREG+2                    ; Point to MSB of FPREG
   1686 7E            [ 7] 3548         LD      A,(HL)                        ; Get MSB
   1687 07            [ 4] 3549         RLCA                                  ; Old sign to carry
   1688 37            [ 4] 3550         SCF                                   ; Set MSBit
   1689 1F            [ 4] 3551         RRA                                   ; Set MSBit of MSB
   168A 77            [ 7] 3552         LD      (HL),A                        ; Save new MSB
   168B 3F            [ 4] 3553         CCF                                   ; Complement sign
   168C 1F            [ 4] 3554         RRA                                   ; Old sign to carry
   168D 23            [ 6] 3555         INC     HL
   168E 23            [ 6] 3556         INC     HL
   168F 77            [ 7] 3557         LD      (HL),A                        ; Set sign of result
   1690 79            [ 4] 3558         LD      A,C                           ; Get MSB
   1691 07            [ 4] 3559         RLCA                                  ; Old sign to carry
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 66
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1692 37            [ 4] 3560         SCF                                   ; Set MSBit
   1693 1F            [ 4] 3561         RRA                                   ; Set MSBit of MSB
   1694 4F            [ 4] 3562         LD      C,A                           ; Save MSB
   1695 1F            [ 4] 3563         RRA
   1696 AE            [ 7] 3564         XOR     (HL)                          ; New sign of result
   1697 C9            [10] 3565         RET
                           3566 ;
   1698 78            [ 4] 3567 CMPNUM: LD      A,B                           ; Get exponent of number
   1699 B7            [ 4] 3568         OR      A
   169A CA 1D 16      [10] 3569         JP      Z,TSTSGN                      ; Zero - Test sign of FPREG
   169D 21 26 16      [10] 3570         LD      HL,RETREL                     ; Return relation routine
   16A0 E5            [11] 3571         PUSH    HL                            ; Save for return
   16A1 CD 1D 16      [17] 3572         CALL    TSTSGN                        ; Test sign of FPREG
   16A4 79            [ 4] 3573         LD      A,C                           ; Get MSB of number
   16A5 C8            [11] 3574         RET     Z                             ; FPREG zero - Number's MSB
   16A6 21 2B 81      [10] 3575         LD      HL,FPREG+2                    ; MSB of FPREG
   16A9 AE            [ 7] 3576         XOR     (HL)                          ; Combine signs
   16AA 79            [ 4] 3577         LD      A,C                           ; Get MSB of number
   16AB F8            [11] 3578         RET     M                             ; Exit if signs different
   16AC CD B2 16      [17] 3579         CALL    CMPFP                         ; Compare FP numbers
   16AF 1F            [ 4] 3580         RRA                                   ; Get carry to sign
   16B0 A9            [ 4] 3581         XOR     C                             ; Combine with MSB of number
   16B1 C9            [10] 3582         RET
                           3583 ;
   16B2 23            [ 6] 3584 CMPFP:  INC     HL                            ; Point to exponent
   16B3 78            [ 4] 3585         LD      A,B                           ; Get exponent
   16B4 BE            [ 7] 3586         CP      (HL)                          ; Compare exponents
   16B5 C0            [11] 3587         RET     NZ                            ; Different
   16B6 2B            [ 6] 3588         DEC     HL                            ; Point to MBS
   16B7 79            [ 4] 3589         LD      A,C                           ; Get MSB
   16B8 BE            [ 7] 3590         CP      (HL)                          ; Compare MSBs
   16B9 C0            [11] 3591         RET     NZ                            ; Different
   16BA 2B            [ 6] 3592         DEC     HL                            ; Point to NMSB
   16BB 7A            [ 4] 3593         LD      A,D                           ; Get NMSB
   16BC BE            [ 7] 3594         CP      (HL)                          ; Compare NMSBs
   16BD C0            [11] 3595         RET     NZ                            ; Different
   16BE 2B            [ 6] 3596         DEC     HL                            ; Point to LSB
   16BF 7B            [ 4] 3597         LD      A,E                           ; Get LSB
   16C0 96            [ 7] 3598         SUB     (HL)                          ; Compare LSBs
   16C1 C0            [11] 3599         RET     NZ                            ; Different
   16C2 E1            [10] 3600         POP     HL                            ; Drop RETurn
   16C3 E1            [10] 3601         POP     HL                            ; Drop another RETurn
   16C4 C9            [10] 3602         RET
                           3603 ;
   16C5 47            [ 4] 3604 FPINT:  LD      B,A                           ; <- Move
   16C6 4F            [ 4] 3605         LD      C,A                           ; <- exponent
   16C7 57            [ 4] 3606         LD      D,A                           ; <- to all
   16C8 5F            [ 4] 3607         LD      E,A                           ; <- bits
   16C9 B7            [ 4] 3608         OR      A                             ; Test exponent
   16CA C8            [11] 3609         RET     Z                             ; Zero - Return zero
   16CB E5            [11] 3610         PUSH    HL                            ; Save pointer to number
   16CC CD 69 16      [17] 3611         CALL    BCDEFP                        ; Move FPREG to BCDE
   16CF CD 83 16      [17] 3612         CALL    SIGNS                         ; Set MSBs & sign of result
   16D2 AE            [ 7] 3613         XOR     (HL)                          ; Combine with sign of FPREG
   16D3 67            [ 4] 3614         LD      H,A                           ; Save combined signs
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 67
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   16D4 FC E9 16      [17] 3615         CALL    M,DCBCDE                      ; Negative - Decrement BCDE
   16D7 3E 98         [ 7] 3616         LD      A,0x80+24                     ; 24 bits
   16D9 90            [ 4] 3617         SUB     B                             ; Bits to shift
   16DA CD 9C 14      [17] 3618         CALL    SCALE                         ; Shift BCDE
   16DD 7C            [ 4] 3619         LD      A,H                           ; Get combined sign
   16DE 17            [ 4] 3620         RLA                                   ; Sign to carry
   16DF DC 6F 14      [17] 3621         CALL    C,FPROND                      ; Negative - Round number up
   16E2 06 00         [ 7] 3622         LD      B,0                           ; Zero exponent
   16E4 DC 88 14      [17] 3623         CALL    C,COMPL                       ; If negative make positive
   16E7 E1            [10] 3624         POP     HL                            ; Restore pointer to number
   16E8 C9            [10] 3625         RET
                           3626 ;
   16E9 1B            [ 6] 3627 DCBCDE: DEC     DE                            ; Decrement BCDE
   16EA 7A            [ 4] 3628         LD      A,D                           ; Test LSBs
   16EB A3            [ 4] 3629         AND     E
   16EC 3C            [ 4] 3630         INC     A
   16ED C0            [11] 3631         RET     NZ                            ; Exit if LSBs not FFFF
   16EE 0B            [ 6] 3632         DEC     BC                            ; Decrement MSBs
   16EF C9            [10] 3633         RET
                           3634 ;
   16F0 21 2C 81      [10] 3635 INT:    LD      HL,FPEXP                      ; Point to exponent
   16F3 7E            [ 7] 3636         LD      A,(HL)                        ; Get exponent
   16F4 FE 98         [ 7] 3637         CP      0x80+24                       ; Integer accuracy only?
   16F6 3A 29 81      [13] 3638         LD      A,(FPREG)                     ; Get LSB
   16F9 D0            [11] 3639         RET     NC                            ; Yes - Already integer
   16FA 7E            [ 7] 3640         LD      A,(HL)                        ; Get exponent
   16FB CD C5 16      [17] 3641         CALL    FPINT                         ; F.P to integer
   16FE 36 98         [10] 3642         LD      (HL),0x80+24                  ; Save 24 bit integer
   1700 7B            [ 4] 3643         LD      A,E                           ; Get LSB of number
   1701 F5            [11] 3644         PUSH    AF                            ; Save LSB
   1702 79            [ 4] 3645         LD      A,C                           ; Get MSB of number
   1703 17            [ 4] 3646         RLA                                   ; Sign to carry
   1704 CD 25 14      [17] 3647         CALL    CONPOS                        ; Set sign of result
   1707 F1            [10] 3648         POP     AF                            ; Restore LSB of number
   1708 C9            [10] 3649         RET
                           3650 ;
   1709 21 00 00      [10] 3651 MLDEBC: LD      HL,0                          ; Clear partial product
   170C 78            [ 4] 3652         LD      A,B                           ; Test multiplier
   170D B1            [ 4] 3653         OR      C
   170E C8            [11] 3654         RET     Z                             ; Return zero if zero
   170F 3E 10         [ 7] 3655         LD      A,16                          ; 16 bits
   1711 29            [11] 3656 MLDBLP: ADD     HL,HL                         ; Shift P.P left
   1712 DA 49 0F      [10] 3657         JP      C,BSERR                       ; ?BS Error if overflow
   1715 EB            [ 4] 3658         EX      DE,HL
   1716 29            [11] 3659         ADD     HL,HL                         ; Shift multiplier left
   1717 EB            [ 4] 3660         EX      DE,HL
   1718 D2 1F 17      [10] 3661         JP      NC,NOMLAD                     ; Bit was zero - No add
   171B 09            [11] 3662         ADD     HL,BC                         ; Add multiplicand
   171C DA 49 0F      [10] 3663         JP      C,BSERR                       ; ?BS Error if overflow
   171F 3D            [ 4] 3664 NOMLAD: DEC     A                             ; Count bits
   1720 C2 11 17      [10] 3665         JP      NZ,MLDBLP                     ; More
   1723 C9            [10] 3666         RET
                           3667 ;
   1724 FE 2D         [ 7] 3668 ASCTFP: CP      '-                            ; Negative?
   1726 F5            [11] 3669         PUSH    AF                            ; Save it and flags
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 68
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1727 CA 30 17      [10] 3670         JP      Z,CNVNUM                      ; Yes - Convert number
   172A FE 2B         [ 7] 3671         CP      '+                            ; Positive?
   172C CA 30 17      [10] 3672         JP      Z,CNVNUM                      ; Yes - Convert number
   172F 2B            [ 6] 3673         DEC     HL                            ; DEC 'cos GETCHR INCs
   1730 CD 3D 14      [17] 3674 CNVNUM: CALL    RESZER                        ; Set result to zero
   1733 47            [ 4] 3675         LD      B,A                           ; Digits after point counter
   1734 57            [ 4] 3676         LD      D,A                           ; Sign of exponent
   1735 5F            [ 4] 3677         LD      E,A                           ; Exponent of ten
   1736 2F            [ 4] 3678         CPL
   1737 4F            [ 4] 3679         LD      C,A                           ; Before or after point flag
   1738 CD CE 07      [17] 3680 MANLP:  CALL    GETCHR                        ; Get next character
   173B DA 81 17      [10] 3681         JP      C,ADDIG                       ; Digit - Add to number
   173E FE 2E         [ 7] 3682         CP      '.
   1740 CA 5C 17      [10] 3683         JP      Z,DPOINT                      ; '. - Flag point
   1743 FE 45         [ 7] 3684         CP      'E
   1745 C2 60 17      [10] 3685         JP      NZ,CONEXP                     ; Not 'E - Scale number
   1748 CD CE 07      [17] 3686         CALL    GETCHR                        ; Get next character
   174B CD 74 0D      [17] 3687         CALL    SGNEXP                        ; Get sign of exponent
   174E CD CE 07      [17] 3688 EXPLP:  CALL    GETCHR                        ; Get next character
   1751 DA A3 17      [10] 3689         JP      C,EDIGIT                      ; Digit - Add to exponent
   1754 14            [ 4] 3690         INC     D                             ; Is sign negative?
   1755 C2 60 17      [10] 3691         JP      NZ,CONEXP                     ; No - Scale number
   1758 AF            [ 4] 3692         XOR     A
   1759 93            [ 4] 3693         SUB     E                             ; Negate exponent
   175A 5F            [ 4] 3694         LD      E,A                           ; And re-save it
   175B 0C            [ 4] 3695         INC     C                             ; Flag end of number
   175C 0C            [ 4] 3696 DPOINT: INC     C                             ; Flag point passed
   175D CA 38 17      [10] 3697         JP      Z,MANLP                       ; Zero - Get another digit
   1760 E5            [11] 3698 CONEXP: PUSH    HL                            ; Save code string address
   1761 7B            [ 4] 3699         LD      A,E                           ; Get exponent
   1762 90            [ 4] 3700         SUB     B                             ; Subtract digits after point
   1763 F4 79 17      [17] 3701 SCALMI: CALL    P,SCALPL                      ; Positive - Multiply number
   1766 F2 6F 17      [10] 3702         JP      P,ENDCON                      ; Positive - All done
   1769 F5            [11] 3703         PUSH    AF                            ; Save number of times to /10
   176A CD 65 15      [17] 3704         CALL    DIV10                         ; Divide by 10
   176D F1            [10] 3705         POP     AF                            ; Restore count
   176E 3C            [ 4] 3706         INC     A                             ; Count divides
                           3707 ;
   176F C2 63 17      [10] 3708 ENDCON: JP      NZ,SCALMI                     ; More to do
   1772 D1            [10] 3709         POP     DE                            ; Restore code string address
   1773 F1            [10] 3710         POP     AF                            ; Restore sign of number
   1774 CC 46 16      [17] 3711         CALL    Z,INVSGN                      ; Negative - Negate number
   1777 EB            [ 4] 3712         EX      DE,HL                         ; Code string address to HL
   1778 C9            [10] 3713         RET
                           3714 ;
   1779 C8            [11] 3715 SCALPL: RET     Z                             ; Exit if no scaling needed
   177A F5            [11] 3716 MULTEN: PUSH    AF                            ; Save count
   177B CD 06 16      [17] 3717         CALL    MLSP10                        ; Multiply number by 10
   177E F1            [10] 3718         POP     AF                            ; Restore count
   177F 3D            [ 4] 3719         DEC     A                             ; Count multiplies
   1780 C9            [10] 3720         RET
                           3721 ;
   1781 D5            [11] 3722 ADDIG:  PUSH    DE                            ; Save sign of exponent
   1782 57            [ 4] 3723         LD      D,A                           ; Save digit
   1783 78            [ 4] 3724         LD      A,B                           ; Get digits after point
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 69
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1784 89            [ 4] 3725         ADC     A,C                           ; Add one if after point
   1785 47            [ 4] 3726         LD      B,A                           ; Re-save counter
   1786 C5            [11] 3727         PUSH    BC                            ; Save point flags
   1787 E5            [11] 3728         PUSH    HL                            ; Save code string address
   1788 D5            [11] 3729         PUSH    DE                            ; Save digit
   1789 CD 06 16      [17] 3730         CALL    MLSP10                        ; Multiply number by 10
   178C F1            [10] 3731         POP     AF                            ; Restore digit
   178D D6 30         [ 7] 3732         SUB     '0                            ; Make it absolute
   178F CD 98 17      [17] 3733         CALL    RSCALE                        ; Re-scale number
   1792 E1            [10] 3734         POP     HL                            ; Restore code string address
   1793 C1            [10] 3735         POP     BC                            ; Restore point flags
   1794 D1            [10] 3736         POP     DE                            ; Restore sign of exponent
   1795 C3 38 17      [10] 3737         JP      MANLP                         ; Get another digit
                           3738 ;
   1798 CD 4E 16      [17] 3739 RSCALE: CALL    STAKFP                        ; Put number on stack
   179B CD 2F 16      [17] 3740         CALL    FLGREL                        ; Digit to add to FPREG
   179E C1            [10] 3741 PADD:   POP     BC                            ; Restore number
   179F D1            [10] 3742         POP     DE
   17A0 C3 D7 13      [10] 3743         JP      FPADD                         ; Add BCDE to FPREG and return
                           3744 ;
   17A3 7B            [ 4] 3745 EDIGIT: LD      A,E                           ; Get digit
   17A4 07            [ 4] 3746         RLCA                                  ; Times 2
   17A5 07            [ 4] 3747         RLCA                                  ; Times 4
   17A6 83            [ 4] 3748         ADD     A,E                           ; Times 5
   17A7 07            [ 4] 3749         RLCA                                  ; Times 10
   17A8 86            [ 7] 3750         ADD     A,(HL)                        ; Add next digit
   17A9 D6 30         [ 7] 3751         SUB     '0                            ; Make it absolute
   17AB 5F            [ 4] 3752         LD      E,A                           ; Save new digit
   17AC C3 4E 17      [10] 3753         JP      EXPLP                         ; Look for another digit
                           3754 ;
   17AF E5            [11] 3755 LINEIN: PUSH    HL                            ; Save code string address
   17B0 21 0E 03      [10] 3756         LD      HL,INMSG                      ; Output " in "
   17B3 CD 14 11      [17] 3757         CALL    PRS                           ; Output string at HL
   17B6 E1            [10] 3758         POP     HL                            ; Restore code string address
   17B7 EB            [ 4] 3759 PRNTHL: EX      DE,HL                         ; Code string address to DE
   17B8 AF            [ 4] 3760         XOR     A
   17B9 06 98         [ 7] 3761         LD      B,0x80+24                     ; 24 bits
   17BB CD 34 16      [17] 3762         CALL    RETINT                        ; Return the integer
   17BE 21 13 11      [10] 3763         LD      HL,PRNUMS                     ; Print number string
   17C1 E5            [11] 3764         PUSH    HL                            ; Save for return
   17C2 21 2E 81      [10] 3765 NUMASC: LD      HL,PBUFF                      ; Convert number to ASCII
   17C5 E5            [11] 3766         PUSH    HL                            ; Save for return
   17C6 CD 1D 16      [17] 3767         CALL    TSTSGN                        ; Test sign of FPREG
   17C9 36 20         [10] 3768         LD      (HL),0x20                     ; Space at start
   17CB F2 D0 17      [10] 3769         JP      P,SPCFST                      ; Positive - Space to start
   17CE 36 2D         [10] 3770         LD      (HL),'-                       ; '- sign at start
   17D0 23            [ 6] 3771 SPCFST: INC     HL                            ; First byte of number
   17D1 36 30         [10] 3772         LD      (HL),'0                       ; '0 if zero
   17D3 CA 86 18      [10] 3773         JP      Z,JSTZER                      ; Return '0 if zero
   17D6 E5            [11] 3774         PUSH    HL                            ; Save buffer address
   17D7 FC 46 16      [17] 3775         CALL    M,INVSGN                      ; Negate FPREG if negative
   17DA AF            [ 4] 3776         XOR     A                             ; Zero A
   17DB F5            [11] 3777         PUSH    AF                            ; Save it
   17DC CD 8C 18      [17] 3778         CALL    RNGTST                        ; Test number is in range
   17DF 01 43 91      [10] 3779 SIXDIG: LD      BC,0x9143                     ; BCDE - 99999.9
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 70
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   17E2 11 F8 4F      [10] 3780         LD      DE,0x4FF8
   17E5 CD 98 16      [17] 3781         CALL    CMPNUM                        ; Compare numbers
   17E8 B7            [ 4] 3782         OR      A
   17E9 E2 FD 17      [10] 3783         JP      PO,INRNG                      ; > 99999.9 - Sort it out
   17EC F1            [10] 3784         POP     AF                            ; Restore count
   17ED CD 7A 17      [17] 3785         CALL    MULTEN                        ; Multiply by ten
   17F0 F5            [11] 3786         PUSH    AF                            ; Re-save count
   17F1 C3 DF 17      [10] 3787         JP      SIXDIG                        ; Test it again
                           3788 ;
   17F4 CD 65 15      [17] 3789 GTSIXD: CALL    DIV10                         ; Divide by 10
   17F7 F1            [10] 3790         POP     AF                            ; Get count
   17F8 3C            [ 4] 3791         INC     A                             ; Count divides
   17F9 F5            [11] 3792         PUSH    AF                            ; Re-save count
   17FA CD 8C 18      [17] 3793         CALL    RNGTST                        ; Test number is in range
   17FD CD C5 13      [17] 3794 INRNG:  CALL    ROUND                         ; Add 0.5 to FPREG
   1800 3C            [ 4] 3795         INC     A
   1801 CD C5 16      [17] 3796         CALL    FPINT                         ; F.P to integer
   1804 CD 5E 16      [17] 3797         CALL    FPBCDE                        ; Move BCDE to FPREG
   1807 01 06 03      [10] 3798         LD      BC,0x0306                     ; 1E+06 to 1E-03 range
   180A F1            [10] 3799         POP     AF                            ; Restore count
   180B 81            [ 4] 3800         ADD     A,C                           ; 6 digits before point
   180C 3C            [ 4] 3801         INC     A                             ; Add one
   180D FA 19 18      [10] 3802         JP      M,MAKNUM                      ; Do it in 'E form if < 1E-02
   1810 FE 08         [ 7] 3803         CP      6+1+1                         ; More than 999999 ?
   1812 D2 19 18      [10] 3804         JP      NC,MAKNUM                     ; Yes - Do it in 'E form
   1815 3C            [ 4] 3805         INC     A                             ; Adjust for exponent
   1816 47            [ 4] 3806         LD      B,A                           ; Exponent of number
   1817 3E 02         [ 7] 3807         LD      A,2                           ; Make it zero after
                           3808 ;
   1819 3D            [ 4] 3809 MAKNUM: DEC     A                             ; Adjust for digits to do
   181A 3D            [ 4] 3810         DEC     A
   181B E1            [10] 3811         POP     HL                            ; Restore buffer address
   181C F5            [11] 3812         PUSH    AF                            ; Save count
   181D 11 9F 18      [10] 3813         LD      DE,POWERS                     ; Powers of ten
   1820 05            [ 4] 3814         DEC     B                             ; Count digits before point
   1821 C2 2A 18      [10] 3815         JP      NZ,DIGTXT                     ; Not zero - Do number
   1824 36 2E         [10] 3816         LD      (HL),'.                       ; Save point
   1826 23            [ 6] 3817         INC     HL                            ; Move on
   1827 36 30         [10] 3818         LD      (HL),'0                       ; Save zero
   1829 23            [ 6] 3819         INC     HL                            ; Move on
   182A 05            [ 4] 3820 DIGTXT: DEC     B                             ; Count digits before point
   182B 36 2E         [10] 3821         LD      (HL),'.                       ; Save point in case
   182D CC 73 16      [17] 3822         CALL    Z,INCHL                       ; Last digit - move on
   1830 C5            [11] 3823         PUSH    BC                            ; Save digits before point
   1831 E5            [11] 3824         PUSH    HL                            ; Save buffer address
   1832 D5            [11] 3825         PUSH    DE                            ; Save powers of ten
   1833 CD 69 16      [17] 3826         CALL    BCDEFP                        ; Move FPREG to BCDE
   1836 E1            [10] 3827         POP     HL                            ; Powers of ten table
   1837 06 2F         [ 7] 3828         LD      B,'0-1                        ; ASCII '0 - 1
   1839 04            [ 4] 3829 TRYAGN: INC     B                             ; Count subtractions
   183A 7B            [ 4] 3830         LD      A,E                           ; Get LSB
   183B 96            [ 7] 3831         SUB     (HL)                          ; Subtract LSB
   183C 5F            [ 4] 3832         LD      E,A                           ; Save LSB
   183D 23            [ 6] 3833         INC     HL
   183E 7A            [ 4] 3834         LD      A,D                           ; Get NMSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 71
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   183F 9E            [ 7] 3835         SBC     A,(HL)                        ; Subtract NMSB
   1840 57            [ 4] 3836         LD      D,A                           ; Save NMSB
   1841 23            [ 6] 3837         INC     HL
   1842 79            [ 4] 3838         LD      A,C                           ; Get MSB
   1843 9E            [ 7] 3839         SBC     A,(HL)                        ; Subtract MSB
   1844 4F            [ 4] 3840         LD      C,A                           ; Save MSB
   1845 2B            [ 6] 3841         DEC     HL                            ; Point back to start
   1846 2B            [ 6] 3842         DEC     HL
   1847 D2 39 18      [10] 3843         JP      NC,TRYAGN                     ; No overflow - Try again
   184A CD 7C 14      [17] 3844         CALL    PLUCDE                        ; Restore number
   184D 23            [ 6] 3845         INC     HL                            ; Start of next number
   184E CD 5E 16      [17] 3846         CALL    FPBCDE                        ; Move BCDE to FPREG
   1851 EB            [ 4] 3847         EX      DE,HL                         ; Save point in table
   1852 E1            [10] 3848         POP     HL                            ; Restore buffer address
   1853 70            [ 7] 3849         LD      (HL),B                        ; Save digit in buffer
   1854 23            [ 6] 3850         INC     HL                            ; And move on
   1855 C1            [10] 3851         POP     BC                            ; Restore digit count
   1856 0D            [ 4] 3852         DEC     C                             ; Count digits
   1857 C2 2A 18      [10] 3853         JP      NZ,DIGTXT                     ; More - Do them
   185A 05            [ 4] 3854         DEC     B                             ; Any decimal part?
   185B CA 6A 18      [10] 3855         JP      Z,DOEBIT                      ; No - Do 'E bit
   185E 2B            [ 6] 3856 SUPTLZ: DEC     HL                            ; Move back through buffer
   185F 7E            [ 7] 3857         LD      A,(HL)                        ; Get character
   1860 FE 30         [ 7] 3858         CP      '0                            ; '0 character?
   1862 CA 5E 18      [10] 3859         JP      Z,SUPTLZ                      ; Yes - Look back for more
   1865 FE 2E         [ 7] 3860         CP      '.                            ; A decimal point?
   1867 C4 73 16      [17] 3861         CALL    NZ,INCHL                      ; Move back over digit
                           3862 ;
   186A F1            [10] 3863 DOEBIT: POP     AF                            ; Get 'E flag
   186B CA 89 18      [10] 3864         JP      Z,NOENED                      ; No 'E needed - End buffer
   186E 36 45         [10] 3865         LD      (HL),'E                       ; Put 'E in buffer
   1870 23            [ 6] 3866         INC     HL                            ; And move on
   1871 36 2B         [10] 3867         LD      (HL),'+                       ; Put '+ in buffer
   1873 F2 7A 18      [10] 3868         JP      P,OUTEXP                      ; Positive - Output exponent
   1876 36 2D         [10] 3869         LD      (HL),'-                       ; Put '- in buffer
   1878 2F            [ 4] 3870         CPL                                   ; Negate exponent
   1879 3C            [ 4] 3871         INC     A
   187A 06 2F         [ 7] 3872 OUTEXP: LD      B,'0-1                        ; ASCII '0 - 1
   187C 04            [ 4] 3873 EXPTEN: INC     B                             ; Count subtractions
   187D D6 0A         [ 7] 3874         SUB     10                            ; Tens digit
   187F D2 7C 18      [10] 3875         JP      NC,EXPTEN                     ; More to do
   1882 C6 3A         [ 7] 3876         ADD     A,'0+10                       ; Restore and make ASCII
   1884 23            [ 6] 3877         INC     HL                            ; Move on
   1885 70            [ 7] 3878         LD      (HL),B                        ; Save MSB of exponent
   1886 23            [ 6] 3879 JSTZER: INC     HL                            ;
   1887 77            [ 7] 3880         LD      (HL),A                        ; Save LSB of exponent
   1888 23            [ 6] 3881         INC     HL
   1889 71            [ 7] 3882 NOENED: LD      (HL),C                        ; Mark end of buffer
   188A E1            [10] 3883         POP     HL                            ; Restore code string address
   188B C9            [10] 3884         RET
                           3885 ;
   188C 01 74 94      [10] 3886 RNGTST: LD      BC,0x9474                     ; BCDE = 999999.
   188F 11 F7 23      [10] 3887         LD      DE,0x23F7
   1892 CD 98 16      [17] 3888         CALL    CMPNUM                        ; Compare numbers
   1895 B7            [ 4] 3889         OR      A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 72
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1896 E1            [10] 3890         POP     HL                            ; Return address to HL
   1897 E2 F4 17      [10] 3891         JP      PO,GTSIXD                     ; Too big - Divide by ten
   189A E9            [ 4] 3892         JP      (HL)                          ; Otherwise return to caller
                           3893 ;
   189B 00 00 00 80        3894 HALF:   .db     0x00,0x00,0x00,0x80           ; 0.5
                           3895 ;
   189F A0 86 01           3896 POWERS: .db     0x0A0,0x086,0x001             ; 100000
   18A2 10 27 00           3897         .db     0x010,0x027,0x000             ; 10000
   18A5 E8 03 00           3898         .db     0x0E8,0x003,0x000             ; 1000
   18A8 64 00 00           3899         .db     0x064,0x000,0x000             ; 100
   18AB 0A 00 00           3900         .db     0x00A,0x000,0x000             ; 10
   18AE 01 00 00           3901         .db     0x001,0x000,0x000             ; 1
                           3902 ;
   18B1 21 46 16      [10] 3903 NEGAFT: LD      HL,INVSGN                     ; Negate result
   18B4 E3            [19] 3904         EX      (SP),HL                       ; To be done after caller
   18B5 E9            [ 4] 3905         JP      (HL)                          ; Return to caller
                           3906 ;
   18B6 CD 4E 16      [17] 3907 SQR:    CALL    STAKFP                        ; Put value on stack
   18B9 21 9B 18      [10] 3908         LD      HL,HALF                       ; Set power to 1/2
   18BC CD 5B 16      [17] 3909         CALL    PHLTFP                        ; Move 1/2 to FPREG
                           3910 ;
   18BF C1            [10] 3911 POWER:  POP     BC                            ; Get base
   18C0 D1            [10] 3912         POP     DE
   18C1 CD 1D 16      [17] 3913         CALL    TSTSGN                        ; Test sign of power
   18C4 78            [ 4] 3914         LD      A,B                           ; Get exponent of base
   18C5 CA 04 19      [10] 3915         JP      Z,EXP                         ; Make result 1 if zero
   18C8 F2 CF 18      [10] 3916         JP      P,POWER1                      ; Positive base - Ok
   18CB B7            [ 4] 3917         OR      A                             ; Zero to negative power?
   18CC CA 79 03      [10] 3918         JP      Z,DZERR                       ; Yes - ?/0 Error
   18CF B7            [ 4] 3919 POWER1: OR      A                             ; Base zero?
   18D0 CA 3E 14      [10] 3920         JP      Z,SAVEXP                      ; Yes - Return zero
   18D3 D5            [11] 3921         PUSH    DE                            ; Save base
   18D4 C5            [11] 3922         PUSH    BC
   18D5 79            [ 4] 3923         LD      A,C                           ; Get MSB of base
   18D6 F6 7F         [ 7] 3924         OR      0b01111111                    ; Get sign status
   18D8 CD 69 16      [17] 3925         CALL    BCDEFP                        ; Move power to BCDE
   18DB F2 EC 18      [10] 3926         JP      P,POWER2                      ; Positive base - Ok
   18DE D5            [11] 3927         PUSH    DE                            ; Save power
   18DF C5            [11] 3928         PUSH    BC
   18E0 CD F0 16      [17] 3929         CALL    INT                           ; Get integer of power
   18E3 C1            [10] 3930         POP     BC                            ; Restore power
   18E4 D1            [10] 3931         POP     DE
   18E5 F5            [11] 3932         PUSH    AF                            ; MSB of base
   18E6 CD 98 16      [17] 3933         CALL    CMPNUM                        ; Power an integer?
   18E9 E1            [10] 3934         POP     HL                            ; Restore MSB of base
   18EA 7C            [ 4] 3935         LD      A,H                           ; but don't affect flags
   18EB 1F            [ 4] 3936         RRA                                   ; Exponent odd or even?
   18EC E1            [10] 3937 POWER2: POP     HL                            ; Restore MSB and exponent
   18ED 22 2B 81      [16] 3938         LD      (FPREG+2),HL                  ; Save base in FPREG
   18F0 E1            [10] 3939         POP     HL                            ; LSBs of base
   18F1 22 29 81      [16] 3940         LD      (FPREG),HL                    ; Save in FPREG
   18F4 DC B1 18      [17] 3941         CALL    C,NEGAFT                      ; Odd power - Negate result
   18F7 CC 46 16      [17] 3942         CALL    Z,INVSGN                      ; Negative base - Negate it
   18FA D5            [11] 3943         PUSH    DE                            ; Save power
   18FB C5            [11] 3944         PUSH    BC
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 73
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   18FC CD D1 14      [17] 3945         CALL    LOG                           ; Get LOG of base
   18FF C1            [10] 3946         POP     BC                            ; Restore power
   1900 D1            [10] 3947         POP     DE
   1901 CD 12 15      [17] 3948         CALL    FPMULT                        ; Multiply LOG by power
                           3949 ;
   1904 CD 4E 16      [17] 3950 EXP:    CALL    STAKFP                        ; Put value on stack
   1907 01 38 81      [10] 3951         LD      BC,0x08138                    ; BCDE = 1/Ln(2)
   190A 11 3B AA      [10] 3952         LD      DE,0x0AA3B
   190D CD 12 15      [17] 3953         CALL    FPMULT                        ; Multiply value by 1/LN(2)
   1910 3A 2C 81      [13] 3954         LD      A,(FPEXP)                     ; Get exponent
   1913 FE 88         [ 7] 3955         CP      0x80+8                        ; Is it in range?
   1915 D2 F9 15      [10] 3956         JP      NC,OVTST1                     ; No - Test for overflow
   1918 CD F0 16      [17] 3957         CALL    INT                           ; Get INT of FPREG
   191B C6 80         [ 7] 3958         ADD     A,0x80                        ; For excess 128
   191D C6 02         [ 7] 3959         ADD     A,2                           ; Exponent > 126?
   191F DA F9 15      [10] 3960         JP      C,OVTST1                      ; Yes - Test for overflow
   1922 F5            [11] 3961         PUSH    AF                            ; Save scaling factor
   1923 21 C0 14      [10] 3962         LD      HL,UNITY                      ; Point to 1.
   1926 CD C8 13      [17] 3963         CALL    ADDPHL                        ; Add 1 to FPREG
   1929 CD 09 15      [17] 3964         CALL    MULLN2                        ; Multiply by LN(2)
   192C F1            [10] 3965         POP     AF                            ; Restore scaling factor
   192D C1            [10] 3966         POP     BC                            ; Restore exponent
   192E D1            [10] 3967         POP     DE
   192F F5            [11] 3968         PUSH    AF                            ; Save scaling factor
   1930 CD D4 13      [17] 3969         CALL    SUBCDE                        ; Subtract exponent from FPREG
   1933 CD 46 16      [17] 3970         CALL    INVSGN                        ; Negate result
   1936 21 44 19      [10] 3971         LD      HL,EXPTAB                     ; Coefficient table
   1939 CD 74 19      [17] 3972         CALL    SMSER1                        ; Sum the series
   193C 11 00 00      [10] 3973         LD      DE,0                          ; Zero LSBs
   193F C1            [10] 3974         POP     BC                            ; Scaling factor
   1940 4A            [ 4] 3975         LD      C,D                           ; Zero MSB
   1941 C3 12 15      [10] 3976         JP      FPMULT                        ; Scale result to correct value
                           3977 ;
   1944 08                 3978 EXPTAB: .db     8                             ; Table used by EXP
   1945 40 2E 94 74        3979         .db     0x040,0x02E,0x094,0x074       ; -1/7! (-1/5040)
   1949 70 4F 2E 77        3980         .db     0x070,0x04F,0x02E,0x077       ;  1/6! ( 1/720)
   194D 6E 02 88 7A        3981         .db     0x06E,0x002,0x088,0x07A       ; -1/5! (-1/120)
   1951 E6 A0 2A 7C        3982         .db     0x0E6,0x0A0,0x02A,0x07C       ;  1/4! ( 1/24)
   1955 50 AA AA 7E        3983         .db     0x050,0x0AA,0x0AA,0x07E       ; -1/3! (-1/6)
   1959 FF FF 7F 7F        3984         .db     0x0FF,0x0FF,0x07F,0x07F       ;  1/2! ( 1/2)
   195D 00 00 80 81        3985         .db     0x000,0x000,0x080,0x081       ; -1/1! (-1/1)
   1961 00 00 00 81        3986         .db     0x000,0x000,0x000,0x081       ;  1/0! ( 1/1)
                           3987 ;
   1965 CD 4E 16      [17] 3988 SUMSER: CALL    STAKFP                        ; Put FPREG on stack
   1968 11 10 15      [10] 3989         LD      DE,MULT                       ; Multiply by "X"
   196B D5            [11] 3990         PUSH    DE                            ; To be done after
   196C E5            [11] 3991         PUSH    HL                            ; Save address of table
   196D CD 69 16      [17] 3992         CALL    BCDEFP                        ; Move FPREG to BCDE
   1970 CD 12 15      [17] 3993         CALL    FPMULT                        ; Square the value
   1973 E1            [10] 3994         POP     HL                            ; Restore address of table
   1974 CD 4E 16      [17] 3995 SMSER1: CALL    STAKFP                        ; Put value on stack
   1977 7E            [ 7] 3996         LD      A,(HL)                        ; Get number of coefficients
   1978 23            [ 6] 3997         INC     HL                            ; Point to start of table
   1979 CD 5B 16      [17] 3998         CALL    PHLTFP                        ; Move coefficient to FPREG
   197C 06                 3999         .db     0x06                          ; Skip "POP AF"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 74
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   197D F1            [10] 4000 SUMLP:  POP     AF                            ; Restore count
   197E C1            [10] 4001         POP     BC                            ; Restore number
   197F D1            [10] 4002         POP     DE
   1980 3D            [ 4] 4003         DEC     A                             ; Cont coefficients
   1981 C8            [11] 4004         RET     Z                             ; All done
   1982 D5            [11] 4005         PUSH    DE                            ; Save number
   1983 C5            [11] 4006         PUSH    BC
   1984 F5            [11] 4007         PUSH    AF                            ; Save count
   1985 E5            [11] 4008         PUSH    HL                            ; Save address in table
   1986 CD 12 15      [17] 4009         CALL    FPMULT                        ; Multiply FPREG by BCDE
   1989 E1            [10] 4010         POP     HL                            ; Restore address in table
   198A CD 6C 16      [17] 4011         CALL    LOADFP                        ; Number at HL to BCDE
   198D E5            [11] 4012         PUSH    HL                            ; Save address in table
   198E CD D7 13      [17] 4013         CALL    FPADD                         ; Add coefficient to FPREG
   1991 E1            [10] 4014         POP     HL                            ; Restore address in table
   1992 C3 7D 19      [10] 4015         JP      SUMLP                         ; More coefficients
                           4016 ;
   1995 CD 1D 16      [17] 4017 RND:    CALL    TSTSGN                        ; Test sign of FPREG
   1998 21 5E 80      [10] 4018         LD      HL,SEED+2                     ; Random number seed
   199B FA F6 19      [10] 4019         JP      M,RESEED                      ; Negative - Re-seed
   199E 21 7F 80      [10] 4020         LD      HL,LSTRND                     ; Last random number
   19A1 CD 5B 16      [17] 4021         CALL    PHLTFP                        ; Move last RND to FPREG
   19A4 21 5E 80      [10] 4022         LD      HL,SEED+2                     ; Random number seed
   19A7 C8            [11] 4023         RET     Z                             ; Return if RND(0)
   19A8 86            [ 7] 4024         ADD     A,(HL)                        ; Add (SEED)+2)
   19A9 E6 07         [ 7] 4025         AND     0b00000111                    ; 0 to 7
   19AB 06 00         [ 7] 4026         LD      B,0
   19AD 77            [ 7] 4027         LD      (HL),A                        ; Re-save seed
   19AE 23            [ 6] 4028         INC     HL                            ; Move to coefficient table
   19AF 87            [ 4] 4029         ADD     A,A                           ; 4 bytes
   19B0 87            [ 4] 4030         ADD     A,A                           ; per entry
   19B1 4F            [ 4] 4031         LD      C,A                           ; BC = Offset into table
   19B2 09            [11] 4032         ADD     HL,BC                         ; Point to coefficient
   19B3 CD 6C 16      [17] 4033         CALL    LOADFP                        ; Coefficient to BCDE
   19B6 CD 12 15      [17] 4034         CALL    FPMULT                        ;	; Multiply FPREG by coefficient
   19B9 3A 5D 80      [13] 4035         LD      A,(SEED+1)                    ; Get (SEED+1)
   19BC 3C            [ 4] 4036         INC     A                             ; Add 1
   19BD E6 03         [ 7] 4037         AND     0b00000011                    ; 0 to 3
   19BF 06 00         [ 7] 4038         LD      B,0
   19C1 FE 01         [ 7] 4039         CP      1                             ; Is it zero?
   19C3 88            [ 4] 4040         ADC     A,B                           ; Yes - Make it 1
   19C4 32 5D 80      [13] 4041         LD      (SEED+1),A                    ; Re-save seed
   19C7 21 FA 19      [10] 4042         LD      HL,RNDTAB-4                   ; Addition table
   19CA 87            [ 4] 4043         ADD     A,A                           ; 4 bytes
   19CB 87            [ 4] 4044         ADD     A,A                           ; per entry
   19CC 4F            [ 4] 4045         LD      C,A                           ; BC = Offset into table
   19CD 09            [11] 4046         ADD     HL,BC                         ; Point to value
   19CE CD C8 13      [17] 4047         CALL    ADDPHL                        ; Add value to FPREG
   19D1 CD 69 16      [17] 4048 RND1:   CALL    BCDEFP                        ; Move FPREG to BCDE
   19D4 7B            [ 4] 4049         LD      A,E                           ; Get LSB
   19D5 59            [ 4] 4050         LD      E,C                           ; LSB = MSB
   19D6 EE 4F         [ 7] 4051         XOR     0b01001111                    ; Fiddle around
   19D8 4F            [ 4] 4052         LD      C,A                           ; New MSB
   19D9 36 80         [10] 4053         LD      (HL),0x80                     ; Set exponent
   19DB 2B            [ 6] 4054         DEC     HL                            ; Point to MSB
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 75
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   19DC 46            [ 7] 4055         LD      B,(HL)                        ; Get MSB
   19DD 36 80         [10] 4056         LD      (HL),0x80                     ; Make value -0.5
   19DF 21 5C 80      [10] 4057         LD      HL,SEED                       ; Random number seed
   19E2 34            [11] 4058         INC     (HL)                          ; Count seed
   19E3 7E            [ 7] 4059         LD      A,(HL)                        ; Get seed
   19E4 D6 AB         [ 7] 4060         SUB     171                           ; Do it modulo 171
   19E6 C2 ED 19      [10] 4061         JP      NZ,RND2                       ; Non-zero - Ok
   19E9 77            [ 7] 4062         LD      (HL),A                        ; Zero seed
   19EA 0C            [ 4] 4063         INC     C                             ; Fillde about
   19EB 15            [ 4] 4064         DEC     D                             ; with the
   19EC 1C            [ 4] 4065         INC     E                             ; number
   19ED CD 28 14      [17] 4066 RND2:   CALL    BNORM                         ; Normalise number
   19F0 21 7F 80      [10] 4067         LD      HL,LSTRND                     ; Save random number
   19F3 C3 75 16      [10] 4068         JP      FPTHL                         ; Move FPREG to last and return
                           4069 ;
   19F6 77            [ 7] 4070 RESEED: LD      (HL),A                        ; Re-seed random numbers
   19F7 2B            [ 6] 4071         DEC     HL
   19F8 77            [ 7] 4072         LD      (HL),A
   19F9 2B            [ 6] 4073         DEC     HL
   19FA 77            [ 7] 4074         LD      (HL),A
   19FB C3 D1 19      [10] 4075         JP      RND1                          ; Return RND seed
                           4076 ;
   19FE 68 B1 46 68        4077 RNDTAB: .db     0x068,0x0B1,0x046,0x068       ; Table used by RND
   1A02 99 E9 92 69        4078         .db     0x099,0x0E9,0x092,0x069
   1A06 10 D1 75 68        4079         .db     0x010,0x0D1,0x075,0x068
                           4080 ;
   1A0A 21 54 1A      [10] 4081 COS:    LD      HL,HALFPI                     ; Point to PI/2
   1A0D CD C8 13      [17] 4082         CALL    ADDPHL                        ; Add it to PPREG
   1A10 CD 4E 16      [17] 4083 SIN:    CALL    STAKFP                        ; Put angle on stack
   1A13 01 49 83      [10] 4084         LD      BC,0x8349                     ; BCDE = 2 PI
   1A16 11 DB 0F      [10] 4085         LD      DE,0x0FDB
   1A19 CD 5E 16      [17] 4086         CALL    FPBCDE                        ; Move 2 PI to FPREG
   1A1C C1            [10] 4087         POP     BC                            ; Restore angle
   1A1D D1            [10] 4088         POP     DE
   1A1E CD 73 15      [17] 4089         CALL    DVBCDE                        ; Divide angle by 2 PI
   1A21 CD 4E 16      [17] 4090         CALL    STAKFP                        ; Put it on stack
   1A24 CD F0 16      [17] 4091         CALL    INT                           ; Get INT of result
   1A27 C1            [10] 4092         POP     BC                            ; Restore number
   1A28 D1            [10] 4093         POP     DE
   1A29 CD D4 13      [17] 4094         CALL    SUBCDE                        ; Make it 0 <= value < 1
   1A2C 21 58 1A      [10] 4095         LD      HL,QUARTR                     ; Point to 0.25
   1A2F CD CE 13      [17] 4096         CALL    SUBPHL                        ; Subtract value from 0.25
   1A32 CD 1D 16      [17] 4097         CALL    TSTSGN                        ; Test sign of value
   1A35 37            [ 4] 4098         SCF                                   ; Flag positive
   1A36 F2 40 1A      [10] 4099         JP      P,SIN1                        ; Positive - Ok
   1A39 CD C5 13      [17] 4100         CALL    ROUND                         ; Add 0.5 to value
   1A3C CD 1D 16      [17] 4101         CALL    TSTSGN                        ; Test sign of value
   1A3F B7            [ 4] 4102         OR      A                             ; Flag negative
   1A40 F5            [11] 4103 SIN1:   PUSH    AF                            ; Save sign
   1A41 F4 46 16      [17] 4104         CALL    P,INVSGN                      ; Negate value if positive
   1A44 21 58 1A      [10] 4105         LD      HL,QUARTR                     ; Point to 0.25
   1A47 CD C8 13      [17] 4106         CALL    ADDPHL                        ; Add 0.25 to value
   1A4A F1            [10] 4107         POP     AF                            ; Restore sign
   1A4B D4 46 16      [17] 4108         CALL    NC,INVSGN                     ; Negative - Make positive
   1A4E 21 5C 1A      [10] 4109         LD      HL,SINTAB                     ; Coefficient table
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 76
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1A51 C3 65 19      [10] 4110         JP      SUMSER                        ; Evaluate sum of series
                           4111 ;
   1A54 DB 0F 49 81        4112 HALFPI: .db     0x0DB,0x00F,0x049,0x081       ; 1.5708 (PI/2)
                           4113 ;
   1A58 00 00 00 7F        4114 QUARTR: .db     0x000,0x000,0x000,0x07F       ; 0.25
                           4115 ;
   1A5C 05                 4116 SINTAB: .db     5                             ; Table used by SIN
   1A5D BA D7 1E 86        4117         .db     0x0BA,0x0D7,0x01E,0x086       ; 39.711
   1A61 64 26 99 87        4118         .db     0x064,0x026,0x099,0x087       ;-76.575
   1A65 58 34 23 87        4119         .db     0x058,0x034,0x023,0x087       ; 81.602
   1A69 E0 5D A5 86        4120         .db     0x0E0,0x05D,0x0A5,0x086       ;-41.342
   1A6D DA 0F 49 83        4121         .db     0x0DA,0x00F,0x049,0x083       ; 6.2832
                           4122 ;
   1A71 CD 4E 16      [17] 4123 TAN:    CALL    STAKFP                        ; Put angle on stack
   1A74 CD 10 1A      [17] 4124         CALL    SIN                           ; Get SIN of angle
   1A77 C1            [10] 4125         POP     BC                            ; Restore angle
   1A78 E1            [10] 4126         POP     HL
   1A79 CD 4E 16      [17] 4127         CALL    STAKFP                        ; Save SIN of angle
   1A7C EB            [ 4] 4128         EX      DE,HL                         ; BCDE = Angle
   1A7D CD 5E 16      [17] 4129         CALL    FPBCDE                        ; Angle to FPREG
   1A80 CD 0A 1A      [17] 4130         CALL    COS                           ; Get COS of angle
   1A83 C3 71 15      [10] 4131         JP      DIV                           ; TAN = SIN / COS
                           4132 ;
   1A86 CD 1D 16      [17] 4133 ATN:    CALL    TSTSGN                        ; Test sign of value
   1A89 FC B1 18      [17] 4134         CALL    M,NEGAFT                      ; Negate result after if -ve
   1A8C FC 46 16      [17] 4135         CALL    M,INVSGN                      ; Negate value if -ve
   1A8F 3A 2C 81      [13] 4136         LD      A,(FPEXP)                     ; Get exponent
   1A92 FE 81         [ 7] 4137         CP      0x81                          ; Number less than 1?
   1A94 DA A3 1A      [10] 4138         JP      C,ATN1                        ; Yes - Get arc tangnt
   1A97 01 00 81      [10] 4139         LD      BC,0x8100                     ; BCDE = 1
   1A9A 51            [ 4] 4140         LD      D,C
   1A9B 59            [ 4] 4141         LD      E,C
   1A9C CD 73 15      [17] 4142         CALL    DVBCDE                        ; Get reciprocal of number
   1A9F 21 CE 13      [10] 4143         LD      HL,SUBPHL                     ; Sub angle from PI/2
   1AA2 E5            [11] 4144         PUSH    HL                            ; Save for angle > 1
   1AA3 21 AD 1A      [10] 4145 ATN1:   LD      HL,ATNTAB                     ; Coefficient table
   1AA6 CD 65 19      [17] 4146         CALL    SUMSER                        ; Evaluate sum of series
   1AA9 21 54 1A      [10] 4147         LD      HL,HALFPI                     ; PI/2 - angle in case > 1
   1AAC C9            [10] 4148         RET                                   ; Number > 1 - Sub from PI/2
                           4149 ;
   1AAD 09                 4150 ATNTAB: .db     9                             ; Table used by ATN
   1AAE 4A D7 3B 78        4151         .db     0x04A,0x0D7,0x03B,0x078       ; 1/17
   1AB2 02 6E 84 7B        4152         .db     0x002,0x06E,0x084,0x07B       ;-1/15
   1AB6 FE C1 2F 7C        4153         .db     0x0FE,0x0C1,0x02F,0x07C       ; 1/13
   1ABA 74 31 9A 7D        4154         .db     0x074,0x031,0x09A,0x07D       ;-1/11
   1ABE 84 3D 5A 7D        4155         .db     0x084,0x03D,0x05A,0x07D       ; 1/9
   1AC2 C8 7F 91 7E        4156         .db     0x0C8,0x07F,0x091,0x07E       ;-1/7
   1AC6 E4 BB 4C 7E        4157         .db     0x0E4,0x0BB,0x04C,0x07E       ; 1/5
   1ACA 6C AA AA 7F        4158         .db     0x06C,0x0AA,0x0AA,0x07F       ;-1/3
   1ACE 00 00 00 81        4159         .db     0x000,0x000,0x000,0x081       ; 1/1
                           4160 ;
                           4161 
   1AD2 C9            [10] 4162 ARET:   RET                                   ; A RETurn instruction
                           4163 ;
   1AD3 D7            [11] 4164 GETINP: RST     0x10                          ;input a character
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 77
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1AD4 C9            [10] 4165         RET
                           4166 ;
   1AD5                    4167 CLS:
   1AD5 3E 0C         [ 7] 4168         LD      A,CS                          ; ASCII Clear screen
   1AD7 C3 0B 1C      [10] 4169         JP      MONOUT                        ; Output character
                           4170 ;
   1ADA CD 9C 13      [17] 4171 WIDTH:  CALL    GETINT                        ; Get integer 0-255
   1ADD 7B            [ 4] 4172         LD      A,E                           ; Width to A
   1ADE 32 87 80      [13] 4173         LD      (LWIDTH),A                    ; Set width
   1AE1 C9            [10] 4174         RET
                           4175 ;
   1AE2 CD 3B 0C      [17] 4176 LINES:  CALL    GETNUM                        ; Get a number
   1AE5 CD 80 08      [17] 4177         CALL    DEINT                         ; Get integer -32768 to 32767
   1AE8 ED 53 8B 80   [20] 4178         LD      (LINESC),DE                   ; Set lines counter
   1AEC ED 53 8D 80   [20] 4179         LD      (LINESN),DE                   ; Set lines number
   1AF0 C9            [10] 4180         RET
                           4181 ;
   1AF1 CD 80 08      [17] 4182 DEEK:   CALL    DEINT                         ; Get integer -32768 to 32767
   1AF4 D5            [11] 4183         PUSH    DE                            ; Save number
   1AF5 E1            [10] 4184         POP     HL                            ; Number to HL
   1AF6 46            [ 7] 4185         LD      B,(HL)                        ; Get LSB of contents
   1AF7 23            [ 6] 4186         INC     HL
   1AF8 7E            [ 7] 4187         LD      A,(HL)                        ; Get MSB of contents
   1AF9 C3 F6 0F      [10] 4188         JP      ABPASS                        ; Return integer AB
                           4189 ;
   1AFC CD 3B 0C      [17] 4190 DOKE:   CALL    GETNUM                        ; Get a number
   1AFF CD 80 08      [17] 4191         CALL    DEINT                         ; Get integer -32768 to 32767
   1B02 D5            [11] 4192         PUSH    DE                            ; Save address
   1B03 CD 44 06      [17] 4193         CALL    CHKSYN                        ; Make sure ', follows
   1B06 2C                 4194         .db     ',
   1B07 CD 3B 0C      [17] 4195         CALL    GETNUM                        ; Get a number
   1B0A CD 80 08      [17] 4196         CALL    DEINT                         ; Get integer -32768 to 32767
   1B0D E3            [19] 4197         EX      (SP),HL                       ; Save value,get address
   1B0E 73            [ 7] 4198         LD      (HL),E                        ; Save LSB of value
   1B0F 23            [ 6] 4199         INC     HL
   1B10 72            [ 7] 4200         LD      (HL),D                        ; Save MSB of value
   1B11 E1            [10] 4201         POP     HL                            ; Restore code string address
   1B12 C9            [10] 4202         RET
                           4203 ;
                           4204 
                           4205 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                           4206 ;
   1B13 CD 3E 0C      [17] 4207 HEX:    CALL    TSTNUM                        ; Verify it's a number
   1B16 CD 80 08      [17] 4208         CALL    DEINT                         ; Get integer -32768 to 32767
   1B19 C5            [11] 4209         PUSH    BC                            ; Save contents of BC
   1B1A 21 2E 81      [10] 4210         LD      HL,PBUFF
   1B1D 7A            [ 4] 4211         LD      A,D                           ; Get high order into A
   1B1E FE 00         [ 7] 4212         CP      0
   1B20 28 0C         [12] 4213         JR      Z,HEX2                        ; Skip output if both high digits are zero
   1B22 CD 4B 1B      [17] 4214         CALL    BYT2ASC                       ; Convert D to ASCII
   1B25 78            [ 4] 4215         LD      A,B
   1B26 FE 30         [ 7] 4216         CP      '0
   1B28 28 02         [12] 4217         JR      Z,HEX1                        ; Don't store high digit if zero
   1B2A 70            [ 7] 4218         LD      (HL),B                        ; Store it to PBUFF
   1B2B 23            [ 6] 4219         INC     HL                            ; Next location
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 78
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1B2C 71            [ 7] 4220 HEX1:   LD      (HL),C                        ; Store C to PBUFF+1
   1B2D 23            [ 6] 4221         INC     HL                            ; Next location
   1B2E 7B            [ 4] 4222 HEX2:   LD      A,E                           ; Get lower byte
   1B2F CD 4B 1B      [17] 4223         CALL    BYT2ASC                       ; Convert E to ASCII
   1B32 7A            [ 4] 4224         LD      A,D
   1B33 FE 00         [ 7] 4225         CP      0
   1B35 20 05         [12] 4226         JR      NZ,HEX3                       ; If upper byte was not zero then always print lower byte
   1B37 78            [ 4] 4227         LD      A,B
   1B38 FE 30         [ 7] 4228         CP      '0                            ; If high digit of lower byte is zero then don't print
   1B3A 28 02         [12] 4229         JR      Z,HEX4
   1B3C 70            [ 7] 4230 HEX3:   LD      (HL),B                        ; to PBUFF+2
   1B3D 23            [ 6] 4231         INC     HL                            ; Next location
   1B3E 71            [ 7] 4232 HEX4:   LD      (HL),C                        ; to PBUFF+3
   1B3F 23            [ 6] 4233         INC     HL                            ; PBUFF+4 to zero
   1B40 AF            [ 4] 4234         XOR     A                             ; Terminating character
   1B41 77            [ 7] 4235         LD      (HL),A                        ; Store zero to terminate
   1B42 23            [ 6] 4236         INC     HL                            ; Make sure PBUFF is terminated
   1B43 77            [ 7] 4237         LD      (HL),A                        ; Store the double zero there
   1B44 C1            [10] 4238         POP     BC                            ; Get BC back
   1B45 21 2E 81      [10] 4239         LD      HL,PBUFF                      ; Reset to start of PBUFF
   1B48 C3 A4 10      [10] 4240         JP      STR1                          ; Convert the PBUFF to a string and return it
                           4241 ;
   1B4B 47            [ 4] 4242 BYT2ASC:LD      B,A                           ; Save original value
   1B4C E6 0F         [ 7] 4243         AND     0x0F                          ; Strip off upper nybble
   1B4E FE 0A         [ 7] 4244         CP      0x0A                          ; 0-9?
   1B50 38 02         [12] 4245         JR      C,ADD30                       ; If A-F, add 7 more
   1B52 C6 07         [ 7] 4246         ADD     A,0x07                        ; Bring value up to ASCII A-F
   1B54 C6 30         [ 7] 4247 ADD30:  ADD     A,0x30                        ; And make ASCII
   1B56 4F            [ 4] 4248         LD      C,A                           ; Save converted char to C
   1B57 78            [ 4] 4249         LD      A,B                           ; Retrieve original value
   1B58 0F            [ 4] 4250         RRCA                                  ; and Rotate it right
   1B59 0F            [ 4] 4251         RRCA
   1B5A 0F            [ 4] 4252         RRCA
   1B5B 0F            [ 4] 4253         RRCA
   1B5C E6 0F         [ 7] 4254         AND     0x0F                          ; Mask off upper nybble
   1B5E FE 0A         [ 7] 4255         CP      0x0A                          ; 0-9? < A hex?
   1B60 38 02         [12] 4256         JR      C,ADD301                      ; Skip Add 7
   1B62 C6 07         [ 7] 4257         ADD     A,0x07                        ; Bring it up to ASCII A-F
   1B64 C6 30         [ 7] 4258 ADD301: ADD     A,0x30                        ; And make it full ASCII
   1B66 47            [ 4] 4259         LD      B,A                           ; Store high order byte
   1B67 C9            [10] 4260         RET
                           4261 ;
                           4262 ; Convert "&Hnnnn" to FPREG
                           4263 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                           4264 ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
   1B68 EB            [ 4] 4265 HEXTFP: EX      DE,HL                         ; Move code string pointer to DE
   1B69 21 00 00      [10] 4266         LD      HL,0x0000                     ; Zero out the value
   1B6C CD 81 1B      [17] 4267         CALL    GETHEX                        ; Check the number for valid hex
   1B6F DA A1 1B      [10] 4268         JP      C,HXERR                       ; First value wasn't hex, HX error
   1B72 18 05         [12] 4269         JR      HEXLP1                        ; Convert first character
   1B74 CD 81 1B      [17] 4270 HEXLP:  CALL    GETHEX                        ; Get second and addtional characters
   1B77 38 1F         [12] 4271         JR      C,HEXIT                       ; Exit if not a hex character
   1B79 29            [11] 4272 HEXLP1: ADD     HL,HL                         ; Rotate 4 bits to the left
   1B7A 29            [11] 4273         ADD     HL,HL
   1B7B 29            [11] 4274         ADD     HL,HL
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 79
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1B7C 29            [11] 4275         ADD     HL,HL
   1B7D B5            [ 4] 4276         OR      L                             ; Add in D0-D3 into L
   1B7E 6F            [ 4] 4277         LD      L,A                           ; Save new value
   1B7F 18 F3         [12] 4278         JR      HEXLP                         ; And continue until all hex characters are in
                           4279 ;
   1B81 13            [ 6] 4280 GETHEX: INC     DE                            ; Next location
   1B82 1A            [ 7] 4281         LD      A,(DE)                        ; Load character at pointer
   1B83 FE 20         [ 7] 4282         CP      0x20
   1B85 CA 81 1B      [10] 4283         JP      Z,GETHEX                      ; Skip spaces
   1B88 D6 30         [ 7] 4284         SUB     0x30                          ; Get absolute value
   1B8A D8            [11] 4285         RET     C                             ; < "0", error
   1B8B FE 0A         [ 7] 4286         CP      0x0A
   1B8D 38 05         [12] 4287         JR      C,NOSUB7                      ; Is already in the range 0-9
   1B8F D6 07         [ 7] 4288         SUB     0x07                          ; Reduce to A-F
   1B91 FE 0A         [ 7] 4289         CP      0x0A                          ; Value should be $0A-$0F at this point
   1B93 D8            [11] 4290         RET     C                             ; CY set if was :		; < = > ? @
   1B94 FE 10         [ 7] 4291 NOSUB7: CP      0x10                          ; > Greater than "F"?
   1B96 3F            [ 4] 4292         CCF
   1B97 C9            [10] 4293         RET                                   ; CY set if it wasn't valid hex
                           4294 
   1B98 EB            [ 4] 4295 HEXIT:  EX      DE,HL                         ; Value into DE, Code string into HL
   1B99 7A            [ 4] 4296         LD      A,D                           ; Load DE into AC
   1B9A 4B            [ 4] 4297         LD      C,E                           ; For prep to
   1B9B E5            [11] 4298         PUSH    HL
   1B9C CD F5 0F      [17] 4299         CALL    ACPASS                        ; ACPASS to set AC as integer into FPREG
   1B9F E1            [10] 4300         POP     HL
   1BA0 C9            [10] 4301         RET
                           4302 ;
   1BA1 1E 26         [ 7] 4303 HXERR:  LD      E,HX                          ; ?HEX Error
   1BA3 C3 8A 03      [10] 4304         JP      ERROR
                           4305 ;
                           4306 ; BIN$(NN) Convert integer to a 1-16 char binary string
   1BA6 CD 3E 0C      [17] 4307 BIN:    CALL    TSTNUM                        ; Verify it's a number
   1BA9 CD 80 08      [17] 4308         CALL    DEINT                         ; Get integer -32768 to 32767
   1BAC C5            [11] 4309 BIN2:   PUSH    BC                            ; Save contents of BC
   1BAD 21 2E 81      [10] 4310         LD      HL,PBUFF
   1BB0 06 11         [ 7] 4311         LD      B,17                          ; One higher than max char count
   1BB2                    4312 ZEROSUP:                                      ; Suppress leading zeros
   1BB2 05            [ 4] 4313         DEC     B                             ; Max 16 chars
   1BB3 78            [ 4] 4314         LD      A,B
   1BB4 FE 01         [ 7] 4315         CP      0x01
   1BB6 28 08         [12] 4316         JR      Z,BITOUT                      ; Always output at least one character
   1BB8 CB 13         [ 8] 4317         RL      E
   1BBA CB 12         [ 8] 4318         RL      D
   1BBC 30 F4         [12] 4319         JR      NC,ZEROSUP
   1BBE 18 04         [12] 4320         JR      BITOUT2
   1BC0                    4321 BITOUT:
   1BC0 CB 13         [ 8] 4322         RL      E
   1BC2 CB 12         [ 8] 4323         RL      D                             ; Top bit now in carry
   1BC4                    4324 BITOUT2:
   1BC4 3E 30         [ 7] 4325         LD      A,'0                          ; Char for '0
   1BC6 CE 00         [ 7] 4326         ADC     A,0                           ; If carry set then '0 --> '1
   1BC8 77            [ 7] 4327         LD      (HL),A
   1BC9 23            [ 6] 4328         INC     HL
   1BCA 05            [ 4] 4329         DEC     B
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 80
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1BCB 20 F3         [12] 4330         JR      NZ,BITOUT
   1BCD AF            [ 4] 4331         XOR     A                             ; Terminating character
   1BCE 77            [ 7] 4332         LD      (HL),A                        ; Store zero to terminate
   1BCF 23            [ 6] 4333         INC     HL                            ; Make sure PBUFF is terminated
   1BD0 77            [ 7] 4334         LD      (HL),A                        ; Store the double zero there
   1BD1 C1            [10] 4335         POP     BC
   1BD2 21 2E 81      [10] 4336         LD      HL,PBUFF
   1BD5 C3 A4 10      [10] 4337         JP      STR1
                           4338 ;
                           4339 ; Convert "&Bnnnn" to FPREG
                           4340 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
   1BD8 EB            [ 4] 4341 BINTFP: EX      DE,HL                         ; Move code string pointer to DE
   1BD9 21 00 00      [10] 4342         LD      HL,0x0000                     ; Zero out the value
   1BDC CD F5 1B      [17] 4343         CALL    CHKBIN                        ; Check the number for valid bin
   1BDF DA 03 1C      [10] 4344         JP      C,BINERR                      ; First value wasn't bin, HX error
   1BE2 D6 30         [ 7] 4345 BINIT:  SUB     '0
   1BE4 29            [11] 4346         ADD     HL,HL                         ; Rotate HL left
   1BE5 B5            [ 4] 4347         OR      L
   1BE6 6F            [ 4] 4348         LD      L,A
   1BE7 CD F5 1B      [17] 4349         CALL    CHKBIN                        ; Get second and addtional characters
   1BEA 30 F6         [12] 4350         JR      NC,BINIT                      ; Process if a bin character
   1BEC EB            [ 4] 4351         EX      DE,HL                         ; Value into DE, Code string into HL
   1BED 7A            [ 4] 4352         LD      A,D                           ; Load DE into AC
   1BEE 4B            [ 4] 4353         LD      C,E                           ; For prep to
   1BEF E5            [11] 4354         PUSH    HL
   1BF0 CD F5 0F      [17] 4355         CALL    ACPASS                        ; ACPASS to set AC as integer into FPREG
   1BF3 E1            [10] 4356         POP     HL
   1BF4 C9            [10] 4357         RET
                           4358 ;
                           4359 ; Char is in A, NC if char is 0 or 1
   1BF5 13            [ 6] 4360 CHKBIN: INC     DE
   1BF6 1A            [ 7] 4361         LD      A,(DE)
   1BF7 FE 20         [ 7] 4362         CP      0x20
   1BF9 CA F5 1B      [10] 4363         JP      Z,CHKBIN                      ; Skip spaces
   1BFC FE 30         [ 7] 4364         CP      '0                            ; Set C if < '0
   1BFE D8            [11] 4365         RET     C
   1BFF FE 32         [ 7] 4366         CP      '2
   1C01 3F            [ 4] 4367         CCF                                   ; Set C if > '1
   1C02 C9            [10] 4368         RET
                           4369 ;
   1C03 1E 28         [ 7] 4370 BINERR: LD      E,BN                          ; ?BIN Error
   1C05 C3 8A 03      [10] 4371         JP      ERROR
                           4372 ;
   1C08 C3 51 00      [10] 4373 JJUMP1: JP      CSTART                        ; Go and initialise
                           4374 ;
   1C0B C3 08 00      [10] 4375 MONOUT: JP      0x0008                        ; output a char
                           4376 ;
   1C0E C3 00 00      [10] 4377 MONITR: JP      0x0000                        ; Restart (Normally Monitor Start)
                           4378 ;
   1C11 3E 00         [ 7] 4379 INITST: LD      A,0                           ; Clear break flag
   1C13 32 92 80      [13] 4380         LD      (BRKFLG),A
   1C16 C3 58 00      [10] 4381         JP      INIT
                           4382 ;
   1C19 F5            [11] 4383 TSTBIT: PUSH    AF                            ; Save bit mask
   1C1A A0            [ 4] 4384         AND     B                             ; Get common bits
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 81
Hexadecimal [16-Bits]                                 Mon Mar 10 22:59:40 2025



   1C1B C1            [10] 4385         POP     BC                            ; Restore bit mask
   1C1C B8            [ 4] 4386         CP      B                             ; Same bit set?
   1C1D 3E 00         [ 7] 4387         LD      A,0                           ; Return 0 in A
   1C1F C9            [10] 4388         RET
                           4389 ;
   1C20 CD 4F 06      [17] 4390 OUTNCR: CALL    OUTC                          ; Output character in A
   1C23 C3 76 0A      [10] 4391         JP      PRCRLF                        ; Output CRLF
                           4392 ;
                           4393         .end
