ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 1
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



                              1         .area   TEST (ABS)
                              2 ;	EMUBASIC based on GRANT's BASIC
                              3 ;	TARGET: EMUZ80
                              4 ;	ASSEMBLER: ARCPIT XZ80.EXE
                              5 ;
                              6 ;	START UP ROUTINE
                              7 ;	VERSION 1.0, 2022/02/15
                              8 ;	WRITTEN by TETSUYA SUZUKI
                              9 ;
                             10 ;	MEMORY ASIGN
                     0000    11 ROMTOP  .equ    0x0000
                     8000    12 RAMTOP  .equ    0x8000
                     1000    13 RAMSIZ  .equ    0x1000
                     80ED    14 TSTACK  .equ    0x80ED
                             15 ;
                             16 ;	UART REGISTER ADDRESS
                     E000    17 UARTDR  .equ    0x0E000                       ; UART DATA REGISTOR
                     E001    18 UARTCR  .equ    0x0E001                       ; UART CONTROL REGISTOR
                             19 ;
                             20 ;	RESET (RST 00H)
   0000                      21         .org    ROMTOP
   0000 F3            [ 4]   22         DI
   0001 31 ED 80      [10]   23         LD      SP,TSTACK
   0004 C3 41 00      [10]   24         JP      SINIT
                             25 ;
                             26 ;	PUT 1CHAR (RST 08H)
   0008                      27         .org    ROMTOP+0x08
   0008 C3 34 00      [10]   28         JP      TXA
                             29 ;
                             30 ;	GET 1CHAR (RST 10H)
   0010                      31         .org    ROMTOP+0x10
   0010 C3 1B 00      [10]   32         JP      RXA
                             33 ;
                             34 ;	KBHIT (RST 18H)
   0018                      35         .org    ROMTOP+0x18
   0018 C3 2E 00      [10]   36         JP      KBHIT
                             37 ;
                             38 ;	UART -> A
   001B 3A 01 E0      [13]   39 RXA:    LD      A,(UARTCR)
   001E CB 47         [ 8]   40         BIT     0,A
   0020 28 F9         [12]   41         JR      Z,RXA
   0022 3A 00 E0      [13]   42         LD      A,(UARTDR)
   0025 FE 61         [ 7]   43         CP      'a
   0027 D8            [11]   44         RET     C
   0028 FE 7B         [ 7]   45         CP      'z+1
   002A D0            [11]   46         RET     NC
   002B E6 DF         [ 7]   47         AND     0x0DF
   002D C9            [10]   48         RET
                             49 ;
                             50 ;	CHECK RECEIVE STATUS
   002E 3A 01 E0      [13]   51 KBHIT:  LD      A,(UARTCR)
   0031 CB 47         [ 8]   52         BIT     0,A
   0033 C9            [10]   53         RET
                             54 ;
                             55 ;	A -> UART
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 2
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0034 F5            [11]   56 TXA:    PUSH    AF
   0035 3A 01 E0      [13]   57 TXAST1: LD      A,(UARTCR)
   0038 CB 4F         [ 8]   58         BIT     1,A
   003A 28 F9         [12]   59         JR      Z,TXAST1
   003C F1            [10]   60         POP     AF
   003D 32 00 E0      [13]   61         LD      (UARTDR),A
   0040 C9            [10]   62         RET
                             63 ;
                             64 ;
                             65 ;	SYSTEM INITIALIZE
   0041                      66 SINIT:
   0041 C3 44 00      [10]   67         JP      COLD
                             68 ;
                             69 ;==================================================================================
                             70 ; The updates to the original BASIC within this file are copyright Grant Searle
                             71 ;
                             72 ; You have permission to use this for NON COMMERCIAL USE ONLY
                             73 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                             74 ;
                             75 ; http://searle.hostei.com/grant/index.html
                             76 ;
                             77 ; eMail: home.micros01@btinternet.com
                             78 ;
                             79 ; If the above don't work, please perform an Internet search to see if I have
                             80 ; updated the web page hosting service.
                             81 ;
                             82 ;==================================================================================
                             83 ;
                             84 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                             85 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                             86 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                             87 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                             88 ; the original ROM code (checksum A934H). PA
                             89 ;
                             90 ; GENERAL EQUATES
                             91 ;
                     0003    92 CTRLC   .equ    0x03                          ; Control "C"
                     0007    93 CTRLG   .equ    0x07                          ; Control "G"
                     0008    94 BKSP    .equ    0x08                          ; Back space
                     000A    95 LF      .equ    0x0A                          ; Line feed
                     000C    96 CS      .equ    0x0C                          ; Clear screen
                     000D    97 CR      .equ    0x0D                          ; Carriage return
                     000F    98 CTRLO   .equ    0x0F                          ; Control "O"
                     0011    99 CTRLQ   .equ    0x11                          ; Control "Q"
                     0012   100 CTRLR   .equ    0x12                          ; Control "R"
                     0013   101 CTRLS   .equ    0x13                          ; Control "S"
                     0015   102 CTRLU   .equ    0x15                          ; Control "U"
                     001B   103 ESC     .equ    0x1B                          ; Escape
                     007F   104 DEL     .equ    0x7F                          ; Delete
                            105 ;
                            106 ; BASIC WORK SPACE LOCATIONS
                            107 ;
                     8045   108 WRKSPC  .equ    0x8045                        ; BASIC Work space
                     8048   109 USR     .equ    WRKSPC+0x3                    ; "USR (x)" jump
                     804B   110 OUTSUB  .equ    WRKSPC+0x6                    ; "OUT p,n"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 3
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



                     804C   111 OTPORT  .equ    WRKSPC+0x7                    ; Port (p)
                     804E   112 DIVSUP  .equ    WRKSPC+0x9                    ; Division support routine
                     804F   113 DIV1    .equ    WRKSPC+0x0A                   ; <- Values
                     8053   114 DIV2    .equ    WRKSPC+0x0E                   ; <- to
                     8057   115 DIV3    .equ    WRKSPC+0x12                   ; <- be
                     805A   116 DIV4    .equ    WRKSPC+0x15                   ; <- inserted
                     805C   117 SEED    .equ    WRKSPC+0x17                   ; Random number seed
                     807F   118 LSTRND  .equ    WRKSPC+0x3A                   ; Last random number
                     8083   119 INPSUB  .equ    WRKSPC+0x3E                   ; #INP (x)" Routine
                     8084   120 INPORT  .equ    WRKSPC+0x3F                   ; PORT (x)
                     8086   121 NULLS   .equ    WRKSPC+0x41                   ; Number of nulls
                     8087   122 LWIDTH  .equ    WRKSPC+0x42                   ; Terminal width
                     8088   123 COMMAN  .equ    WRKSPC+0x43                   ; Width for commas
                     8089   124 NULFLG  .equ    WRKSPC+0x44                   ; Null after input byte flag
                     808A   125 CTLOFG  .equ    WRKSPC+0x45                   ; Control "O" flag
                     808B   126 LINESC  .equ    WRKSPC+0x46                   ; Lines counter
                     808D   127 LINESN  .equ    WRKSPC+0x48                   ; Lines number
                     808F   128 CHKSUM  .equ    WRKSPC+0x4A                   ; Array load/save check sum
                     8091   129 NMIFLG  .equ    WRKSPC+0x4C                   ; Flag for NMI break routine
                     8092   130 BRKFLG  .equ    WRKSPC+0x4D                   ; Break flag
                     8093   131 RINPUT  .equ    WRKSPC+0x4E                   ; Input reflection
                     8096   132 POINT   .equ    WRKSPC+0x51                   ; "POINT" reflection (unused)
                     8099   133 PSET    .equ    WRKSPC+0x54                   ; "SET"	reflection
                     809C   134 RESET   .equ    WRKSPC+0x57                   ; "RESET" reflection
                     809F   135 STRSPC  .equ    WRKSPC+0x5A                   ; Bottom of string space
                     80A1   136 LINEAT  .equ    WRKSPC+0x5C                   ; Current line number
                     80A3   137 BASTXT  .equ    WRKSPC+0x5E                   ; Pointer to start of program
                     80A6   138 BUFFER  .equ    WRKSPC+0x61                   ; Input buffer
                     80AB   139 STACK   .equ    WRKSPC+0x66                   ; Initial stack
                     80F0   140 CURPOS  .equ    WRKSPC+0x0AB                  ; Character position on line
                     80F1   141 LCRFLG  .equ    WRKSPC+0x0AC                  ; Locate/Create flag
                     80F2   142 TYPE    .equ    WRKSPC+0x0AD                  ; Data type flag
                     80F3   143 DATFLG  .equ    WRKSPC+0x0AE                  ; Literal statement flag
                     80F4   144 LSTRAM  .equ    WRKSPC+0x0AF                  ; Last available RAM
                     80F6   145 TMSTPT  .equ    WRKSPC+0x0B1                  ; Temporary string pointer
                     80F8   146 TMSTPL  .equ    WRKSPC+0x0B3                  ; Temporary string pool
                     8104   147 TMPSTR  .equ    WRKSPC+0x0BF                  ; Temporary string
                     8108   148 STRBOT  .equ    WRKSPC+0x0C3                  ; Bottom of string space
                     810A   149 CUROPR  .equ    WRKSPC+0x0C5                  ; Current operator in EVAL
                     810C   150 LOOPST  .equ    WRKSPC+0x0C7                  ; First statement of loop
                     810E   151 DATLIN  .equ    WRKSPC+0x0C9                  ; Line of current DATA item
                     8110   152 FORFLG  .equ    WRKSPC+0x0CB                  ; "FOR" loop flag
                     8111   153 LSTBIN  .equ    WRKSPC+0x0CC                  ; Last byte entered
                     8112   154 READFG  .equ    WRKSPC+0x0CD                  ; Read/Input flag
                     8113   155 BRKLIN  .equ    WRKSPC+0x0CE                  ; Line of break
                     8115   156 NXTOPR  .equ    WRKSPC+0x0D0                  ; Next operator in EVAL
                     8117   157 ERRLIN  .equ    WRKSPC+0x0D2                  ; Line of error
                     8119   158 CONTAD  .equ    WRKSPC+0x0D4                  ; Where to CONTinue
                     811B   159 PROGND  .equ    WRKSPC+0x0D6                  ; End of program
                     811D   160 VAREND  .equ    WRKSPC+0x0D8                  ; End of variables
                     811F   161 ARREND  .equ    WRKSPC+0x0DA                  ; End of arrays
                     8121   162 NXTDAT  .equ    WRKSPC+0x0DC                  ; Next data item
                     8123   163 FNRGNM  .equ    WRKSPC+0x0DE                  ; Name of FN argument
                     8125   164 FNARG   .equ    WRKSPC+0x0E0                  ; FN argument value
                     8129   165 FPREG   .equ    WRKSPC+0x0E4                  ; Floating point register
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 4
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



                     812C   166 FPEXP   .equ    FPREG+3                       ; Floating point exponent
                     812D   167 SGNRES  .equ    WRKSPC+0x0E8                  ; Sign of result
                     812E   168 PBUFF   .equ    WRKSPC+0x0E9                  ; Number print buffer
                     813B   169 MULVAL  .equ    WRKSPC+0x0F6                  ; Multiplier
                     813E   170 PROGST  .equ    WRKSPC+0x0F9                  ; Start of program text area
                     81A2   171 STLOOK  .equ    WRKSPC+0x15D                  ; Start of memory test
                            172 ;
                            173 ; BASIC ERROR CODE VALUES
                            174 ;
                     0000   175 NF      .equ    0x00                          ; NEXT without FOR
                     0002   176 SN      .equ    0x02                          ; Syntax error
                     0004   177 RG      .equ    0x04                          ; RETURN without GOSUB
                     0006   178 OD      .equ    0x06                          ; Out of DATA
                     0008   179 FC      .equ    0x08                          ; Function call error
                     000A   180 OV      .equ    0x0A                          ; Overflow
                     000C   181 OM      .equ    0x0C                          ; Out of memory
                     000E   182 UL      .equ    0x0E                          ; Undefined line number
                     0010   183 BS      .equ    0x10                          ; Bad subscript
                     0012   184 RD      .equ    0x12                          ; Re-DIMensioned array
                     0014   185 DZ      .equ    0x14                          ; Division by zero (/0)
                     0016   186 ID      .equ    0x16                          ; Illegal direct
                     0018   187 TM      .equ    0x18                          ; Type miss-match
                     001A   188 OS      .equ    0x1A                          ; Out of string space
                     001C   189 LS      .equ    0x1C                          ; String too long
                     001E   190 ST      .equ    0x1E                          ; String formula too complex
                     0020   191 CN      .equ    0x20                          ; Can't CONTinue
                     0022   192 UF      .equ    0x22                          ; UnDEFined FN function
                     0024   193 MO      .equ    0x24                          ; Missing operand
                     0026   194 HX      .equ    0x26                          ; HEX error
                     0028   195 BN      .equ    0x28                          ; BIN error
                            196 ;
   0044 C3 4A 00      [10]  197 COLD:   JP      STARTB                        ; Jump for cold start
   0047 C3 BF 00      [10]  198 WARM:   JP      WARMST                        ; Jump for warm start
   004A C3 51 00      [10]  199 STARTB: JP      CSTART                        ; Jump to initialise
                            200 ;
   004D 02 09               201         .dw     DEINT                         ; Get integer -32768 to 32767
   004F 78 10               202         .dw     ABPASS                        ; Return integer in AB
                            203 ;
   0051 21 45 80      [10]  204 CSTART: LD      HL,WRKSPC                     ; Start of workspace RAM
   0054 F9            [ 6]  205         LD      SP,HL                         ; Set up a temporary stack
   0055 C3 93 1C      [10]  206         JP      INITST                        ; Go to initialise
                            207 ;
   0058 11 29 03      [10]  208 INIT:   LD      DE,INITAB                     ; Initialise workspace
   005B 06 63         [ 7]  209         LD      B,INITBE-INITAB+3             ; Bytes to copy
   005D 21 45 80      [10]  210         LD      HL,WRKSPC                     ; Into workspace RAM
   0060 1A            [ 7]  211 COPY:   LD      A,(DE)                        ; Get source
   0061 77            [ 7]  212         LD      (HL),A                        ; To destination
   0062 23            [ 6]  213         INC     HL                            ; Next destination
   0063 13            [ 6]  214         INC     DE                            ; Next source
   0064 05            [ 4]  215         DEC     B                             ; Count bytes
   0065 C2 60 00      [10]  216         JP      NZ,COPY                       ; More to move
   0068 F9            [ 6]  217         LD      SP,HL                         ; Temporary stack
   0069 CD 2A 05      [17]  218         CALL    CLREG                         ; Clear registers and stack
   006C CD F8 0A      [17]  219         CALL    PRCRLF                        ; Output CRLF
   006F 32 EF 80      [13]  220         LD      (BUFFER+72+1),A               ; Mark end of buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 5
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0072 32 3E 81      [13]  221         LD      (PROGST),A                    ; Initialise program area
   0075 21 A2 81      [10]  222 MSIZE:  LD      HL,STLOOK                     ; Point to start of RAM
   0078 23            [ 6]  223 MLOOP:  INC     HL                            ; Next byte
   0079 7C            [ 4]  224         LD      A,H                           ; Above address FFFF ?
   007A B5            [ 4]  225         OR      L
   007B CA 87 00      [10]  226         JP      Z,SETTOP                      ; Yes - 64K RAM
   007E 7E            [ 7]  227         LD      A,(HL)                        ; Get contents
   007F 47            [ 4]  228         LD      B,A                           ; Save it
   0080 2F            [ 4]  229         CPL                                   ; Flip all bits
   0081 77            [ 7]  230         LD      (HL),A                        ; Put it back
   0082 BE            [ 7]  231         CP      (HL)                          ; RAM there if same
   0083 70            [ 7]  232         LD      (HL),B                        ; Restore old contents
   0084 CA 78 00      [10]  233         JP      Z,MLOOP                       ; If RAM - test next byte
                            234 ;
   0087 2B            [ 6]  235 SETTOP: DEC     HL                            ; Back one byte
   0088 11 A1 81      [10]  236         LD      DE,STLOOK-1                   ; See if enough RAM
   008B CD C0 06      [17]  237         CALL    CPDEHL                        ; Compare DE with HL
   008E DA C8 00      [10]  238         JP      C,NEMEM                       ; If not enough RAM
   0091 11 CE FF      [10]  239         LD      DE,0-50                       ; 50 Bytes string space
   0094 22 F4 80      [16]  240         LD      (LSTRAM),HL                   ; Save last available RAM
   0097 19            [11]  241         ADD     HL,DE                         ; Allocate string space
   0098 22 9F 80      [16]  242         LD      (STRSPC),HL                   ; Save string space
   009B CD 05 05      [17]  243         CALL    CLRPTR                        ; Clear program area
   009E 2A 9F 80      [16]  244         LD      HL,(STRSPC)                   ; Get end of memory
   00A1 11 EF FF      [10]  245         LD      DE,0-17                       ; Offset for free bytes
   00A4 19            [11]  246         ADD     HL,DE                         ; Adjust HL
   00A5 11 3E 81      [10]  247         LD      DE,PROGST                     ; Start of program text
   00A8 7D            [ 4]  248         LD      A,L                           ; Get LSB
   00A9 93            [ 4]  249         SUB     E                             ; Adjust it
   00AA 6F            [ 4]  250         LD      L,A                           ; Re-save
   00AB 7C            [ 4]  251         LD      A,H                           ; Get MSB
   00AC 9A            [ 4]  252         SBC     A,D                           ; Adjust it
   00AD 67            [ 4]  253         LD      H,A                           ; Re-save
   00AE E5            [11]  254         PUSH    HL                            ; Save bytes free
   00AF 21 E0 00      [10]  255         LD      HL,SIGNON                     ; Sign-on message
   00B2 CD 96 11      [17]  256         CALL    PRS                           ; Output string
   00B5 E1            [10]  257         POP     HL                            ; Get bytes free back
   00B6 CD 39 18      [17]  258         CALL    PRNTHL                        ; Output amount of free memory
   00B9 21 D1 00      [10]  259         LD      HL,BFREE                      ; " Bytes free" message
   00BC CD 96 11      [17]  260         CALL    PRS                           ; Output string
                            261 ;
   00BF 31 AB 80      [10]  262 WARMST: LD      SP,STACK                      ; Temporary stack
   00C2 CD 2A 05      [17]  263 BRKRET: CALL    CLREG                         ; Clear registers and stack
   00C5 C3 43 04      [10]  264         JP      PRNTOK                        ; Go to get command line
                            265 ;
   00C8 21 17 01      [10]  266 NEMEM:  LD      HL,MEMMSG                     ; Memory size not enough
   00CB CD 96 11      [17]  267         CALL    PRS                           ; Print it
   00CE C3 CE 00      [10]  268 XXXXX:  JP      XXXXX                         ; Stop
                            269 ;
   00D1 20 42 79 74 65 73   270 BFREE:  .ascii  " Bytes free"
        20 66 72 65 65
   00DC 0D 0A 00 00         271         .db     CR,LF,0,0
                            272 ;
   00E0 5A 38 30 20 42 41   273 SIGNON: .ascii  "Z80 BASIC Ver 4.7b"
        53 49 43 20 56 65
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 6
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



        72 20 34 2E 37 62
   00F2 0D 0A               274         .db     CR,LF
   00F4 43 6F 70 79 72 69   275         .ascii  "Copyright "
        67 68 74 20
   00FE 28                  276         .db     40
   00FF 43                  277         .ascii  "C"
   0100 29                  278         .db     41
   0101 20 31 39 37 38 20   279         .ascii  " 1978 by Microsoft"
        62 79 20 4D 69 63
        72 6F 73 6F 66 74
   0113 0D 0A 00 00         280         .db     CR,LF,0,0
                            281 ;
   0117 4D 65 6D 6F 72 79   282 MEMMSG: .ascii  "Memory size not enough"
        20 73 69 7A 65 20
        6E 6F 74 20 65 6E
        6F 75 67 68
   012D 0D 0A               283         .db     CR,LF
   012F 54 68 65 20 73 79   284         .ascii  "The system is stopped."
        73 74 65 6D 20 69
        73 20 73 74 6F 70
        70 65 64 2E
   0145 0D 0A 00 00         285         .db     CR,LF,0,0
                            286 ;
                            287 ; FUNCTION ADDRESS TABLE
                            288 ;
   0149 AE 16               289 FNCTAB: .dw     SGN
   014B 72 17               290         .dw     INT
   014D C4 16               291         .dw     ABS
   014F 48 80               292         .dw     USR
   0151 56 10               293         .dw     FRE
   0153 DB 13               294         .dw     INP
   0155 84 10               295         .dw     POS
   0157 38 19               296         .dw     SQR
   0159 17 1A               297         .dw     RND
   015B 53 15               298         .dw     LOG
   015D 86 19               299         .dw     EXP
   015F 8C 1A               300         .dw     COS
   0161 92 1A               301         .dw     SIN
   0163 F3 1A               302         .dw     TAN
   0165 08 1B               303         .dw     ATN
   0167 2F 14               304         .dw     PEEK
   0169 73 1B               305         .dw     DEEK
   016B 96 80               306         .dw     POINT
   016D 08 13               307         .dw     LEN
   016F 20 11               308         .dw     STR
   0171 A2 13               309         .dw     VAL
   0173 17 13               310         .dw     ASC
   0175 28 13               311         .dw     CHR
   0177 95 1B               312         .dw     HEX
   0179 28 1C               313         .dw     BIN
   017B 38 13               314         .dw     LEFT
   017D 68 13               315         .dw     RIGHT
   017F 72 13               316         .dw     MID
                            317 ;
                            318 ; RESERVED WORD LIST
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 7
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



                            319 ;
   0181 C5                  320 WORDS:  .db     0x0C5
   0182 4E 44               321         .ascii  "ND"
   0184 C6                  322         .db     0x0C6
   0185 4F 52               323         .ascii  "OR"
   0187 CE                  324         .db     0x0CE
   0188 45 58 54            325         .ascii  "EXT"
   018B C4                  326         .db     0x0C4
   018C 41 54 41            327         .ascii  "ATA"
   018F C9                  328         .db     0x0C9
   0190 4E 50 55 54         329         .ascii  "NPUT"
   0194 C4                  330         .db     0x0C4
   0195 49 4D               331         .ascii  "IM"
   0197 D2                  332         .db     0x0D2
   0198 45 41 44            333         .ascii  "EAD"
   019B CC                  334         .db     0x0CC
   019C 45 54               335         .ascii  "ET"
   019E C7                  336         .db     0x0C7
   019F 4F 54 4F            337         .ascii  "OTO"
   01A2 D2                  338         .db     0x0D2
   01A3 55 4E               339         .ascii  "UN"
   01A5 C9                  340         .db     0x0C9
   01A6 46                  341         .ascii  "F"
   01A7 D2                  342         .db     0x0D2
   01A8 45 53 54 4F 52 45   343         .ascii  "ESTORE"
   01AE C7                  344         .db     0x0C7
   01AF 4F 53 55 42         345         .ascii  "OSUB"
   01B3 D2                  346         .db     0x0D2
   01B4 45 54 55 52 4E      347         .ascii  "ETURN"
   01B9 D2                  348         .db     0x0D2
   01BA 45 4D               349         .ascii  "EM"
   01BC D3                  350         .db     0x0D3
   01BD 54 4F 50            351         .ascii  "TOP"
   01C0 CF                  352         .db     0x0CF
   01C1 55 54               353         .ascii  "UT"
   01C3 CF                  354         .db     0x0CF
   01C4 4E                  355         .ascii  "N"
   01C5 CE                  356         .db     0x0CE
   01C6 55 4C 4C            357         .ascii  "ULL"
   01C9 D7                  358         .db     0x0D7
   01CA 41 49 54            359         .ascii  "AIT"
   01CD C4                  360         .db     0x0C4
   01CE 45 46               361         .ascii  "EF"
   01D0 D0                  362         .db     0x0D0
   01D1 4F 4B 45            363         .ascii  "OKE"
   01D4 C4                  364         .db     0x0C4
   01D5 4F 4B 45            365         .ascii  "OKE"
   01D8 D3                  366         .db     0x0D3
   01D9 43 52 45 45 4E      367         .ascii  "CREEN"
   01DE CC                  368         .db     0x0CC
   01DF 49 4E 45 53         369         .ascii  "INES"
   01E3 C3                  370         .db     0x0C3
   01E4 4C 53               371         .ascii  "LS"
   01E6 D7                  372         .db     0x0D7
   01E7 49 44 54 48         373         .ascii  "IDTH"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 8
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   01EB CD                  374         .db     0x0CD
   01EC 4F 4E 49 54 4F 52   375         .ascii  "ONITOR"
   01F2 D3                  376         .db     0x0D3
   01F3 45 54               377         .ascii  "ET"
   01F5 D2                  378         .db     0x0D2
   01F6 45 53 45 54         379         .ascii  "ESET"
   01FA D0                  380         .db     0x0D0
   01FB 52 49 4E 54         381         .ascii  "RINT"
   01FF C3                  382         .db     0x0C3
   0200 4F 4E 54            383         .ascii  "ONT"
   0203 CC                  384         .db     0x0CC
   0204 49 53 54            385         .ascii  "IST"
   0207 C3                  386         .db     0x0C3
   0208 4C 45 41 52         387         .ascii  "LEAR"
   020C C3                  388         .db     0x0C3
   020D 4C 4F 41 44         389         .ascii  "LOAD"
   0211 C3                  390         .db     0x0C3
   0212 53 41 56 45         391         .ascii  "SAVE"
   0216 CE                  392         .db     0x0CE
   0217 45 57               393         .ascii  "EW"
                            394 ;
   0219 D4                  395         .db     0x0D4
   021A 41 42 28            396         .ascii  "AB("
   021D D4                  397         .db     0x0D4
   021E 4F                  398         .ascii  "O"
   021F C6                  399         .db     0x0C6
   0220 4E                  400         .ascii  "N"
   0221 D3                  401         .db     0x0D3
   0222 50 43 28            402         .ascii  "PC("
   0225 D4                  403         .db     0x0D4
   0226 48 45 4E            404         .ascii  "HEN"
   0229 CE                  405         .db     0x0CE
   022A 4F 54               406         .ascii  "OT"
   022C D3                  407         .db     0x0D3
   022D 54 45 50            408         .ascii  "TEP"
                            409 ;
   0230 0B                  410         .db     0x0A0b
   0231 AD                  411         .db     0x0AD
   0232 AA                  412         .db     0x0AA
   0233 AF                  413         .db     0x0AF
   0234 DE                  414         .db     0x0DE
   0235 C1                  415         .db     0x0C1
   0236 4E 44               416         .ascii  "ND"
   0238 CF                  417         .db     0x0CF
   0239 52                  418         .ascii  "R"
   023A BE                  419         .db     0x0BE
   023B BD                  420         .db     0x0BD
   023C BC                  421         .db     0x0BC
                            422 ;
   023D D3                  423         .db     0x0D3
   023E 47 4E               424         .ascii  "GN"
   0240 C9                  425         .db     0x0C9
   0241 4E 54               426         .ascii  "NT"
   0243 C1                  427         .db     0x0C1
   0244 42 53               428         .ascii  "BS"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                  Page 9
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0246 D5                  429         .db     0x0D5
   0247 53 52               430         .ascii  "SR"
   0249 C6                  431         .db     0x0C6
   024A 52 45               432         .ascii  "RE"
   024C C9                  433         .db     0x0C9
   024D 4E 50               434         .ascii  "NP"
   024F D0                  435         .db     0x0D0
   0250 4F 53               436         .ascii  "OS"
   0252 D3                  437         .db     0x0D3
   0253 51 52               438         .ascii  "QR"
   0255 D2                  439         .db     0x0D2
   0256 4E 44               440         .ascii  "ND"
   0258 CC                  441         .db     0x0CC
   0259 4F 47               442         .ascii  "OG"
   025B C5                  443         .db     0x0C5
   025C 58 50               444         .ascii  "XP"
   025E C3                  445         .db     0x0C3
   025F 4F 53               446         .ascii  "OS"
   0261 D3                  447         .db     0x0D3
   0262 49 4E               448         .ascii  "IN"
   0264 D4                  449         .db     0x0D4
   0265 41 4E               450         .ascii  "AN"
   0267 C1                  451         .db     0x0C1
   0268 54 4E               452         .ascii  "TN"
   026A D0                  453         .db     0x0D0
   026B 45 45 4B            454         .ascii  "EEK"
   026E C4                  455         .db     0x0C4
   026F 45 45 4B            456         .ascii  "EEK"
   0272 D0                  457         .db     0x0D0
   0273 4F 49 4E 54         458         .ascii  "OINT"
   0277 CC                  459         .db     0x0CC
   0278 45 4E               460         .ascii  "EN"
   027A D3                  461         .db     0x0D3
   027B 54 52 24            462         .ascii  "TR$"
   027E D6                  463         .db     0x0D6
   027F 41 4C               464         .ascii  "AL"
   0281 C1                  465         .db     0x0C1
   0282 53 43               466         .ascii  "SC"
   0284 C3                  467         .db     0x0C3
   0285 48 52 24            468         .ascii  "HR$"
   0288 C8                  469         .db     0x0C8
   0289 45 58 24            470         .ascii  "EX$"
   028C C2                  471         .db     0x0C2
   028D 49 4E 24            472         .ascii  "IN$"
   0290 CC                  473         .db     0x0CC
   0291 45 46 54 24         474         .ascii  "EFT$"
   0295 D2                  475         .db     0x0D2
   0296 49 47 48 54 24      476         .ascii  "IGHT$"
   029B CD                  477         .db     0x0CD
   029C 49 44 24            478         .ascii  "ID$"
   029F 80                  479         .db     0x80                          ; End of list marker
                            480 ;
                            481 ; KEYWORD ADDRESS TABLE
                            482 ;
   02A0 9A 08               483 WORDTB: .dw     PEND
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 10
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   02A2 97 07               484         .dw     FOR
   02A4 72 0C               485         .dw     NEXT
   02A6 E7 09               486         .dw     DATA
   02A8 79 0B               487         .dw     INPUT
   02AA AE 0E               488         .dw     DIM
   02AC A8 0B               489         .dw     READ
   02AE FE 09               490         .dw     LET
   02B0 A4 09               491         .dw     GOTO
   02B2 87 09               492         .dw     RUN
   02B4 76 0A               493         .dw     IF
   02B6 60 08               494         .dw     RESTOR
   02B8 93 09               495         .dw     GOSUB
   02BA C2 09               496         .dw     RETURN
   02BC E9 09               497         .dw     REM
   02BE 98 08               498         .dw     STOP
   02C0 E7 13               499         .dw     POUT
   02C2 58 0A               500         .dw     ON
   02C4 D9 08               501         .dw     NULL
   02C6 ED 13               502         .dw     WAIT
   02C8 8C 10               503         .dw     DEF
   02CA 36 14               504         .dw     POKE
   02CC 7E 1B               505         .dw     DOKE
   02CE E9 09               506         .dw     REM
   02D0 64 1B               507         .dw     LINES
   02D2 57 1B               508         .dw     CLS
   02D4 5C 1B               509         .dw     WIDTH
   02D6 90 1C               510         .dw     MONITR
   02D8 99 80               511         .dw     PSET
   02DA 9C 80               512         .dw     RESET
   02DC 9A 0A               513         .dw     PRINT
   02DE C6 08               514         .dw     CONT
   02E0 0C 07               515         .dw     LIST
   02E2 41 09               516         .dw     CLEAR
   02E4 E9 09               517         .dw     REM
   02E6 E9 09               518         .dw     REM
   02E8 04 05               519         .dw     NEW
                            520 ;
                            521 ; RESERVED WORD TOKEN VALUES
                            522 ;
                     0080   523 ZEND    .equ    0x080                         ; END
                     0081   524 ZFOR    .equ    0x081                         ; FOR
                     0083   525 ZDATA   .equ    0x083                         ; DATA
                     0088   526 ZGOTO   .equ    0x088                         ; GOTO
                     008C   527 ZGOSUB  .equ    0x08C                         ; GOSUB
                     008E   528 ZREM    .equ    0x08E                         ; REM
                     009E   529 ZPRINT  .equ    0x09E                         ; PRINT
                     00A4   530 ZNEW    .equ    0x0A4                         ; NEW
                            531 ;
                     00A5   532 ZTAB    .equ    0x0A5                         ; TAB
                     00A6   533 ZTO     .equ    0x0A6                         ; TO
                     00A7   534 ZFN     .equ    0x0A7                         ; FN
                     00A8   535 ZSPC    .equ    0x0A8                         ; SPC
                     00A9   536 ZTHEN   .equ    0x0A9                         ; THEN
                     00AA   537 ZNOT    .equ    0x0AA                         ; NOT
                     00AB   538 ZSTEP   .equ    0x0AB                         ; STEP
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 11
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



                            539 ;
                     00AC   540 ZPLUS   .equ    0x0AC                         ; +
                     00AD   541 ZMINUS  .equ    0x0AD                         ; -
                     00AE   542 ZTIMES  .equ    0x0AE                         ; *
                     00AF   543 ZDIV    .equ    0x0AF                         ; /
                     00B2   544 ZOR     .equ    0x0B2                         ; OR
                     00B3   545 ZGTR    .equ    0x0B3                         ; >
                     00B4   546 ZEQUAL  .equ    0x0B4                         ; M
                     00B5   547 ZLTH    .equ    0x0B5                         ; <
                     00B6   548 ZSGN    .equ    0x0B6                         ; SGN
                     00C7   549 ZPOINT  .equ    0x0C7                         ; POINT
                     00CF   550 ZLEFT   .equ    0x0CD+2                       ; LEFT.
                            551 ;
                            552 ; ARITHMETIC PRECEDENCE TABLE
                            553 ;
   02EA 79                  554 PRITAB: .db     0x79                          ; Precedence value
   02EB 20 18               555         .dw     PADD                          ; FPREG = <last> + FPREG
                            556 ;
   02ED 79                  557         .db     0x79                          ; Precedence value
   02EE 54 14               558         .dw     PSUB                          ; FPREG = <last> - FPREG
                            559 ;
   02F0 7C                  560         .db     0x7C                          ; Precedence value
   02F1 92 15               561         .dw     MULT                          ; PPREG = <last> * FPREG
                            562 ;
   02F3 7C                  563         .db     0x7C                          ; Precedence value
   02F4 F3 15               564         .dw     DIV                           ; FPREG = <last> / FPREG
                            565 ;
   02F6 7F                  566         .db     0x7F                          ; Precedence value
   02F7 41 19               567         .dw     POWER                         ; FPREG = <last> ^ FPREG
                            568 ;
   02F9 50                  569         .db     0x50                          ; Precedence value
   02FA 07 0E               570         .dw     PAND                          ; FPREG = <last> AND FPREG
                            571 ;
   02FC 46                  572         .db     0x46                          ; Precedence value
   02FD 06 0E               573         .dw     POR                           ; FPREG = <last> OR FPREG
                            574 ;
                            575 ; BASIC ERROR CODE LIST
                            576 ;
   02FF 4E 46               577 ERRORS: .ascii  "NF"                              ; NEXT without FOR
   0301 53 4E               578         .ascii  "SN"                              ; Syntax error
   0303 52 47               579         .ascii  "RG"                              ; RETURN without GOSUB
   0305 4F 44               580         .ascii  "OD"                              ; Out of DATA
   0307 46 43               581         .ascii  "FC"                              ; Illegal function call
   0309 4F 56               582         .ascii  "OV"                              ; Overflow error
   030B 4F 4D               583         .ascii  "OM"                              ; Out of memory
   030D 55 4C               584         .ascii  "UL"                              ; Undefined line
   030F 42 53               585         .ascii  "BS"                              ; Bad subscript
   0311 44 44               586         .ascii  "DD"                              ; Re-DIMensioned array
   0313 2F 30               587         .ascii  "/0"                              ; Division by zero
   0315 49 44               588         .ascii  "ID"                              ; Illegal direct
   0317 54 4D               589         .ascii  "TM"                              ; Type mis-match
   0319 4F 53               590         .ascii  "OS"                              ; Out of string space
   031B 4C 53               591         .ascii  "LS"                              ; String too long
   031D 53 54               592         .ascii  "ST"                              ; String formula too complex
   031F 43 4E               593         .ascii  "CN"                              ; Can't CONTinue
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 12
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0321 55 46               594         .ascii  "UF"                              ; Undefined FN function
   0323 4D 4F               595         .ascii  "MO"                              ; Missing operand
   0325 48 58               596         .ascii  "HX"                              ; HEX error
   0327 42 4E               597         .ascii  "BN"                              ; BIN error
                            598 ;
                            599 ; INITIALISATION TABLE -------------------------------------------------------
                            600 ;
   0329 C3 BF 00      [10]  601 INITAB: JP      WARMST                        ; Warm start jump
   032C C3 17 09      [10]  602         JP      FCERR                         ; "USR (X)" jump (Set to Error)
   032F D3 00         [11]  603         OUT     (0),A                         ; "OUT p,n" skeleton
   0331 C9            [10]  604         RET
   0332 D6 00         [ 7]  605         SUB     0                             ; Division support routine
   0334 6F            [ 4]  606         LD      L,A
   0335 7C            [ 4]  607         LD      A,H
   0336 DE 00         [ 7]  608         SBC     A,0
   0338 67            [ 4]  609         LD      H,A
   0339 78            [ 4]  610         LD      A,B
   033A DE 00         [ 7]  611         SBC     A,0
   033C 47            [ 4]  612         LD      B,A
   033D 3E 00         [ 7]  613         LD      A,0
   033F C9            [10]  614         RET
   0340 00 00 00            615         .db     0,0,0                         ; Random number seed table used by RND
   0343 35 4A CA 99         616         .db     0x035,0x04A,0x0CA,0x099       ;-2.65145E+07
   0347 39 1C 76 98         617         .db     0x039,0x01C,0x076,0x098       ; 1.61291E+07
   034B 22 95 B3 98         618         .db     0x022,0x095,0x0B3,0x098       ;-1.17691E+07
   034F 0A DD 47 98         619         .db     0x00A,0x0DD,0x047,0x098       ; 1.30983E+07
   0353 53 D1 99 99         620         .db     0x053,0x0D1,0x099,0x099       ;-2-01612E+07
   0357 0A 1A 9F 98         621         .db     0x00A,0x01A,0x09F,0x098       ;-1.04269E+07
   035B 65 BC CD 98         622         .db     0x065,0x0BC,0x0CD,0x098       ;-1.34831E+07
   035F D6 77 3E 98         623         .db     0x0D6,0x077,0x03E,0x098       ; 1.24825E+07
   0363 52 C7 4F 80         624         .db     0x052,0x0C7,0x04F,0x080       ; Last random number
   0367 DB 00         [11]  625         IN      A,(0)                         ; INP (x) skeleton
   0369 C9            [10]  626         RET
   036A 01                  627         .db     1                             ; POS (x) number (1)
   036B FF                  628         .db     255                           ; Terminal width (255 = no auto CRLF)
   036C 1C                  629         .db     28                            ; Width for commas (3 columns)
   036D 00                  630         .db     0                             ; No nulls after input bytes
   036E 00                  631         .db     0                             ; Output enabled (^O off)
   036F 14 00               632         .dw     20                            ; Initial lines counter
   0371 14 00               633         .dw     20                            ; Initial lines number
   0373 00 00               634         .dw     0                             ; Array load/save check sum
   0375 00                  635         .db     0                             ; Break not by NMI
   0376 00                  636         .db     0                             ; Break flag
   0377 C3 3D 06      [10]  637         JP      TTYLIN                        ; Input reflection (set to TTY)
   037A C3 00 00      [10]  638         JP      0x0000                        ; POINT reflection unused
   037D C3 00 00      [10]  639         JP      0x0000                        ; SET reflection
   0380 C3 00 00      [10]  640         JP      0x0000                        ; RESET reflection
   0383 A2 81               641         .dw     STLOOK                        ; Temp string space
   0385 FE FF               642         .dw     -2                            ; Current line number (cold)
   0387 3F 81               643         .dw     PROGST+1                      ; Start of program text
   0389                     644 INITBE:
                            645 ;
                            646 ; END OF INITIALISATION TABLE ---------------------------------------------------
                            647 ;
   0389 20 45 72 72 6F 72   648 ERRMSG: .ascii  " Error"
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 13
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   038F 00                  649         .db     0
   0390 20 69 6E 20         650 INMSG:  .ascii  " in "
   0394 00                  651         .db     0
                     0394   652 ZERBYT  .equ    .-1                           ; A zero byte
   0395 4F 6B               653 OKMSG:  .ascii  "Ok"
   0397 0D 0A 00 00         654         .db     CR,LF,0,0
   039B 42 72 65 61 6B      655 BRKMSG: .ascii  "Break"
   03A0 00                  656         .db     0
                            657 ;
   03A1 21 04 00      [10]  658 BAKSTK: LD      HL,4                          ; Look for "FOR" block with
   03A4 39            [11]  659         ADD     HL,SP                         ; same index as specified
   03A5 7E            [ 7]  660 LOKFOR: LD      A,(HL)                        ; Get block ID
   03A6 23            [ 6]  661         INC     HL                            ; Point to index address
   03A7 FE 81         [ 7]  662         CP      ZFOR                          ; Is it a "FOR" token
   03A9 C0            [11]  663         RET     NZ                            ; No - exit
   03AA 4E            [ 7]  664         LD      C,(HL)                        ; BC = Address of "FOR" index
   03AB 23            [ 6]  665         INC     HL
   03AC 46            [ 7]  666         LD      B,(HL)
   03AD 23            [ 6]  667         INC     HL                            ; Point to sign of STEP
   03AE E5            [11]  668         PUSH    HL                            ; Save pointer to sign
   03AF 69            [ 4]  669         LD      L,C                           ; HL = address of "FOR" index
   03B0 60            [ 4]  670         LD      H,B
   03B1 7A            [ 4]  671         LD      A,D                           ; See if an index was specified
   03B2 B3            [ 4]  672         OR      E                             ; DE = 0 if no index specified
   03B3 EB            [ 4]  673         EX      DE,HL                         ; Specified index into HL
   03B4 CA BB 03      [10]  674         JP      Z,INDFND                      ; Skip if no index given
   03B7 EB            [ 4]  675         EX      DE,HL                         ; Index back into DE
   03B8 CD C0 06      [17]  676         CALL    CPDEHL                        ; Compare index with one given
   03BB 01 0D 00      [10]  677 INDFND: LD      BC,16-3                       ; Offset to next block
   03BE E1            [10]  678         POP     HL                            ; Restore pointer to sign
   03BF C8            [11]  679         RET     Z                             ; Return if block found
   03C0 09            [11]  680         ADD     HL,BC                         ; Point to next block
   03C1 C3 A5 03      [10]  681         JP      LOKFOR                        ; Keep on looking
                            682 ;
   03C4 CD DE 03      [17]  683 MOVUP:  CALL    ENFMEM                        ; See if enough memory
   03C7 C5            [11]  684 MOVSTR: PUSH    BC                            ; Save end of source
   03C8 E3            [19]  685         EX      (SP),HL                       ; Swap source and dest" end
   03C9 C1            [10]  686         POP     BC                            ; Get end of destination
   03CA CD C0 06      [17]  687 MOVLP:  CALL    CPDEHL                        ; See if list moved
   03CD 7E            [ 7]  688         LD      A,(HL)                        ; Get byte
   03CE 02            [ 7]  689         LD      (BC),A                        ; Move it
   03CF C8            [11]  690         RET     Z                             ; Exit if all done
   03D0 0B            [ 6]  691         DEC     BC                            ; Next byte to move to
   03D1 2B            [ 6]  692         DEC     HL                            ; Next byte to move
   03D2 C3 CA 03      [10]  693         JP      MOVLP                         ; Loop until all bytes moved
                            694 ;
   03D5 E5            [11]  695 CHKSTK: PUSH    HL                            ; Save code string address
   03D6 2A 1F 81      [16]  696         LD      HL,(ARREND)                   ; Lowest free memory
   03D9 06 00         [ 7]  697         LD      B,0                           ; BC = Number of levels to test
   03DB 09            [11]  698         ADD     HL,BC                         ; 2 Bytes for 0xeac level
   03DC 09            [11]  699         ADD     HL,BC
   03DD 3E                  700         .db     0x3E                          ; Skip "PUSH HL"
   03DE E5            [11]  701 ENFMEM: PUSH    HL                            ; Save code string address
   03DF 3E D0         [ 7]  702         LD      A,0x0D0                       ; LOW -48; 48 Bytes minimum RAM
   03E1 95            [ 4]  703         SUB     L
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 14
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   03E2 6F            [ 4]  704         LD      L,A
   03E3 3E FF         [ 7]  705         LD      A,0x0FF                       ; HIGH (-48); 48 Bytes minimum RAM
   03E5 9C            [ 4]  706         SBC     A,H
   03E6 DA ED 03      [10]  707         JP      C,OMERR                       ; Not enough - ?OM Error
   03E9 67            [ 4]  708         LD      H,A
   03EA 39            [11]  709         ADD     HL,SP                         ; Test if stack is overflowed
   03EB E1            [10]  710         POP     HL                            ; Restore code string address
   03EC D8            [11]  711         RET     C                             ; Return if enough mmory
   03ED 1E 0C         [ 7]  712 OMERR:  LD      E,OM                          ; ?OM Error
   03EF C3 0C 04      [10]  713         JP      ERROR
                            714 ;
   03F2 2A 0E 81      [16]  715 DATSNR: LD      HL,(DATLIN)                   ; Get line of current DATA item
   03F5 22 A1 80      [16]  716         LD      (LINEAT),HL                   ; Save as current line
   03F8 1E 02         [ 7]  717 SNERR:  LD      E,SN                          ; ?SN Error
   03FA 01                  718         .db     0x01                          ; Skip "LD E,DZ"
   03FB 1E 14         [ 7]  719 DZERR:  LD      E,DZ                          ; ?/0 Error
   03FD 01                  720         .db     0x01                          ; Skip "LD E,NF"
   03FE 1E 00         [ 7]  721 NFERR:  LD      E,NF                          ; ?NF Error
   0400 01                  722         .db     0x01                          ; Skip "LD E,RD"
   0401 1E 12         [ 7]  723 DDERR:  LD      E,RD                          ; ?DD Error
   0403 01                  724         .db     0x01                          ; Skip "LD E,UF"
   0404 1E 22         [ 7]  725 UFERR:  LD      E,UF                          ; ?UF Error
   0406 01                  726         .db     0x01                          ; Skip "LD E,OV"
   0407 1E 0A         [ 7]  727 OVERR:  LD      E,OV                          ; ?OV Error
   0409 01                  728         .db     0x01                          ; Skip "LD E,TM"
   040A 1E 18         [ 7]  729 TMERR:  LD      E,TM                          ; ?TM Error
                            730 ;
   040C CD 2A 05      [17]  731 ERROR:  CALL    CLREG                         ; Clear registers and stack
   040F 32 8A 80      [13]  732         LD      (CTLOFG),A                    ; Enable output (A is 0)
   0412 CD EB 0A      [17]  733         CALL    STTLIN                        ; Start new line
   0415 21 FF 02      [10]  734         LD      HL,ERRORS                     ; Point to error codes
   0418 57            [ 4]  735         LD      D,A                           ; D = 0 (A is 0)
   0419 3E 3F         [ 7]  736         LD      A,'?
   041B CD D1 06      [17]  737         CALL    OUTC                          ; Output '?
   041E 19            [11]  738         ADD     HL,DE                         ; Offset to correct error code
   041F 7E            [ 7]  739         LD      A,(HL)                        ; First character
   0420 CD D1 06      [17]  740         CALL    OUTC                          ; Output it
   0423 CD 50 08      [17]  741         CALL    GETCHR                        ; Get next character
   0426 CD D1 06      [17]  742         CALL    OUTC                          ; Output it
   0429 21 89 03      [10]  743         LD      HL,ERRMSG                     ; "Error" message
   042C CD 96 11      [17]  744 ERRIN:  CALL    PRS                           ; Output message
   042F 2A A1 80      [16]  745         LD      HL,(LINEAT)                   ; Get line of error
   0432 11 FE FF      [10]  746         LD      DE,-2                         ; Cold start error if -2
   0435 CD C0 06      [17]  747         CALL    CPDEHL                        ; See if cold start error
   0438 CA 51 00      [10]  748         JP      Z,CSTART                      ; Cold start error - Restart
   043B 7C            [ 4]  749         LD      A,H                           ; Was it a direct error?
   043C A5            [ 4]  750         AND     L                             ; Line = -1 if direct error
   043D 3C            [ 4]  751         INC     A
   043E C4 31 18      [17]  752         CALL    NZ,LINEIN                     ; No - output line of error
   0441 3E                  753         .db     0x3E                          ; Skip "POP BC"
   0442 C1            [10]  754 POPNOK: POP     BC                            ; Drop address in input buffer
                            755 ;
   0443 AF            [ 4]  756 PRNTOK: XOR     A                             ; Output "Ok" and get command
   0444 32 8A 80      [13]  757         LD      (CTLOFG),A                    ; Enable output
   0447 CD EB 0A      [17]  758         CALL    STTLIN                        ; Start new line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 15
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   044A 21 95 03      [10]  759         LD      HL,OKMSG                      ; "Ok" message
   044D CD 96 11      [17]  760         CALL    PRS                           ; Output "Ok"
   0450 21 FF FF      [10]  761 GETCMD: LD      HL,-1                         ; Flag direct mode
   0453 22 A1 80      [16]  762         LD      (LINEAT),HL                   ; Save as current line
   0456 CD 3D 06      [17]  763         CALL    GETLIN                        ; Get an input line
   0459 DA 50 04      [10]  764         JP      C,GETCMD                      ; Get line again if break
   045C CD 50 08      [17]  765         CALL    GETCHR                        ; Get first character
   045F 3C            [ 4]  766         INC     A                             ; Test if end of line
   0460 3D            [ 4]  767         DEC     A                             ; Without affecting Carry
   0461 CA 50 04      [10]  768         JP      Z,GETCMD                      ; Nothing entered - Get another
   0464 F5            [11]  769         PUSH    AF                            ; Save Carry status
   0465 CD 1C 09      [17]  770         CALL    ATOH                          ; Get line number into DE
   0468 D5            [11]  771         PUSH    DE                            ; Save line number
   0469 CD 54 05      [17]  772         CALL    CRUNCH                        ; Tokenise rest of line
   046C 47            [ 4]  773         LD      B,A                           ; Length of tokenised line
   046D D1            [10]  774         POP     DE                            ; Restore line number
   046E F1            [10]  775         POP     AF                            ; Restore Carry
   046F D2 30 08      [10]  776         JP      NC,EXCUTE                     ; No line number - Direct mode
   0472 D5            [11]  777         PUSH    DE                            ; Save line number
   0473 C5            [11]  778         PUSH    BC                            ; Save length of tokenised line
   0474 AF            [ 4]  779         XOR     A
   0475 32 11 81      [13]  780         LD      (LSTBIN),A                    ; Clear last byte input
   0478 CD 50 08      [17]  781         CALL    GETCHR                        ; Get next character
   047B B7            [ 4]  782         OR      A                             ; Set flags
   047C F5            [11]  783         PUSH    AF                            ; And save them
   047D CD E4 04      [17]  784         CALL    SRCHLN                        ; Search for line number in DE
   0480 DA 89 04      [10]  785         JP      C,LINFND                      ; Jump if line found
   0483 F1            [10]  786         POP     AF                            ; Get status
   0484 F5            [11]  787         PUSH    AF                            ; And re-save
   0485 CA BD 09      [10]  788         JP      Z,ULERR                       ; Nothing after number - Error
   0488 B7            [ 4]  789         OR      A                             ; Clear Carry
   0489 C5            [11]  790 LINFND: PUSH    BC                            ; Save address of line in prog
   048A D2 A0 04      [10]  791         JP      NC,INEWLN                     ; Line not found - Insert new
   048D EB            [ 4]  792         EX      DE,HL                         ; Next line address in DE
   048E 2A 1B 81      [16]  793         LD      HL,(PROGND)                   ; End of program
   0491 1A            [ 7]  794 SFTPRG: LD      A,(DE)                        ; Shift rest of program down
   0492 02            [ 7]  795         LD      (BC),A
   0493 03            [ 6]  796         INC     BC                            ; Next destination
   0494 13            [ 6]  797         INC     DE                            ; Next source
   0495 CD C0 06      [17]  798         CALL    CPDEHL                        ; All done?
   0498 C2 91 04      [10]  799         JP      NZ,SFTPRG                     ; More to do
   049B 60            [ 4]  800         LD      H,B                           ; HL - New end of program
   049C 69            [ 4]  801         LD      L,C
   049D 22 1B 81      [16]  802         LD      (PROGND),HL                   ; Update end of program
                            803 ;
   04A0 D1            [10]  804 INEWLN: POP     DE                            ; Get address of line,
   04A1 F1            [10]  805         POP     AF                            ; Get status
   04A2 CA C7 04      [10]  806         JP      Z,SETPTR                      ; No text - Set up pointers
   04A5 2A 1B 81      [16]  807         LD      HL,(PROGND)                   ; Get end of program
   04A8 E3            [19]  808         EX      (SP),HL                       ; Get length of input line
   04A9 C1            [10]  809         POP     BC                            ; End of program to BC
   04AA 09            [11]  810         ADD     HL,BC                         ; Find new end
   04AB E5            [11]  811         PUSH    HL                            ; Save new end
   04AC CD C4 03      [17]  812         CALL    MOVUP                         ; Make space for line
   04AF E1            [10]  813         POP     HL                            ; Restore new end
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 16
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   04B0 22 1B 81      [16]  814         LD      (PROGND),HL                   ; Update end of program pointer
   04B3 EB            [ 4]  815         EX      DE,HL                         ; Get line to move up in HL
   04B4 74            [ 7]  816         LD      (HL),H                        ; Save MSB
   04B5 D1            [10]  817         POP     DE                            ; Get new line number
   04B6 23            [ 6]  818         INC     HL                            ; Skip pointer
   04B7 23            [ 6]  819         INC     HL
   04B8 73            [ 7]  820         LD      (HL),E                        ; Save LSB of line number
   04B9 23            [ 6]  821         INC     HL
   04BA 72            [ 7]  822         LD      (HL),D                        ; Save MSB of line number
   04BB 23            [ 6]  823         INC     HL                            ; To first byte in line
   04BC 11 A6 80      [10]  824         LD      DE,BUFFER                     ; Copy buffer to program
   04BF 1A            [ 7]  825 MOVBUF: LD      A,(DE)                        ; Get source
   04C0 77            [ 7]  826         LD      (HL),A                        ; Save destinations
   04C1 23            [ 6]  827         INC     HL                            ; Next source
   04C2 13            [ 6]  828         INC     DE                            ; Next destination
   04C3 B7            [ 4]  829         OR      A                             ; Done?
   04C4 C2 BF 04      [10]  830         JP      NZ,MOVBUF                     ; No - Repeat
   04C7 CD 10 05      [17]  831 SETPTR: CALL    RUNFST                        ; Set line pointers
   04CA 23            [ 6]  832         INC     HL                            ; To LSB of pointer
   04CB EB            [ 4]  833         EX      DE,HL                         ; Address to DE
   04CC 62            [ 4]  834 PTRLP:  LD      H,D                           ; Address to HL
   04CD 6B            [ 4]  835         LD      L,E
   04CE 7E            [ 7]  836         LD      A,(HL)                        ; Get LSB of pointer
   04CF 23            [ 6]  837         INC     HL                            ; To MSB of pointer
   04D0 B6            [ 7]  838         OR      (HL)                          ; Compare with MSB pointer
   04D1 CA 50 04      [10]  839         JP      Z,GETCMD                      ; Get command line if end
   04D4 23            [ 6]  840         INC     HL                            ; To LSB of line number
   04D5 23            [ 6]  841         INC     HL                            ; Skip line number
   04D6 23            [ 6]  842         INC     HL                            ; Point to first byte in line
   04D7 AF            [ 4]  843         XOR     A                             ; Looking for 00 byte
   04D8 BE            [ 7]  844 FNDEND: CP      (HL)                          ; Found end of line?
   04D9 23            [ 6]  845         INC     HL                            ; Move to next byte
   04DA C2 D8 04      [10]  846         JP      NZ,FNDEND                     ; No - Keep looking
   04DD EB            [ 4]  847         EX      DE,HL                         ; Next line address to HL
   04DE 73            [ 7]  848         LD      (HL),E                        ; Save LSB of pointer
   04DF 23            [ 6]  849         INC     HL
   04E0 72            [ 7]  850         LD      (HL),D                        ; Save MSB of pointer
   04E1 C3 CC 04      [10]  851         JP      PTRLP                         ; Do next line
                            852 ;
   04E4 2A A3 80      [16]  853 SRCHLN: LD      HL,(BASTXT)                   ; Start of program text
   04E7 44            [ 4]  854 SRCHLP: LD      B,H                           ; BC = Address to look at
   04E8 4D            [ 4]  855         LD      C,L
   04E9 7E            [ 7]  856         LD      A,(HL)                        ; Get address of next line
   04EA 23            [ 6]  857         INC     HL
   04EB B6            [ 7]  858         OR      (HL)                          ; End of program found?
   04EC 2B            [ 6]  859         DEC     HL
   04ED C8            [11]  860         RET     Z                             ; Yes - Line not found
   04EE 23            [ 6]  861         INC     HL
   04EF 23            [ 6]  862         INC     HL
   04F0 7E            [ 7]  863         LD      A,(HL)                        ; Get LSB of line number
   04F1 23            [ 6]  864         INC     HL
   04F2 66            [ 7]  865         LD      H,(HL)                        ; Get MSB of line number
   04F3 6F            [ 4]  866         LD      L,A
   04F4 CD C0 06      [17]  867         CALL    CPDEHL                        ; Compare with line in DE
   04F7 60            [ 4]  868         LD      H,B                           ; HL = Start of this line
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 17
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   04F8 69            [ 4]  869         LD      L,C
   04F9 7E            [ 7]  870         LD      A,(HL)                        ; Get LSB of next line address
   04FA 23            [ 6]  871         INC     HL
   04FB 66            [ 7]  872         LD      H,(HL)                        ; Get MSB of next line address
   04FC 6F            [ 4]  873         LD      L,A                           ; Next line to HL
   04FD 3F            [ 4]  874         CCF
   04FE C8            [11]  875         RET     Z                             ; Lines found - Exit
   04FF 3F            [ 4]  876         CCF
   0500 D0            [11]  877         RET     NC                            ; Line not found,at line after
   0501 C3 E7 04      [10]  878         JP      SRCHLP                        ; Keep looking
                            879 ;
   0504 C0            [11]  880 NEW:    RET     NZ                            ; Return if any more on line
   0505 2A A3 80      [16]  881 CLRPTR: LD      HL,(BASTXT)                   ; Point to start of program
   0508 AF            [ 4]  882         XOR     A                             ; Set program area to empty
   0509 77            [ 7]  883         LD      (HL),A                        ; Save LSB = 00
   050A 23            [ 6]  884         INC     HL
   050B 77            [ 7]  885         LD      (HL),A                        ; Save MSB = 00
   050C 23            [ 6]  886         INC     HL
   050D 22 1B 81      [16]  887         LD      (PROGND),HL                   ; Set program end
                            888 ;
   0510 2A A3 80      [16]  889 RUNFST: LD      HL,(BASTXT)                   ; Clear all variables
   0513 2B            [ 6]  890         DEC     HL
                            891 ;
   0514 22 13 81      [16]  892 INTVAR: LD      (BRKLIN),HL                   ; Initialise RUN variables
   0517 2A F4 80      [16]  893         LD      HL,(LSTRAM)                   ; Get end of RAM
   051A 22 08 81      [16]  894         LD      (STRBOT),HL                   ; Clear string space
   051D AF            [ 4]  895         XOR     A
   051E CD 60 08      [17]  896         CALL    RESTOR                        ; Reset DATA pointers
   0521 2A 1B 81      [16]  897         LD      HL,(PROGND)                   ; Get end of program
   0524 22 1D 81      [16]  898         LD      (VAREND),HL                   ; Clear variables
   0527 22 1F 81      [16]  899         LD      (ARREND),HL                   ; Clear arrays
                            900 ;
   052A C1            [10]  901 CLREG:  POP     BC                            ; Save return address
   052B 2A 9F 80      [16]  902         LD      HL,(STRSPC)                   ; Get end of working RAN
   052E F9            [ 6]  903         LD      SP,HL                         ; Set stack
   052F 21 F8 80      [10]  904         LD      HL,TMSTPL                     ; Temporary string pool
   0532 22 F6 80      [16]  905         LD      (TMSTPT),HL                   ; Reset temporary string ptr
   0535 AF            [ 4]  906         XOR     A                             ; A = 00
   0536 6F            [ 4]  907         LD      L,A                           ; HL = 0000
   0537 67            [ 4]  908         LD      H,A
   0538 22 19 81      [16]  909         LD      (CONTAD),HL                   ; No CONTinue
   053B 32 10 81      [13]  910         LD      (FORFLG),A                    ; Clear FOR flag
   053E 22 23 81      [16]  911         LD      (FNRGNM),HL                   ; Clear FN argument
   0541 E5            [11]  912         PUSH    HL                            ; HL = 0000
   0542 C5            [11]  913         PUSH    BC                            ; Put back return
   0543 2A 13 81      [16]  914 DOAGN:  LD      HL,(BRKLIN)                   ; Get address of code to RUN
   0546 C9            [10]  915         RET                                   ; Return to execution driver
                            916 ;
   0547 3E 3F         [ 7]  917 PROMPT: LD      A,'?                          ; '?
   0549 CD D1 06      [17]  918         CALL    OUTC                          ; Output character
   054C 3E 20         [ 7]  919         LD      A,0x20                        ; Space
   054E CD D1 06      [17]  920         CALL    OUTC                          ; Output character
   0551 C3 93 80      [10]  921         JP      RINPUT                        ; Get input line
                            922 ;
   0554 AF            [ 4]  923 CRUNCH: XOR     A                             ; Tokenise line @ HL to BUFFER
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 18
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0555 32 F3 80      [13]  924         LD      (DATFLG),A                    ; Reset literal flag
   0558 0E 05         [ 7]  925         LD      C,2+3                         ; 2 byte number and 3 nulls
   055A 11 A6 80      [10]  926         LD      DE,BUFFER                     ; Start of input buffer
   055D 7E            [ 7]  927 CRNCLP: LD      A,(HL)                        ; Get byte
   055E FE 20         [ 7]  928         CP      0x20                          ; Is it a space?
   0560 CA DC 05      [10]  929         JP      Z,MOVDIR                      ; Yes - Copy direct
   0563 47            [ 4]  930         LD      B,A                           ; Save character
   0564 FE 22         [ 7]  931         CP      '"                            ; Is it a quote?
   0566 CA FC 05      [10]  932         JP      Z,CPYLIT                      ; Yes - Copy literal string
   0569 B7            [ 4]  933         OR      A                             ; Is it end of buffer?
   056A CA 03 06      [10]  934         JP      Z,ENDBUF                      ; Yes - End buffer
   056D 3A F3 80      [13]  935         LD      A,(DATFLG)                    ; Get data type
   0570 B7            [ 4]  936         OR      A                             ; Literal?
   0571 7E            [ 7]  937         LD      A,(HL)                        ; Get byte to copy
   0572 C2 DC 05      [10]  938         JP      NZ,MOVDIR                     ; Literal - Copy direct
   0575 FE 3F         [ 7]  939         CP      '?                            ; Is it '? short for PRINT
   0577 3E 9E         [ 7]  940         LD      A,ZPRINT                      ; "PRINT" token
   0579 CA DC 05      [10]  941         JP      Z,MOVDIR                      ; Yes - replace it
   057C 7E            [ 7]  942         LD      A,(HL)                        ; Get byte again
   057D FE 30         [ 7]  943         CP      '0                            ; Is it less than '0
   057F DA 87 05      [10]  944         JP      C,FNDWRD                      ; Yes - Look for reserved words
   0582 FE 3C         [ 7]  945         CP      60                            ; ";"+1; Is it "0123456789:;" ?
   0584 DA DC 05      [10]  946         JP      C,MOVDIR                      ; Yes - copy it direct
   0587 D5            [11]  947 FNDWRD: PUSH    DE                            ; Look for reserved words
   0588 11 80 01      [10]  948         LD      DE,WORDS-1                    ; Point to table
   058B C5            [11]  949         PUSH    BC                            ; Save count
   058C 01 D8 05      [10]  950         LD      BC,RETNAD                     ; Where to return to
   058F C5            [11]  951         PUSH    BC                            ; Save return address
   0590 06 7F         [ 7]  952         LD      B,ZEND-1                      ; First token value -1
   0592 7E            [ 7]  953         LD      A,(HL)                        ; Get byte
   0593 FE 61         [ 7]  954         CP      'a                            ; Less than 'a ?
   0595 DA A0 05      [10]  955         JP      C,SEARCH                      ; Yes - search for words
   0598 FE 7B         [ 7]  956         CP      'z+1                          ; Greater than 'z ?
   059A D2 A0 05      [10]  957         JP      NC,SEARCH                     ; Yes - search for words
   059D E6 5F         [ 7]  958         AND     0b01011111                    ; Force upper case
   059F 77            [ 7]  959         LD      (HL),A                        ; Replace byte
   05A0 4E            [ 7]  960 SEARCH: LD      C,(HL)                        ; Search for a word
   05A1 EB            [ 4]  961         EX      DE,HL
   05A2 23            [ 6]  962 GETNXT: INC     HL                            ; Get next reserved word
   05A3 B6            [ 7]  963         OR      (HL)                          ; Start of word?
   05A4 F2 A2 05      [10]  964         JP      P,GETNXT                      ; No - move on
   05A7 04            [ 4]  965         INC     B                             ; Increment token value
   05A8 7E            [ 7]  966         LD      A,(HL)                        ; Get byte from table
   05A9 E6 7F         [ 7]  967         AND     0b01111111                    ; Strip bit 7
   05AB C8            [11]  968         RET     Z                             ; Return if end of list
   05AC B9            [ 4]  969         CP      C                             ; Same character as in buffer?
   05AD C2 A2 05      [10]  970         JP      NZ,GETNXT                     ; No - get next word
   05B0 EB            [ 4]  971         EX      DE,HL
   05B1 E5            [11]  972         PUSH    HL                            ; Save start of word
                            973 ;
   05B2 13            [ 6]  974 NXTBYT: INC     DE                            ; Look through rest of word
   05B3 1A            [ 7]  975         LD      A,(DE)                        ; Get byte from table
   05B4 B7            [ 4]  976         OR      A                             ; End of word ?
   05B5 FA D4 05      [10]  977         JP      M,MATCH                       ; Yes - Match found
   05B8 4F            [ 4]  978         LD      C,A                           ; Save it
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 19
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   05B9 78            [ 4]  979         LD      A,B                           ; Get token value
   05BA FE 88         [ 7]  980         CP      ZGOTO                         ; Is it "GOTO" token ?
   05BC C2 C3 05      [10]  981         JP      NZ,NOSPC                      ; No - Don't allow spaces
   05BF CD 50 08      [17]  982         CALL    GETCHR                        ; Get next character
   05C2 2B            [ 6]  983         DEC     HL                            ; Cancel increment from GETCHR
   05C3 23            [ 6]  984 NOSPC:  INC     HL                            ; Next byte
   05C4 7E            [ 7]  985         LD      A,(HL)                        ; Get byte
   05C5 FE 61         [ 7]  986         CP      'a                            ; Less than 'a ?
   05C7 DA CC 05      [10]  987         JP      C,NOCHNG                      ; Yes - don't change
   05CA E6 5F         [ 7]  988         AND     0b01011111                    ; Make upper case
   05CC B9            [ 4]  989 NOCHNG: CP      C                             ; Same as in buffer ?
   05CD CA B2 05      [10]  990         JP      Z,NXTBYT                      ; Yes - keep testing
   05D0 E1            [10]  991         POP     HL                            ; Get back start of word
   05D1 C3 A0 05      [10]  992         JP      SEARCH                        ; Look at next word
                            993 ;
   05D4 48            [ 4]  994 MATCH:  LD      C,B                           ; Word found - Save token value
   05D5 F1            [10]  995         POP     AF                            ; Throw away return
   05D6 EB            [ 4]  996         EX      DE,HL
   05D7 C9            [10]  997         RET                                   ; Return to "RETNAD"
   05D8 EB            [ 4]  998 RETNAD: EX      DE,HL                         ; Get address in string
   05D9 79            [ 4]  999         LD      A,C                           ; Get token value
   05DA C1            [10] 1000         POP     BC                            ; Restore buffer length
   05DB D1            [10] 1001         POP     DE                            ; Get destination address
   05DC 23            [ 6] 1002 MOVDIR: INC     HL                            ; Next source in buffer
   05DD 12            [ 7] 1003         LD      (DE),A                        ; Put byte in buffer
   05DE 13            [ 6] 1004         INC     DE                            ; Move up buffer
   05DF 0C            [ 4] 1005         INC     C                             ; Increment length of buffer
   05E0 D6 3A         [ 7] 1006         SUB     ':                            ; End of statement?
   05E2 CA EA 05      [10] 1007         JP      Z,SETLIT                      ; Jump if multi-statement line
   05E5 FE 49         [ 7] 1008         CP      ZDATA-0x3A                    ; Is it DATA statement ?
   05E7 C2 ED 05      [10] 1009         JP      NZ,TSTREM                     ; No - see if REM
   05EA 32 F3 80      [13] 1010 SETLIT: LD      (DATFLG),A                    ; Set literal flag
   05ED D6 54         [ 7] 1011 TSTREM: SUB     ZREM-0x3A                     ; Is it REM?
   05EF C2 5D 05      [10] 1012         JP      NZ,CRNCLP                     ; No - Leave flag
   05F2 47            [ 4] 1013         LD      B,A                           ; Copy rest of buffer
   05F3 7E            [ 7] 1014 NXTCHR: LD      A,(HL)                        ; Get byte
   05F4 B7            [ 4] 1015         OR      A                             ; End of line ?
   05F5 CA 03 06      [10] 1016         JP      Z,ENDBUF                      ; Yes - Terminate buffer
   05F8 B8            [ 4] 1017         CP      B                             ; End of statement ?
   05F9 CA DC 05      [10] 1018         JP      Z,MOVDIR                      ; Yes - Get next one
   05FC 23            [ 6] 1019 CPYLIT: INC     HL                            ; Move up source string
   05FD 12            [ 7] 1020         LD      (DE),A                        ; Save in destination
   05FE 0C            [ 4] 1021         INC     C                             ; Increment length
   05FF 13            [ 6] 1022         INC     DE                            ; Move up destination
   0600 C3 F3 05      [10] 1023         JP      NXTCHR                        ; Repeat
                           1024 ;
   0603 21 A5 80      [10] 1025 ENDBUF: LD      HL,BUFFER-1                   ; Point to start of buffer
   0606 12            [ 7] 1026         LD      (DE),A                        ; Mark end of buffer (A = 00)
   0607 13            [ 6] 1027         INC     DE
   0608 12            [ 7] 1028         LD      (DE),A                        ; A = 00
   0609 13            [ 6] 1029         INC     DE
   060A 12            [ 7] 1030         LD      (DE),A                        ; A = 00
   060B C9            [10] 1031         RET
                           1032 ;
   060C 3A 89 80      [13] 1033 DODEL:  LD      A,(NULFLG)                    ; Get null flag status
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 20
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   060F B7            [ 4] 1034         OR      A                             ; Is it zero?
   0610 3E 00         [ 7] 1035         LD      A,0                           ; Zero A - Leave flags
   0612 32 89 80      [13] 1036         LD      (NULFLG),A                    ; Zero null flag
   0615 C2 20 06      [10] 1037         JP      NZ,ECHDEL                     ; Set - Echo it
   0618 05            [ 4] 1038         DEC     B                             ; Decrement length
   0619 CA 3D 06      [10] 1039         JP      Z,GETLIN                      ; Get line again if empty
   061C CD D1 06      [17] 1040         CALL    OUTC                          ; Output null character
   061F 3E                 1041         .db     0x3E                          ; Skip "DEC B"
   0620 05            [ 4] 1042 ECHDEL: DEC     B                             ; Count bytes in buffer
   0621 2B            [ 6] 1043         DEC     HL                            ; Back space buffer
   0622 CA 34 06      [10] 1044         JP      Z,OTKLN                       ; No buffer - Try again
   0625 7E            [ 7] 1045         LD      A,(HL)                        ; Get deleted byte
   0626 CD D1 06      [17] 1046         CALL    OUTC                          ; Echo it
   0629 C3 46 06      [10] 1047         JP      MORINP                        ; Get more input
                           1048 ;
   062C 05            [ 4] 1049 DELCHR: DEC     B                             ; Count bytes in buffer
   062D 2B            [ 6] 1050         DEC     HL                            ; Back space buffer
   062E CD D1 06      [17] 1051         CALL    OUTC                          ; Output character in A
   0631 C2 46 06      [10] 1052         JP      NZ,MORINP                     ; Not end - Get more
   0634 CD D1 06      [17] 1053 OTKLN:  CALL    OUTC                          ; Output character in A
   0637 CD F8 0A      [17] 1054 KILIN:  CALL    PRCRLF                        ; Output CRLF
   063A C3 3D 06      [10] 1055         JP      TTYLIN                        ; Get line again
                           1056 ;
   063D                    1057 GETLIN:
   063D 21 A6 80      [10] 1058 TTYLIN: LD      HL,BUFFER                     ; Get a line by character
   0640 06 01         [ 7] 1059         LD      B,1                           ; Set buffer as empty
   0642 AF            [ 4] 1060         XOR     A
   0643 32 89 80      [13] 1061         LD      (NULFLG),A                    ; Clear null flag
   0646 CD FB 06      [17] 1062 MORINP: CALL    CLOTST                        ; Get character and test ^O
   0649 4F            [ 4] 1063         LD      C,A                           ; Save character in C
   064A FE 7F         [ 7] 1064         CP      DEL                           ; Delete character?
   064C CA 0C 06      [10] 1065         JP      Z,DODEL                       ; Yes - Process it
   064F 3A 89 80      [13] 1066         LD      A,(NULFLG)                    ; Get null flag
   0652 B7            [ 4] 1067         OR      A                             ; Test null flag status
   0653 CA 5F 06      [10] 1068         JP      Z,PROCES                      ; Reset - Process character
   0656 3E 00         [ 7] 1069         LD      A,0                           ; Set a null
   0658 CD D1 06      [17] 1070         CALL    OUTC                          ; Output null
   065B AF            [ 4] 1071         XOR     A                             ; Clear A
   065C 32 89 80      [13] 1072         LD      (NULFLG),A                    ; Reset null flag
   065F 79            [ 4] 1073 PROCES: LD      A,C                           ; Get character
   0660 FE 07         [ 7] 1074         CP      CTRLG                         ; Bell?
   0662 CA A3 06      [10] 1075         JP      Z,PUTCTL                      ; Yes - Save it
   0665 FE 03         [ 7] 1076         CP      CTRLC                         ; Is it control "C"?
   0667 CC F8 0A      [17] 1077         CALL    Z,PRCRLF                      ; Yes - Output CRLF
   066A 37            [ 4] 1078         SCF                                   ; Flag break
   066B C8            [11] 1079         RET     Z                             ; Return if control "C"
   066C FE 0D         [ 7] 1080         CP      CR                            ; Is it enter?
   066E CA F3 0A      [10] 1081         JP      Z,ENDINP                      ; Yes - Terminate input
   0671 FE 15         [ 7] 1082         CP      CTRLU                         ; Is it control "U"?
   0673 CA 37 06      [10] 1083         JP      Z,KILIN                       ; Yes - Get another line
   0676 FE 40         [ 7] 1084         CP      '@                            ; Is it "kill line"?
   0678 CA 34 06      [10] 1085         JP      Z,OTKLN                       ; Yes - Kill line
   067B FE 5F         [ 7] 1086         CP      '_                            ; Is it delete?
   067D CA 2C 06      [10] 1087         JP      Z,DELCHR                      ; Yes - Delete character
   0680 FE 08         [ 7] 1088         CP      BKSP                          ; Is it backspace?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 21
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0682 CA 2C 06      [10] 1089         JP      Z,DELCHR                      ; Yes - Delete character
   0685 FE 12         [ 7] 1090         CP      CTRLR                         ; Is it control "R"?
   0687 C2 9E 06      [10] 1091         JP      NZ,PUTBUF                     ; No - Put in buffer
   068A C5            [11] 1092         PUSH    BC                            ; Save buffer length
   068B D5            [11] 1093         PUSH    DE                            ; Save DE
   068C E5            [11] 1094         PUSH    HL                            ; Save buffer address
   068D 36 00         [10] 1095         LD      (HL),0                        ; Mark end of buffer
   068F CD A2 1C      [17] 1096         CALL    OUTNCR                        ; Output and do CRLF
   0692 21 A6 80      [10] 1097         LD      HL,BUFFER                     ; Point to buffer start
   0695 CD 96 11      [17] 1098         CALL    PRS                           ; Output buffer
   0698 E1            [10] 1099         POP     HL                            ; Restore buffer address
   0699 D1            [10] 1100         POP     DE                            ; Restore DE
   069A C1            [10] 1101         POP     BC                            ; Restore buffer length
   069B C3 46 06      [10] 1102         JP      MORINP                        ; Get another character
                           1103 ;
   069E FE 20         [ 7] 1104 PUTBUF: CP      0x20                          ; Is it a control code?
   06A0 DA 46 06      [10] 1105         JP      C,MORINP                      ; Yes - Ignore
   06A3 78            [ 4] 1106 PUTCTL: LD      A,B                           ; Get number of bytes in buffer
   06A4 FE 49         [ 7] 1107         CP      72+1                          ; Test for line overflow
   06A6 3E 07         [ 7] 1108         LD      A,CTRLG                       ; Set a bell
   06A8 D2 B8 06      [10] 1109         JP      NC,OUTNBS                     ; Ring bell if buffer full
   06AB 79            [ 4] 1110         LD      A,C                           ; Get character
   06AC 71            [ 7] 1111         LD      (HL),C                        ; Save in buffer
   06AD 32 11 81      [13] 1112         LD      (LSTBIN),A                    ; Save last input byte
   06B0 23            [ 6] 1113         INC     HL                            ; Move up buffer
   06B1 04            [ 4] 1114         INC     B                             ; Increment length
   06B2 CD D1 06      [17] 1115 OUTIT:  CALL    OUTC                          ; Output the character entered
   06B5 C3 46 06      [10] 1116         JP      MORINP                        ; Get another character
                           1117 ;
   06B8 CD D1 06      [17] 1118 OUTNBS: CALL    OUTC                          ; Output bell and back over it
   06BB 3E 08         [ 7] 1119         LD      A,BKSP                        ; Set back space
   06BD C3 B2 06      [10] 1120         JP      OUTIT                         ; Output it and get more
                           1121 ;
   06C0 7C            [ 4] 1122 CPDEHL: LD      A,H                           ; Get H
   06C1 92            [ 4] 1123         SUB     D                             ; Compare with D
   06C2 C0            [11] 1124         RET     NZ                            ; Different - Exit
   06C3 7D            [ 4] 1125         LD      A,L                           ; Get L
   06C4 93            [ 4] 1126         SUB     E                             ; Compare with E
   06C5 C9            [10] 1127         RET                                   ; Return status
                           1128 ;
   06C6 7E            [ 7] 1129 CHKSYN: LD      A,(HL)                        ; Check syntax of character
   06C7 E3            [19] 1130         EX      (SP),HL                       ; Address of test byte
   06C8 BE            [ 7] 1131         CP      (HL)                          ; Same as in code string?
   06C9 23            [ 6] 1132         INC     HL                            ; Return address
   06CA E3            [19] 1133         EX      (SP),HL                       ; Put it back
   06CB CA 50 08      [10] 1134         JP      Z,GETCHR                      ; Yes - Get next character
   06CE C3 F8 03      [10] 1135         JP      SNERR                         ; Different - ?SN Error
                           1136 ;
   06D1 F5            [11] 1137 OUTC:   PUSH    AF                            ; Save character
   06D2 3A 8A 80      [13] 1138         LD      A,(CTLOFG)                    ; Get control "O" flag
   06D5 B7            [ 4] 1139         OR      A                             ; Is it set?
   06D6 C2 CB 11      [10] 1140         JP      NZ,POPAF                      ; Yes - don't output
   06D9 F1            [10] 1141         POP     AF                            ; Restore character
   06DA C5            [11] 1142         PUSH    BC                            ; Save buffer length
   06DB F5            [11] 1143         PUSH    AF                            ; Save character
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 22
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   06DC FE 20         [ 7] 1144         CP      0x20                          ; Is it a control code?
   06DE DA F5 06      [10] 1145         JP      C,DINPOS                      ; Yes - Don't INC POS(X)
   06E1 3A 87 80      [13] 1146         LD      A,(LWIDTH)                    ; Get line width
   06E4 47            [ 4] 1147         LD      B,A                           ; To B
   06E5 3A F0 80      [13] 1148         LD      A,(CURPOS)                    ; Get cursor position
   06E8 04            [ 4] 1149         INC     B                             ; Width 255?
   06E9 CA F1 06      [10] 1150         JP      Z,INCLEN                      ; Yes - No width limit
   06EC 05            [ 4] 1151         DEC     B                             ; Restore width
   06ED B8            [ 4] 1152         CP      B                             ; At end of line?
   06EE CC F8 0A      [17] 1153         CALL    Z,PRCRLF                      ; Yes - output CRLF
   06F1 3C            [ 4] 1154 INCLEN: INC     A                             ; Move on one character
   06F2 32 F0 80      [13] 1155         LD      (CURPOS),A                    ; Save new position
   06F5 F1            [10] 1156 DINPOS: POP     AF                            ; Restore character
   06F6 C1            [10] 1157         POP     BC                            ; Restore buffer length
   06F7 CD 8D 1C      [17] 1158         CALL    MONOUT                        ; Send it
   06FA C9            [10] 1159         RET
                           1160 ;
   06FB CD 55 1B      [17] 1161 CLOTST: CALL    GETINP                        ; Get input character
   06FE E6 7F         [ 7] 1162         AND     0b01111111                    ; Strip bit 7
   0700 FE 0F         [ 7] 1163         CP      CTRLO                         ; Is it control "O"?
   0702 C0            [11] 1164         RET     NZ                            ; No don't flip flag
   0703 3A 8A 80      [13] 1165         LD      A,(CTLOFG)                    ; Get flag
   0706 2F            [ 4] 1166         CPL                                   ; Flip it
   0707 32 8A 80      [13] 1167         LD      (CTLOFG),A                    ; Put it back
   070A AF            [ 4] 1168         XOR     A                             ; Null character
   070B C9            [10] 1169         RET
                           1170 ;
   070C CD 1C 09      [17] 1171 LIST:   CALL    ATOH                          ; ASCII number to DE
   070F C0            [11] 1172         RET     NZ                            ; Return if anything extra
   0710 C1            [10] 1173         POP     BC                            ; Rubbish - Not needed
   0711 CD E4 04      [17] 1174         CALL    SRCHLN                        ; Search for line number in DE
   0714 C5            [11] 1175         PUSH    BC                            ; Save address of line
   0715 CD 62 07      [17] 1176         CALL    SETLIN                        ; Set up lines counter
   0718 E1            [10] 1177 LISTLP: POP     HL                            ; Restore address of line
   0719 4E            [ 7] 1178         LD      C,(HL)                        ; Get LSB of next line
   071A 23            [ 6] 1179         INC     HL
   071B 46            [ 7] 1180         LD      B,(HL)                        ; Get MSB of next line
   071C 23            [ 6] 1181         INC     HL
   071D 78            [ 4] 1182         LD      A,B                           ; BC = 0 (End of program)?
   071E B1            [ 4] 1183         OR      C
   071F CA 43 04      [10] 1184         JP      Z,PRNTOK                      ; Yes - Go to command mode
   0722 CD 6B 07      [17] 1185         CALL    COUNT                         ; Count lines
   0725 CD 7B 08      [17] 1186         CALL    TSTBRK                        ; Test for break key
   0728 C5            [11] 1187         PUSH    BC                            ; Save address of next line
   0729 CD F8 0A      [17] 1188         CALL    PRCRLF                        ; Output CRLF
   072C 5E            [ 7] 1189         LD      E,(HL)                        ; Get LSB of line number
   072D 23            [ 6] 1190         INC     HL
   072E 56            [ 7] 1191         LD      D,(HL)                        ; Get MSB of line number
   072F 23            [ 6] 1192         INC     HL
   0730 E5            [11] 1193         PUSH    HL                            ; Save address of line start
   0731 EB            [ 4] 1194         EX      DE,HL                         ; Line number to HL
   0732 CD 39 18      [17] 1195         CALL    PRNTHL                        ; Output line number in decimal
   0735 3E 20         [ 7] 1196         LD      A,0x20                        ; Space after line number
   0737 E1            [10] 1197         POP     HL                            ; Restore start of line address
   0738 CD D1 06      [17] 1198 LSTLP2: CALL    OUTC                          ; Output character in A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 23
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   073B 7E            [ 7] 1199 LSTLP3: LD      A,(HL)                        ; Get next byte in line
   073C B7            [ 4] 1200         OR      A                             ; End of line?
   073D 23            [ 6] 1201         INC     HL                            ; To next byte in line
   073E CA 18 07      [10] 1202         JP      Z,LISTLP                      ; Yes - get next line
   0741 F2 38 07      [10] 1203         JP      P,LSTLP2                      ; No token - output it
   0744 D6 7F         [ 7] 1204         SUB     ZEND-1                        ; Find and output word
   0746 4F            [ 4] 1205         LD      C,A                           ; Token offset+1 to C
   0747 11 81 01      [10] 1206         LD      DE,WORDS                      ; Reserved word list
   074A 1A            [ 7] 1207 FNDTOK: LD      A,(DE)                        ; Get character in list
   074B 13            [ 6] 1208         INC     DE                            ; Move on to next
   074C B7            [ 4] 1209         OR      A                             ; Is it start of word?
   074D F2 4A 07      [10] 1210         JP      P,FNDTOK                      ; No - Keep looking for word
   0750 0D            [ 4] 1211         DEC     C                             ; Count words
   0751 C2 4A 07      [10] 1212         JP      NZ,FNDTOK                     ; Not there - keep looking
   0754 E6 7F         [ 7] 1213 OUTWRD: AND     0b01111111                    ; Strip bit 7
   0756 CD D1 06      [17] 1214         CALL    OUTC                          ; Output first character
   0759 1A            [ 7] 1215         LD      A,(DE)                        ; Get next character
   075A 13            [ 6] 1216         INC     DE                            ; Move on to next
   075B B7            [ 4] 1217         OR      A                             ; Is it end of word?
   075C F2 54 07      [10] 1218         JP      P,OUTWRD                      ; No - output the rest
   075F C3 3B 07      [10] 1219         JP      LSTLP3                        ; Next byte in line
                           1220 ;
   0762 E5            [11] 1221 SETLIN: PUSH    HL                            ; Set up LINES counter
   0763 2A 8D 80      [16] 1222         LD      HL,(LINESN)                   ; Get LINES number
   0766 22 8B 80      [16] 1223         LD      (LINESC),HL                   ; Save in LINES counter
   0769 E1            [10] 1224         POP     HL
   076A C9            [10] 1225         RET
                           1226 ;
   076B E5            [11] 1227 COUNT:  PUSH    HL                            ; Save code string address
   076C D5            [11] 1228         PUSH    DE
   076D 2A 8B 80      [16] 1229         LD      HL,(LINESC)                   ; Get LINES counter
   0770 11 FF FF      [10] 1230         LD      DE,-1
   0773 ED 5A         [15] 1231         ADC     HL,DE                         ; Decrement
   0775 22 8B 80      [16] 1232         LD      (LINESC),HL                   ; Put it back
   0778 D1            [10] 1233         POP     DE
   0779 E1            [10] 1234         POP     HL                            ; Restore code string address
   077A F0            [11] 1235         RET     P                             ; Return if more lines to go
   077B E5            [11] 1236         PUSH    HL                            ; Save code string address
   077C 2A 8D 80      [16] 1237         LD      HL,(LINESN)                   ; Get LINES number
   077F 22 8B 80      [16] 1238         LD      (LINESC),HL                   ; Reset LINES counter
   0782 CD 55 1B      [17] 1239         CALL    GETINP                        ; Get input character
   0785 FE 03         [ 7] 1240         CP      CTRLC                         ; Is it control "C"?
   0787 CA 8E 07      [10] 1241         JP      Z,RSLNBK                      ; Yes - Reset LINES and break
   078A E1            [10] 1242         POP     HL                            ; Restore code string address
   078B C3 6B 07      [10] 1243         JP      COUNT                         ; Keep on counting
                           1244 ;
   078E 2A 8D 80      [16] 1245 RSLNBK: LD      HL,(LINESN)                   ; Get LINES number
   0791 22 8B 80      [16] 1246         LD      (LINESC),HL                   ; Reset LINES counter
   0794 C3 C2 00      [10] 1247         JP      BRKRET                        ; Go and output "Break"
                           1248 ;
   0797 3E 64         [ 7] 1249 FOR:    LD      A,0x64                        ; Flag "FOR" assignment
   0799 32 10 81      [13] 1250         LD      (FORFLG),A                    ; Save "FOR" flag
   079C CD FE 09      [17] 1251         CALL    LET                           ; Set up initial index
   079F C1            [10] 1252         POP     BC                            ; Drop RETurn address
   07A0 E5            [11] 1253         PUSH    HL                            ; Save code string address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 24
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   07A1 CD E7 09      [17] 1254         CALL    DATA                          ; Get next statement address
   07A4 22 0C 81      [16] 1255         LD      (LOOPST),HL                   ; Save it for start of loop
   07A7 21 02 00      [10] 1256         LD      HL,2                          ; Offset for "FOR" block
   07AA 39            [11] 1257         ADD     HL,SP                         ; Point to it
   07AB CD A5 03      [17] 1258 FORSLP: CALL    LOKFOR                        ; Look for existing "FOR" block
   07AE D1            [10] 1259         POP     DE                            ; Get code string address
   07AF C2 C7 07      [10] 1260         JP      NZ,FORFND                     ; No nesting found
   07B2 09            [11] 1261         ADD     HL,BC                         ; Move into "FOR" block
   07B3 D5            [11] 1262         PUSH    DE                            ; Save code string address
   07B4 2B            [ 6] 1263         DEC     HL
   07B5 56            [ 7] 1264         LD      D,(HL)                        ; Get MSB of loop statement
   07B6 2B            [ 6] 1265         DEC     HL
   07B7 5E            [ 7] 1266         LD      E,(HL)                        ; Get LSB of loop statement
   07B8 23            [ 6] 1267         INC     HL
   07B9 23            [ 6] 1268         INC     HL
   07BA E5            [11] 1269         PUSH    HL                            ; Save block address
   07BB 2A 0C 81      [16] 1270         LD      HL,(LOOPST)                   ; Get address of loop statement
   07BE CD C0 06      [17] 1271         CALL    CPDEHL                        ; Compare the FOR loops
   07C1 E1            [10] 1272         POP     HL                            ; Restore block address
   07C2 C2 AB 07      [10] 1273         JP      NZ,FORSLP                     ; Different FORs - Find another
   07C5 D1            [10] 1274         POP     DE                            ; Restore code string address
   07C6 F9            [ 6] 1275         LD      SP,HL                         ; Remove all nested loops
                           1276 ;
   07C7 EB            [ 4] 1277 FORFND: EX      DE,HL                         ; Code string address to HL
   07C8 0E 08         [ 7] 1278         LD      C,8
   07CA CD D5 03      [17] 1279         CALL    CHKSTK                        ; Check for 8 levels of stack
   07CD E5            [11] 1280         PUSH    HL                            ; Save code string address
   07CE 2A 0C 81      [16] 1281         LD      HL,(LOOPST)                   ; Get first statement of loop
   07D1 E3            [19] 1282         EX      (SP),HL                       ; Save and restore code string
   07D2 E5            [11] 1283         PUSH    HL                            ; Re-save code string address
   07D3 2A A1 80      [16] 1284         LD      HL,(LINEAT)                   ; Get current line number
   07D6 E3            [19] 1285         EX      (SP),HL                       ; Save and restore code string
   07D7 CD C0 0C      [17] 1286         CALL    TSTNUM                        ; Make sure it's a number
   07DA CD C6 06      [17] 1287         CALL    CHKSYN                        ; Make sure "TO" is next
   07DD A6                 1288         .db     ZTO                           ; "TO" token
   07DE CD BD 0C      [17] 1289         CALL    GETNUM                        ; Get "TO" expression value
   07E1 E5            [11] 1290         PUSH    HL                            ; Save code string address
   07E2 CD EB 16      [17] 1291         CALL    BCDEFP                        ; Move "TO" value to BCDE
   07E5 E1            [10] 1292         POP     HL                            ; Restore code string address
   07E6 C5            [11] 1293         PUSH    BC                            ; Save "TO" value in block
   07E7 D5            [11] 1294         PUSH    DE
   07E8 01 00 81      [10] 1295         LD      BC,0x8100                     ; BCDE - 1 (default STEP)
   07EB 51            [ 4] 1296         LD      D,C                           ; C=0
   07EC 5A            [ 4] 1297         LD      E,D                           ; D=0
   07ED 7E            [ 7] 1298         LD      A,(HL)                        ; Get next byte in code string
   07EE FE AB         [ 7] 1299         CP      ZSTEP                         ; See if "STEP" is stated
   07F0 3E 01         [ 7] 1300         LD      A,1                           ; Sign of step = 1
   07F2 C2 03 08      [10] 1301         JP      NZ,SAVSTP                     ; No STEP given - Default to 1
   07F5 CD 50 08      [17] 1302         CALL    GETCHR                        ; Jump over "STEP" token
   07F8 CD BD 0C      [17] 1303         CALL    GETNUM                        ; Get step value
   07FB E5            [11] 1304         PUSH    HL                            ; Save code string address
   07FC CD EB 16      [17] 1305         CALL    BCDEFP                        ; Move STEP to BCDE
   07FF CD 9F 16      [17] 1306         CALL    TSTSGN                        ; Test sign of FPREG
   0802 E1            [10] 1307         POP     HL                            ; Restore code string address
   0803 C5            [11] 1308 SAVSTP: PUSH    BC                            ; Save the STEP value in block
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 25
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0804 D5            [11] 1309         PUSH    DE
   0805 F5            [11] 1310         PUSH    AF                            ; Save sign of STEP
   0806 33            [ 6] 1311         INC     SP                            ; Don't save flags
   0807 E5            [11] 1312         PUSH    HL                            ; Save code string address
   0808 2A 13 81      [16] 1313         LD      HL,(BRKLIN)                   ; Get address of index variable
   080B E3            [19] 1314         EX      (SP),HL                       ; Save and restore code string
   080C 06 81         [ 7] 1315 PUTFID: LD      B,ZFOR                        ; "FOR" block marker
   080E C5            [11] 1316         PUSH    BC                            ; Save it
   080F 33            [ 6] 1317         INC     SP                            ; Don't save C
                           1318 ;
   0810 CD 7B 08      [17] 1319 RUNCNT: CALL    TSTBRK                        ; Execution driver - Test break
   0813 22 13 81      [16] 1320         LD      (BRKLIN),HL                   ; Save code address for break
   0816 7E            [ 7] 1321         LD      A,(HL)                        ; Get next byte in code string
   0817 FE 3A         [ 7] 1322         CP      ':                            ; Multi statement line?
   0819 CA 30 08      [10] 1323         JP      Z,EXCUTE                      ; Yes - Execute it
   081C B7            [ 4] 1324         OR      A                             ; End of line?
   081D C2 F8 03      [10] 1325         JP      NZ,SNERR                      ; No - Syntax error
   0820 23            [ 6] 1326         INC     HL                            ; Point to address of next line
   0821 7E            [ 7] 1327         LD      A,(HL)                        ; Get LSB of line pointer
   0822 23            [ 6] 1328         INC     HL
   0823 B6            [ 7] 1329         OR      (HL)                          ; Is it zero (End of prog)?
   0824 CA A2 08      [10] 1330         JP      Z,ENDPRG                      ; Yes - Terminate execution
   0827 23            [ 6] 1331         INC     HL                            ; Point to line number
   0828 5E            [ 7] 1332         LD      E,(HL)                        ; Get LSB of line number
   0829 23            [ 6] 1333         INC     HL
   082A 56            [ 7] 1334         LD      D,(HL)                        ; Get MSB of line number
   082B EB            [ 4] 1335         EX      DE,HL                         ; Line number to HL
   082C 22 A1 80      [16] 1336         LD      (LINEAT),HL                   ; Save as current line number
   082F EB            [ 4] 1337         EX      DE,HL                         ; Line number back to DE
   0830 CD 50 08      [17] 1338 EXCUTE: CALL    GETCHR                        ; Get key word
   0833 11 10 08      [10] 1339         LD      DE,RUNCNT                     ; Where to RETurn to
   0836 D5            [11] 1340         PUSH    DE                            ; Save for RETurn
   0837 C8            [11] 1341 IFJMP:  RET     Z                             ; Go to RUNCNT if end of STMT
   0838 D6 80         [ 7] 1342 ONJMP:  SUB     ZEND                          ; Is it a token?
   083A DA FE 09      [10] 1343         JP      C,LET                         ; No - try to assign it
   083D FE 25         [ 7] 1344         CP      ZNEW+1-ZEND                   ; END to NEW ?
   083F D2 F8 03      [10] 1345         JP      NC,SNERR                      ; Not a key word - ?SN Error
   0842 07            [ 4] 1346         RLCA                                  ; Double it
   0843 4F            [ 4] 1347         LD      C,A                           ; BC = Offset into table
   0844 06 00         [ 7] 1348         LD      B,0
   0846 EB            [ 4] 1349         EX      DE,HL                         ; Save code string address
   0847 21 A0 02      [10] 1350         LD      HL,WORDTB                     ; Keyword address table
   084A 09            [11] 1351         ADD     HL,BC                         ; Point to routine address
   084B 4E            [ 7] 1352         LD      C,(HL)                        ; Get LSB of routine address
   084C 23            [ 6] 1353         INC     HL
   084D 46            [ 7] 1354         LD      B,(HL)                        ; Get MSB of routine address
   084E C5            [11] 1355         PUSH    BC                            ; Save routine address
   084F EB            [ 4] 1356         EX      DE,HL                         ; Restore code string address
                           1357 ;
   0850 23            [ 6] 1358 GETCHR: INC     HL                            ; Point to next character
   0851 7E            [ 7] 1359         LD      A,(HL)                        ; Get next code string byte
   0852 FE 3A         [ 7] 1360         CP      ':                            ; Z if ':
   0854 D0            [11] 1361         RET     NC                            ; NC if > "9"
   0855 FE 20         [ 7] 1362         CP      0x20
   0857 CA 50 08      [10] 1363         JP      Z,GETCHR                      ; Skip over spaces
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 26
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   085A FE 30         [ 7] 1364         CP      '0
   085C 3F            [ 4] 1365         CCF                                   ; NC if < '0
   085D 3C            [ 4] 1366         INC     A                             ; Test for zero - Leave carry
   085E 3D            [ 4] 1367         DEC     A                             ; Z if Null
   085F C9            [10] 1368         RET
                           1369 ;
   0860 EB            [ 4] 1370 RESTOR: EX      DE,HL                         ; Save code string address
   0861 2A A3 80      [16] 1371         LD      HL,(BASTXT)                   ; Point to start of program
   0864 CA 75 08      [10] 1372         JP      Z,RESTNL                      ; Just RESTORE - reset pointer
   0867 EB            [ 4] 1373         EX      DE,HL                         ; Restore code string address
   0868 CD 1C 09      [17] 1374         CALL    ATOH                          ; Get line number to DE
   086B E5            [11] 1375         PUSH    HL                            ; Save code string address
   086C CD E4 04      [17] 1376         CALL    SRCHLN                        ; Search for line number in DE
   086F 60            [ 4] 1377         LD      H,B                           ; HL = Address of line
   0870 69            [ 4] 1378         LD      L,C
   0871 D1            [10] 1379         POP     DE                            ; Restore code string address
   0872 D2 BD 09      [10] 1380         JP      NC,ULERR                      ; ?UL Error if not found
   0875 2B            [ 6] 1381 RESTNL: DEC     HL                            ; Byte before DATA statement
   0876 22 21 81      [16] 1382 UPDATA: LD      (NXTDAT),HL                   ; Update DATA pointer
   0879 EB            [ 4] 1383         EX      DE,HL                         ; Restore code string address
   087A C9            [10] 1384         RET
                           1385 ;
                           1386 
   087B DF            [11] 1387 TSTBRK: RST     0x18                          ; Check input status
   087C C8            [11] 1388         RET     Z                             ; No key, go back
   087D D7            [11] 1389         RST     0x10                          ; Get the key into A
   087E FE 1B         [ 7] 1390         CP      ESC                           ; Escape key?
   0880 28 11         [12] 1391         JR      Z,BRK                         ; Yes, break
   0882 FE 03         [ 7] 1392         CP      CTRLC                         ; <Ctrl-C>
   0884 28 0D         [12] 1393         JR      Z,BRK                         ; Yes, break
   0886 FE 13         [ 7] 1394         CP      CTRLS                         ; Stop scrolling?
   0888 C0            [11] 1395         RET     NZ                            ; Other key, ignore
                           1396 ;
                           1397 
   0889 D7            [11] 1398 STALL:  RST     0x10                          ; Wait for key
   088A FE 11         [ 7] 1399         CP      CTRLQ                         ; Resume scrolling?
   088C C8            [11] 1400         RET     Z                             ; Release the chokehold
   088D FE 03         [ 7] 1401         CP      CTRLC                         ; Second break?
   088F 28 07         [12] 1402         JR      Z,STOP                        ; Break during hold exits prog
   0891 18 F6         [12] 1403         JR      STALL                         ; Loop until <Ctrl-Q> or <brk>
                           1404 ;
   0893 3E FF         [ 7] 1405 BRK:    LD      A,0x0FF                       ; Set BRKFLG
   0895 32 92 80      [13] 1406         LD      (BRKFLG),A                    ; Store it
                           1407 ;
                           1408 
   0898 C0            [11] 1409 STOP:   RET     NZ                            ; Exit if anything else
   0899 F6                 1410         .db     0x0F6                         ; Flag "STOP"
   089A C0            [11] 1411 PEND:   RET     NZ                            ; Exit if anything else
   089B 22 13 81      [16] 1412         LD      (BRKLIN),HL                   ; Save point of break
   089E 21                 1413         .db     0x21                          ; Skip "OR 11111111B"
   089F F6 FF         [ 7] 1414 INPBRK: OR      0b11111111                    ; Flag "Break" wanted
   08A1 C1            [10] 1415         POP     BC                            ; Return not needed and more
   08A2 2A A1 80      [16] 1416 ENDPRG: LD      HL,(LINEAT)                   ; Get current line number
   08A5 F5            [11] 1417         PUSH    AF                            ; Save STOP / END status
   08A6 7D            [ 4] 1418         LD      A,L                           ; Is it direct break?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 27
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   08A7 A4            [ 4] 1419         AND     H
   08A8 3C            [ 4] 1420         INC     A                             ; Line is -1 if direct break
   08A9 CA B5 08      [10] 1421         JP      Z,NOLIN                       ; Yes - No line number
   08AC 22 17 81      [16] 1422         LD      (ERRLIN),HL                   ; Save line of break
   08AF 2A 13 81      [16] 1423         LD      HL,(BRKLIN)                   ; Get point of break
   08B2 22 19 81      [16] 1424         LD      (CONTAD),HL                   ; Save point to CONTinue
   08B5 AF            [ 4] 1425 NOLIN:  XOR     A
   08B6 32 8A 80      [13] 1426         LD      (CTLOFG),A                    ; Enable output
   08B9 CD EB 0A      [17] 1427         CALL    STTLIN                        ; Start a new line
   08BC F1            [10] 1428         POP     AF                            ; Restore STOP / END status
   08BD 21 9B 03      [10] 1429         LD      HL,BRKMSG                     ; "Break" message
   08C0 C2 2C 04      [10] 1430         JP      NZ,ERRIN                      ; "in line" wanted?
   08C3 C3 43 04      [10] 1431         JP      PRNTOK                        ; Go to command mode
                           1432 ;
   08C6 2A 19 81      [16] 1433 CONT:   LD      HL,(CONTAD)                   ; Get CONTinue address
   08C9 7C            [ 4] 1434         LD      A,H                           ; Is it zero?
   08CA B5            [ 4] 1435         OR      L
   08CB 1E 20         [ 7] 1436         LD      E,CN                          ; ?CN Error
   08CD CA 0C 04      [10] 1437         JP      Z,ERROR                       ; Yes - output "?CN Error"
   08D0 EB            [ 4] 1438         EX      DE,HL                         ; Save code string address
   08D1 2A 17 81      [16] 1439         LD      HL,(ERRLIN)                   ; Get line of last break
   08D4 22 A1 80      [16] 1440         LD      (LINEAT),HL                   ; Set up current line number
   08D7 EB            [ 4] 1441         EX      DE,HL                         ; Restore code string address
   08D8 C9            [10] 1442         RET                                   ; CONTinue where left off
                           1443 ;
   08D9 CD 1E 14      [17] 1444 NULL:   CALL    GETINT                        ; Get integer 0-255
   08DC C0            [11] 1445         RET     NZ                            ; Return if bad value
   08DD 32 86 80      [13] 1446         LD      (NULLS),A                     ; Set nulls number
   08E0 C9            [10] 1447         RET
                           1448 ;
                           1449 
   08E1 E5            [11] 1450 ACCSUM: PUSH    HL                            ; Save address in array
   08E2 2A 8F 80      [16] 1451         LD      HL,(CHKSUM)                   ; Get check sum
   08E5 06 00         [ 7] 1452         LD      B,0                           ; BC - Value of byte
   08E7 4F            [ 4] 1453         LD      C,A
   08E8 09            [11] 1454         ADD     HL,BC                         ; Add byte to check sum
   08E9 22 8F 80      [16] 1455         LD      (CHKSUM),HL                   ; Re-save check sum
   08EC E1            [10] 1456         POP     HL                            ; Restore address in array
   08ED C9            [10] 1457         RET
                           1458 ;
   08EE 7E            [ 7] 1459 CHKLTR: LD      A,(HL)                        ; Get byte
   08EF FE 41         [ 7] 1460         CP      'A                            ; < 'a ?
   08F1 D8            [11] 1461         RET     C                             ; Carry set if not letter
   08F2 FE 5B         [ 7] 1462         CP      'Z+1                          ; > 'z ?
   08F4 3F            [ 4] 1463         CCF
   08F5 C9            [10] 1464         RET                                   ; Carry set if not letter
                           1465 ;
   08F6 CD 50 08      [17] 1466 FPSINT: CALL    GETCHR                        ; Get next character
   08F9 CD BD 0C      [17] 1467 POSINT: CALL    GETNUM                        ; Get integer 0 to 32767
   08FC CD 9F 16      [17] 1468 DEPINT: CALL    TSTSGN                        ; Test sign of FPREG
   08FF FA 17 09      [10] 1469         JP      M,FCERR                       ; Negative - ?FC Error
   0902 3A 2C 81      [13] 1470 DEINT:  LD      A,(FPEXP)                     ; Get integer value to DE
   0905 FE 90         [ 7] 1471         CP      0x80+16                       ; Exponent in range (16 bits)?
   0907 DA 47 17      [10] 1472         JP      C,FPINT                       ; Yes - convert it
   090A 01 80 90      [10] 1473         LD      BC,0x9080                     ; BCDE = -32768
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 28
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   090D 11 00 00      [10] 1474         LD      DE,0000
   0910 E5            [11] 1475         PUSH    HL                            ; Save code string address
   0911 CD 1A 17      [17] 1476         CALL    CMPNUM                        ; Compare FPREG with BCDE
   0914 E1            [10] 1477         POP     HL                            ; Restore code string address
   0915 51            [ 4] 1478         LD      D,C                           ; MSB to D
   0916 C8            [11] 1479         RET     Z                             ; Return if in range
   0917 1E 08         [ 7] 1480 FCERR:  LD      E,FC                          ; ?FC Error
   0919 C3 0C 04      [10] 1481         JP      ERROR                         ; Output error-
                           1482 ;
   091C 2B            [ 6] 1483 ATOH:   DEC     HL                            ; ASCII number to DE binary
   091D 11 00 00      [10] 1484 GETLN:  LD      DE,0                          ; Get number to DE
   0920 CD 50 08      [17] 1485 GTLNLP: CALL    GETCHR                        ; Get next character
   0923 D0            [11] 1486         RET     NC                            ; Exit if not a digit
   0924 E5            [11] 1487         PUSH    HL                            ; Save code string address
   0925 F5            [11] 1488         PUSH    AF                            ; Save digit
   0926 21 98 19      [10] 1489         LD      HL,65529/10                   ; Largest number 65529
   0929 CD C0 06      [17] 1490         CALL    CPDEHL                        ; Number in range?
   092C DA F8 03      [10] 1491         JP      C,SNERR                       ; No - ?SN Error
   092F 62            [ 4] 1492         LD      H,D                           ; HL = Number
   0930 6B            [ 4] 1493         LD      L,E
   0931 19            [11] 1494         ADD     HL,DE                         ; Times 2
   0932 29            [11] 1495         ADD     HL,HL                         ; Times 4
   0933 19            [11] 1496         ADD     HL,DE                         ; Times 5
   0934 29            [11] 1497         ADD     HL,HL                         ; Times 10
   0935 F1            [10] 1498         POP     AF                            ; Restore digit
   0936 D6 30         [ 7] 1499         SUB     '0                            ; Make it 0 to 9
   0938 5F            [ 4] 1500         LD      E,A                           ; DE = Value of digit
   0939 16 00         [ 7] 1501         LD      D,0
   093B 19            [11] 1502         ADD     HL,DE                         ; Add to number
   093C EB            [ 4] 1503         EX      DE,HL                         ; Number to DE
   093D E1            [10] 1504         POP     HL                            ; Restore code string address
   093E C3 20 09      [10] 1505         JP      GTLNLP                        ; Go to next character
                           1506 ;
   0941 CA 14 05      [10] 1507 CLEAR:  JP      Z,INTVAR                      ; Just "CLEAR" Keep parameters
   0944 CD F9 08      [17] 1508         CALL    POSINT                        ; Get integer 0 to 32767 to DE
   0947 2B            [ 6] 1509         DEC     HL                            ; Cancel increment
   0948 CD 50 08      [17] 1510         CALL    GETCHR                        ; Get next character
   094B E5            [11] 1511         PUSH    HL                            ; Save code string address
   094C 2A F4 80      [16] 1512         LD      HL,(LSTRAM)                   ; Get end of RAM
   094F CA 64 09      [10] 1513         JP      Z,STORED                      ; No value given - Use stored
   0952 E1            [10] 1514         POP     HL                            ; Restore code string address
   0953 CD C6 06      [17] 1515         CALL    CHKSYN                        ; Check for comma
   0956 2C                 1516         .db     ',
   0957 D5            [11] 1517         PUSH    DE                            ; Save number
   0958 CD F9 08      [17] 1518         CALL    POSINT                        ; Get integer 0 to 32767
   095B 2B            [ 6] 1519         DEC     HL                            ; Cancel increment
   095C CD 50 08      [17] 1520         CALL    GETCHR                        ; Get next character
   095F C2 F8 03      [10] 1521         JP      NZ,SNERR                      ; ?SN Error if more on line
   0962 E3            [19] 1522         EX      (SP),HL                       ; Save code string address
   0963 EB            [ 4] 1523         EX      DE,HL                         ; Number to DE
   0964 7D            [ 4] 1524 STORED: LD      A,L                           ; Get LSB of new RAM top
   0965 93            [ 4] 1525         SUB     E                             ; Subtract LSB of string space
   0966 5F            [ 4] 1526         LD      E,A                           ; Save LSB
   0967 7C            [ 4] 1527         LD      A,H                           ; Get MSB of new RAM top
   0968 9A            [ 4] 1528         SBC     A,D                           ; Subtract MSB of string space
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 29
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0969 57            [ 4] 1529         LD      D,A                           ; Save MSB
   096A DA ED 03      [10] 1530         JP      C,OMERR                       ; ?OM Error if not enough mem
   096D E5            [11] 1531         PUSH    HL                            ; Save RAM top
   096E 2A 1B 81      [16] 1532         LD      HL,(PROGND)                   ; Get program end
   0971 01 28 00      [10] 1533         LD      BC,40                         ; 40 Bytes minimum working RAM
   0974 09            [11] 1534         ADD     HL,BC                         ; Get lowest address
   0975 CD C0 06      [17] 1535         CALL    CPDEHL                        ; Enough memory?
   0978 D2 ED 03      [10] 1536         JP      NC,OMERR                      ; No - ?OM Error
   097B EB            [ 4] 1537         EX      DE,HL                         ; RAM top to HL
   097C 22 9F 80      [16] 1538         LD      (STRSPC),HL                   ; Set new string space
   097F E1            [10] 1539         POP     HL                            ; End of memory to use
   0980 22 F4 80      [16] 1540         LD      (LSTRAM),HL                   ; Set new top of RAM
   0983 E1            [10] 1541         POP     HL                            ; Restore code string address
   0984 C3 14 05      [10] 1542         JP      INTVAR                        ; Initialise variables
                           1543 ;
   0987 CA 10 05      [10] 1544 RUN:    JP      Z,RUNFST                      ; RUN from start if just RUN
   098A CD 14 05      [17] 1545         CALL    INTVAR                        ; Initialise variables
   098D 01 10 08      [10] 1546         LD      BC,RUNCNT                     ; Execution driver loop
   0990 C3 A3 09      [10] 1547         JP      RUNLIN                        ; RUN from line number
                           1548 ;
   0993 0E 03         [ 7] 1549 GOSUB:  LD      C,3                           ; 3 Levels of stack needed
   0995 CD D5 03      [17] 1550         CALL    CHKSTK                        ; Check for 3 levels of stack
   0998 C1            [10] 1551         POP     BC                            ; Get return address
   0999 E5            [11] 1552         PUSH    HL                            ; Save code string for RETURN
   099A E5            [11] 1553         PUSH    HL                            ; And for GOSUB routine
   099B 2A A1 80      [16] 1554         LD      HL,(LINEAT)                   ; Get current line
   099E E3            [19] 1555         EX      (SP),HL                       ; Into stack - Code string out
   099F 3E 8C         [ 7] 1556         LD      A,ZGOSUB                      ; "GOSUB" token
   09A1 F5            [11] 1557         PUSH    AF                            ; Save token
   09A2 33            [ 6] 1558         INC     SP                            ; Don't save flags
                           1559 ;
   09A3 C5            [11] 1560 RUNLIN: PUSH    BC                            ; Save return address
   09A4 CD 1C 09      [17] 1561 GOTO:   CALL    ATOH                          ; ASCII number to DE binary
   09A7 CD E9 09      [17] 1562         CALL    REM                           ; Get end of line
   09AA E5            [11] 1563         PUSH    HL                            ; Save end of line
   09AB 2A A1 80      [16] 1564         LD      HL,(LINEAT)                   ; Get current line
   09AE CD C0 06      [17] 1565         CALL    CPDEHL                        ; Line after current?
   09B1 E1            [10] 1566         POP     HL                            ; Restore end of line
   09B2 23            [ 6] 1567         INC     HL                            ; Start of next line
   09B3 DC E7 04      [17] 1568         CALL    C,SRCHLP                      ; Line is after current line
   09B6 D4 E4 04      [17] 1569         CALL    NC,SRCHLN                     ; Line is before current line
   09B9 60            [ 4] 1570         LD      H,B                           ; Set up code string address
   09BA 69            [ 4] 1571         LD      L,C
   09BB 2B            [ 6] 1572         DEC     HL                            ; Incremented after
   09BC D8            [11] 1573         RET     C                             ; Line found
   09BD 1E 0E         [ 7] 1574 ULERR:  LD      E,UL                          ; ?UL Error
   09BF C3 0C 04      [10] 1575         JP      ERROR                         ; Output error message
                           1576 ;
   09C2 C0            [11] 1577 RETURN: RET     NZ                            ; Return if not just RETURN
   09C3 16 FF         [ 7] 1578         LD      D,-1                          ; Flag "GOSUB" search
   09C5 CD A1 03      [17] 1579         CALL    BAKSTK                        ; Look "GOSUB" block
   09C8 F9            [ 6] 1580         LD      SP,HL                         ; Kill all FORs in subroutine
   09C9 FE 8C         [ 7] 1581         CP      ZGOSUB                        ; Test for "GOSUB" token
   09CB 1E 04         [ 7] 1582         LD      E,RG                          ; ?RG Error
   09CD C2 0C 04      [10] 1583         JP      NZ,ERROR                      ; Error if no "GOSUB" found
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 30
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   09D0 E1            [10] 1584         POP     HL                            ; Get RETURN line number
   09D1 22 A1 80      [16] 1585         LD      (LINEAT),HL                   ; Save as current
   09D4 23            [ 6] 1586         INC     HL                            ; Was it from direct statement?
   09D5 7C            [ 4] 1587         LD      A,H
   09D6 B5            [ 4] 1588         OR      L                             ; Return to line
   09D7 C2 E1 09      [10] 1589         JP      NZ,RETLIN                     ; No - Return to line
   09DA 3A 11 81      [13] 1590         LD      A,(LSTBIN)                    ; Any INPUT in subroutine?
   09DD B7            [ 4] 1591         OR      A                             ; If so buffer is corrupted
   09DE C2 42 04      [10] 1592         JP      NZ,POPNOK                     ; Yes - Go to command mode
   09E1 21 10 08      [10] 1593 RETLIN: LD      HL,RUNCNT                     ; Execution driver loop
   09E4 E3            [19] 1594         EX      (SP),HL                       ; Into stack - Code string out
   09E5 3E                 1595         .db     0x3E                          ; Skip "POP HL"
   09E6 E1            [10] 1596 NXTDTA: POP     HL                            ; Restore code string address
                           1597 ;
   09E7 01 3A              1598 DATA:   .db     0x01,0x3A                     ; ': End of statement
   09E9 0E 00         [ 7] 1599 REM:    LD      C,0                           ; 00	End of statement
   09EB 06 00         [ 7] 1600         LD      B,0
   09ED 79            [ 4] 1601 NXTSTL: LD      A,C                           ; Statement and byte
   09EE 48            [ 4] 1602         LD      C,B
   09EF 47            [ 4] 1603         LD      B,A                           ; Statement end byte
   09F0 7E            [ 7] 1604 NXTSTT: LD      A,(HL)                        ; Get byte
   09F1 B7            [ 4] 1605         OR      A                             ; End of line?
   09F2 C8            [11] 1606         RET     Z                             ; Yes - Exit
   09F3 B8            [ 4] 1607         CP      B                             ; End of statement?
   09F4 C8            [11] 1608         RET     Z                             ; Yes - Exit
   09F5 23            [ 6] 1609         INC     HL                            ; Next byte
   09F6 FE 22         [ 7] 1610         CP      '"                            ; Literal string?
   09F8 CA ED 09      [10] 1611         JP      Z,NXTSTL                      ; Yes - Look for another '"
   09FB C3 F0 09      [10] 1612         JP      NXTSTT                        ; Keep looking
                           1613 ;
   09FE CD B3 0E      [17] 1614 LET:    CALL    GETVAR                        ; Get variable name
   0A01 CD C6 06      [17] 1615         CALL    CHKSYN                        ; Make sure "=" follows
   0A04 B4                 1616         .db     ZEQUAL                        ; "=" token
   0A05 D5            [11] 1617         PUSH    DE                            ; Save address of variable
   0A06 3A F2 80      [13] 1618         LD      A,(TYPE)                      ; Get data type
   0A09 F5            [11] 1619         PUSH    AF                            ; Save type
   0A0A CD CF 0C      [17] 1620         CALL    EVAL                          ; Evaluate expression
   0A0D F1            [10] 1621         POP     AF                            ; Restore type
   0A0E E3            [19] 1622         EX      (SP),HL                       ; Save code - Get var addr
   0A0F 22 13 81      [16] 1623         LD      (BRKLIN),HL                   ; Save address of variable
   0A12 1F            [ 4] 1624         RRA                                   ; Adjust type
   0A13 CD C2 0C      [17] 1625         CALL    CHKTYP                        ; Check types are the same
   0A16 CA 51 0A      [10] 1626         JP      Z,LETNUM                      ; Numeric - Move value
   0A19 E5            [11] 1627 LETSTR: PUSH    HL                            ; Save address of string var
   0A1A 2A 29 81      [16] 1628         LD      HL,(FPREG)                    ; Pointer to string entry
   0A1D E5            [11] 1629         PUSH    HL                            ; Save it on stack
   0A1E 23            [ 6] 1630         INC     HL                            ; Skip over length
   0A1F 23            [ 6] 1631         INC     HL
   0A20 5E            [ 7] 1632         LD      E,(HL)                        ; LSB of string address
   0A21 23            [ 6] 1633         INC     HL
   0A22 56            [ 7] 1634         LD      D,(HL)                        ; MSB of string address
   0A23 2A A3 80      [16] 1635         LD      HL,(BASTXT)                   ; Point to start of program
   0A26 CD C0 06      [17] 1636         CALL    CPDEHL                        ; Is string before program?
   0A29 D2 40 0A      [10] 1637         JP      NC,CRESTR                     ; Yes - Create string entry
   0A2C 2A 9F 80      [16] 1638         LD      HL,(STRSPC)                   ; Point to string space
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 31
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0A2F CD C0 06      [17] 1639         CALL    CPDEHL                        ; Is string literal in program?
   0A32 D1            [10] 1640         POP     DE                            ; Restore address of string
   0A33 D2 48 0A      [10] 1641         JP      NC,MVSTPT                     ; Yes - Set up pointer
   0A36 21 04 81      [10] 1642         LD      HL,TMPSTR                     ; Temporary string pool
   0A39 CD C0 06      [17] 1643         CALL    CPDEHL                        ; Is string in temporary pool?
   0A3C D2 48 0A      [10] 1644         JP      NC,MVSTPT                     ; No - Set up pointer
   0A3F 3E                 1645         .db     0x3E                          ; Skip "POP DE"
   0A40 D1            [10] 1646 CRESTR: POP     DE                            ; Restore address of string
   0A41 CD F7 12      [17] 1647         CALL    BAKTMP                        ; Back to last tmp-str entry
   0A44 EB            [ 4] 1648         EX      DE,HL                         ; Address of string entry
   0A45 CD 30 11      [17] 1649         CALL    SAVSTR                        ; Save string in string area
   0A48 CD F7 12      [17] 1650 MVSTPT: CALL    BAKTMP                        ; Back to last tmp-str entry
   0A4B E1            [10] 1651         POP     HL                            ; Get string pointer
   0A4C CD FA 16      [17] 1652         CALL    DETHL4                        ; Move string pointer to var
   0A4F E1            [10] 1653         POP     HL                            ; Restore code string address
   0A50 C9            [10] 1654         RET
                           1655 ;
   0A51 E5            [11] 1656 LETNUM: PUSH    HL                            ; Save address of variable
   0A52 CD F7 16      [17] 1657         CALL    FPTHL                         ; Move value to variable
   0A55 D1            [10] 1658         POP     DE                            ; Restore address of variable
   0A56 E1            [10] 1659         POP     HL                            ; Restore code string address
   0A57 C9            [10] 1660         RET
                           1661 ;
   0A58 CD 1E 14      [17] 1662 ON:     CALL    GETINT                        ; Get integer 0-255
   0A5B 7E            [ 7] 1663         LD      A,(HL)                        ; Get "GOTO" or "GOSUB" token
   0A5C 47            [ 4] 1664         LD      B,A                           ; Save in B
   0A5D FE 8C         [ 7] 1665         CP      ZGOSUB                        ; "GOSUB" token?
   0A5F CA 67 0A      [10] 1666         JP      Z,ONGO                        ; Yes - Find line number
   0A62 CD C6 06      [17] 1667         CALL    CHKSYN                        ; Make sure it's "GOTO"
   0A65 88                 1668         .db     ZGOTO                         ; "GOTO" token
   0A66 2B            [ 6] 1669         DEC     HL                            ; Cancel increment
   0A67 4B            [ 4] 1670 ONGO:   LD      C,E                           ; Integer of branch value
   0A68 0D            [ 4] 1671 ONGOLP: DEC     C                             ; Count branches
   0A69 78            [ 4] 1672         LD      A,B                           ; Get "GOTO" or "GOSUB" token
   0A6A CA 38 08      [10] 1673         JP      Z,ONJMP                       ; Go to that line if right one
   0A6D CD 1D 09      [17] 1674         CALL    GETLN                         ; Get line number to DE
   0A70 FE 2C         [ 7] 1675         CP      ',                            ; Another line number?
   0A72 C0            [11] 1676         RET     NZ                            ; No - Drop through
   0A73 C3 68 0A      [10] 1677         JP      ONGOLP                        ; Yes - loop
                           1678 ;
   0A76 CD CF 0C      [17] 1679 IF:     CALL    EVAL                          ; Evaluate expression
   0A79 7E            [ 7] 1680         LD      A,(HL)                        ; Get token
   0A7A FE 88         [ 7] 1681         CP      ZGOTO                         ; "GOTO" token?
   0A7C CA 84 0A      [10] 1682         JP      Z,IFGO                        ; Yes - Get line
   0A7F CD C6 06      [17] 1683         CALL    CHKSYN                        ; Make sure it's "THEN"
   0A82 A9                 1684         .db     ZTHEN                         ; "THEN" token
   0A83 2B            [ 6] 1685         DEC     HL                            ; Cancel increment
   0A84 CD C0 0C      [17] 1686 IFGO:   CALL    TSTNUM                        ; Make sure it's numeric
   0A87 CD 9F 16      [17] 1687         CALL    TSTSGN                        ; Test state of expression
   0A8A CA E9 09      [10] 1688         JP      Z,REM                         ; False - Drop through
   0A8D CD 50 08      [17] 1689         CALL    GETCHR                        ; Get next character
   0A90 DA A4 09      [10] 1690         JP      C,GOTO                        ; Number - GOTO that line
   0A93 C3 37 08      [10] 1691         JP      IFJMP                         ; Otherwise do statement
                           1692 ;
   0A96 2B            [ 6] 1693 MRPRNT: DEC     HL                            ; DEC 'cos GETCHR INCs
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 32
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0A97 CD 50 08      [17] 1694         CALL    GETCHR                        ; Get next character
   0A9A CA F8 0A      [10] 1695 PRINT:  JP      Z,PRCRLF                      ; CRLF if just PRINT
   0A9D C8            [11] 1696 PRNTLP: RET     Z                             ; End of list - Exit
   0A9E FE A5         [ 7] 1697         CP      ZTAB                          ; "TAB(" token?
   0AA0 CA 2B 0B      [10] 1698         JP      Z,DOTAB                       ; Yes - Do TAB routine
   0AA3 FE A8         [ 7] 1699         CP      ZSPC                          ; "SPC(" token?
   0AA5 CA 2B 0B      [10] 1700         JP      Z,DOTAB                       ; Yes - Do SPC routine
   0AA8 E5            [11] 1701         PUSH    HL                            ; Save code string address
   0AA9 FE 2C         [ 7] 1702         CP      ',                            ; Comma?
   0AAB CA 14 0B      [10] 1703         JP      Z,DOCOM                       ; Yes - Move to next zone
   0AAE FE 3B         [ 7] 1704         CP      59                            ;";"		; Semi-colon?
   0AB0 CA 4E 0B      [10] 1705         JP      Z,NEXITM                      ; Do semi-colon routine
   0AB3 C1            [10] 1706         POP     BC                            ; Code string address to BC
   0AB4 CD CF 0C      [17] 1707         CALL    EVAL                          ; Evaluate expression
   0AB7 E5            [11] 1708         PUSH    HL                            ; Save code string address
   0AB8 3A F2 80      [13] 1709         LD      A,(TYPE)                      ; Get variable type
   0ABB B7            [ 4] 1710         OR      A                             ; Is it a string variable?
   0ABC C2 E4 0A      [10] 1711         JP      NZ,PRNTST                     ; Yes - Output string contents
   0ABF CD 44 18      [17] 1712         CALL    NUMASC                        ; Convert number to text
   0AC2 CD 54 11      [17] 1713         CALL    CRTST                         ; Create temporary string
   0AC5 36 20         [10] 1714         LD      (HL),0x20                     ; Followed by a space
   0AC7 2A 29 81      [16] 1715         LD      HL,(FPREG)                    ; Get length of output
   0ACA 34            [11] 1716         INC     (HL)                          ; Plus 1 for the space
   0ACB 2A 29 81      [16] 1717         LD      HL,(FPREG)                    ; < Not needed >
   0ACE 3A 87 80      [13] 1718         LD      A,(LWIDTH)                    ; Get width of line
   0AD1 47            [ 4] 1719         LD      B,A                           ; To B
   0AD2 04            [ 4] 1720         INC     B                             ; Width 255 (No limit)?
   0AD3 CA E0 0A      [10] 1721         JP      Z,PRNTNB                      ; Yes - Output number string
   0AD6 04            [ 4] 1722         INC     B                             ; Adjust it
   0AD7 3A F0 80      [13] 1723         LD      A,(CURPOS)                    ; Get cursor position
   0ADA 86            [ 7] 1724         ADD     A,(HL)                        ; Add length of string
   0ADB 3D            [ 4] 1725         DEC     A                             ; Adjust it
   0ADC B8            [ 4] 1726         CP      B                             ; Will output fit on this line?
   0ADD D4 F8 0A      [17] 1727         CALL    NC,PRCRLF                     ; No - CRLF first
   0AE0 CD 99 11      [17] 1728 PRNTNB: CALL    PRS1                          ; Output string at (HL)
   0AE3 AF            [ 4] 1729         XOR     A                             ; Skip CALL by setting 'z flag
   0AE4 C4 99 11      [17] 1730 PRNTST: CALL    NZ,PRS1                       ; Output string at (HL)
   0AE7 E1            [10] 1731         POP     HL                            ; Restore code string address
   0AE8 C3 96 0A      [10] 1732         JP      MRPRNT                        ; See if more to PRINT
                           1733 ;
   0AEB 3A F0 80      [13] 1734 STTLIN: LD      A,(CURPOS)                    ; Make sure on new line
   0AEE B7            [ 4] 1735         OR      A                             ; Already at start?
   0AEF C8            [11] 1736         RET     Z                             ; Yes - Do nothing
   0AF0 C3 F8 0A      [10] 1737         JP      PRCRLF                        ; Start a new line
                           1738 ;
   0AF3 36 00         [10] 1739 ENDINP: LD      (HL),0                        ; Mark end of buffer
   0AF5 21 A5 80      [10] 1740         LD      HL,BUFFER-1                   ; Point to buffer
   0AF8 3E 0D         [ 7] 1741 PRCRLF: LD      A,CR                          ; Load a CR
   0AFA CD D1 06      [17] 1742         CALL    OUTC                          ; Output character
   0AFD 3E 0A         [ 7] 1743         LD      A,LF                          ; Load a LF
   0AFF CD D1 06      [17] 1744         CALL    OUTC                          ; Output character
   0B02 AF            [ 4] 1745 DONULL: XOR     A                             ; Set to position 0
   0B03 32 F0 80      [13] 1746         LD      (CURPOS),A                    ; Store it
   0B06 3A 86 80      [13] 1747         LD      A,(NULLS)                     ; Get number of nulls
   0B09 3D            [ 4] 1748 NULLP:  DEC     A                             ; Count them
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 33
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0B0A C8            [11] 1749         RET     Z                             ; Return if done
   0B0B F5            [11] 1750         PUSH    AF                            ; Save count
   0B0C AF            [ 4] 1751         XOR     A                             ; Load a null
   0B0D CD D1 06      [17] 1752         CALL    OUTC                          ; Output it
   0B10 F1            [10] 1753         POP     AF                            ; Restore count
   0B11 C3 09 0B      [10] 1754         JP      NULLP                         ; Keep counting
                           1755 ;
   0B14 3A 88 80      [13] 1756 DOCOM:  LD      A,(COMMAN)                    ; Get comma width
   0B17 47            [ 4] 1757         LD      B,A                           ; Save in B
   0B18 3A F0 80      [13] 1758         LD      A,(CURPOS)                    ; Get current position
   0B1B B8            [ 4] 1759         CP      B                             ; Within the limit?
   0B1C D4 F8 0A      [17] 1760         CALL    NC,PRCRLF                     ; No - output CRLF
   0B1F D2 4E 0B      [10] 1761         JP      NC,NEXITM                     ; Get next item
   0B22 D6 0E         [ 7] 1762 ZONELP: SUB     14                            ; Next zone of 14 characters
   0B24 D2 22 0B      [10] 1763         JP      NC,ZONELP                     ; Repeat if more zones
   0B27 2F            [ 4] 1764         CPL                                   ; Number of spaces to output
   0B28 C3 43 0B      [10] 1765         JP      ASPCS                         ; Output them
                           1766 ;
   0B2B F5            [11] 1767 DOTAB:  PUSH    AF                            ; Save token
   0B2C CD 1B 14      [17] 1768         CALL    FNDNUM                        ; Evaluate expression
   0B2F CD C6 06      [17] 1769         CALL    CHKSYN                        ; Make sure ")" follows
   0B32 29                 1770         .ascii  ")"
   0B33 2B            [ 6] 1771         DEC     HL                            ; Back space on to ")"
   0B34 F1            [10] 1772         POP     AF                            ; Restore token
   0B35 D6 A8         [ 7] 1773         SUB     ZSPC                          ; Was it "SPC(" ?
   0B37 E5            [11] 1774         PUSH    HL                            ; Save code string address
   0B38 CA 3E 0B      [10] 1775         JP      Z,DOSPC                       ; Yes - Do 'E spaces
   0B3B 3A F0 80      [13] 1776         LD      A,(CURPOS)                    ; Get current position
   0B3E 2F            [ 4] 1777 DOSPC:  CPL                                   ; Number of spaces to print to
   0B3F 83            [ 4] 1778         ADD     A,E                           ; Total number to print
   0B40 D2 4E 0B      [10] 1779         JP      NC,NEXITM                     ; TAB < Current POS(X)
   0B43 3C            [ 4] 1780 ASPCS:  INC     A                             ; Output A spaces
   0B44 47            [ 4] 1781         LD      B,A                           ; Save number to print
   0B45 3E 20         [ 7] 1782         LD      A,0x20                        ; Space
   0B47 CD D1 06      [17] 1783 SPCLP:  CALL    OUTC                          ; Output character in A
   0B4A 05            [ 4] 1784         DEC     B                             ; Count them
   0B4B C2 47 0B      [10] 1785         JP      NZ,SPCLP                      ; Repeat if more
   0B4E E1            [10] 1786 NEXITM: POP     HL                            ; Restore code string address
   0B4F CD 50 08      [17] 1787         CALL    GETCHR                        ; Get next character
   0B52 C3 9D 0A      [10] 1788         JP      PRNTLP                        ; More to print
                           1789 ;
   0B55 3F 52 65 64 6F 20  1790 REDO:   .ascii  "?Redo from start"
        66 72 6F 6D 20 73
        74 61 72 74
   0B65 0D 0A 00           1791         .db     CR,LF,0
                           1792 ;
   0B68 3A 12 81      [13] 1793 BADINP: LD      A,(READFG)                    ; READ or INPUT?
   0B6B B7            [ 4] 1794         OR      A
   0B6C C2 F2 03      [10] 1795         JP      NZ,DATSNR                     ; READ - ?SN Error
   0B6F C1            [10] 1796         POP     BC                            ; Throw away code string addr
   0B70 21 55 0B      [10] 1797         LD      HL,REDO                       ; "Redo from start" message
   0B73 CD 96 11      [17] 1798         CALL    PRS                           ; Output string
   0B76 C3 43 05      [10] 1799         JP      DOAGN                         ; Do last INPUT again
                           1800 ;
   0B79 CD 01 11      [17] 1801 INPUT:  CALL    IDTEST                        ; Test for illegal direct
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 34
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0B7C 7E            [ 7] 1802         LD      A,(HL)                        ; Get character after "INPUT"
   0B7D FE 22         [ 7] 1803         CP      '"                            ; Is there a prompt string?
   0B7F 3E 00         [ 7] 1804         LD      A,0                           ; Clear A and leave flags
   0B81 32 8A 80      [13] 1805         LD      (CTLOFG),A                    ; Enable output
   0B84 C2 93 0B      [10] 1806         JP      NZ,NOPMPT                     ; No prompt - get input
   0B87 CD 55 11      [17] 1807         CALL    QTSTR                         ; Get string terminated by '"
   0B8A CD C6 06      [17] 1808         CALL    CHKSYN                        ; Check for '; after prompt
   0B8D 3B                 1809         .db     ';
   0B8E E5            [11] 1810         PUSH    HL                            ; Save code string address
   0B8F CD 99 11      [17] 1811         CALL    PRS1                          ; Output prompt string
   0B92 3E                 1812         .db     0x3E                          ; Skip "PUSH HL"
   0B93 E5            [11] 1813 NOPMPT: PUSH    HL                            ; Save code string address
   0B94 CD 47 05      [17] 1814         CALL    PROMPT                        ; Get input with "? " prompt
   0B97 C1            [10] 1815         POP     BC                            ; Restore code string address
   0B98 DA 9F 08      [10] 1816         JP      C,INPBRK                      ; Break pressed - Exit
   0B9B 23            [ 6] 1817         INC     HL                            ; Next byte
   0B9C 7E            [ 7] 1818         LD      A,(HL)                        ; Get it
   0B9D B7            [ 4] 1819         OR      A                             ; End of line?
   0B9E 2B            [ 6] 1820         DEC     HL                            ; Back again
   0B9F C5            [11] 1821         PUSH    BC                            ; Re-save code string address
   0BA0 CA E6 09      [10] 1822         JP      Z,NXTDTA                      ; Yes - Find next DATA stmt
   0BA3 36 2C         [10] 1823         LD      (HL),',                       ; Store comma as separator
   0BA5 C3 AD 0B      [10] 1824         JP      NXTITM                        ; Get next item
                           1825 ;
   0BA8 E5            [11] 1826 READ:   PUSH    HL                            ; Save code string address
   0BA9 2A 21 81      [16] 1827         LD      HL,(NXTDAT)                   ; Next DATA statement
   0BAC F6                 1828         .db     0x0F6                         ; Flag "READ"
   0BAD AF            [ 4] 1829 NXTITM: XOR     A                             ; Flag "INPUT"
   0BAE 32 12 81      [13] 1830         LD      (READFG),A                    ; Save "READ"/"INPUT" flag
   0BB1 E3            [19] 1831         EX      (SP),HL                       ; Get code str' , Save pointer
   0BB2 C3 B9 0B      [10] 1832         JP      GTVLUS                        ; Get values
                           1833 ;
   0BB5 CD C6 06      [17] 1834 NEDMOR: CALL    CHKSYN                        ; Check for comma between items
   0BB8 2C                 1835         .db     ',
   0BB9 CD B3 0E      [17] 1836 GTVLUS: CALL    GETVAR                        ; Get variable name
   0BBC E3            [19] 1837         EX      (SP),HL                       ; Save code str" , Get pointer
   0BBD D5            [11] 1838         PUSH    DE                            ; Save variable address
   0BBE 7E            [ 7] 1839         LD      A,(HL)                        ; Get next "INPUT"/"DATA" byte
   0BBF FE 2C         [ 7] 1840         CP      ',                            ; Comma?
   0BC1 CA E1 0B      [10] 1841         JP      Z,ANTVLU                      ; Yes - Get another value
   0BC4 3A 12 81      [13] 1842         LD      A,(READFG)                    ; Is it READ?
   0BC7 B7            [ 4] 1843         OR      A
   0BC8 C2 4E 0C      [10] 1844         JP      NZ,FDTLP                      ; Yes - Find next DATA stmt
   0BCB 3E 3F         [ 7] 1845         LD      A,'?                          ; More INPUT needed
   0BCD CD D1 06      [17] 1846         CALL    OUTC                          ; Output character
   0BD0 CD 47 05      [17] 1847         CALL    PROMPT                        ; Get INPUT with prompt
   0BD3 D1            [10] 1848         POP     DE                            ; Variable address
   0BD4 C1            [10] 1849         POP     BC                            ; Code string address
   0BD5 DA 9F 08      [10] 1850         JP      C,INPBRK                      ; Break pressed
   0BD8 23            [ 6] 1851         INC     HL                            ; Point to next DATA byte
   0BD9 7E            [ 7] 1852         LD      A,(HL)                        ; Get byte
   0BDA B7            [ 4] 1853         OR      A                             ; Is it zero (No input) ?
   0BDB 2B            [ 6] 1854         DEC     HL                            ; Back space INPUT pointer
   0BDC C5            [11] 1855         PUSH    BC                            ; Save code string address
   0BDD CA E6 09      [10] 1856         JP      Z,NXTDTA                      ; Find end of buffer
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 35
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0BE0 D5            [11] 1857         PUSH    DE                            ; Save variable address
   0BE1 3A F2 80      [13] 1858 ANTVLU: LD      A,(TYPE)                      ; Check data type
   0BE4 B7            [ 4] 1859         OR      A                             ; Is it numeric?
   0BE5 CA 0B 0C      [10] 1860         JP      Z,INPBIN                      ; Yes - Convert to binary
   0BE8 CD 50 08      [17] 1861         CALL    GETCHR                        ; Get next character
   0BEB 57            [ 4] 1862         LD      D,A                           ; Save input character
   0BEC 47            [ 4] 1863         LD      B,A                           ; Again
   0BED FE 22         [ 7] 1864         CP      '"                            ; Start of literal sting?
   0BEF CA FF 0B      [10] 1865         JP      Z,STRENT                      ; Yes - Create string entry
   0BF2 3A 12 81      [13] 1866         LD      A,(READFG)                    ; "READ" or "INPUT" ?
   0BF5 B7            [ 4] 1867         OR      A
   0BF6 57            [ 4] 1868         LD      D,A                           ; Save 00 if "INPUT"
   0BF7 CA FC 0B      [10] 1869         JP      Z,ITMSEP                      ; "INPUT" - End with 00
   0BFA 16 3A         [ 7] 1870         LD      D,':                          ; "DATA" - End with 00 or ':
   0BFC 06 2C         [ 7] 1871 ITMSEP: LD      B,',                          ; Item separator
   0BFE 2B            [ 6] 1872         DEC     HL                            ; Back space for DTSTR
   0BFF CD 58 11      [17] 1873 STRENT: CALL    DTSTR                         ; Get string terminated by D
   0C02 EB            [ 4] 1874         EX      DE,HL                         ; String address to DE
   0C03 21 16 0C      [10] 1875         LD      HL,LTSTND                     ; Where to go after LETSTR
   0C06 E3            [19] 1876         EX      (SP),HL                       ; Save HL , get input pointer
   0C07 D5            [11] 1877         PUSH    DE                            ; Save address of string
   0C08 C3 19 0A      [10] 1878         JP      LETSTR                        ; Assign string to variable
                           1879 ;
   0C0B CD 50 08      [17] 1880 INPBIN: CALL    GETCHR                        ; Get next character
   0C0E CD A6 17      [17] 1881         CALL    ASCTFP                        ; Convert ASCII to FP number
   0C11 E3            [19] 1882         EX      (SP),HL                       ; Save input ptr, Get var addr
   0C12 CD F7 16      [17] 1883         CALL    FPTHL                         ; Move FPREG to variable
   0C15 E1            [10] 1884         POP     HL                            ; Restore input pointer
   0C16 2B            [ 6] 1885 LTSTND: DEC     HL                            ; DEC 'cos GETCHR INCs
   0C17 CD 50 08      [17] 1886         CALL    GETCHR                        ; Get next character
   0C1A CA 22 0C      [10] 1887         JP      Z,MORDT                       ; End of line - More needed?
   0C1D FE 2C         [ 7] 1888         CP      ',                            ; Another value?
   0C1F C2 68 0B      [10] 1889         JP      NZ,BADINP                     ; No - Bad input
   0C22 E3            [19] 1890 MORDT:  EX      (SP),HL                       ; Get code string address
   0C23 2B            [ 6] 1891         DEC     HL                            ; DEC 'cos GETCHR INCs
   0C24 CD 50 08      [17] 1892         CALL    GETCHR                        ; Get next character
   0C27 C2 B5 0B      [10] 1893         JP      NZ,NEDMOR                     ; More needed - Get it
   0C2A D1            [10] 1894         POP     DE                            ; Restore DATA pointer
   0C2B 3A 12 81      [13] 1895         LD      A,(READFG)                    ; "READ" or "INPUT" ?
   0C2E B7            [ 4] 1896         OR      A
   0C2F EB            [ 4] 1897         EX      DE,HL                         ; DATA pointer to HL
   0C30 C2 76 08      [10] 1898         JP      NZ,UPDATA                     ; Update DATA pointer if "READ"
   0C33 D5            [11] 1899         PUSH    DE                            ; Save code string address
   0C34 B6            [ 7] 1900         OR      (HL)                          ; More input given?
   0C35 21 3D 0C      [10] 1901         LD      HL,EXTIG                      ; "?Extra ignored" message
   0C38 C4 96 11      [17] 1902         CALL    NZ,PRS                        ; Output string if extra given
   0C3B E1            [10] 1903         POP     HL                            ; Restore code string address
   0C3C C9            [10] 1904         RET
                           1905 ;
   0C3D 3F 45 78 74 72 61  1906 EXTIG:  .ascii  "?Extra ignored"
        20 69 67 6E 6F 72
        65 64
   0C4B 0D 0A 00           1907         .db     CR,LF,0
                           1908 ;
   0C4E CD E7 09      [17] 1909 FDTLP:  CALL    DATA                          ; Get next statement
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 36
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0C51 B7            [ 4] 1910         OR      A                             ; End of line?
   0C52 C2 67 0C      [10] 1911         JP      NZ,FANDT                      ; No - See if DATA statement
   0C55 23            [ 6] 1912         INC     HL
   0C56 7E            [ 7] 1913         LD      A,(HL)                        ; End of program?
   0C57 23            [ 6] 1914         INC     HL
   0C58 B6            [ 7] 1915         OR      (HL)                          ; 00 00 Ends program
   0C59 1E 06         [ 7] 1916         LD      E,OD                          ; ?OD Error
   0C5B CA 0C 04      [10] 1917         JP      Z,ERROR                       ; Yes - Out of DATA
   0C5E 23            [ 6] 1918         INC     HL
   0C5F 5E            [ 7] 1919         LD      E,(HL)                        ; LSB of line number
   0C60 23            [ 6] 1920         INC     HL
   0C61 56            [ 7] 1921         LD      D,(HL)                        ; MSB of line number
   0C62 EB            [ 4] 1922         EX      DE,HL
   0C63 22 0E 81      [16] 1923         LD      (DATLIN),HL                   ; Set line of current DATA item
   0C66 EB            [ 4] 1924         EX      DE,HL
   0C67 CD 50 08      [17] 1925 FANDT:  CALL    GETCHR                        ; Get next character
   0C6A FE 83         [ 7] 1926         CP      ZDATA                         ; "DATA" token
   0C6C C2 4E 0C      [10] 1927         JP      NZ,FDTLP                      ; No "DATA" - Keep looking
   0C6F C3 E1 0B      [10] 1928         JP      ANTVLU                        ; Found - Convert input
                           1929 ;
   0C72 11 00 00      [10] 1930 NEXT:   LD      DE,0                          ; In case no index given
   0C75 C4 B3 0E      [17] 1931 NEXT1:  CALL    NZ,GETVAR                     ; Get index address
   0C78 22 13 81      [16] 1932         LD      (BRKLIN),HL                   ; Save code string address
   0C7B CD A1 03      [17] 1933         CALL    BAKSTK                        ; Look for "FOR" block
   0C7E C2 FE 03      [10] 1934         JP      NZ,NFERR                      ; No "FOR" - ?NF Error
   0C81 F9            [ 6] 1935         LD      SP,HL                         ; Clear nested loops
   0C82 D5            [11] 1936         PUSH    DE                            ; Save index address
   0C83 7E            [ 7] 1937         LD      A,(HL)                        ; Get sign of STEP
   0C84 23            [ 6] 1938         INC     HL
   0C85 F5            [11] 1939         PUSH    AF                            ; Save sign of STEP
   0C86 D5            [11] 1940         PUSH    DE                            ; Save index address
   0C87 CD DD 16      [17] 1941         CALL    PHLTFP                        ; Move index value to FPREG
   0C8A E3            [19] 1942         EX      (SP),HL                       ; Save address of TO value
   0C8B E5            [11] 1943         PUSH    HL                            ; Save address of index
   0C8C CD 4A 14      [17] 1944         CALL    ADDPHL                        ; Add STEP to index value
   0C8F E1            [10] 1945         POP     HL                            ; Restore address of index
   0C90 CD F7 16      [17] 1946         CALL    FPTHL                         ; Move value to index variable
   0C93 E1            [10] 1947         POP     HL                            ; Restore address of TO value
   0C94 CD EE 16      [17] 1948         CALL    LOADFP                        ; Move TO value to BCDE
   0C97 E5            [11] 1949         PUSH    HL                            ; Save address of line of FOR
   0C98 CD 1A 17      [17] 1950         CALL    CMPNUM                        ; Compare index with TO value
   0C9B E1            [10] 1951         POP     HL                            ; Restore address of line num
   0C9C C1            [10] 1952         POP     BC                            ; Address of sign of STEP
   0C9D 90            [ 4] 1953         SUB     B                             ; Compare with expected sign
   0C9E CD EE 16      [17] 1954         CALL    LOADFP                        ; BC = Loop stmt,DE = Line num
   0CA1 CA AD 0C      [10] 1955         JP      Z,KILFOR                      ; Loop finished - Terminate it
   0CA4 EB            [ 4] 1956         EX      DE,HL                         ; Loop statement line number
   0CA5 22 A1 80      [16] 1957         LD      (LINEAT),HL                   ; Set loop line number
   0CA8 69            [ 4] 1958         LD      L,C                           ; Set code string to loop
   0CA9 60            [ 4] 1959         LD      H,B
   0CAA C3 0C 08      [10] 1960         JP      PUTFID                        ; Put back "FOR" and continue
                           1961 ;
   0CAD F9            [ 6] 1962 KILFOR: LD      SP,HL                         ; Remove "FOR" block
   0CAE 2A 13 81      [16] 1963         LD      HL,(BRKLIN)                   ; Code string after "NEXT"
   0CB1 7E            [ 7] 1964         LD      A,(HL)                        ; Get next byte in code string
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 37
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0CB2 FE 2C         [ 7] 1965         CP      ',                            ; More NEXTs ?
   0CB4 C2 10 08      [10] 1966         JP      NZ,RUNCNT                     ; No - Do next statement
   0CB7 CD 50 08      [17] 1967         CALL    GETCHR                        ; Position to index name
   0CBA CD 75 0C      [17] 1968         CALL    NEXT1                         ; Re-enter NEXT routine
                           1969 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1970 ;
   0CBD CD CF 0C      [17] 1971 GETNUM: CALL    EVAL                          ; Get a numeric expression
   0CC0 F6                 1972 TSTNUM: .db     0x0F6                         ; Clear carry (numeric)
   0CC1 37            [ 4] 1973 TSTSTR: SCF                                   ; Set carry (string)
   0CC2 3A F2 80      [13] 1974 CHKTYP: LD      A,(TYPE)                      ; Check types match
   0CC5 8F            [ 4] 1975         ADC     A,A                           ; Expected + actual
   0CC6 B7            [ 4] 1976         OR      A                             ; Clear carry , set parity
   0CC7 E8            [11] 1977         RET     PE                            ; Even parity - Types match
   0CC8 C3 0A 04      [10] 1978         JP      TMERR                         ; Different types - Error
                           1979 ;
   0CCB CD C6 06      [17] 1980 OPNPAR: CALL    CHKSYN                        ; Make sure "(" follows
   0CCE 28                 1981         .ascii  "("
   0CCF 2B            [ 6] 1982 EVAL:   DEC     HL                            ; Evaluate expression & save
   0CD0 16 00         [ 7] 1983         LD      D,0                           ; Precedence value
   0CD2 D5            [11] 1984 EVAL1:  PUSH    DE                            ; Save precedence
   0CD3 0E 01         [ 7] 1985         LD      C,1
   0CD5 CD D5 03      [17] 1986         CALL    CHKSTK                        ; Check for 1 level of stack
   0CD8 CD 46 0D      [17] 1987         CALL    OPRND                         ; Get next expression value
   0CDB 22 15 81      [16] 1988 EVAL2:  LD      (NXTOPR),HL                   ; Save address of next operator
   0CDE 2A 15 81      [16] 1989 EVAL3:  LD      HL,(NXTOPR)                   ; Restore address of next opr
   0CE1 C1            [10] 1990         POP     BC                            ; Precedence value and operator
   0CE2 78            [ 4] 1991         LD      A,B                           ; Get precedence value
   0CE3 FE 78         [ 7] 1992         CP      0x78                          ; "AND" or "OR" ?
   0CE5 D4 C0 0C      [17] 1993         CALL    NC,TSTNUM                     ; No - Make sure it's a number
   0CE8 7E            [ 7] 1994         LD      A,(HL)                        ; Get next operator / function
   0CE9 16 00         [ 7] 1995         LD      D,0                           ; Clear Last relation
   0CEB D6 B3         [ 7] 1996 RLTLP:  SUB     ZGTR                          ; ">" Token
   0CED DA 07 0D      [10] 1997         JP      C,FOPRND                      ; + - * / ^ AND OR - Test it
   0CF0 FE 03         [ 7] 1998         CP      ZLTH+1-ZGTR                   ; < = >
   0CF2 D2 07 0D      [10] 1999         JP      NC,FOPRND                     ; Function - Call it
   0CF5 FE 01         [ 7] 2000         CP      ZEQUAL-ZGTR                   ; "="
   0CF7 17            [ 4] 2001         RLA                                   ; <- Test for legal
   0CF8 AA            [ 4] 2002         XOR     D                             ; <- combinations of < = >
   0CF9 BA            [ 4] 2003         CP      D                             ; <- by combining last token
   0CFA 57            [ 4] 2004         LD      D,A                           ; <- with current one
   0CFB DA F8 03      [10] 2005         JP      C,SNERR                       ; Error if "<<' '==" or ">>"
   0CFE 22 0A 81      [16] 2006         LD      (CUROPR),HL                   ; Save address of current token
   0D01 CD 50 08      [17] 2007         CALL    GETCHR                        ; Get next character
   0D04 C3 EB 0C      [10] 2008         JP      RLTLP                         ; Treat the two as one
                           2009 ;
   0D07 7A            [ 4] 2010 FOPRND: LD      A,D                           ; < = > found ?
   0D08 B7            [ 4] 2011         OR      A
   0D09 C2 2E 0E      [10] 2012         JP      NZ,TSTRED                     ; Yes - Test for reduction
   0D0C 7E            [ 7] 2013         LD      A,(HL)                        ; Get operator token
   0D0D 22 0A 81      [16] 2014         LD      (CUROPR),HL                   ; Save operator address
   0D10 D6 AC         [ 7] 2015         SUB     ZPLUS                         ; Operator or function?
   0D12 D8            [11] 2016         RET     C                             ; Neither - Exit
   0D13 FE 07         [ 7] 2017         CP      ZOR+1-ZPLUS                   ; Is it + - * / ^ AND OR ?
   0D15 D0            [11] 2018         RET     NC                            ; No - Exit
   0D16 5F            [ 4] 2019         LD      E,A                           ; Coded operator
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 38
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0D17 3A F2 80      [13] 2020         LD      A,(TYPE)                      ; Get data type
   0D1A 3D            [ 4] 2021         DEC     A                             ; FF = numeric , 00 = string
   0D1B B3            [ 4] 2022         OR      E                             ; Combine with coded operator
   0D1C 7B            [ 4] 2023         LD      A,E                           ; Get coded operator
   0D1D CA 8C 12      [10] 2024         JP      Z,CONCAT                      ; String concatenation
   0D20 07            [ 4] 2025         RLCA                                  ; Times 2
   0D21 83            [ 4] 2026         ADD     A,E                           ; Times 3
   0D22 5F            [ 4] 2027         LD      E,A                           ; To DE (D is 0)
   0D23 21 EA 02      [10] 2028         LD      HL,PRITAB                     ; Precedence table
   0D26 19            [11] 2029         ADD     HL,DE                         ; To the operator concerned
   0D27 78            [ 4] 2030         LD      A,B                           ; Last operator precedence
   0D28 56            [ 7] 2031         LD      D,(HL)                        ; Get evaluation precedence
   0D29 BA            [ 4] 2032         CP      D                             ; Compare with eval precedence
   0D2A D0            [11] 2033         RET     NC                            ; Exit if higher precedence
   0D2B 23            [ 6] 2034         INC     HL                            ; Point to routine address
   0D2C CD C0 0C      [17] 2035         CALL    TSTNUM                        ; Make sure it's a number
                           2036 ;
   0D2F C5            [11] 2037 STKTHS: PUSH    BC                            ; Save last precedence & token
   0D30 01 DE 0C      [10] 2038         LD      BC,EVAL3                      ; Where to go on prec' break
   0D33 C5            [11] 2039         PUSH    BC                            ; Save on stack for return
   0D34 43            [ 4] 2040         LD      B,E                           ; Save operator
   0D35 4A            [ 4] 2041         LD      C,D                           ; Save precedence
   0D36 CD D0 16      [17] 2042         CALL    STAKFP                        ; Move value to stack
   0D39 58            [ 4] 2043         LD      E,B                           ; Restore operator
   0D3A 51            [ 4] 2044         LD      D,C                           ; Restore precedence
   0D3B 4E            [ 7] 2045         LD      C,(HL)                        ; Get LSB of routine address
   0D3C 23            [ 6] 2046         INC     HL
   0D3D 46            [ 7] 2047         LD      B,(HL)                        ; Get MSB of routine address
   0D3E 23            [ 6] 2048         INC     HL
   0D3F C5            [11] 2049         PUSH    BC                            ; Save routine address
   0D40 2A 0A 81      [16] 2050         LD      HL,(CUROPR)                   ; Address of current operator
   0D43 C3 D2 0C      [10] 2051         JP      EVAL1                         ; Loop until prec' break
                           2052 ;
   0D46 AF            [ 4] 2053 OPRND:  XOR     A                             ; Get operand routine
   0D47 32 F2 80      [13] 2054         LD      (TYPE),A                      ; Set numeric expected
   0D4A CD 50 08      [17] 2055         CALL    GETCHR                        ; Get next character
   0D4D 1E 24         [ 7] 2056         LD      E,MO                          ; ?MO Error
   0D4F CA 0C 04      [10] 2057         JP      Z,ERROR                       ; No operand - Error
   0D52 DA A6 17      [10] 2058         JP      C,ASCTFP                      ; Number - Get value
   0D55 CD EE 08      [17] 2059         CALL    CHKLTR                        ; See if a letter
   0D58 D2 AD 0D      [10] 2060         JP      NC,CONVAR                     ; Letter - Find variable
   0D5B FE 26         [ 7] 2061         CP      '&                            ; &H = HEX, &B = BINARY
   0D5D 20 12         [12] 2062         JR      NZ,NOTAMP
   0D5F CD 50 08      [17] 2063         CALL    GETCHR                        ; Get next character
   0D62 FE 48         [ 7] 2064         CP      'H                            ; Hex number indicated? [function added]
   0D64 CA EA 1B      [10] 2065         JP      Z,HEXTFP                      ; Convert Hex to FPREG
   0D67 FE 42         [ 7] 2066         CP      'B                            ; Binary number indicated? [function added]
   0D69 CA 5A 1C      [10] 2067         JP      Z,BINTFP                      ; Convert Bin to FPREG
   0D6C 1E 02         [ 7] 2068         LD      E,SN                          ; If neither then a ?SN Error
   0D6E CA 0C 04      [10] 2069         JP      Z,ERROR
   0D71 FE AC         [ 7] 2070 NOTAMP: CP      ZPLUS                         ; '+ Token ?
   0D73 CA 46 0D      [10] 2071         JP      Z,OPRND                       ; Yes - Look for operand
   0D76 FE 2E         [ 7] 2072         CP      '.                            ; '. ?
   0D78 CA A6 17      [10] 2073         JP      Z,ASCTFP                      ; Yes - Create FP number
   0D7B FE AD         [ 7] 2074         CP      ZMINUS                        ; '- Token ?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 39
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0D7D CA 9C 0D      [10] 2075         JP      Z,MINUS                       ; Yes - Do minus
   0D80 FE 22         [ 7] 2076         CP      '"                            ; Literal string ?
   0D82 CA 55 11      [10] 2077         JP      Z,QTSTR                       ; Get string terminated by '"
   0D85 FE AA         [ 7] 2078         CP      ZNOT                          ; "NOT" Token ?
   0D87 CA 8E 0E      [10] 2079         JP      Z,EVNOT                       ; Yes - Eval NOT expression
   0D8A FE A7         [ 7] 2080         CP      ZFN                           ; "FN" Token ?
   0D8C CA B9 10      [10] 2081         JP      Z,DOFN                        ; Yes - Do FN routine
   0D8F D6 B6         [ 7] 2082         SUB     ZSGN                          ; Is it a function?
   0D91 D2 BE 0D      [10] 2083         JP      NC,FNOFST                     ; Yes - Evaluate function
   0D94 CD CB 0C      [17] 2084 EVLPAR: CALL    OPNPAR                        ; Evaluate expression in "()"
   0D97 CD C6 06      [17] 2085         CALL    CHKSYN                        ; Make sure ")" follows
   0D9A 29                 2086         .ascii  ")"
   0D9B C9            [10] 2087         RET
                           2088 ;
   0D9C 16 7D         [ 7] 2089 MINUS:  LD      D,0x7D                        ; '- precedence
   0D9E CD D2 0C      [17] 2090         CALL    EVAL1                         ; Evaluate until prec' break
   0DA1 2A 15 81      [16] 2091         LD      HL,(NXTOPR)                   ; Get next operator address
   0DA4 E5            [11] 2092         PUSH    HL                            ; Save next operator address
   0DA5 CD C8 16      [17] 2093         CALL    INVSGN                        ; Negate value
   0DA8 CD C0 0C      [17] 2094 RETNUM: CALL    TSTNUM                        ; Make sure it's a number
   0DAB E1            [10] 2095         POP     HL                            ; Restore next operator address
   0DAC C9            [10] 2096         RET
                           2097 ;
   0DAD CD B3 0E      [17] 2098 CONVAR: CALL    GETVAR                        ; Get variable address to DE
   0DB0 E5            [11] 2099 FRMEVL: PUSH    HL                            ; Save code string address
   0DB1 EB            [ 4] 2100         EX      DE,HL                         ; Variable address to HL
   0DB2 22 29 81      [16] 2101         LD      (FPREG),HL                    ; Save address of variable
   0DB5 3A F2 80      [13] 2102         LD      A,(TYPE)                      ; Get type
   0DB8 B7            [ 4] 2103         OR      A                             ; Numeric?
   0DB9 CC DD 16      [17] 2104         CALL    Z,PHLTFP                      ; Yes - Move contents to FPREG
   0DBC E1            [10] 2105         POP     HL                            ; Restore code string address
   0DBD C9            [10] 2106         RET
                           2107 ;
   0DBE 06 00         [ 7] 2108 FNOFST: LD      B,0                           ; Get address of function
   0DC0 07            [ 4] 2109         RLCA                                  ; Double function offset
   0DC1 4F            [ 4] 2110         LD      C,A                           ; BC = Offset in function table
   0DC2 C5            [11] 2111         PUSH    BC                            ; Save adjusted token value
   0DC3 CD 50 08      [17] 2112         CALL    GETCHR                        ; Get next character
   0DC6 79            [ 4] 2113         LD      A,C                           ; Get adjusted token value
   0DC7 FE 31         [ 7] 2114         CP      2*(ZLEFT-ZSGN)-1              ; Adj' LEFT$,RIGHT$ or MID$ ?
   0DC9 DA E5 0D      [10] 2115         JP      C,FNVAL                       ; No - Do function
   0DCC CD CB 0C      [17] 2116         CALL    OPNPAR                        ; Evaluate expression	(X,...
   0DCF CD C6 06      [17] 2117         CALL    CHKSYN                        ; Make sure ', follows
   0DD2 2C                 2118         .db     ',
   0DD3 CD C1 0C      [17] 2119         CALL    TSTSTR                        ; Make sure it's a string
   0DD6 EB            [ 4] 2120         EX      DE,HL                         ; Save code string address
   0DD7 2A 29 81      [16] 2121         LD      HL,(FPREG)                    ; Get address of string
   0DDA E3            [19] 2122         EX      (SP),HL                       ; Save address of string
   0DDB E5            [11] 2123         PUSH    HL                            ; Save adjusted token value
   0DDC EB            [ 4] 2124         EX      DE,HL                         ; Restore code string address
   0DDD CD 1E 14      [17] 2125         CALL    GETINT                        ; Get integer 0-255
   0DE0 EB            [ 4] 2126         EX      DE,HL                         ; Save code string address
   0DE1 E3            [19] 2127         EX      (SP),HL                       ; Save integer,HL = adj' token
   0DE2 C3 ED 0D      [10] 2128         JP      GOFUNC                        ; Jump to string function
                           2129 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 40
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0DE5 CD 94 0D      [17] 2130 FNVAL:  CALL    EVLPAR                        ; Evaluate expression
   0DE8 E3            [19] 2131         EX      (SP),HL                       ; HL = Adjusted token value
   0DE9 11 A8 0D      [10] 2132         LD      DE,RETNUM                     ; Return number from function
   0DEC D5            [11] 2133         PUSH    DE                            ; Save on stack
   0DED 01 49 01      [10] 2134 GOFUNC: LD      BC,FNCTAB                     ; Function routine addresses
   0DF0 09            [11] 2135         ADD     HL,BC                         ; Point to right address
   0DF1 4E            [ 7] 2136         LD      C,(HL)                        ; Get LSB of address
   0DF2 23            [ 6] 2137         INC     HL                            ;
   0DF3 66            [ 7] 2138         LD      H,(HL)                        ; Get MSB of address
   0DF4 69            [ 4] 2139         LD      L,C                           ; Address to HL
   0DF5 E9            [ 4] 2140         JP      (HL)                          ; Jump to function
                           2141 ;
   0DF6 15            [ 4] 2142 SGNEXP: DEC     D                             ; Dee to flag negative exponent
   0DF7 FE AD         [ 7] 2143         CP      ZMINUS                        ; '- token ?
   0DF9 C8            [11] 2144         RET     Z                             ; Yes - Return
   0DFA FE 2D         [ 7] 2145         CP      '-                            ; '- ASCII ?
   0DFC C8            [11] 2146         RET     Z                             ; Yes - Return
   0DFD 14            [ 4] 2147         INC     D                             ; Inc to flag positive exponent
   0DFE FE 2B         [ 7] 2148         CP      '+                            ; '+ ASCII ?
   0E00 C8            [11] 2149         RET     Z                             ; Yes - Return
   0E01 FE AC         [ 7] 2150         CP      ZPLUS                         ; '+ token ?
   0E03 C8            [11] 2151         RET     Z                             ; Yes - Return
   0E04 2B            [ 6] 2152         DEC     HL                            ; DEC 'cos GETCHR INCs
   0E05 C9            [10] 2153         RET                                   ; Return "NZ"
                           2154 ;
   0E06 F6                 2155 POR:    .db     0x0F6                         ; Flag "OR"
   0E07 AF            [ 4] 2156 PAND:   XOR     A                             ; Flag "AND"
   0E08 F5            [11] 2157         PUSH    AF                            ; Save "AND" / "OR" flag
   0E09 CD C0 0C      [17] 2158         CALL    TSTNUM                        ; Make sure it's a number
   0E0C CD 02 09      [17] 2159         CALL    DEINT                         ; Get integer -32768 to 32767
   0E0F F1            [10] 2160         POP     AF                            ; Restore "AND" / "OR" flag
   0E10 EB            [ 4] 2161         EX      DE,HL                         ; <- Get last
   0E11 C1            [10] 2162         POP     BC                            ; <- value
   0E12 E3            [19] 2163         EX      (SP),HL                       ; <- from
   0E13 EB            [ 4] 2164         EX      DE,HL                         ; <- stack
   0E14 CD E0 16      [17] 2165         CALL    FPBCDE                        ; Move last value to FPREG
   0E17 F5            [11] 2166         PUSH    AF                            ; Save "AND" / "OR" flag
   0E18 CD 02 09      [17] 2167         CALL    DEINT                         ; Get integer -32768 to 32767
   0E1B F1            [10] 2168         POP     AF                            ; Restore "AND" / "OR" flag
   0E1C C1            [10] 2169         POP     BC                            ; Get value
   0E1D 79            [ 4] 2170         LD      A,C                           ; Get LSB
   0E1E 21 77 10      [10] 2171         LD      HL,ACPASS                     ; Address of save AC as current
   0E21 C2 29 0E      [10] 2172         JP      NZ,POR1                       ; Jump if OR
   0E24 A3            [ 4] 2173         AND     E                             ; "AND" LSBs
   0E25 4F            [ 4] 2174         LD      C,A                           ; Save LSB
   0E26 78            [ 4] 2175         LD      A,B                           ; Get MBS
   0E27 A2            [ 4] 2176         AND     D                             ; "AND" MSBs
   0E28 E9            [ 4] 2177         JP      (HL)                          ; Save AC as current (ACPASS)
                           2178 ;
   0E29 B3            [ 4] 2179 POR1:   OR      E                             ; "OR" LSBs
   0E2A 4F            [ 4] 2180         LD      C,A                           ; Save LSB
   0E2B 78            [ 4] 2181         LD      A,B                           ; Get MSB
   0E2C B2            [ 4] 2182         OR      D                             ; "OR" MSBs
   0E2D E9            [ 4] 2183         JP      (HL)                          ; Save AC as current (ACPASS)
                           2184 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 41
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0E2E 21 40 0E      [10] 2185 TSTRED: LD      HL,CMPLOG                     ; Logical compare routine
   0E31 3A F2 80      [13] 2186         LD      A,(TYPE)                      ; Get data type
   0E34 1F            [ 4] 2187         RRA                                   ; Carry set = string
   0E35 7A            [ 4] 2188         LD      A,D                           ; Get last precedence value
   0E36 17            [ 4] 2189         RLA                                   ; Times 2 plus carry
   0E37 5F            [ 4] 2190         LD      E,A                           ; To E
   0E38 16 64         [ 7] 2191         LD      D,0x64                        ; Relational precedence
   0E3A 78            [ 4] 2192         LD      A,B                           ; Get current precedence
   0E3B BA            [ 4] 2193         CP      D                             ; Compare with last
   0E3C D0            [11] 2194         RET     NC                            ; Eval if last was rel' or log'
   0E3D C3 2F 0D      [10] 2195         JP      STKTHS                        ; Stack this one and get next
                           2196 ;
   0E40 42 0E              2197 CMPLOG: .dw     CMPLG1                        ; Compare two values / strings
   0E42 79            [ 4] 2198 CMPLG1: LD      A,C                           ; Get data type
   0E43 B7            [ 4] 2199         OR      A
   0E44 1F            [ 4] 2200         RRA
   0E45 C1            [10] 2201         POP     BC                            ; Get last expression to BCDE
   0E46 D1            [10] 2202         POP     DE
   0E47 F5            [11] 2203         PUSH    AF                            ; Save status
   0E48 CD C2 0C      [17] 2204         CALL    CHKTYP                        ; Check that types match
   0E4B 21 84 0E      [10] 2205         LD      HL,CMPRES                     ; Result to comparison
   0E4E E5            [11] 2206         PUSH    HL                            ; Save for RETurn
   0E4F CA 1A 17      [10] 2207         JP      Z,CMPNUM                      ; Compare values if numeric
   0E52 AF            [ 4] 2208         XOR     A                             ; Compare two strings
   0E53 32 F2 80      [13] 2209         LD      (TYPE),A                      ; Set type to numeric
   0E56 D5            [11] 2210         PUSH    DE                            ; Save string name
   0E57 CD D9 12      [17] 2211         CALL    GSTRCU                        ; Get current string
   0E5A 7E            [ 7] 2212         LD      A,(HL)                        ; Get length of string
   0E5B 23            [ 6] 2213         INC     HL
   0E5C 23            [ 6] 2214         INC     HL
   0E5D 4E            [ 7] 2215         LD      C,(HL)                        ; Get LSB of address
   0E5E 23            [ 6] 2216         INC     HL
   0E5F 46            [ 7] 2217         LD      B,(HL)                        ; Get MSB of address
   0E60 D1            [10] 2218         POP     DE                            ; Restore string name
   0E61 C5            [11] 2219         PUSH    BC                            ; Save address of string
   0E62 F5            [11] 2220         PUSH    AF                            ; Save length of string
   0E63 CD DD 12      [17] 2221         CALL    GSTRDE                        ; Get second string
   0E66 CD EE 16      [17] 2222         CALL    LOADFP                        ; Get address of second string
   0E69 F1            [10] 2223         POP     AF                            ; Restore length of string 1
   0E6A 57            [ 4] 2224         LD      D,A                           ; Length to D
   0E6B E1            [10] 2225         POP     HL                            ; Restore address of string 1
   0E6C 7B            [ 4] 2226 CMPSTR: LD      A,E                           ; Bytes of string 2 to do
   0E6D B2            [ 4] 2227         OR      D                             ; Bytes of string 1 to do
   0E6E C8            [11] 2228         RET     Z                             ; Exit if all bytes compared
   0E6F 7A            [ 4] 2229         LD      A,D                           ; Get bytes of string 1 to do
   0E70 D6 01         [ 7] 2230         SUB     1
   0E72 D8            [11] 2231         RET     C                             ; Exit if end of string 1
   0E73 AF            [ 4] 2232         XOR     A
   0E74 BB            [ 4] 2233         CP      E                             ; Bytes of string 2 to do
   0E75 3C            [ 4] 2234         INC     A
   0E76 D0            [11] 2235         RET     NC                            ; Exit if end of string 2
   0E77 15            [ 4] 2236         DEC     D                             ; Count bytes in string 1
   0E78 1D            [ 4] 2237         DEC     E                             ; Count bytes in string 2
   0E79 0A            [ 7] 2238         LD      A,(BC)                        ; Byte in string 2
   0E7A BE            [ 7] 2239         CP      (HL)                          ; Compare to byte in string 1
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 42
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0E7B 23            [ 6] 2240         INC     HL                            ; Move up string 1
   0E7C 03            [ 6] 2241         INC     BC                            ; Move up string 2
   0E7D CA 6C 0E      [10] 2242         JP      Z,CMPSTR                      ; Same - Try next bytes
   0E80 3F            [ 4] 2243         CCF                                   ; Flag difference (">" or "<")
   0E81 C3 AA 16      [10] 2244         JP      FLGDIF                        ; "<" gives -1 , ">" gives +1
                           2245 ;
   0E84 3C            [ 4] 2246 CMPRES: INC     A                             ; Increment current value
   0E85 8F            [ 4] 2247         ADC     A,A                           ; Double plus carry
   0E86 C1            [10] 2248         POP     BC                            ; Get other value
   0E87 A0            [ 4] 2249         AND     B                             ; Combine them
   0E88 C6 FF         [ 7] 2250         ADD     A,-1                          ; Carry set if different
   0E8A 9F            [ 4] 2251         SBC     A,A                           ; 00 - Equal , FF - Different
   0E8B C3 B1 16      [10] 2252         JP      FLGREL                        ; Set current value & continue
                           2253 ;
   0E8E 16 5A         [ 7] 2254 EVNOT:  LD      D,0x5A                        ; Precedence value for "NOT"
   0E90 CD D2 0C      [17] 2255         CALL    EVAL1                         ; Eval until precedence break
   0E93 CD C0 0C      [17] 2256         CALL    TSTNUM                        ; Make sure it's a number
   0E96 CD 02 09      [17] 2257         CALL    DEINT                         ; Get integer -32768 - 32767
   0E99 7B            [ 4] 2258         LD      A,E                           ; Get LSB
   0E9A 2F            [ 4] 2259         CPL                                   ; Invert LSB
   0E9B 4F            [ 4] 2260         LD      C,A                           ; Save "NOT" of LSB
   0E9C 7A            [ 4] 2261         LD      A,D                           ; Get MSB
   0E9D 2F            [ 4] 2262         CPL                                   ; Invert MSB
   0E9E CD 77 10      [17] 2263         CALL    ACPASS                        ; Save AC as current
   0EA1 C1            [10] 2264         POP     BC                            ; Clean up stack
   0EA2 C3 DE 0C      [10] 2265         JP      EVAL3                         ; Continue evaluation
                           2266 ;
   0EA5 2B            [ 6] 2267 DIMRET: DEC     HL                            ; DEC 'cos GETCHR INCs
   0EA6 CD 50 08      [17] 2268         CALL    GETCHR                        ; Get next character
   0EA9 C8            [11] 2269         RET     Z                             ; End of DIM statement
   0EAA CD C6 06      [17] 2270         CALL    CHKSYN                        ; Make sure ', follows
   0EAD 2C                 2271         .db     ',
   0EAE 01 A5 0E      [10] 2272 DIM:    LD      BC,DIMRET                     ; Return to "DIMRET"
   0EB1 C5            [11] 2273         PUSH    BC                            ; Save on stack
   0EB2 F6                 2274         .db     0x0F6                         ; Flag "Create" variable
   0EB3 AF            [ 4] 2275 GETVAR: XOR     A                             ; Find variable address,to DE
   0EB4 32 F1 80      [13] 2276         LD      (LCRFLG),A                    ; Set locate / create flag
   0EB7 46            [ 7] 2277         LD      B,(HL)                        ; Get First byte of name
   0EB8 CD EE 08      [17] 2278 GTFNAM: CALL    CHKLTR                        ; See if a letter
   0EBB DA F8 03      [10] 2279         JP      C,SNERR                       ; ?SN Error if not a letter
   0EBE AF            [ 4] 2280         XOR     A
   0EBF 4F            [ 4] 2281         LD      C,A                           ; Clear second byte of name
   0EC0 32 F2 80      [13] 2282         LD      (TYPE),A                      ; Set type to numeric
   0EC3 CD 50 08      [17] 2283         CALL    GETCHR                        ; Get next character
   0EC6 DA CF 0E      [10] 2284         JP      C,SVNAM2                      ; Numeric - Save in name
   0EC9 CD EE 08      [17] 2285         CALL    CHKLTR                        ; See if a letter
   0ECC DA DC 0E      [10] 2286         JP      C,CHARTY                      ; Not a letter - Check type
   0ECF 4F            [ 4] 2287 SVNAM2: LD      C,A                           ; Save second byte of name
   0ED0 CD 50 08      [17] 2288 ENDNAM: CALL    GETCHR                        ; Get next character
   0ED3 DA D0 0E      [10] 2289         JP      C,ENDNAM                      ; Numeric - Get another
   0ED6 CD EE 08      [17] 2290         CALL    CHKLTR                        ; See if a letter
   0ED9 D2 D0 0E      [10] 2291         JP      NC,ENDNAM                     ; Letter - Get another
   0EDC D6 24         [ 7] 2292 CHARTY: SUB     '$                            ; String variable?
   0EDE C2 EB 0E      [10] 2293         JP      NZ,NOTSTR                     ; No - Numeric variable
   0EE1 3C            [ 4] 2294         INC     A                             ; A = 1 (string type)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 43
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0EE2 32 F2 80      [13] 2295         LD      (TYPE),A                      ; Set type to string
   0EE5 0F            [ 4] 2296         RRCA                                  ; A = 0x80 , Flag for string
   0EE6 81            [ 4] 2297         ADD     A,C                           ; 2nd byte of name has bit 7 on
   0EE7 4F            [ 4] 2298         LD      C,A                           ; Resave second byte on name
   0EE8 CD 50 08      [17] 2299         CALL    GETCHR                        ; Get next character
   0EEB 3A 10 81      [13] 2300 NOTSTR: LD      A,(FORFLG)                    ; Array name needed ?
   0EEE 3D            [ 4] 2301         DEC     A
   0EEF CA 98 0F      [10] 2302         JP      Z,ARLDSV                      ; Yes - Get array name
   0EF2 F2 FB 0E      [10] 2303         JP      P,NSCFOR                      ; No array with "FOR" or "FN"
   0EF5 7E            [ 7] 2304         LD      A,(HL)                        ; Get byte again
   0EF6 D6 28         [ 7] 2305         SUB     '(                            ; Subscripted variable?
   0EF8 CA 70 0F      [10] 2306         JP      Z,SBSCPT                      ; Yes - Sort out subscript
                           2307 ;
   0EFB AF            [ 4] 2308 NSCFOR: XOR     A                             ; Simple variable
   0EFC 32 10 81      [13] 2309         LD      (FORFLG),A                    ; Clear "FOR" flag
   0EFF E5            [11] 2310         PUSH    HL                            ; Save code string address
   0F00 50            [ 4] 2311         LD      D,B                           ; DE = Variable name to find
   0F01 59            [ 4] 2312         LD      E,C
   0F02 2A 23 81      [16] 2313         LD      HL,(FNRGNM)                   ; FN argument name
   0F05 CD C0 06      [17] 2314         CALL    CPDEHL                        ; Is it the FN argument?
   0F08 11 25 81      [10] 2315         LD      DE,FNARG                      ; Point to argument value
   0F0B CA E0 15      [10] 2316         JP      Z,POPHRT                      ; Yes - Return FN argument value
   0F0E 2A 1D 81      [16] 2317         LD      HL,(VAREND)                   ; End of variables
   0F11 EB            [ 4] 2318         EX      DE,HL                         ; Address of end of search
   0F12 2A 1B 81      [16] 2319         LD      HL,(PROGND)                   ; Start of variables address
   0F15 CD C0 06      [17] 2320 FNDVAR: CALL    CPDEHL                        ; End of variable list table?
   0F18 CA 2E 0F      [10] 2321         JP      Z,CFEVAL                      ; Yes - Called from EVAL?
   0F1B 79            [ 4] 2322         LD      A,C                           ; Get second byte of name
   0F1C 96            [ 7] 2323         SUB     (HL)                          ; Compare with name in list
   0F1D 23            [ 6] 2324         INC     HL                            ; Move on to first byte
   0F1E C2 23 0F      [10] 2325         JP      NZ,FNTHR                      ; Different - Find another
   0F21 78            [ 4] 2326         LD      A,B                           ; Get first byte of name
   0F22 96            [ 7] 2327         SUB     (HL)                          ; Compare with name in list
   0F23 23            [ 6] 2328 FNTHR:  INC     HL                            ; Move on to LSB of value
   0F24 CA 62 0F      [10] 2329         JP      Z,RETADR                      ; Found - Return address
   0F27 23            [ 6] 2330         INC     HL                            ; <- Skip
   0F28 23            [ 6] 2331         INC     HL                            ; <- over
   0F29 23            [ 6] 2332         INC     HL                            ; <- F.P.
   0F2A 23            [ 6] 2333         INC     HL                            ; <- value
   0F2B C3 15 0F      [10] 2334         JP      FNDVAR                        ; Keep looking
                           2335 ;
   0F2E E1            [10] 2336 CFEVAL: POP     HL                            ; Restore code string address
   0F2F E3            [19] 2337         EX      (SP),HL                       ; Get return address
   0F30 D5            [11] 2338         PUSH    DE                            ; Save address of variable
   0F31 11 B0 0D      [10] 2339         LD      DE,FRMEVL                     ; Return address in EVAL
   0F34 CD C0 06      [17] 2340         CALL    CPDEHL                        ; Called from EVAL ?
   0F37 D1            [10] 2341         POP     DE                            ; Restore address of variable
   0F38 CA 65 0F      [10] 2342         JP      Z,RETNUL                      ; Yes - Return null variable
   0F3B E3            [19] 2343         EX      (SP),HL                       ; Put back return
   0F3C E5            [11] 2344         PUSH    HL                            ; Save code string address
   0F3D C5            [11] 2345         PUSH    BC                            ; Save variable name
   0F3E 01 06 00      [10] 2346         LD      BC,6                          ; 2 byte name plus 4 byte data
   0F41 2A 1F 81      [16] 2347         LD      HL,(ARREND)                   ; End of arrays
   0F44 E5            [11] 2348         PUSH    HL                            ; Save end of arrays
   0F45 09            [11] 2349         ADD     HL,BC                         ; Move up 6 bytes
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 44
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0F46 C1            [10] 2350         POP     BC                            ; Source address in BC
   0F47 E5            [11] 2351         PUSH    HL                            ; Save new end address
   0F48 CD C4 03      [17] 2352         CALL    MOVUP                         ; Move arrays up
   0F4B E1            [10] 2353         POP     HL                            ; Restore new end address
   0F4C 22 1F 81      [16] 2354         LD      (ARREND),HL                   ; Set new end address
   0F4F 60            [ 4] 2355         LD      H,B                           ; End of variables to HL
   0F50 69            [ 4] 2356         LD      L,C
   0F51 22 1D 81      [16] 2357         LD      (VAREND),HL                   ; Set new end address
                           2358 ;
   0F54 2B            [ 6] 2359 ZEROLP: DEC     HL                            ; Back through to zero variable
   0F55 36 00         [10] 2360         LD      (HL),0                        ; Zero byte in variable
   0F57 CD C0 06      [17] 2361         CALL    CPDEHL                        ; Done them all?
   0F5A C2 54 0F      [10] 2362         JP      NZ,ZEROLP                     ; No - Keep on going
   0F5D D1            [10] 2363         POP     DE                            ; Get variable name
   0F5E 73            [ 7] 2364         LD      (HL),E                        ; Store second character
   0F5F 23            [ 6] 2365         INC     HL
   0F60 72            [ 7] 2366         LD      (HL),D                        ; Store first character
   0F61 23            [ 6] 2367         INC     HL
   0F62 EB            [ 4] 2368 RETADR: EX      DE,HL                         ; Address of variable in DE
   0F63 E1            [10] 2369         POP     HL                            ; Restore code string address
   0F64 C9            [10] 2370         RET
                           2371 ;
   0F65 32 2C 81      [13] 2372 RETNUL: LD      (FPEXP),A                     ; Set result to zero
   0F68 21 94 03      [10] 2373         LD      HL,ZERBYT                     ; Also set a null string
   0F6B 22 29 81      [16] 2374         LD      (FPREG),HL                    ; Save for EVAL
   0F6E E1            [10] 2375         POP     HL                            ; Restore code string address
   0F6F C9            [10] 2376         RET
                           2377 ;
   0F70 E5            [11] 2378 SBSCPT: PUSH    HL                            ; Save code string address
   0F71 2A F1 80      [16] 2379         LD      HL,(LCRFLG)                   ; Locate/Create and Type
   0F74 E3            [19] 2380         EX      (SP),HL                       ; Save and get code string
   0F75 57            [ 4] 2381         LD      D,A                           ; Zero number of dimensions
   0F76 D5            [11] 2382 SCPTLP: PUSH    DE                            ; Save number of dimensions
   0F77 C5            [11] 2383         PUSH    BC                            ; Save array name
   0F78 CD F6 08      [17] 2384         CALL    FPSINT                        ; Get subscript (0-32767)
   0F7B C1            [10] 2385         POP     BC                            ; Restore array name
   0F7C F1            [10] 2386         POP     AF                            ; Get number of dimensions
   0F7D EB            [ 4] 2387         EX      DE,HL
   0F7E E3            [19] 2388         EX      (SP),HL                       ; Save subscript value
   0F7F E5            [11] 2389         PUSH    HL                            ; Save LCRFLG and TYPE
   0F80 EB            [ 4] 2390         EX      DE,HL
   0F81 3C            [ 4] 2391         INC     A                             ; Count dimensions
   0F82 57            [ 4] 2392         LD      D,A                           ; Save in D
   0F83 7E            [ 7] 2393         LD      A,(HL)                        ; Get next byte in code string
   0F84 FE 2C         [ 7] 2394         CP      ',                            ; Comma (more to come)?
   0F86 CA 76 0F      [10] 2395         JP      Z,SCPTLP                      ; Yes - More subscripts
   0F89 CD C6 06      [17] 2396         CALL    CHKSYN                        ; Make sure ")" follows
   0F8C 29                 2397         .ascii  ")"
   0F8D 22 15 81      [16] 2398         LD      (NXTOPR),HL                   ; Save code string address
   0F90 E1            [10] 2399         POP     HL                            ; Get LCRFLG and TYPE
   0F91 22 F1 80      [16] 2400         LD      (LCRFLG),HL                   ; Restore Locate/create & type
   0F94 1E 00         [ 7] 2401         LD      E,0                           ; Flag not CSAVE* or CLOAD*
   0F96 D5            [11] 2402         PUSH    DE                            ; Save number of dimensions (D)
   0F97 11                 2403         .db     0x11                          ; Skip "PUSH HL" and "PUSH AF"
                           2404 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 45
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0F98 E5            [11] 2405 ARLDSV: PUSH    HL                            ; Save code string address
   0F99 F5            [11] 2406         PUSH    AF                            ; A = 00 , Flags set = Z,N
   0F9A 2A 1D 81      [16] 2407         LD      HL,(VAREND)                   ; Start of arrays
   0F9D 3E                 2408         .db     0x3E                          ; Skip "ADD HL,DE"
   0F9E 19            [11] 2409 FNDARY: ADD     HL,DE                         ; Move to next array start
   0F9F EB            [ 4] 2410         EX      DE,HL
   0FA0 2A 1F 81      [16] 2411         LD      HL,(ARREND)                   ; End of arrays
   0FA3 EB            [ 4] 2412         EX      DE,HL                         ; Current array pointer
   0FA4 CD C0 06      [17] 2413         CALL    CPDEHL                        ; End of arrays found?
   0FA7 CA D0 0F      [10] 2414         JP      Z,CREARY                      ; Yes - Create array
   0FAA 7E            [ 7] 2415         LD      A,(HL)                        ; Get second byte of name
   0FAB B9            [ 4] 2416         CP      C                             ; Compare with name given
   0FAC 23            [ 6] 2417         INC     HL                            ; Move on
   0FAD C2 B2 0F      [10] 2418         JP      NZ,NXTARY                     ; Different - Find next array
   0FB0 7E            [ 7] 2419         LD      A,(HL)                        ; Get first byte of name
   0FB1 B8            [ 4] 2420         CP      B                             ; Compare with name given
   0FB2 23            [ 6] 2421 NXTARY: INC     HL                            ; Move on
   0FB3 5E            [ 7] 2422         LD      E,(HL)                        ; Get LSB of next array address
   0FB4 23            [ 6] 2423         INC     HL
   0FB5 56            [ 7] 2424         LD      D,(HL)                        ; Get MSB of next array address
   0FB6 23            [ 6] 2425         INC     HL
   0FB7 C2 9E 0F      [10] 2426         JP      NZ,FNDARY                     ; Not found - Keep looking
   0FBA 3A F1 80      [13] 2427         LD      A,(LCRFLG)                    ; Found Locate or Create it?
   0FBD B7            [ 4] 2428         OR      A
   0FBE C2 01 04      [10] 2429         JP      NZ,DDERR                      ; Create - ?DD Error
   0FC1 F1            [10] 2430         POP     AF                            ; Locate - Get number of dim'ns
   0FC2 44            [ 4] 2431         LD      B,H                           ; BC Points to array dim'ns
   0FC3 4D            [ 4] 2432         LD      C,L
   0FC4 CA E0 15      [10] 2433         JP      Z,POPHRT                      ; Jump if array load/save
   0FC7 96            [ 7] 2434         SUB     (HL)                          ; Same number of dimensions?
   0FC8 CA 2E 10      [10] 2435         JP      Z,FINDEL                      ; Yes - Find element
   0FCB 1E 10         [ 7] 2436 BSERR:  LD      E,BS                          ; ?BS Error
   0FCD C3 0C 04      [10] 2437         JP      ERROR                         ; Output error
                           2438 ;
   0FD0 11 04 00      [10] 2439 CREARY: LD      DE,4                          ; 4 Bytes per entry
   0FD3 F1            [10] 2440         POP     AF                            ; Array to save or 0 dim'ns?
   0FD4 CA 17 09      [10] 2441         JP      Z,FCERR                       ; Yes - ?FC Error
   0FD7 71            [ 7] 2442         LD      (HL),C                        ; Save second byte of name
   0FD8 23            [ 6] 2443         INC     HL
   0FD9 70            [ 7] 2444         LD      (HL),B                        ; Save first byte of name
   0FDA 23            [ 6] 2445         INC     HL
   0FDB 4F            [ 4] 2446         LD      C,A                           ; Number of dimensions to C
   0FDC CD D5 03      [17] 2447         CALL    CHKSTK                        ; Check if enough memory
   0FDF 23            [ 6] 2448         INC     HL                            ; Point to number of dimensions
   0FE0 23            [ 6] 2449         INC     HL
   0FE1 22 0A 81      [16] 2450         LD      (CUROPR),HL                   ; Save address of pointer
   0FE4 71            [ 7] 2451         LD      (HL),C                        ; Set number of dimensions
   0FE5 23            [ 6] 2452         INC     HL
   0FE6 3A F1 80      [13] 2453         LD      A,(LCRFLG)                    ; Locate of Create?
   0FE9 17            [ 4] 2454         RLA                                   ; Carry set = Create
   0FEA 79            [ 4] 2455         LD      A,C                           ; Get number of dimensions
   0FEB 01 0B 00      [10] 2456 CRARLP: LD      BC,10+1                       ; Default dimension size 10
   0FEE D2 F3 0F      [10] 2457         JP      NC,DEFSIZ                     ; Locate - Set default size
   0FF1 C1            [10] 2458         POP     BC                            ; Get specified dimension size
   0FF2 03            [ 6] 2459         INC     BC                            ; Include zero element
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 46
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   0FF3 71            [ 7] 2460 DEFSIZ: LD      (HL),C                        ; Save LSB of dimension size
   0FF4 23            [ 6] 2461         INC     HL
   0FF5 70            [ 7] 2462         LD      (HL),B                        ; Save MSB of dimension size
   0FF6 23            [ 6] 2463         INC     HL
   0FF7 F5            [11] 2464         PUSH    AF                            ; Save num' of dim'ns an status
   0FF8 E5            [11] 2465         PUSH    HL                            ; Save address of dim'n size
   0FF9 CD 8B 17      [17] 2466         CALL    MLDEBC                        ; Multiply DE by BC to find
   0FFC EB            [ 4] 2467         EX      DE,HL                         ; amount of mem needed (to DE)
   0FFD E1            [10] 2468         POP     HL                            ; Restore address of dimension
   0FFE F1            [10] 2469         POP     AF                            ; Restore number of dimensions
   0FFF 3D            [ 4] 2470         DEC     A                             ; Count them
   1000 C2 EB 0F      [10] 2471         JP      NZ,CRARLP                     ; Do next dimension if more
   1003 F5            [11] 2472         PUSH    AF                            ; Save locate/create flag
   1004 42            [ 4] 2473         LD      B,D                           ; MSB of memory needed
   1005 4B            [ 4] 2474         LD      C,E                           ; LSB of memory needed
   1006 EB            [ 4] 2475         EX      DE,HL
   1007 19            [11] 2476         ADD     HL,DE                         ; Add bytes to array start
   1008 DA ED 03      [10] 2477         JP      C,OMERR                       ; Too big - Error
   100B CD DE 03      [17] 2478         CALL    ENFMEM                        ; See if enough memory
   100E 22 1F 81      [16] 2479         LD      (ARREND),HL                   ; Save new end of array
                           2480 ;
   1011 2B            [ 6] 2481 ZERARY: DEC     HL                            ; Back through array data
   1012 36 00         [10] 2482         LD      (HL),0                        ; Set array element to zero
   1014 CD C0 06      [17] 2483         CALL    CPDEHL                        ; All elements zeroed?
   1017 C2 11 10      [10] 2484         JP      NZ,ZERARY                     ; No - Keep on going
   101A 03            [ 6] 2485         INC     BC                            ; Number of bytes + 1
   101B 57            [ 4] 2486         LD      D,A                           ; A=0
   101C 2A 0A 81      [16] 2487         LD      HL,(CUROPR)                   ; Get address of array
   101F 5E            [ 7] 2488         LD      E,(HL)                        ; Number of dimensions
   1020 EB            [ 4] 2489         EX      DE,HL                         ; To HL
   1021 29            [11] 2490         ADD     HL,HL                         ; Two bytes per dimension size
   1022 09            [11] 2491         ADD     HL,BC                         ; Add number of bytes
   1023 EB            [ 4] 2492         EX      DE,HL                         ; Bytes needed to DE
   1024 2B            [ 6] 2493         DEC     HL
   1025 2B            [ 6] 2494         DEC     HL
   1026 73            [ 7] 2495         LD      (HL),E                        ; Save LSB of bytes needed
   1027 23            [ 6] 2496         INC     HL
   1028 72            [ 7] 2497         LD      (HL),D                        ; Save MSB of bytes needed
   1029 23            [ 6] 2498         INC     HL
   102A F1            [10] 2499         POP     AF                            ; Locate / Create?
   102B DA 52 10      [10] 2500         JP      C,ENDDIM                      ; A is 0 , End if create
   102E 47            [ 4] 2501 FINDEL: LD      B,A                           ; Find array element
   102F 4F            [ 4] 2502         LD      C,A
   1030 7E            [ 7] 2503         LD      A,(HL)                        ; Number of dimensions
   1031 23            [ 6] 2504         INC     HL
   1032 16                 2505         .db     0x16                          ; Skip "POP HL"
   1033 E1            [10] 2506 FNDELP: POP     HL                            ; Address of next dim' size
   1034 5E            [ 7] 2507         LD      E,(HL)                        ; Get LSB of dim'n size
   1035 23            [ 6] 2508         INC     HL
   1036 56            [ 7] 2509         LD      D,(HL)                        ; Get MSB of dim'n size
   1037 23            [ 6] 2510         INC     HL
   1038 E3            [19] 2511         EX      (SP),HL                       ; Save address - Get index
   1039 F5            [11] 2512         PUSH    AF                            ; Save number of dim'ns
   103A CD C0 06      [17] 2513         CALL    CPDEHL                        ; Dimension too large?
   103D D2 CB 0F      [10] 2514         JP      NC,BSERR                      ; Yes - ?BS Error
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 47
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1040 E5            [11] 2515         PUSH    HL                            ; Save index
   1041 CD 8B 17      [17] 2516         CALL    MLDEBC                        ; Multiply previous by size
   1044 D1            [10] 2517         POP     DE                            ; Index supplied to DE
   1045 19            [11] 2518         ADD     HL,DE                         ; Add index to pointer
   1046 F1            [10] 2519         POP     AF                            ; Number of dimensions
   1047 3D            [ 4] 2520         DEC     A                             ; Count them
   1048 44            [ 4] 2521         LD      B,H                           ; MSB of pointer
   1049 4D            [ 4] 2522         LD      C,L                           ; LSB of pointer
   104A C2 33 10      [10] 2523         JP      NZ,FNDELP                     ; More - Keep going
   104D 29            [11] 2524         ADD     HL,HL                         ; 4 Bytes per element
   104E 29            [11] 2525         ADD     HL,HL
   104F C1            [10] 2526         POP     BC                            ; Start of array
   1050 09            [11] 2527         ADD     HL,BC                         ; Point to element
   1051 EB            [ 4] 2528         EX      DE,HL                         ; Address of element to DE
   1052 2A 15 81      [16] 2529 ENDDIM: LD      HL,(NXTOPR)                   ; Got code string address
   1055 C9            [10] 2530         RET
                           2531 ;
   1056 2A 1F 81      [16] 2532 FRE:    LD      HL,(ARREND)                   ; Start of free memory
   1059 EB            [ 4] 2533         EX      DE,HL                         ; To DE
   105A 21 00 00      [10] 2534         LD      HL,0                          ; End of free memory
   105D 39            [11] 2535         ADD     HL,SP                         ; Current stack value
   105E 3A F2 80      [13] 2536         LD      A,(TYPE)                      ; Dummy argument type
   1061 B7            [ 4] 2537         OR      A
   1062 CA 72 10      [10] 2538         JP      Z,FRENUM                      ; Numeric - Free variable space
   1065 CD D9 12      [17] 2539         CALL    GSTRCU                        ; Current string to pool
   1068 CD D9 11      [17] 2540         CALL    GARBGE                        ; Garbage collection
   106B 2A 9F 80      [16] 2541         LD      HL,(STRSPC)                   ; Bottom of string space in use
   106E EB            [ 4] 2542         EX      DE,HL                         ; To DE
   106F 2A 08 81      [16] 2543         LD      HL,(STRBOT)                   ; Bottom of string space
   1072 7D            [ 4] 2544 FRENUM: LD      A,L                           ; Get LSB of end
   1073 93            [ 4] 2545         SUB     E                             ; Subtract LSB of beginning
   1074 4F            [ 4] 2546         LD      C,A                           ; Save difference if C
   1075 7C            [ 4] 2547         LD      A,H                           ; Get MSB of end
   1076 9A            [ 4] 2548         SBC     A,D                           ; Subtract MSB of beginning
   1077 41            [ 4] 2549 ACPASS: LD      B,C                           ; Return integer AC
   1078 50            [ 4] 2550 ABPASS: LD      D,B                           ; Return integer AB
   1079 1E 00         [ 7] 2551         LD      E,0
   107B 21 F2 80      [10] 2552         LD      HL,TYPE                       ; Point to type
   107E 73            [ 7] 2553         LD      (HL),E                        ; Set type to numeric
   107F 06 90         [ 7] 2554         LD      B,0x80+16                     ; 16 bit integer
   1081 C3 B6 16      [10] 2555         JP      RETINT                        ; Return the integr
                           2556 ;
   1084 3A F0 80      [13] 2557 POS:    LD      A,(CURPOS)                    ; Get cursor position
   1087 47            [ 4] 2558 PASSA:  LD      B,A                           ; Put A into AB
   1088 AF            [ 4] 2559         XOR     A                             ; Zero A
   1089 C3 78 10      [10] 2560         JP      ABPASS                        ; Return integer AB
                           2561 ;
   108C CD 0F 11      [17] 2562 DEF:    CALL    CHEKFN                        ; Get "FN" and name
   108F CD 01 11      [17] 2563         CALL    IDTEST                        ; Test for illegal direct
   1092 01 E7 09      [10] 2564         LD      BC,DATA                       ; To get next statement
   1095 C5            [11] 2565         PUSH    BC                            ; Save address for RETurn
   1096 D5            [11] 2566         PUSH    DE                            ; Save address of function ptr
   1097 CD C6 06      [17] 2567         CALL    CHKSYN                        ; Make sure "(" follows
   109A 28                 2568         .ascii  "("
   109B CD B3 0E      [17] 2569         CALL    GETVAR                        ; Get argument variable name
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 48
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   109E E5            [11] 2570         PUSH    HL                            ; Save code string address
   109F EB            [ 4] 2571         EX      DE,HL                         ; Argument address to HL
   10A0 2B            [ 6] 2572         DEC     HL
   10A1 56            [ 7] 2573         LD      D,(HL)                        ; Get first byte of arg name
   10A2 2B            [ 6] 2574         DEC     HL
   10A3 5E            [ 7] 2575         LD      E,(HL)                        ; Get second byte of arg name
   10A4 E1            [10] 2576         POP     HL                            ; Restore code string address
   10A5 CD C0 0C      [17] 2577         CALL    TSTNUM                        ; Make sure numeric argument
   10A8 CD C6 06      [17] 2578         CALL    CHKSYN                        ; Make sure ")" follows
   10AB 29                 2579         .ascii  ")"
   10AC CD C6 06      [17] 2580         CALL    CHKSYN                        ; Make sure "=" follows
   10AF B4                 2581         .db     ZEQUAL                        ; "=" token
   10B0 44            [ 4] 2582         LD      B,H                           ; Code string address to BC
   10B1 4D            [ 4] 2583         LD      C,L
   10B2 E3            [19] 2584         EX      (SP),HL                       ; Save code str , Get FN ptr
   10B3 71            [ 7] 2585         LD      (HL),C                        ; Save LSB of FN code string
   10B4 23            [ 6] 2586         INC     HL
   10B5 70            [ 7] 2587         LD      (HL),B                        ; Save MSB of FN code string
   10B6 C3 4E 11      [10] 2588         JP      SVSTAD                        ; Save address and do function
                           2589 ;
   10B9 CD 0F 11      [17] 2590 DOFN:   CALL    CHEKFN                        ; Make sure FN follows
   10BC D5            [11] 2591         PUSH    DE                            ; Save function pointer address
   10BD CD 94 0D      [17] 2592         CALL    EVLPAR                        ; Evaluate expression in "()"
   10C0 CD C0 0C      [17] 2593         CALL    TSTNUM                        ; Make sure numeric result
   10C3 E3            [19] 2594         EX      (SP),HL                       ; Save code str , Get FN ptr
   10C4 5E            [ 7] 2595         LD      E,(HL)                        ; Get LSB of FN code string
   10C5 23            [ 6] 2596         INC     HL
   10C6 56            [ 7] 2597         LD      D,(HL)                        ; Get MSB of FN code string
   10C7 23            [ 6] 2598         INC     HL
   10C8 7A            [ 4] 2599         LD      A,D                           ; And function DEFined?
   10C9 B3            [ 4] 2600         OR      E
   10CA CA 04 04      [10] 2601         JP      Z,UFERR                       ; No - ?UF Error
   10CD 7E            [ 7] 2602         LD      A,(HL)                        ; Get LSB of argument address
   10CE 23            [ 6] 2603         INC     HL
   10CF 66            [ 7] 2604         LD      H,(HL)                        ; Get MSB of argument address
   10D0 6F            [ 4] 2605         LD      L,A                           ; HL = Arg variable address
   10D1 E5            [11] 2606         PUSH    HL                            ; Save it
   10D2 2A 23 81      [16] 2607         LD      HL,(FNRGNM)                   ; Get old argument name
   10D5 E3            [19] 2608         EX      (SP),HL                       ;	; Save old , Get new
   10D6 22 23 81      [16] 2609         LD      (FNRGNM),HL                   ; Set new argument name
   10D9 2A 27 81      [16] 2610         LD      HL,(FNARG+2)                  ; Get LSB,NLSB of old arg value
   10DC E5            [11] 2611         PUSH    HL                            ; Save it
   10DD 2A 25 81      [16] 2612         LD      HL,(FNARG)                    ; Get MSB,EXP of old arg value
   10E0 E5            [11] 2613         PUSH    HL                            ; Save it
   10E1 21 25 81      [10] 2614         LD      HL,FNARG                      ; HL = Value of argument
   10E4 D5            [11] 2615         PUSH    DE                            ; Save FN code string address
   10E5 CD F7 16      [17] 2616         CALL    FPTHL                         ; Move FPREG to argument
   10E8 E1            [10] 2617         POP     HL                            ; Get FN code string address
   10E9 CD BD 0C      [17] 2618         CALL    GETNUM                        ; Get value from function
   10EC 2B            [ 6] 2619         DEC     HL                            ; DEC 'cos GETCHR INCs
   10ED CD 50 08      [17] 2620         CALL    GETCHR                        ; Get next character
   10F0 C2 F8 03      [10] 2621         JP      NZ,SNERR                      ; Bad character in FN - Error
   10F3 E1            [10] 2622         POP     HL                            ; Get MSB,EXP of old arg
   10F4 22 25 81      [16] 2623         LD      (FNARG),HL                    ; Restore it
   10F7 E1            [10] 2624         POP     HL                            ; Get LSB,NLSB of old arg
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 49
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   10F8 22 27 81      [16] 2625         LD      (FNARG+2),HL                  ; Restore it
   10FB E1            [10] 2626         POP     HL                            ; Get name of old arg
   10FC 22 23 81      [16] 2627         LD      (FNRGNM),HL                   ; Restore it
   10FF E1            [10] 2628         POP     HL                            ; Restore code string address
   1100 C9            [10] 2629         RET
                           2630 ;
   1101 E5            [11] 2631 IDTEST: PUSH    HL                            ; Save code string address
   1102 2A A1 80      [16] 2632         LD      HL,(LINEAT)                   ; Get current line number
   1105 23            [ 6] 2633         INC     HL                            ; -1 means direct statement
   1106 7C            [ 4] 2634         LD      A,H
   1107 B5            [ 4] 2635         OR      L
   1108 E1            [10] 2636         POP     HL                            ; Restore code string address
   1109 C0            [11] 2637         RET     NZ                            ; Return if in program
   110A 1E 16         [ 7] 2638         LD      E,ID                          ; ?ID Error
   110C C3 0C 04      [10] 2639         JP      ERROR
                           2640 ;
   110F CD C6 06      [17] 2641 CHEKFN: CALL    CHKSYN                        ; Make sure FN follows
   1112 A7                 2642         .db     ZFN                           ; "FN" token
   1113 3E 80         [ 7] 2643         LD      A,0x80
   1115 32 10 81      [13] 2644         LD      (FORFLG),A                    ; Flag FN name to find
   1118 B6            [ 7] 2645         OR      (HL)                          ; FN name has bit 7 set
   1119 47            [ 4] 2646         LD      B,A                           ; in first byte of name
   111A CD B8 0E      [17] 2647         CALL    GTFNAM                        ; Get FN name
   111D C3 C0 0C      [10] 2648         JP      TSTNUM                        ; Make sure numeric function
                           2649 ;
   1120 CD C0 0C      [17] 2650 STR:    CALL    TSTNUM                        ; Make sure it's a number
   1123 CD 44 18      [17] 2651         CALL    NUMASC                        ; Turn number into text
   1126 CD 54 11      [17] 2652 STR1:   CALL    CRTST                         ; Create string entry for it
   1129 CD D9 12      [17] 2653         CALL    GSTRCU                        ; Current string to pool
   112C 01 34 13      [10] 2654         LD      BC,TOPOOL                     ; Save in string pool
   112F C5            [11] 2655         PUSH    BC                            ; Save address on stack
                           2656 ;
   1130 7E            [ 7] 2657 SAVSTR: LD      A,(HL)                        ; Get string length
   1131 23            [ 6] 2658         INC     HL
   1132 23            [ 6] 2659         INC     HL
   1133 E5            [11] 2660         PUSH    HL                            ; Save pointer to string
   1134 CD AF 11      [17] 2661         CALL    TESTR                         ; See if enough string space
   1137 E1            [10] 2662         POP     HL                            ; Restore pointer to string
   1138 4E            [ 7] 2663         LD      C,(HL)                        ; Get LSB of address
   1139 23            [ 6] 2664         INC     HL
   113A 46            [ 7] 2665         LD      B,(HL)                        ; Get MSB of address
   113B CD 48 11      [17] 2666         CALL    CRTMST                        ; Create string entry
   113E E5            [11] 2667         PUSH    HL                            ; Save pointer to MSB of addr
   113F 6F            [ 4] 2668         LD      L,A                           ; Length of string
   1140 CD CC 12      [17] 2669         CALL    TOSTRA                        ; Move to string area
   1143 D1            [10] 2670         POP     DE                            ; Restore pointer to MSB
   1144 C9            [10] 2671         RET
                           2672 ;
   1145 CD AF 11      [17] 2673 MKTMST: CALL    TESTR                         ; See if enough string space
   1148 21 04 81      [10] 2674 CRTMST: LD      HL,TMPSTR                     ; Temporary string
   114B E5            [11] 2675         PUSH    HL                            ; Save it
   114C 77            [ 7] 2676         LD      (HL),A                        ; Save length of string
   114D 23            [ 6] 2677         INC     HL
   114E 23            [ 6] 2678 SVSTAD: INC     HL
   114F 73            [ 7] 2679         LD      (HL),E                        ; Save LSB of address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 50
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1150 23            [ 6] 2680         INC     HL
   1151 72            [ 7] 2681         LD      (HL),D                        ; Save MSB of address
   1152 E1            [10] 2682         POP     HL                            ; Restore pointer
   1153 C9            [10] 2683         RET
                           2684 ;
   1154 2B            [ 6] 2685 CRTST:  DEC     HL                            ; DEC - INCed after
   1155 06 22         [ 7] 2686 QTSTR:  LD      B,'"                          ; Terminating quote
   1157 50            [ 4] 2687         LD      D,B                           ; Quote to D
   1158 E5            [11] 2688 DTSTR:  PUSH    HL                            ; Save start
   1159 0E FF         [ 7] 2689         LD      C,-1                          ; Set counter to -1
   115B 23            [ 6] 2690 QTSTLP: INC     HL                            ; Move on
   115C 7E            [ 7] 2691         LD      A,(HL)                        ; Get byte
   115D 0C            [ 4] 2692         INC     C                             ; Count bytes
   115E B7            [ 4] 2693         OR      A                             ; End of line?
   115F CA 6A 11      [10] 2694         JP      Z,CRTSTE                      ; Yes - Create string entry
   1162 BA            [ 4] 2695         CP      D                             ; Terminator D found?
   1163 CA 6A 11      [10] 2696         JP      Z,CRTSTE                      ; Yes - Create string entry
   1166 B8            [ 4] 2697         CP      B                             ; Terminator B found?
   1167 C2 5B 11      [10] 2698         JP      NZ,QTSTLP                     ; No - Keep looking
   116A FE 22         [ 7] 2699 CRTSTE: CP      '"                            ; End with '"'?
   116C CC 50 08      [17] 2700         CALL    Z,GETCHR                      ; Yes - Get next character
   116F E3            [19] 2701         EX      (SP),HL                       ; Starting quote
   1170 23            [ 6] 2702         INC     HL                            ; First byte of string
   1171 EB            [ 4] 2703         EX      DE,HL                         ; To DE
   1172 79            [ 4] 2704         LD      A,C                           ; Get length
   1173 CD 48 11      [17] 2705         CALL    CRTMST                        ; Create string entry
   1176 11 04 81      [10] 2706 TSTOPL: LD      DE,TMPSTR                     ; Temporary string
   1179 2A F6 80      [16] 2707         LD      HL,(TMSTPT)                   ; Temporary string pool pointer
   117C 22 29 81      [16] 2708         LD      (FPREG),HL                    ; Save address of string ptr
   117F 3E 01         [ 7] 2709         LD      A,1
   1181 32 F2 80      [13] 2710         LD      (TYPE),A                      ; Set type to string
   1184 CD FA 16      [17] 2711         CALL    DETHL4                        ; Move string to pool
   1187 CD C0 06      [17] 2712         CALL    CPDEHL                        ; Out of string pool?
   118A 22 F6 80      [16] 2713         LD      (TMSTPT),HL                   ; Save new pointer
   118D E1            [10] 2714         POP     HL                            ; Restore code string address
   118E 7E            [ 7] 2715         LD      A,(HL)                        ; Get next code byte
   118F C0            [11] 2716         RET     NZ                            ; Return if pool OK
   1190 1E 1E         [ 7] 2717         LD      E,ST                          ; ?ST Error
   1192 C3 0C 04      [10] 2718         JP      ERROR                         ; String pool overflow
                           2719 ;
   1195 23            [ 6] 2720 PRNUMS: INC     HL                            ; Skip leading space
   1196 CD 54 11      [17] 2721 PRS:    CALL    CRTST                         ; Create string entry for it
   1199 CD D9 12      [17] 2722 PRS1:   CALL    GSTRCU                        ; Current string to pool
   119C CD EE 16      [17] 2723         CALL    LOADFP                        ; Move string block to BCDE
   119F 1C            [ 4] 2724         INC     E                             ; Length + 1
   11A0 1D            [ 4] 2725 PRSLP:  DEC     E                             ; Count characters
   11A1 C8            [11] 2726         RET     Z                             ; End of string
   11A2 0A            [ 7] 2727         LD      A,(BC)                        ; Get byte to output
   11A3 CD D1 06      [17] 2728         CALL    OUTC                          ; Output character in A
   11A6 FE 0D         [ 7] 2729         CP      CR                            ; Return?
   11A8 CC 02 0B      [17] 2730         CALL    Z,DONULL                      ; Yes - Do nulls
   11AB 03            [ 6] 2731         INC     BC                            ; Next byte in string
   11AC C3 A0 11      [10] 2732         JP      PRSLP                         ; More characters to output
                           2733 ;
   11AF B7            [ 4] 2734 TESTR:  OR      A                             ; Test if enough room
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 51
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   11B0 0E                 2735         .db     0x0E                          ; No garbage collection done
   11B1 F1            [10] 2736 GRBDON: POP     AF                            ; Garbage collection done
   11B2 F5            [11] 2737         PUSH    AF                            ; Save status
   11B3 2A 9F 80      [16] 2738         LD      HL,(STRSPC)                   ; Bottom of string space in use
   11B6 EB            [ 4] 2739         EX      DE,HL                         ; To DE
   11B7 2A 08 81      [16] 2740         LD      HL,(STRBOT)                   ; Bottom of string area
   11BA 2F            [ 4] 2741         CPL                                   ; Negate length (Top down)
   11BB 4F            [ 4] 2742         LD      C,A                           ; -Length to BC
   11BC 06 FF         [ 7] 2743         LD      B,-1                          ; BC = -ve length of string
   11BE 09            [11] 2744         ADD     HL,BC                         ; Add to bottom of space in use
   11BF 23            [ 6] 2745         INC     HL                            ; Plus one for 2's complement
   11C0 CD C0 06      [17] 2746         CALL    CPDEHL                        ; Below string RAM area?
   11C3 DA CD 11      [10] 2747         JP      C,TESTOS                      ; Tidy up if not done else err
   11C6 22 08 81      [16] 2748         LD      (STRBOT),HL                   ; Save new bottom of area
   11C9 23            [ 6] 2749         INC     HL                            ; Point to first byte of string
   11CA EB            [ 4] 2750         EX      DE,HL                         ; Address to DE
   11CB F1            [10] 2751 POPAF:  POP     AF                            ; Throw away status push
   11CC C9            [10] 2752         RET
                           2753 ;
   11CD F1            [10] 2754 TESTOS: POP     AF                            ; Garbage collect been done?
   11CE 1E 1A         [ 7] 2755         LD      E,OS                          ; ?OS Error
   11D0 CA 0C 04      [10] 2756         JP      Z,ERROR                       ; Yes - Not enough string apace
   11D3 BF            [ 4] 2757         CP      A                             ; Flag garbage collect done
   11D4 F5            [11] 2758         PUSH    AF                            ; Save status
   11D5 01 B1 11      [10] 2759         LD      BC,GRBDON                     ; Garbage collection done
   11D8 C5            [11] 2760         PUSH    BC                            ; Save for RETurn
   11D9 2A F4 80      [16] 2761 GARBGE: LD      HL,(LSTRAM)                   ; Get end of RAM pointer
   11DC 22 08 81      [16] 2762 GARBLP: LD      (STRBOT),HL                   ; Reset string pointer
   11DF 21 00 00      [10] 2763         LD      HL,0
   11E2 E5            [11] 2764         PUSH    HL                            ; Flag no string found
   11E3 2A 9F 80      [16] 2765         LD      HL,(STRSPC)                   ; Get bottom of string space
   11E6 E5            [11] 2766         PUSH    HL                            ; Save bottom of string space
   11E7 21 F8 80      [10] 2767         LD      HL,TMSTPL                     ; Temporary string pool
   11EA EB            [ 4] 2768 GRBLP:  EX      DE,HL
   11EB 2A F6 80      [16] 2769         LD      HL,(TMSTPT)                   ; Temporary string pool pointer
   11EE EB            [ 4] 2770         EX      DE,HL
   11EF CD C0 06      [17] 2771         CALL    CPDEHL                        ; Temporary string pool done?
   11F2 01 EA 11      [10] 2772         LD      BC,GRBLP                      ; Loop until string pool done
   11F5 C2 3E 12      [10] 2773         JP      NZ,STPOOL                     ; No - See if in string area
   11F8 2A 1B 81      [16] 2774         LD      HL,(PROGND)                   ; Start of simple variables
   11FB EB            [ 4] 2775 SMPVAR: EX      DE,HL
   11FC 2A 1D 81      [16] 2776         LD      HL,(VAREND)                   ; End of simple variables
   11FF EB            [ 4] 2777         EX      DE,HL
   1200 CD C0 06      [17] 2778         CALL    CPDEHL                        ; All simple strings done?
   1203 CA 11 12      [10] 2779         JP      Z,ARRLP                       ; Yes - Do string arrays
   1206 7E            [ 7] 2780         LD      A,(HL)                        ; Get type of variable
   1207 23            [ 6] 2781         INC     HL
   1208 23            [ 6] 2782         INC     HL
   1209 B7            [ 4] 2783         OR      A                             ; "S" flag set if string
   120A CD 41 12      [17] 2784         CALL    STRADD                        ; See if string in string area
   120D C3 FB 11      [10] 2785         JP      SMPVAR                        ; Loop until simple ones done
                           2786 ;
   1210 C1            [10] 2787 GNXARY: POP     BC                            ; Scrap address of this array
   1211 EB            [ 4] 2788 ARRLP:  EX      DE,HL
   1212 2A 1F 81      [16] 2789         LD      HL,(ARREND)                   ; End of string arrays
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 52
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1215 EB            [ 4] 2790         EX      DE,HL
   1216 CD C0 06      [17] 2791         CALL    CPDEHL                        ; All string arrays done?
   1219 CA 67 12      [10] 2792         JP      Z,SCNEND                      ; Yes - Move string if found
   121C CD EE 16      [17] 2793         CALL    LOADFP                        ; Get array name to BCDE
   121F 7B            [ 4] 2794         LD      A,E                           ; Get type of array
   1220 E5            [11] 2795         PUSH    HL                            ; Save address of num of dim'ns
   1221 09            [11] 2796         ADD     HL,BC                         ; Start of next array
   1222 B7            [ 4] 2797         OR      A                             ; Test type of array
   1223 F2 10 12      [10] 2798         JP      P,GNXARY                      ; Numeric array - Ignore it
   1226 22 0A 81      [16] 2799         LD      (CUROPR),HL                   ; Save address of next array
   1229 E1            [10] 2800         POP     HL                            ; Get address of num of dim'ns
   122A 4E            [ 7] 2801         LD      C,(HL)                        ; BC = Number of dimensions
   122B 06 00         [ 7] 2802         LD      B,0
   122D 09            [11] 2803         ADD     HL,BC                         ; Two bytes per dimension size
   122E 09            [11] 2804         ADD     HL,BC
   122F 23            [ 6] 2805         INC     HL                            ; Plus one for number of dim'ns
   1230 EB            [ 4] 2806 GRBARY: EX      DE,HL
   1231 2A 0A 81      [16] 2807         LD      HL,(CUROPR)                   ; Get address of next array
   1234 EB            [ 4] 2808         EX      DE,HL
   1235 CD C0 06      [17] 2809         CALL    CPDEHL                        ; Is this array finished?
   1238 CA 11 12      [10] 2810         JP      Z,ARRLP                       ; Yes - Get next one
   123B 01 30 12      [10] 2811         LD      BC,GRBARY                     ; Loop until array all done
   123E C5            [11] 2812 STPOOL: PUSH    BC                            ; Save return address
   123F F6 80         [ 7] 2813         OR      0x80                          ; Flag string type
   1241 7E            [ 7] 2814 STRADD: LD      A,(HL)                        ; Get string length
   1242 23            [ 6] 2815         INC     HL
   1243 23            [ 6] 2816         INC     HL
   1244 5E            [ 7] 2817         LD      E,(HL)                        ; Get LSB of string address
   1245 23            [ 6] 2818         INC     HL
   1246 56            [ 7] 2819         LD      D,(HL)                        ; Get MSB of string address
   1247 23            [ 6] 2820         INC     HL
   1248 F0            [11] 2821         RET     P                             ; Not a string - Return
   1249 B7            [ 4] 2822         OR      A                             ; Set flags on string length
   124A C8            [11] 2823         RET     Z                             ; Null string - Return
   124B 44            [ 4] 2824         LD      B,H                           ; Save variable pointer
   124C 4D            [ 4] 2825         LD      C,L
   124D 2A 08 81      [16] 2826         LD      HL,(STRBOT)                   ; Bottom of new area
   1250 CD C0 06      [17] 2827         CALL    CPDEHL                        ; String been done?
   1253 60            [ 4] 2828         LD      H,B                           ; Restore variable pointer
   1254 69            [ 4] 2829         LD      L,C
   1255 D8            [11] 2830         RET     C                             ; String done - Ignore
   1256 E1            [10] 2831         POP     HL                            ; Return address
   1257 E3            [19] 2832         EX      (SP),HL                       ; Lowest available string area
   1258 CD C0 06      [17] 2833         CALL    CPDEHL                        ; String within string area?
   125B E3            [19] 2834         EX      (SP),HL                       ; Lowest available string area
   125C E5            [11] 2835         PUSH    HL                            ; Re-save return address
   125D 60            [ 4] 2836         LD      H,B                           ; Restore variable pointer
   125E 69            [ 4] 2837         LD      L,C
   125F D0            [11] 2838         RET     NC                            ; Outside string area - Ignore
   1260 C1            [10] 2839         POP     BC                            ; Get return , Throw 2 away
   1261 F1            [10] 2840         POP     AF                            ;
   1262 F1            [10] 2841         POP     AF                            ;
   1263 E5            [11] 2842         PUSH    HL                            ; Save variable pointer
   1264 D5            [11] 2843         PUSH    DE                            ; Save address of current
   1265 C5            [11] 2844         PUSH    BC                            ; Put back return address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 53
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1266 C9            [10] 2845         RET                                   ; Go to it
                           2846 ;
   1267 D1            [10] 2847 SCNEND: POP     DE                            ; Addresses of strings
   1268 E1            [10] 2848         POP     HL                            ;
   1269 7D            [ 4] 2849         LD      A,L                           ; HL = 0 if no more to do
   126A B4            [ 4] 2850         OR      H
   126B C8            [11] 2851         RET     Z                             ; No more to do - Return
   126C 2B            [ 6] 2852         DEC     HL
   126D 46            [ 7] 2853         LD      B,(HL)                        ; MSB of address of string
   126E 2B            [ 6] 2854         DEC     HL
   126F 4E            [ 7] 2855         LD      C,(HL)                        ; LSB of address of string
   1270 E5            [11] 2856         PUSH    HL                            ; Save variable address
   1271 2B            [ 6] 2857         DEC     HL
   1272 2B            [ 6] 2858         DEC     HL
   1273 6E            [ 7] 2859         LD      L,(HL)                        ; HL = Length of string
   1274 26 00         [ 7] 2860         LD      H,0
   1276 09            [11] 2861         ADD     HL,BC                         ; Address of end of string+1
   1277 50            [ 4] 2862         LD      D,B                           ; String address to DE
   1278 59            [ 4] 2863         LD      E,C
   1279 2B            [ 6] 2864         DEC     HL                            ; Last byte in string
   127A 44            [ 4] 2865         LD      B,H                           ; Address to BC
   127B 4D            [ 4] 2866         LD      C,L
   127C 2A 08 81      [16] 2867         LD      HL,(STRBOT)                   ; Current bottom of string area
   127F CD C7 03      [17] 2868         CALL    MOVSTR                        ; Move string to new address
   1282 E1            [10] 2869         POP     HL                            ; Restore variable address
   1283 71            [ 7] 2870         LD      (HL),C                        ; Save new LSB of address
   1284 23            [ 6] 2871         INC     HL
   1285 70            [ 7] 2872         LD      (HL),B                        ; Save new MSB of address
   1286 69            [ 4] 2873         LD      L,C                           ; Next string area+1 to HL
   1287 60            [ 4] 2874         LD      H,B
   1288 2B            [ 6] 2875         DEC     HL                            ; Next string area address
   1289 C3 DC 11      [10] 2876         JP      GARBLP                        ; Look for more strings
                           2877 ;
   128C C5            [11] 2878 CONCAT: PUSH    BC                            ; Save prec' opr & code string
   128D E5            [11] 2879         PUSH    HL                            ;
   128E 2A 29 81      [16] 2880         LD      HL,(FPREG)                    ; Get first string
   1291 E3            [19] 2881         EX      (SP),HL                       ; Save first string
   1292 CD 46 0D      [17] 2882         CALL    OPRND                         ; Get second string
   1295 E3            [19] 2883         EX      (SP),HL                       ; Restore first string
   1296 CD C1 0C      [17] 2884         CALL    TSTSTR                        ; Make sure it's a string
   1299 7E            [ 7] 2885         LD      A,(HL)                        ; Get length of second string
   129A E5            [11] 2886         PUSH    HL                            ; Save first string
   129B 2A 29 81      [16] 2887         LD      HL,(FPREG)                    ; Get second string
   129E E5            [11] 2888         PUSH    HL                            ; Save second string
   129F 86            [ 7] 2889         ADD     A,(HL)                        ; Add length of second string
   12A0 1E 1C         [ 7] 2890         LD      E,LS                          ; ?LS Error
   12A2 DA 0C 04      [10] 2891         JP      C,ERROR                       ; String too long - Error
   12A5 CD 45 11      [17] 2892         CALL    MKTMST                        ; Make temporary string
   12A8 D1            [10] 2893         POP     DE                            ; Get second string to DE
   12A9 CD DD 12      [17] 2894         CALL    GSTRDE                        ; Move to string pool if needed
   12AC E3            [19] 2895         EX      (SP),HL                       ; Get first string
   12AD CD DC 12      [17] 2896         CALL    GSTRHL                        ; Move to string pool if needed
   12B0 E5            [11] 2897         PUSH    HL                            ; Save first string
   12B1 2A 06 81      [16] 2898         LD      HL,(TMPSTR+2)                 ; Temporary string address
   12B4 EB            [ 4] 2899         EX      DE,HL                         ; To DE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 54
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   12B5 CD C3 12      [17] 2900         CALL    SSTSA                         ; First string to string area
   12B8 CD C3 12      [17] 2901         CALL    SSTSA                         ; Second string to string area
   12BB 21 DB 0C      [10] 2902         LD      HL,EVAL2                      ; Return to evaluation loop
   12BE E3            [19] 2903         EX      (SP),HL                       ; Save return,get code string
   12BF E5            [11] 2904         PUSH    HL                            ; Save code string address
   12C0 C3 76 11      [10] 2905         JP      TSTOPL                        ; To temporary string to pool
                           2906 ;
   12C3 E1            [10] 2907 SSTSA:  POP     HL                            ; Return address
   12C4 E3            [19] 2908         EX      (SP),HL                       ; Get string block,save return
   12C5 7E            [ 7] 2909         LD      A,(HL)                        ; Get length of string
   12C6 23            [ 6] 2910         INC     HL
   12C7 23            [ 6] 2911         INC     HL
   12C8 4E            [ 7] 2912         LD      C,(HL)                        ; Get LSB of string address
   12C9 23            [ 6] 2913         INC     HL
   12CA 46            [ 7] 2914         LD      B,(HL)                        ; Get MSB of string address
   12CB 6F            [ 4] 2915         LD      L,A                           ; Length to L
   12CC 2C            [ 4] 2916 TOSTRA: INC     L                             ; INC - DECed after
   12CD 2D            [ 4] 2917 TSALP:  DEC     L                             ; Count bytes moved
   12CE C8            [11] 2918         RET     Z                             ; End of string - Return
   12CF 0A            [ 7] 2919         LD      A,(BC)                        ; Get source
   12D0 12            [ 7] 2920         LD      (DE),A                        ; Save destination
   12D1 03            [ 6] 2921         INC     BC                            ; Next source
   12D2 13            [ 6] 2922         INC     DE                            ; Next destination
   12D3 C3 CD 12      [10] 2923         JP      TSALP                         ; Loop until string moved
                           2924 ;
   12D6 CD C1 0C      [17] 2925 GETSTR: CALL    TSTSTR                        ; Make sure it's a string
   12D9 2A 29 81      [16] 2926 GSTRCU: LD      HL,(FPREG)                    ; Get current string
   12DC EB            [ 4] 2927 GSTRHL: EX      DE,HL                         ; Save DE
   12DD CD F7 12      [17] 2928 GSTRDE: CALL    BAKTMP                        ; Was it last tmp-str?
   12E0 EB            [ 4] 2929         EX      DE,HL                         ; Restore DE
   12E1 C0            [11] 2930         RET     NZ                            ; No - Return
   12E2 D5            [11] 2931         PUSH    DE                            ; Save string
   12E3 50            [ 4] 2932         LD      D,B                           ; String block address to DE
   12E4 59            [ 4] 2933         LD      E,C
   12E5 1B            [ 6] 2934         DEC     DE                            ; Point to length
   12E6 4E            [ 7] 2935         LD      C,(HL)                        ; Get string length
   12E7 2A 08 81      [16] 2936         LD      HL,(STRBOT)                   ; Current bottom of string area
   12EA CD C0 06      [17] 2937         CALL    CPDEHL                        ; Last one in string area?
   12ED C2 F5 12      [10] 2938         JP      NZ,POPHL                      ; No - Return
   12F0 47            [ 4] 2939         LD      B,A                           ; Clear B (A=0)
   12F1 09            [11] 2940         ADD     HL,BC                         ; Remove string from str' area
   12F2 22 08 81      [16] 2941         LD      (STRBOT),HL                   ; Save new bottom of str' area
   12F5 E1            [10] 2942 POPHL:  POP     HL                            ; Restore string
   12F6 C9            [10] 2943         RET
                           2944 ;
   12F7 2A F6 80      [16] 2945 BAKTMP: LD      HL,(TMSTPT)                   ; Get temporary string pool top
   12FA 2B            [ 6] 2946         DEC     HL                            ; Back
   12FB 46            [ 7] 2947         LD      B,(HL)                        ; Get MSB of address
   12FC 2B            [ 6] 2948         DEC     HL                            ; Back
   12FD 4E            [ 7] 2949         LD      C,(HL)                        ; Get LSB of address
   12FE 2B            [ 6] 2950         DEC     HL                            ; Back
   12FF 2B            [ 6] 2951         DEC     HL                            ; Back
   1300 CD C0 06      [17] 2952         CALL    CPDEHL                        ; String last in string pool?
   1303 C0            [11] 2953         RET     NZ                            ; Yes - Leave it
   1304 22 F6 80      [16] 2954         LD      (TMSTPT),HL                   ; Save new string pool top
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 55
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1307 C9            [10] 2955         RET
                           2956 ;
   1308 01 87 10      [10] 2957 LEN:    LD      BC,PASSA                      ; To return integer A
   130B C5            [11] 2958         PUSH    BC                            ; Save address
   130C CD D6 12      [17] 2959 GETLEN: CALL    GETSTR                        ; Get string and its length
   130F AF            [ 4] 2960         XOR     A
   1310 57            [ 4] 2961         LD      D,A                           ; Clear D
   1311 32 F2 80      [13] 2962         LD      (TYPE),A                      ; Set type to numeric
   1314 7E            [ 7] 2963         LD      A,(HL)                        ; Get length of string
   1315 B7            [ 4] 2964         OR      A                             ; Set status flags
   1316 C9            [10] 2965         RET
                           2966 ;
   1317 01 87 10      [10] 2967 ASC:    LD      BC,PASSA                      ; To return integer A
   131A C5            [11] 2968         PUSH    BC                            ; Save address
   131B CD 0C 13      [17] 2969 GTFLNM: CALL    GETLEN                        ; Get length of string
   131E CA 17 09      [10] 2970         JP      Z,FCERR                       ; Null string - Error
   1321 23            [ 6] 2971         INC     HL
   1322 23            [ 6] 2972         INC     HL
   1323 5E            [ 7] 2973         LD      E,(HL)                        ; Get LSB of address
   1324 23            [ 6] 2974         INC     HL
   1325 56            [ 7] 2975         LD      D,(HL)                        ; Get MSB of address
   1326 1A            [ 7] 2976         LD      A,(DE)                        ; Get first byte of string
   1327 C9            [10] 2977         RET
                           2978 ;
   1328 3E 01         [ 7] 2979 CHR:    LD      A,1                           ; One character string
   132A CD 45 11      [17] 2980         CALL    MKTMST                        ; Make a temporary string
   132D CD 21 14      [17] 2981         CALL    MAKINT                        ; Make it integer A
   1330 2A 06 81      [16] 2982         LD      HL,(TMPSTR+2)                 ; Get address of string
   1333 73            [ 7] 2983         LD      (HL),E                        ; Save character
   1334 C1            [10] 2984 TOPOOL: POP     BC                            ; Clean up stack
   1335 C3 76 11      [10] 2985         JP      TSTOPL                        ; Temporary string to pool
                           2986 ;
   1338 CD D1 13      [17] 2987 LEFT:   CALL    LFRGNM                        ; Get number and ending ")"
   133B AF            [ 4] 2988         XOR     A                             ; Start at first byte in string
   133C E3            [19] 2989 RIGHT1: EX      (SP),HL                       ; Save code string,Get string
   133D 4F            [ 4] 2990         LD      C,A                           ; Starting position in string
   133E E5            [11] 2991 MID1:   PUSH    HL                            ; Save string block address
   133F 7E            [ 7] 2992         LD      A,(HL)                        ; Get length of string
   1340 B8            [ 4] 2993         CP      B                             ; Compare with number given
   1341 DA 46 13      [10] 2994         JP      C,ALLFOL                      ; All following bytes required
   1344 78            [ 4] 2995         LD      A,B                           ; Get new length
   1345 11                 2996         .db     0x11                          ; Skip "LD C,0"
   1346 0E 00         [ 7] 2997 ALLFOL: LD      C,0                           ; First byte of string
   1348 C5            [11] 2998         PUSH    BC                            ; Save position in string
   1349 CD AF 11      [17] 2999         CALL    TESTR                         ; See if enough string space
   134C C1            [10] 3000         POP     BC                            ; Get position in string
   134D E1            [10] 3001         POP     HL                            ; Restore string block address
   134E E5            [11] 3002         PUSH    HL                            ; And re-save it
   134F 23            [ 6] 3003         INC     HL
   1350 23            [ 6] 3004         INC     HL
   1351 46            [ 7] 3005         LD      B,(HL)                        ; Get LSB of address
   1352 23            [ 6] 3006         INC     HL
   1353 66            [ 7] 3007         LD      H,(HL)                        ; Get MSB of address
   1354 68            [ 4] 3008         LD      L,B                           ; HL = address of string
   1355 06 00         [ 7] 3009         LD      B,0                           ; BC = starting address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 56
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1357 09            [11] 3010         ADD     HL,BC                         ; Point to that byte
   1358 44            [ 4] 3011         LD      B,H                           ; BC = source string
   1359 4D            [ 4] 3012         LD      C,L
   135A CD 48 11      [17] 3013         CALL    CRTMST                        ; Create a string entry
   135D 6F            [ 4] 3014         LD      L,A                           ; Length of new string
   135E CD CC 12      [17] 3015         CALL    TOSTRA                        ; Move string to string area
   1361 D1            [10] 3016         POP     DE                            ; Clear stack
   1362 CD DD 12      [17] 3017         CALL    GSTRDE                        ; Move to string pool if needed
   1365 C3 76 11      [10] 3018         JP      TSTOPL                        ; Temporary string to pool
                           3019 ;
   1368 CD D1 13      [17] 3020 RIGHT:  CALL    LFRGNM                        ; Get number and ending ")"
   136B D1            [10] 3021         POP     DE                            ; Get string length
   136C D5            [11] 3022         PUSH    DE                            ; And re-save
   136D 1A            [ 7] 3023         LD      A,(DE)                        ; Get length
   136E 90            [ 4] 3024         SUB     B                             ; Move back N bytes
   136F C3 3C 13      [10] 3025         JP      RIGHT1                        ; Go and get sub-string
                           3026 ;
   1372 EB            [ 4] 3027 MID:    EX      DE,HL                         ; Get code string address
   1373 7E            [ 7] 3028         LD      A,(HL)                        ; Get next byte ', or ")"
   1374 CD D6 13      [17] 3029         CALL    MIDNUM                        ; Get number supplied
   1377 04            [ 4] 3030         INC     B                             ; Is it character zero?
   1378 05            [ 4] 3031         DEC     B
   1379 CA 17 09      [10] 3032         JP      Z,FCERR                       ; Yes - Error
   137C C5            [11] 3033         PUSH    BC                            ; Save starting position
   137D 1E FF         [ 7] 3034         LD      E,255                         ; All of string
   137F FE 29         [ 7] 3035         CP      ')                            ; Any length given?
   1381 CA 8B 13      [10] 3036         JP      Z,RSTSTR                      ; No - Rest of string
   1384 CD C6 06      [17] 3037         CALL    CHKSYN                        ; Make sure ', follows
   1387 2C                 3038         .db     ',
   1388 CD 1E 14      [17] 3039         CALL    GETINT                        ; Get integer 0-255
   138B CD C6 06      [17] 3040 RSTSTR: CALL    CHKSYN                        ; Make sure ")" follows
   138E 29                 3041         .ascii  ")"
   138F F1            [10] 3042         POP     AF                            ; Restore starting position
   1390 E3            [19] 3043         EX      (SP),HL                       ; Get string,8ave code string
   1391 01 3E 13      [10] 3044         LD      BC,MID1                       ; Continuation of MID$ routine
   1394 C5            [11] 3045         PUSH    BC                            ; Save for return
   1395 3D            [ 4] 3046         DEC     A                             ; Starting position-1
   1396 BE            [ 7] 3047         CP      (HL)                          ; Compare with length
   1397 06 00         [ 7] 3048         LD      B,0                           ; Zero bytes length
   1399 D0            [11] 3049         RET     NC                            ; Null string if start past end
   139A 4F            [ 4] 3050         LD      C,A                           ; Save starting position-1
   139B 7E            [ 7] 3051         LD      A,(HL)                        ; Get length of string
   139C 91            [ 4] 3052         SUB     C                             ; Subtract start
   139D BB            [ 4] 3053         CP      E                             ; Enough string for it?
   139E 47            [ 4] 3054         LD      B,A                           ; Save maximum length available
   139F D8            [11] 3055         RET     C                             ; Truncate string if needed
   13A0 43            [ 4] 3056         LD      B,E                           ; Set specified length
   13A1 C9            [10] 3057         RET                                   ; Go and create string
                           3058 ;
   13A2 CD 0C 13      [17] 3059 VAL:    CALL    GETLEN                        ; Get length of string
   13A5 CA BF 14      [10] 3060         JP      Z,RESZER                      ; Result zero
   13A8 5F            [ 4] 3061         LD      E,A                           ; Save length
   13A9 23            [ 6] 3062         INC     HL
   13AA 23            [ 6] 3063         INC     HL
   13AB 7E            [ 7] 3064         LD      A,(HL)                        ; Get LSB of address
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 57
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   13AC 23            [ 6] 3065         INC     HL
   13AD 66            [ 7] 3066         LD      H,(HL)                        ; Get MSB of address
   13AE 6F            [ 4] 3067         LD      L,A                           ; HL = String address
   13AF E5            [11] 3068         PUSH    HL                            ; Save string address
   13B0 19            [11] 3069         ADD     HL,DE
   13B1 46            [ 7] 3070         LD      B,(HL)                        ; Get end of string+1 byte
   13B2 72            [ 7] 3071         LD      (HL),D                        ; Zero it to terminate
   13B3 E3            [19] 3072         EX      (SP),HL                       ; Save string end,get start
   13B4 C5            [11] 3073         PUSH    BC                            ; Save end+1 byte
   13B5 7E            [ 7] 3074         LD      A,(HL)                        ; Get starting byte
   13B6 FE 24         [ 7] 3075         CP      '$                            ; Hex number indicated? [function added]
   13B8 C2 C0 13      [10] 3076         JP      NZ,VAL1
   13BB CD EA 1B      [17] 3077         CALL    HEXTFP                        ; Convert Hex to FPREG
   13BE 18 0D         [12] 3078         JR      VAL3
   13C0 FE 25         [ 7] 3079 VAL1:   CP      '%                            ; Binary number indicated? [function added]
   13C2 C2 CA 13      [10] 3080         JP      NZ,VAL2
   13C5 CD 5A 1C      [17] 3081         CALL    BINTFP                        ; Convert Bin to FPREG
   13C8 18 03         [12] 3082         JR      VAL3
   13CA CD A6 17      [17] 3083 VAL2:   CALL    ASCTFP                        ; Convert ASCII string to FP
   13CD C1            [10] 3084 VAL3:   POP     BC                            ; Restore end+1 byte
   13CE E1            [10] 3085         POP     HL                            ; Restore end+1 address
   13CF 70            [ 7] 3086         LD      (HL),B                        ; Put back original byte
   13D0 C9            [10] 3087         RET
                           3088 ;
   13D1 EB            [ 4] 3089 LFRGNM: EX      DE,HL                         ; Code string address to HL
   13D2 CD C6 06      [17] 3090         CALL    CHKSYN                        ; Make sure ")" follows
   13D5 29                 3091         .ascii  ")"
   13D6 C1            [10] 3092 MIDNUM: POP     BC                            ; Get return address
   13D7 D1            [10] 3093         POP     DE                            ; Get number supplied
   13D8 C5            [11] 3094         PUSH    BC                            ; Re-save return address
   13D9 43            [ 4] 3095         LD      B,E                           ; Number to B
   13DA C9            [10] 3096         RET
                           3097 ;
   13DB CD 21 14      [17] 3098 INP:    CALL    MAKINT                        ; Make it integer A
   13DE 32 84 80      [13] 3099         LD      (INPORT),A                    ; Set input port
   13E1 CD 83 80      [17] 3100         CALL    INPSUB                        ; Get input from port
   13E4 C3 87 10      [10] 3101         JP      PASSA                         ; Return integer A
                           3102 ;
   13E7 CD 0B 14      [17] 3103 POUT:   CALL    SETIO                         ; Set up port number
   13EA C3 4B 80      [10] 3104         JP      OUTSUB                        ; Output data and return
                           3105 ;
   13ED CD 0B 14      [17] 3106 WAIT:   CALL    SETIO                         ; Set up port number
   13F0 F5            [11] 3107         PUSH    AF                            ; Save AND mask
   13F1 1E 00         [ 7] 3108         LD      E,0                           ; Assume zero if none given
   13F3 2B            [ 6] 3109         DEC     HL                            ; DEC 'cos GETCHR INCs
   13F4 CD 50 08      [17] 3110         CALL    GETCHR                        ; Get next character
   13F7 CA 01 14      [10] 3111         JP      Z,NOXOR                       ; No XOR byte given
   13FA CD C6 06      [17] 3112         CALL    CHKSYN                        ; Make sure ', follows
   13FD 2C                 3113         .db     ',
   13FE CD 1E 14      [17] 3114         CALL    GETINT                        ; Get integer 0-255 to XOR with
   1401 C1            [10] 3115 NOXOR:  POP     BC                            ; Restore AND mask
   1402 CD 83 80      [17] 3116 WAITLP: CALL    INPSUB                        ; Get input
   1405 AB            [ 4] 3117         XOR     E                             ; Flip selected bits
   1406 A0            [ 4] 3118         AND     B                             ; Result non-zero?
   1407 CA 02 14      [10] 3119         JP      Z,WAITLP                      ; No = keep waiting
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 58
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   140A C9            [10] 3120         RET
                           3121 ;
   140B CD 1E 14      [17] 3122 SETIO:  CALL    GETINT                        ; Get integer 0-255
   140E 32 84 80      [13] 3123         LD      (INPORT),A                    ; Set input port
   1411 32 4C 80      [13] 3124         LD      (OTPORT),A                    ; Set output port
   1414 CD C6 06      [17] 3125         CALL    CHKSYN                        ; Make sure ', follows
   1417 2C                 3126         .db     ',
   1418 C3 1E 14      [10] 3127         JP      GETINT                        ; Get integer 0-255 and return
                           3128 ;
   141B CD 50 08      [17] 3129 FNDNUM: CALL    GETCHR                        ; Get next character
   141E CD BD 0C      [17] 3130 GETINT: CALL    GETNUM                        ; Get a number from 0 to 255
   1421 CD FC 08      [17] 3131 MAKINT: CALL    DEPINT                        ; Make sure value 0 - 255
   1424 7A            [ 4] 3132         LD      A,D                           ; Get MSB of number
   1425 B7            [ 4] 3133         OR      A                             ; Zero?
   1426 C2 17 09      [10] 3134         JP      NZ,FCERR                      ; No - Error
   1429 2B            [ 6] 3135         DEC     HL                            ; DEC 'cos GETCHR INCs
   142A CD 50 08      [17] 3136         CALL    GETCHR                        ; Get next character
   142D 7B            [ 4] 3137         LD      A,E                           ; Get number to A
   142E C9            [10] 3138         RET
                           3139 ;
   142F CD 02 09      [17] 3140 PEEK:   CALL    DEINT                         ; Get memory address
   1432 1A            [ 7] 3141         LD      A,(DE)                        ; Get byte in memory
   1433 C3 87 10      [10] 3142         JP      PASSA                         ; Return integer A
                           3143 ;
   1436 CD BD 0C      [17] 3144 POKE:   CALL    GETNUM                        ; Get memory address
   1439 CD 02 09      [17] 3145         CALL    DEINT                         ; Get integer -32768 to 3276
   143C D5            [11] 3146         PUSH    DE                            ; Save memory address
   143D CD C6 06      [17] 3147         CALL    CHKSYN                        ; Make sure ', follows
   1440 2C                 3148         .db     ',
   1441 CD 1E 14      [17] 3149         CALL    GETINT                        ; Get integer 0-255
   1444 D1            [10] 3150         POP     DE                            ; Restore memory address
   1445 12            [ 7] 3151         LD      (DE),A                        ; Load it into memory
   1446 C9            [10] 3152         RET
                           3153 ;
   1447 21 1D 19      [10] 3154 ROUND:  LD      HL,HALF                       ; Add 0.5 to FPREG
   144A CD EE 16      [17] 3155 ADDPHL: CALL    LOADFP                        ; Load FP at (HL) to BCDE
   144D C3 59 14      [10] 3156         JP      FPADD                         ; Add BCDE to FPREG
                           3157 ;
   1450 CD EE 16      [17] 3158 SUBPHL: CALL    LOADFP                        ; FPREG = -FPREG + number at HL
   1453 21                 3159         .db     0x21                          ; Skip "POP BC" and "POP DE"
   1454 C1            [10] 3160 PSUB:   POP     BC                            ; Get FP number from stack
   1455 D1            [10] 3161         POP     DE
   1456 CD C8 16      [17] 3162 SUBCDE: CALL    INVSGN                        ; Negate FPREG
   1459 78            [ 4] 3163 FPADD:  LD      A,B                           ; Get FP exponent
   145A B7            [ 4] 3164         OR      A                             ; Is number zero?
   145B C8            [11] 3165         RET     Z                             ; Yes - Nothing to add
   145C 3A 2C 81      [13] 3166         LD      A,(FPEXP)                     ; Get FPREG exponent
   145F B7            [ 4] 3167         OR      A                             ; Is this number zero?
   1460 CA E0 16      [10] 3168         JP      Z,FPBCDE                      ; Yes - Move BCDE to FPREG
   1463 90            [ 4] 3169         SUB     B                             ; BCDE number larger?
   1464 D2 73 14      [10] 3170         JP      NC,NOSWAP                     ; No - Don't swap them
   1467 2F            [ 4] 3171         CPL                                   ; Two's complement
   1468 3C            [ 4] 3172         INC     A                             ;	FP exponent
   1469 EB            [ 4] 3173         EX      DE,HL
   146A CD D0 16      [17] 3174         CALL    STAKFP                        ; Put FPREG on stack
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 59
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   146D EB            [ 4] 3175         EX      DE,HL
   146E CD E0 16      [17] 3176         CALL    FPBCDE                        ; Move BCDE to FPREG
   1471 C1            [10] 3177         POP     BC                            ; Restore number from stack
   1472 D1            [10] 3178         POP     DE
   1473 FE 19         [ 7] 3179 NOSWAP: CP      24+1                          ; Second number insignificant?
   1475 D0            [11] 3180         RET     NC                            ; Yes - First number is result
   1476 F5            [11] 3181         PUSH    AF                            ; Save number of bits to scale
   1477 CD 05 17      [17] 3182         CALL    SIGNS                         ; Set MSBs & sign of result
   147A 67            [ 4] 3183         LD      H,A                           ; Save sign of result
   147B F1            [10] 3184         POP     AF                            ; Restore scaling factor
   147C CD 1E 15      [17] 3185         CALL    SCALE                         ; Scale BCDE to same exponent
   147F B4            [ 4] 3186         OR      H                             ; Result to be positive?
   1480 21 29 81      [10] 3187         LD      HL,FPREG                      ; Point to FPREG
   1483 F2 99 14      [10] 3188         JP      P,MINCDE                      ; No - Subtract FPREG from CDE
   1486 CD FE 14      [17] 3189         CALL    PLUCDE                        ; Add FPREG to CDE
   1489 D2 DF 14      [10] 3190         JP      NC,RONDUP                     ; No overflow - Round it up
   148C 23            [ 6] 3191         INC     HL                            ; Point to exponent
   148D 34            [11] 3192         INC     (HL)                          ; Increment it
   148E CA 07 04      [10] 3193         JP      Z,OVERR                       ; Number overflowed - Error
   1491 2E 01         [ 7] 3194         LD      L,1                           ; 1 bit to shift right
   1493 CD 34 15      [17] 3195         CALL    SHRT1                         ; Shift result right
   1496 C3 DF 14      [10] 3196         JP      RONDUP                        ; Round it up
                           3197 ;
   1499 AF            [ 4] 3198 MINCDE: XOR     A                             ; Clear A and carry
   149A 90            [ 4] 3199         SUB     B                             ; Negate exponent
   149B 47            [ 4] 3200         LD      B,A                           ; Re-save exponent
   149C 7E            [ 7] 3201         LD      A,(HL)                        ; Get LSB of FPREG
   149D 9B            [ 4] 3202         SBC     A,E                           ; Subtract LSB of BCDE
   149E 5F            [ 4] 3203         LD      E,A                           ; Save LSB of BCDE
   149F 23            [ 6] 3204         INC     HL
   14A0 7E            [ 7] 3205         LD      A,(HL)                        ; Get NMSB of FPREG
   14A1 9A            [ 4] 3206         SBC     A,D                           ; Subtract NMSB of BCDE
   14A2 57            [ 4] 3207         LD      D,A                           ; Save NMSB of BCDE
   14A3 23            [ 6] 3208         INC     HL
   14A4 7E            [ 7] 3209         LD      A,(HL)                        ; Get MSB of FPREG
   14A5 99            [ 4] 3210         SBC     A,C                           ; Subtract MSB of BCDE
   14A6 4F            [ 4] 3211         LD      C,A                           ; Save MSB of BCDE
   14A7 DC 0A 15      [17] 3212 CONPOS: CALL    C,COMPL                       ; Overflow - Make it positive
                           3213 ;
   14AA 68            [ 4] 3214 BNORM:  LD      L,B                           ; L = Exponent
   14AB 63            [ 4] 3215         LD      H,E                           ; H = LSB
   14AC AF            [ 4] 3216         XOR     A
   14AD 47            [ 4] 3217 BNRMLP: LD      B,A                           ; Save bit count
   14AE 79            [ 4] 3218         LD      A,C                           ; Get MSB
   14AF B7            [ 4] 3219         OR      A                             ; Is it zero?
   14B0 C2 CC 14      [10] 3220         JP      NZ,PNORM                      ; No - Do it bit at a time
   14B3 4A            [ 4] 3221         LD      C,D                           ; MSB = NMSB
   14B4 54            [ 4] 3222         LD      D,H                           ; NMSB= LSB
   14B5 65            [ 4] 3223         LD      H,L                           ; LSB = VLSB
   14B6 6F            [ 4] 3224         LD      L,A                           ; VLSB= 0
   14B7 78            [ 4] 3225         LD      A,B                           ; Get exponent
   14B8 D6 08         [ 7] 3226         SUB     8                             ; Count 8 bits
   14BA FE E0         [ 7] 3227         CP      0x0E0                         ; -24-8 Was number zero?
   14BC C2 AD 14      [10] 3228         JP      NZ,BNRMLP                     ; No - Keep normalising
   14BF AF            [ 4] 3229 RESZER: XOR     A                             ; Result is zero
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 60
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   14C0 32 2C 81      [13] 3230 SAVEXP: LD      (FPEXP),A                     ; Save result as zero
   14C3 C9            [10] 3231         RET
                           3232 ;
   14C4 05            [ 4] 3233 NORMAL: DEC     B                             ; Count bits
   14C5 29            [11] 3234         ADD     HL,HL                         ; Shift HL left
   14C6 7A            [ 4] 3235         LD      A,D                           ; Get NMSB
   14C7 17            [ 4] 3236         RLA                                   ; Shift left with last bit
   14C8 57            [ 4] 3237         LD      D,A                           ; Save NMSB
   14C9 79            [ 4] 3238         LD      A,C                           ; Get MSB
   14CA 8F            [ 4] 3239         ADC     A,A                           ; Shift left with last bit
   14CB 4F            [ 4] 3240         LD      C,A                           ; Save MSB
   14CC F2 C4 14      [10] 3241 PNORM:  JP      P,NORMAL                      ; Not done - Keep going
   14CF 78            [ 4] 3242         LD      A,B                           ; Number of bits shifted
   14D0 5C            [ 4] 3243         LD      E,H                           ; Save HL in EB
   14D1 45            [ 4] 3244         LD      B,L
   14D2 B7            [ 4] 3245         OR      A                             ; Any shifting done?
   14D3 CA DF 14      [10] 3246         JP      Z,RONDUP                      ; No - Round it up
   14D6 21 2C 81      [10] 3247         LD      HL,FPEXP                      ; Point to exponent
   14D9 86            [ 7] 3248         ADD     A,(HL)                        ; Add shifted bits
   14DA 77            [ 7] 3249         LD      (HL),A                        ; Re-save exponent
   14DB D2 BF 14      [10] 3250         JP      NC,RESZER                     ; Underflow - Result is zero
   14DE C8            [11] 3251         RET     Z                             ; Result is zero
   14DF 78            [ 4] 3252 RONDUP: LD      A,B                           ; Get VLSB of number
   14E0 21 2C 81      [10] 3253 RONDB:  LD      HL,FPEXP                      ; Point to exponent
   14E3 B7            [ 4] 3254         OR      A                             ; Any rounding?
   14E4 FC F1 14      [17] 3255         CALL    M,FPROND                      ; Yes - Round number up
   14E7 46            [ 7] 3256         LD      B,(HL)                        ; B = Exponent
   14E8 23            [ 6] 3257         INC     HL
   14E9 7E            [ 7] 3258         LD      A,(HL)                        ; Get sign of result
   14EA E6 80         [ 7] 3259         AND     0b10000000                    ; Only bit 7 needed
   14EC A9            [ 4] 3260         XOR     C                             ; Set correct sign
   14ED 4F            [ 4] 3261         LD      C,A                           ; Save correct sign in number
   14EE C3 E0 16      [10] 3262         JP      FPBCDE                        ; Move BCDE to FPREG
                           3263 ;
   14F1 1C            [ 4] 3264 FPROND: INC     E                             ; Round LSB
   14F2 C0            [11] 3265         RET     NZ                            ; Return if ok
   14F3 14            [ 4] 3266         INC     D                             ; Round NMSB
   14F4 C0            [11] 3267         RET     NZ                            ; Return if ok
   14F5 0C            [ 4] 3268         INC     C                             ; Round MSB
   14F6 C0            [11] 3269         RET     NZ                            ; Return if ok
   14F7 0E 80         [ 7] 3270         LD      C,0x80                        ; Set normal value
   14F9 34            [11] 3271         INC     (HL)                          ; Increment exponent
   14FA C0            [11] 3272         RET     NZ                            ; Return if ok
   14FB C3 07 04      [10] 3273         JP      OVERR                         ; Overflow error
                           3274 ;
   14FE 7E            [ 7] 3275 PLUCDE: LD      A,(HL)                        ; Get LSB of FPREG
   14FF 83            [ 4] 3276         ADD     A,E                           ; Add LSB of BCDE
   1500 5F            [ 4] 3277         LD      E,A                           ; Save LSB of BCDE
   1501 23            [ 6] 3278         INC     HL
   1502 7E            [ 7] 3279         LD      A,(HL)                        ; Get NMSB of FPREG
   1503 8A            [ 4] 3280         ADC     A,D                           ; Add NMSB of BCDE
   1504 57            [ 4] 3281         LD      D,A                           ; Save NMSB of BCDE
   1505 23            [ 6] 3282         INC     HL
   1506 7E            [ 7] 3283         LD      A,(HL)                        ; Get MSB of FPREG
   1507 89            [ 4] 3284         ADC     A,C                           ; Add MSB of BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 61
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1508 4F            [ 4] 3285         LD      C,A                           ; Save MSB of BCDE
   1509 C9            [10] 3286         RET
                           3287 ;
   150A 21 2D 81      [10] 3288 COMPL:  LD      HL,SGNRES                     ; Sign of result
   150D 7E            [ 7] 3289         LD      A,(HL)                        ; Get sign of result
   150E 2F            [ 4] 3290         CPL                                   ; Negate it
   150F 77            [ 7] 3291         LD      (HL),A                        ; Put it back
   1510 AF            [ 4] 3292         XOR     A
   1511 6F            [ 4] 3293         LD      L,A                           ; Set L to zero
   1512 90            [ 4] 3294         SUB     B                             ; Negate exponent,set carry
   1513 47            [ 4] 3295         LD      B,A                           ; Re-save exponent
   1514 7D            [ 4] 3296         LD      A,L                           ; Load zero
   1515 9B            [ 4] 3297         SBC     A,E                           ; Negate LSB
   1516 5F            [ 4] 3298         LD      E,A                           ; Re-save LSB
   1517 7D            [ 4] 3299         LD      A,L                           ; Load zero
   1518 9A            [ 4] 3300         SBC     A,D                           ; Negate NMSB
   1519 57            [ 4] 3301         LD      D,A                           ; Re-save NMSB
   151A 7D            [ 4] 3302         LD      A,L                           ; Load zero
   151B 99            [ 4] 3303         SBC     A,C                           ; Negate MSB
   151C 4F            [ 4] 3304         LD      C,A                           ; Re-save MSB
   151D C9            [10] 3305         RET
                           3306 ;
   151E 06 00         [ 7] 3307 SCALE:  LD      B,0                           ; Clear underflow
   1520 D6 08         [ 7] 3308 SCALLP: SUB     8                             ; 8 bits (a whole byte)?
   1522 DA 2D 15      [10] 3309         JP      C,SHRITE                      ; No - Shift right A bits
   1525 43            [ 4] 3310         LD      B,E                           ; <- Shift
   1526 5A            [ 4] 3311         LD      E,D                           ; <- right
   1527 51            [ 4] 3312         LD      D,C                           ; <- eight
   1528 0E 00         [ 7] 3313         LD      C,0                           ; <- bits
   152A C3 20 15      [10] 3314         JP      SCALLP                        ; More bits to shift
                           3315 ;
   152D C6 09         [ 7] 3316 SHRITE: ADD     A,8+1                         ; Adjust count
   152F 6F            [ 4] 3317         LD      L,A                           ; Save bits to shift
   1530 AF            [ 4] 3318 SHRLP:  XOR     A                             ; Flag for all done
   1531 2D            [ 4] 3319         DEC     L                             ; All shifting done?
   1532 C8            [11] 3320         RET     Z                             ; Yes - Return
   1533 79            [ 4] 3321         LD      A,C                           ; Get MSB
   1534 1F            [ 4] 3322 SHRT1:  RRA                                   ; Shift it right
   1535 4F            [ 4] 3323         LD      C,A                           ; Re-save
   1536 7A            [ 4] 3324         LD      A,D                           ; Get NMSB
   1537 1F            [ 4] 3325         RRA                                   ; Shift right with last bit
   1538 57            [ 4] 3326         LD      D,A                           ; Re-save it
   1539 7B            [ 4] 3327         LD      A,E                           ; Get LSB
   153A 1F            [ 4] 3328         RRA                                   ; Shift right with last bit
   153B 5F            [ 4] 3329         LD      E,A                           ; Re-save it
   153C 78            [ 4] 3330         LD      A,B                           ; Get underflow
   153D 1F            [ 4] 3331         RRA                                   ; Shift right with last bit
   153E 47            [ 4] 3332         LD      B,A                           ; Re-save underflow
   153F C3 30 15      [10] 3333         JP      SHRLP                         ; More bits to do
                           3334 ;
   1542 00 00 00 81        3335 UNITY:  .db     0x000,0x000,0x000,0x081       ; 1.00000
                           3336 ;
   1546 03                 3337 LOGTAB: .db     3                             ; Table used by LOG
   1547 AA 56 19 80        3338         .db     0x0AA,0x056,0x019,0x080       ; 0.59898
   154B F1 22 76 80        3339         .db     0x0F1,0x022,0x076,0x080       ; 0.96147
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 62
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   154F 45 AA 38 82        3340         .db     0x045,0x0AA,0x038,0x082       ; 2.88539
                           3341 ;
   1553 CD 9F 16      [17] 3342 LOG:    CALL    TSTSGN                        ; Test sign of value
   1556 B7            [ 4] 3343         OR      A
   1557 EA 17 09      [10] 3344         JP      PE,FCERR                      ; ?FC Error if <= zero
   155A 21 2C 81      [10] 3345         LD      HL,FPEXP                      ; Point to exponent
   155D 7E            [ 7] 3346         LD      A,(HL)                        ; Get exponent
   155E 01 35 80      [10] 3347         LD      BC,0x8035                     ; BCDE = SQR(1/2)
   1561 11 F3 04      [10] 3348         LD      DE,0x04F3
   1564 90            [ 4] 3349         SUB     B                             ; Scale value to be < 1
   1565 F5            [11] 3350         PUSH    AF                            ; Save scale factor
   1566 70            [ 7] 3351         LD      (HL),B                        ; Save new exponent
   1567 D5            [11] 3352         PUSH    DE                            ; Save SQR(1/2)
   1568 C5            [11] 3353         PUSH    BC
   1569 CD 59 14      [17] 3354         CALL    FPADD                         ; Add SQR(1/2) to value
   156C C1            [10] 3355         POP     BC                            ; Restore SQR(1/2)
   156D D1            [10] 3356         POP     DE
   156E 04            [ 4] 3357         INC     B                             ; Make it SQR(2)
   156F CD F5 15      [17] 3358         CALL    DVBCDE                        ; Divide by SQR(2)
   1572 21 42 15      [10] 3359         LD      HL,UNITY                      ; Point to 1.
   1575 CD 50 14      [17] 3360         CALL    SUBPHL                        ; Subtract FPREG from 1
   1578 21 46 15      [10] 3361         LD      HL,LOGTAB                     ; Coefficient table
   157B CD E7 19      [17] 3362         CALL    SUMSER                        ; Evaluate sum of series
   157E 01 80 80      [10] 3363         LD      BC,0x8080                     ; BCDE = -0.5
   1581 11 00 00      [10] 3364         LD      DE,0x0000
   1584 CD 59 14      [17] 3365         CALL    FPADD                         ; Subtract 0.5 from FPREG
   1587 F1            [10] 3366         POP     AF                            ; Restore scale factor
   1588 CD 1A 18      [17] 3367         CALL    RSCALE                        ; Re-scale number
   158B 01 31 80      [10] 3368 MULLN2: LD      BC,0x8031                     ; BCDE = Ln(2)
   158E 11 18 72      [10] 3369         LD      DE,0x7218
   1591 21                 3370         .db     0x21                          ; Skip "POP BC" and "POP DE"
                           3371 ;
   1592 C1            [10] 3372 MULT:   POP     BC                            ; Get number from stack
   1593 D1            [10] 3373         POP     DE
   1594 CD 9F 16      [17] 3374 FPMULT: CALL    TSTSGN                        ; Test sign of FPREG
   1597 C8            [11] 3375         RET     Z                             ; Return zero if zero
   1598 2E 00         [ 7] 3376         LD      L,0                           ; Flag add exponents
   159A CD 5D 16      [17] 3377         CALL    ADDEXP                        ; Add exponents
   159D 79            [ 4] 3378         LD      A,C                           ; Get MSB of multiplier
   159E 32 3B 81      [13] 3379         LD      (MULVAL),A                    ; Save MSB of multiplier
   15A1 EB            [ 4] 3380         EX      DE,HL
   15A2 22 3C 81      [16] 3381         LD      (MULVAL+1),HL                 ; Save rest of multiplier
   15A5 01 00 00      [10] 3382         LD      BC,0                          ; Partial product (BCDE) = zero
   15A8 50            [ 4] 3383         LD      D,B
   15A9 58            [ 4] 3384         LD      E,B
   15AA 21 AA 14      [10] 3385         LD      HL,BNORM                      ; Address of normalise
   15AD E5            [11] 3386         PUSH    HL                            ; Save for return
   15AE 21 B6 15      [10] 3387         LD      HL,MULT8                      ; Address of 8 bit multiply
   15B1 E5            [11] 3388         PUSH    HL                            ; Save for NMSB,MSB
   15B2 E5            [11] 3389         PUSH    HL                            ;
   15B3 21 29 81      [10] 3390         LD      HL,FPREG                      ; Point to number
   15B6 7E            [ 7] 3391 MULT8:  LD      A,(HL)                        ; Get LSB of number
   15B7 23            [ 6] 3392         INC     HL                            ; Point to NMSB
   15B8 B7            [ 4] 3393         OR      A                             ; Test LSB
   15B9 CA E2 15      [10] 3394         JP      Z,BYTSFT                      ; Zero - shift to next byte
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 63
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   15BC E5            [11] 3395         PUSH    HL                            ; Save address of number
   15BD 2E 08         [ 7] 3396         LD      L,8                           ; 8 bits to multiply by
   15BF 1F            [ 4] 3397 MUL8LP: RRA                                   ; Shift LSB right
   15C0 67            [ 4] 3398         LD      H,A                           ; Save LSB
   15C1 79            [ 4] 3399         LD      A,C                           ; Get MSB
   15C2 D2 D0 15      [10] 3400         JP      NC,NOMADD                     ; Bit was zero - Don't add
   15C5 E5            [11] 3401         PUSH    HL                            ; Save LSB and count
   15C6 2A 3C 81      [16] 3402         LD      HL,(MULVAL+1)                 ; Get LSB and NMSB
   15C9 19            [11] 3403         ADD     HL,DE                         ; Add NMSB and LSB
   15CA EB            [ 4] 3404         EX      DE,HL                         ; Leave sum in DE
   15CB E1            [10] 3405         POP     HL                            ; Restore MSB and count
   15CC 3A 3B 81      [13] 3406         LD      A,(MULVAL)                    ; Get MSB of multiplier
   15CF 89            [ 4] 3407         ADC     A,C                           ; Add MSB
   15D0 1F            [ 4] 3408 NOMADD: RRA                                   ; Shift MSB right
   15D1 4F            [ 4] 3409         LD      C,A                           ; Re-save MSB
   15D2 7A            [ 4] 3410         LD      A,D                           ; Get NMSB
   15D3 1F            [ 4] 3411         RRA                                   ; Shift NMSB right
   15D4 57            [ 4] 3412         LD      D,A                           ; Re-save NMSB
   15D5 7B            [ 4] 3413         LD      A,E                           ; Get LSB
   15D6 1F            [ 4] 3414         RRA                                   ; Shift LSB right
   15D7 5F            [ 4] 3415         LD      E,A                           ; Re-save LSB
   15D8 78            [ 4] 3416         LD      A,B                           ; Get VLSB
   15D9 1F            [ 4] 3417         RRA                                   ; Shift VLSB right
   15DA 47            [ 4] 3418         LD      B,A                           ; Re-save VLSB
   15DB 2D            [ 4] 3419         DEC     L                             ; Count bits multiplied
   15DC 7C            [ 4] 3420         LD      A,H                           ; Get LSB of multiplier
   15DD C2 BF 15      [10] 3421         JP      NZ,MUL8LP                     ; More - Do it
   15E0 E1            [10] 3422 POPHRT: POP     HL                            ; Restore address of number
   15E1 C9            [10] 3423         RET
                           3424 ;
   15E2 43            [ 4] 3425 BYTSFT: LD      B,E                           ; Shift partial product left
   15E3 5A            [ 4] 3426         LD      E,D
   15E4 51            [ 4] 3427         LD      D,C
   15E5 4F            [ 4] 3428         LD      C,A
   15E6 C9            [10] 3429         RET
                           3430 ;
   15E7 CD D0 16      [17] 3431 DIV10:  CALL    STAKFP                        ; Save FPREG on stack
   15EA 01 20 84      [10] 3432         LD      BC,0x8420                     ; BCDE = 10.
   15ED 11 00 00      [10] 3433         LD      DE,0x0000
   15F0 CD E0 16      [17] 3434         CALL    FPBCDE                        ; Move 10 to FPREG
                           3435 ;
   15F3 C1            [10] 3436 DIV:    POP     BC                            ; Get number from stack
   15F4 D1            [10] 3437         POP     DE
   15F5 CD 9F 16      [17] 3438 DVBCDE: CALL    TSTSGN                        ; Test sign of FPREG
   15F8 CA FB 03      [10] 3439         JP      Z,DZERR                       ; Error if division by zero
   15FB 2E FF         [ 7] 3440         LD      L,-1                          ; Flag subtract exponents
   15FD CD 5D 16      [17] 3441         CALL    ADDEXP                        ; Subtract exponents
   1600 34            [11] 3442         INC     (HL)                          ; Add 2 to exponent to adjust
   1601 34            [11] 3443         INC     (HL)
   1602 2B            [ 6] 3444         DEC     HL                            ; Point to MSB
   1603 7E            [ 7] 3445         LD      A,(HL)                        ; Get MSB of dividend
   1604 32 57 80      [13] 3446         LD      (DIV3),A                      ; Save for subtraction
   1607 2B            [ 6] 3447         DEC     HL
   1608 7E            [ 7] 3448         LD      A,(HL)                        ; Get NMSB of dividend
   1609 32 53 80      [13] 3449         LD      (DIV2),A                      ; Save for subtraction
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 64
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   160C 2B            [ 6] 3450         DEC     HL
   160D 7E            [ 7] 3451         LD      A,(HL)                        ; Get MSB of dividend
   160E 32 4F 80      [13] 3452         LD      (DIV1),A                      ; Save for subtraction
   1611 41            [ 4] 3453         LD      B,C                           ; Get MSB
   1612 EB            [ 4] 3454         EX      DE,HL                         ; NMSB,LSB to HL
   1613 AF            [ 4] 3455         XOR     A
   1614 4F            [ 4] 3456         LD      C,A                           ; Clear MSB of quotient
   1615 57            [ 4] 3457         LD      D,A                           ; Clear NMSB of quotient
   1616 5F            [ 4] 3458         LD      E,A                           ; Clear LSB of quotient
   1617 32 5A 80      [13] 3459         LD      (DIV4),A                      ; Clear overflow count
   161A E5            [11] 3460 DIVLP:  PUSH    HL                            ; Save divisor
   161B C5            [11] 3461         PUSH    BC
   161C 7D            [ 4] 3462         LD      A,L                           ; Get LSB of number
   161D CD 4E 80      [17] 3463         CALL    DIVSUP                        ; Subt' divisor from dividend
   1620 DE 00         [ 7] 3464         SBC     A,0                           ; Count for overflows
   1622 3F            [ 4] 3465         CCF
   1623 D2 2D 16      [10] 3466         JP      NC,RESDIV                     ; Restore divisor if borrow
   1626 32 5A 80      [13] 3467         LD      (DIV4),A                      ; Re-save overflow count
   1629 F1            [10] 3468         POP     AF                            ; Scrap divisor
   162A F1            [10] 3469         POP     AF
   162B 37            [ 4] 3470         SCF                                   ; Set carry to
   162C D2                 3471         .db     0x0D2                         ; Skip "POP BC" and "POP HL"
                           3472 ;
   162D C1            [10] 3473 RESDIV: POP     BC                            ; Restore divisor
   162E E1            [10] 3474         POP     HL
   162F 79            [ 4] 3475         LD      A,C                           ; Get MSB of quotient
   1630 3C            [ 4] 3476         INC     A
   1631 3D            [ 4] 3477         DEC     A
   1632 1F            [ 4] 3478         RRA                                   ; Bit 0 to bit 7
   1633 FA E0 14      [10] 3479         JP      M,RONDB                       ; Done - Normalise result
   1636 17            [ 4] 3480         RLA                                   ; Restore carry
   1637 7B            [ 4] 3481         LD      A,E                           ; Get LSB of quotient
   1638 17            [ 4] 3482         RLA                                   ; Double it
   1639 5F            [ 4] 3483         LD      E,A                           ; Put it back
   163A 7A            [ 4] 3484         LD      A,D                           ; Get NMSB of quotient
   163B 17            [ 4] 3485         RLA                                   ; Double it
   163C 57            [ 4] 3486         LD      D,A                           ; Put it back
   163D 79            [ 4] 3487         LD      A,C                           ; Get MSB of quotient
   163E 17            [ 4] 3488         RLA                                   ; Double it
   163F 4F            [ 4] 3489         LD      C,A                           ; Put it back
   1640 29            [11] 3490         ADD     HL,HL                         ; Double NMSB,LSB of divisor
   1641 78            [ 4] 3491         LD      A,B                           ; Get MSB of divisor
   1642 17            [ 4] 3492         RLA                                   ; Double it
   1643 47            [ 4] 3493         LD      B,A                           ; Put it back
   1644 3A 5A 80      [13] 3494         LD      A,(DIV4)                      ; Get VLSB of quotient
   1647 17            [ 4] 3495         RLA                                   ; Double it
   1648 32 5A 80      [13] 3496         LD      (DIV4),A                      ; Put it back
   164B 79            [ 4] 3497         LD      A,C                           ; Get MSB of quotient
   164C B2            [ 4] 3498         OR      D                             ; Merge NMSB
   164D B3            [ 4] 3499         OR      E                             ; Merge LSB
   164E C2 1A 16      [10] 3500         JP      NZ,DIVLP                      ; Not done - Keep dividing
   1651 E5            [11] 3501         PUSH    HL                            ; Save divisor
   1652 21 2C 81      [10] 3502         LD      HL,FPEXP                      ; Point to exponent
   1655 35            [11] 3503         DEC     (HL)                          ; Divide by 2
   1656 E1            [10] 3504         POP     HL                            ; Restore divisor
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 65
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1657 C2 1A 16      [10] 3505         JP      NZ,DIVLP                      ; Ok - Keep going
   165A C3 07 04      [10] 3506         JP      OVERR                         ; Overflow error
                           3507 ;
   165D 78            [ 4] 3508 ADDEXP: LD      A,B                           ; Get exponent of dividend
   165E B7            [ 4] 3509         OR      A                             ; Test it
   165F CA 81 16      [10] 3510         JP      Z,OVTST3                      ; Zero - Result zero
   1662 7D            [ 4] 3511         LD      A,L                           ; Get add/subtract flag
   1663 21 2C 81      [10] 3512         LD      HL,FPEXP                      ; Point to exponent
   1666 AE            [ 7] 3513         XOR     (HL)                          ; Add or subtract it
   1667 80            [ 4] 3514         ADD     A,B                           ; Add the other exponent
   1668 47            [ 4] 3515         LD      B,A                           ; Save new exponent
   1669 1F            [ 4] 3516         RRA                                   ; Test exponent for overflow
   166A A8            [ 4] 3517         XOR     B
   166B 78            [ 4] 3518         LD      A,B                           ; Get exponent
   166C F2 80 16      [10] 3519         JP      P,OVTST2                      ; Positive - Test for overflow
   166F C6 80         [ 7] 3520         ADD     A,0x80                        ; Add excess 128
   1671 77            [ 7] 3521         LD      (HL),A                        ; Save new exponent
   1672 CA E0 15      [10] 3522         JP      Z,POPHRT                      ; Zero - Result zero
   1675 CD 05 17      [17] 3523         CALL    SIGNS                         ; Set MSBs and sign of result
   1678 77            [ 7] 3524         LD      (HL),A                        ; Save new exponent
   1679 2B            [ 6] 3525         DEC     HL                            ; Point to MSB
   167A C9            [10] 3526         RET
                           3527 ;
   167B CD 9F 16      [17] 3528 OVTST1: CALL    TSTSGN                        ; Test sign of FPREG
   167E 2F            [ 4] 3529         CPL                                   ; Invert sign
   167F E1            [10] 3530         POP     HL                            ; Clean up stack
   1680 B7            [ 4] 3531 OVTST2: OR      A                             ; Test if new exponent zero
   1681 E1            [10] 3532 OVTST3: POP     HL                            ; Clear off return address
   1682 F2 BF 14      [10] 3533         JP      P,RESZER                      ; Result zero
   1685 C3 07 04      [10] 3534         JP      OVERR                         ; Overflow error
                           3535 ;
   1688 CD EB 16      [17] 3536 MLSP10: CALL    BCDEFP                        ; Move FPREG to BCDE
   168B 78            [ 4] 3537         LD      A,B                           ; Get exponent
   168C B7            [ 4] 3538         OR      A                             ; Is it zero?
   168D C8            [11] 3539         RET     Z                             ; Yes - Result is zero
   168E C6 02         [ 7] 3540         ADD     A,2                           ; Multiply by 4
   1690 DA 07 04      [10] 3541         JP      C,OVERR                       ; Overflow - ?OV Error
   1693 47            [ 4] 3542         LD      B,A                           ; Re-save exponent
   1694 CD 59 14      [17] 3543         CALL    FPADD                         ; Add BCDE to FPREG (Times 5)
   1697 21 2C 81      [10] 3544         LD      HL,FPEXP                      ; Point to exponent
   169A 34            [11] 3545         INC     (HL)                          ; Double number (Times 10)
   169B C0            [11] 3546         RET     NZ                            ; Ok - Return
   169C C3 07 04      [10] 3547         JP      OVERR                         ; Overflow error
                           3548 ;
   169F 3A 2C 81      [13] 3549 TSTSGN: LD      A,(FPEXP)                     ; Get sign of FPREG
   16A2 B7            [ 4] 3550         OR      A
   16A3 C8            [11] 3551         RET     Z                             ; RETurn if number is zero
   16A4 3A 2B 81      [13] 3552         LD      A,(FPREG+2)                   ; Get MSB of FPREG
   16A7 FE                 3553         .db     0x0FE                         ; Test sign
   16A8 2F            [ 4] 3554 RETREL: CPL                                   ; Invert sign
   16A9 17            [ 4] 3555         RLA                                   ; Sign bit to carry
   16AA 9F            [ 4] 3556 FLGDIF: SBC     A,A                           ; Carry to all bits of A
   16AB C0            [11] 3557         RET     NZ                            ; Return -1 if negative
   16AC 3C            [ 4] 3558         INC     A                             ; Bump to +1
   16AD C9            [10] 3559         RET                                   ; Positive - Return +1
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 66
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



                           3560 ;
   16AE CD 9F 16      [17] 3561 SGN:    CALL    TSTSGN                        ; Test sign of FPREG
   16B1 06 88         [ 7] 3562 FLGREL: LD      B,0x80+8                      ; 8 bit integer in exponent
   16B3 11 00 00      [10] 3563         LD      DE,0                          ; Zero NMSB and LSB
   16B6 21 2C 81      [10] 3564 RETINT: LD      HL,FPEXP                      ; Point to exponent
   16B9 4F            [ 4] 3565         LD      C,A                           ; CDE = MSB,NMSB and LSB
   16BA 70            [ 7] 3566         LD      (HL),B                        ; Save exponent
   16BB 06 00         [ 7] 3567         LD      B,0                           ; CDE = integer to normalise
   16BD 23            [ 6] 3568         INC     HL                            ; Point to sign of result
   16BE 36 80         [10] 3569         LD      (HL),0x80                     ; Set sign of result
   16C0 17            [ 4] 3570         RLA                                   ; Carry = sign of integer
   16C1 C3 A7 14      [10] 3571         JP      CONPOS                        ; Set sign of result
                           3572 ;
   16C4 CD 9F 16      [17] 3573 ABS:    CALL    TSTSGN                        ; Test sign of FPREG
   16C7 F0            [11] 3574         RET     P                             ; Return if positive
   16C8 21 2B 81      [10] 3575 INVSGN: LD      HL,FPREG+2                    ; Point to MSB
   16CB 7E            [ 7] 3576         LD      A,(HL)                        ; Get sign of mantissa
   16CC EE 80         [ 7] 3577         XOR     0x80                          ; Invert sign of mantissa
   16CE 77            [ 7] 3578         LD      (HL),A                        ; Re-save sign of mantissa
   16CF C9            [10] 3579         RET
                           3580 ;
   16D0 EB            [ 4] 3581 STAKFP: EX      DE,HL                         ; Save code string address
   16D1 2A 29 81      [16] 3582         LD      HL,(FPREG)                    ; LSB,NLSB of FPREG
   16D4 E3            [19] 3583         EX      (SP),HL                       ; Stack them,get return
   16D5 E5            [11] 3584         PUSH    HL                            ; Re-save return
   16D6 2A 2B 81      [16] 3585         LD      HL,(FPREG+2)                  ; MSB and exponent of FPREG
   16D9 E3            [19] 3586         EX      (SP),HL                       ; Stack them,get return
   16DA E5            [11] 3587         PUSH    HL                            ; Re-save return
   16DB EB            [ 4] 3588         EX      DE,HL                         ; Restore code string address
   16DC C9            [10] 3589         RET
                           3590 ;
   16DD CD EE 16      [17] 3591 PHLTFP: CALL    LOADFP                        ; Number at HL to BCDE
   16E0 EB            [ 4] 3592 FPBCDE: EX      DE,HL                         ; Save code string address
   16E1 22 29 81      [16] 3593         LD      (FPREG),HL                    ; Save LSB,NLSB of number
   16E4 60            [ 4] 3594         LD      H,B                           ; Exponent of number
   16E5 69            [ 4] 3595         LD      L,C                           ; MSB of number
   16E6 22 2B 81      [16] 3596         LD      (FPREG+2),HL                  ; Save MSB and exponent
   16E9 EB            [ 4] 3597         EX      DE,HL                         ; Restore code string address
   16EA C9            [10] 3598         RET
                           3599 ;
   16EB 21 29 81      [10] 3600 BCDEFP: LD      HL,FPREG                      ; Point to FPREG
   16EE 5E            [ 7] 3601 LOADFP: LD      E,(HL)                        ; Get LSB of number
   16EF 23            [ 6] 3602         INC     HL
   16F0 56            [ 7] 3603         LD      D,(HL)                        ; Get NMSB of number
   16F1 23            [ 6] 3604         INC     HL
   16F2 4E            [ 7] 3605         LD      C,(HL)                        ; Get MSB of number
   16F3 23            [ 6] 3606         INC     HL
   16F4 46            [ 7] 3607         LD      B,(HL)                        ; Get exponent of number
   16F5 23            [ 6] 3608 INCHL:  INC     HL                            ; Used for conditional "INC HL"
   16F6 C9            [10] 3609         RET
                           3610 ;
   16F7 11 29 81      [10] 3611 FPTHL:  LD      DE,FPREG                      ; Point to FPREG
   16FA 06 04         [ 7] 3612 DETHL4: LD      B,4                           ; 4 bytes to move
   16FC 1A            [ 7] 3613 DETHLB: LD      A,(DE)                        ; Get source
   16FD 77            [ 7] 3614         LD      (HL),A                        ; Save destination
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 67
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   16FE 13            [ 6] 3615         INC     DE                            ; Next source
   16FF 23            [ 6] 3616         INC     HL                            ; Next destination
   1700 05            [ 4] 3617         DEC     B                             ; Count bytes
   1701 C2 FC 16      [10] 3618         JP      NZ,DETHLB                     ; Loop if more
   1704 C9            [10] 3619         RET
                           3620 ;
   1705 21 2B 81      [10] 3621 SIGNS:  LD      HL,FPREG+2                    ; Point to MSB of FPREG
   1708 7E            [ 7] 3622         LD      A,(HL)                        ; Get MSB
   1709 07            [ 4] 3623         RLCA                                  ; Old sign to carry
   170A 37            [ 4] 3624         SCF                                   ; Set MSBit
   170B 1F            [ 4] 3625         RRA                                   ; Set MSBit of MSB
   170C 77            [ 7] 3626         LD      (HL),A                        ; Save new MSB
   170D 3F            [ 4] 3627         CCF                                   ; Complement sign
   170E 1F            [ 4] 3628         RRA                                   ; Old sign to carry
   170F 23            [ 6] 3629         INC     HL
   1710 23            [ 6] 3630         INC     HL
   1711 77            [ 7] 3631         LD      (HL),A                        ; Set sign of result
   1712 79            [ 4] 3632         LD      A,C                           ; Get MSB
   1713 07            [ 4] 3633         RLCA                                  ; Old sign to carry
   1714 37            [ 4] 3634         SCF                                   ; Set MSBit
   1715 1F            [ 4] 3635         RRA                                   ; Set MSBit of MSB
   1716 4F            [ 4] 3636         LD      C,A                           ; Save MSB
   1717 1F            [ 4] 3637         RRA
   1718 AE            [ 7] 3638         XOR     (HL)                          ; New sign of result
   1719 C9            [10] 3639         RET
                           3640 ;
   171A 78            [ 4] 3641 CMPNUM: LD      A,B                           ; Get exponent of number
   171B B7            [ 4] 3642         OR      A
   171C CA 9F 16      [10] 3643         JP      Z,TSTSGN                      ; Zero - Test sign of FPREG
   171F 21 A8 16      [10] 3644         LD      HL,RETREL                     ; Return relation routine
   1722 E5            [11] 3645         PUSH    HL                            ; Save for return
   1723 CD 9F 16      [17] 3646         CALL    TSTSGN                        ; Test sign of FPREG
   1726 79            [ 4] 3647         LD      A,C                           ; Get MSB of number
   1727 C8            [11] 3648         RET     Z                             ; FPREG zero - Number's MSB
   1728 21 2B 81      [10] 3649         LD      HL,FPREG+2                    ; MSB of FPREG
   172B AE            [ 7] 3650         XOR     (HL)                          ; Combine signs
   172C 79            [ 4] 3651         LD      A,C                           ; Get MSB of number
   172D F8            [11] 3652         RET     M                             ; Exit if signs different
   172E CD 34 17      [17] 3653         CALL    CMPFP                         ; Compare FP numbers
   1731 1F            [ 4] 3654         RRA                                   ; Get carry to sign
   1732 A9            [ 4] 3655         XOR     C                             ; Combine with MSB of number
   1733 C9            [10] 3656         RET
                           3657 ;
   1734 23            [ 6] 3658 CMPFP:  INC     HL                            ; Point to exponent
   1735 78            [ 4] 3659         LD      A,B                           ; Get exponent
   1736 BE            [ 7] 3660         CP      (HL)                          ; Compare exponents
   1737 C0            [11] 3661         RET     NZ                            ; Different
   1738 2B            [ 6] 3662         DEC     HL                            ; Point to MBS
   1739 79            [ 4] 3663         LD      A,C                           ; Get MSB
   173A BE            [ 7] 3664         CP      (HL)                          ; Compare MSBs
   173B C0            [11] 3665         RET     NZ                            ; Different
   173C 2B            [ 6] 3666         DEC     HL                            ; Point to NMSB
   173D 7A            [ 4] 3667         LD      A,D                           ; Get NMSB
   173E BE            [ 7] 3668         CP      (HL)                          ; Compare NMSBs
   173F C0            [11] 3669         RET     NZ                            ; Different
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 68
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1740 2B            [ 6] 3670         DEC     HL                            ; Point to LSB
   1741 7B            [ 4] 3671         LD      A,E                           ; Get LSB
   1742 96            [ 7] 3672         SUB     (HL)                          ; Compare LSBs
   1743 C0            [11] 3673         RET     NZ                            ; Different
   1744 E1            [10] 3674         POP     HL                            ; Drop RETurn
   1745 E1            [10] 3675         POP     HL                            ; Drop another RETurn
   1746 C9            [10] 3676         RET
                           3677 ;
   1747 47            [ 4] 3678 FPINT:  LD      B,A                           ; <- Move
   1748 4F            [ 4] 3679         LD      C,A                           ; <- exponent
   1749 57            [ 4] 3680         LD      D,A                           ; <- to all
   174A 5F            [ 4] 3681         LD      E,A                           ; <- bits
   174B B7            [ 4] 3682         OR      A                             ; Test exponent
   174C C8            [11] 3683         RET     Z                             ; Zero - Return zero
   174D E5            [11] 3684         PUSH    HL                            ; Save pointer to number
   174E CD EB 16      [17] 3685         CALL    BCDEFP                        ; Move FPREG to BCDE
   1751 CD 05 17      [17] 3686         CALL    SIGNS                         ; Set MSBs & sign of result
   1754 AE            [ 7] 3687         XOR     (HL)                          ; Combine with sign of FPREG
   1755 67            [ 4] 3688         LD      H,A                           ; Save combined signs
   1756 FC 6B 17      [17] 3689         CALL    M,DCBCDE                      ; Negative - Decrement BCDE
   1759 3E 98         [ 7] 3690         LD      A,0x80+24                     ; 24 bits
   175B 90            [ 4] 3691         SUB     B                             ; Bits to shift
   175C CD 1E 15      [17] 3692         CALL    SCALE                         ; Shift BCDE
   175F 7C            [ 4] 3693         LD      A,H                           ; Get combined sign
   1760 17            [ 4] 3694         RLA                                   ; Sign to carry
   1761 DC F1 14      [17] 3695         CALL    C,FPROND                      ; Negative - Round number up
   1764 06 00         [ 7] 3696         LD      B,0                           ; Zero exponent
   1766 DC 0A 15      [17] 3697         CALL    C,COMPL                       ; If negative make positive
   1769 E1            [10] 3698         POP     HL                            ; Restore pointer to number
   176A C9            [10] 3699         RET
                           3700 ;
   176B 1B            [ 6] 3701 DCBCDE: DEC     DE                            ; Decrement BCDE
   176C 7A            [ 4] 3702         LD      A,D                           ; Test LSBs
   176D A3            [ 4] 3703         AND     E
   176E 3C            [ 4] 3704         INC     A
   176F C0            [11] 3705         RET     NZ                            ; Exit if LSBs not FFFF
   1770 0B            [ 6] 3706         DEC     BC                            ; Decrement MSBs
   1771 C9            [10] 3707         RET
                           3708 ;
   1772 21 2C 81      [10] 3709 INT:    LD      HL,FPEXP                      ; Point to exponent
   1775 7E            [ 7] 3710         LD      A,(HL)                        ; Get exponent
   1776 FE 98         [ 7] 3711         CP      0x80+24                       ; Integer accuracy only?
   1778 3A 29 81      [13] 3712         LD      A,(FPREG)                     ; Get LSB
   177B D0            [11] 3713         RET     NC                            ; Yes - Already integer
   177C 7E            [ 7] 3714         LD      A,(HL)                        ; Get exponent
   177D CD 47 17      [17] 3715         CALL    FPINT                         ; F.P to integer
   1780 36 98         [10] 3716         LD      (HL),0x80+24                  ; Save 24 bit integer
   1782 7B            [ 4] 3717         LD      A,E                           ; Get LSB of number
   1783 F5            [11] 3718         PUSH    AF                            ; Save LSB
   1784 79            [ 4] 3719         LD      A,C                           ; Get MSB of number
   1785 17            [ 4] 3720         RLA                                   ; Sign to carry
   1786 CD A7 14      [17] 3721         CALL    CONPOS                        ; Set sign of result
   1789 F1            [10] 3722         POP     AF                            ; Restore LSB of number
   178A C9            [10] 3723         RET
                           3724 ;
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 69
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   178B 21 00 00      [10] 3725 MLDEBC: LD      HL,0                          ; Clear partial product
   178E 78            [ 4] 3726         LD      A,B                           ; Test multiplier
   178F B1            [ 4] 3727         OR      C
   1790 C8            [11] 3728         RET     Z                             ; Return zero if zero
   1791 3E 10         [ 7] 3729         LD      A,16                          ; 16 bits
   1793 29            [11] 3730 MLDBLP: ADD     HL,HL                         ; Shift P.P left
   1794 DA CB 0F      [10] 3731         JP      C,BSERR                       ; ?BS Error if overflow
   1797 EB            [ 4] 3732         EX      DE,HL
   1798 29            [11] 3733         ADD     HL,HL                         ; Shift multiplier left
   1799 EB            [ 4] 3734         EX      DE,HL
   179A D2 A1 17      [10] 3735         JP      NC,NOMLAD                     ; Bit was zero - No add
   179D 09            [11] 3736         ADD     HL,BC                         ; Add multiplicand
   179E DA CB 0F      [10] 3737         JP      C,BSERR                       ; ?BS Error if overflow
   17A1 3D            [ 4] 3738 NOMLAD: DEC     A                             ; Count bits
   17A2 C2 93 17      [10] 3739         JP      NZ,MLDBLP                     ; More
   17A5 C9            [10] 3740         RET
                           3741 ;
   17A6 FE 2D         [ 7] 3742 ASCTFP: CP      '-                            ; Negative?
   17A8 F5            [11] 3743         PUSH    AF                            ; Save it and flags
   17A9 CA B2 17      [10] 3744         JP      Z,CNVNUM                      ; Yes - Convert number
   17AC FE 2B         [ 7] 3745         CP      '+                            ; Positive?
   17AE CA B2 17      [10] 3746         JP      Z,CNVNUM                      ; Yes - Convert number
   17B1 2B            [ 6] 3747         DEC     HL                            ; DEC 'cos GETCHR INCs
   17B2 CD BF 14      [17] 3748 CNVNUM: CALL    RESZER                        ; Set result to zero
   17B5 47            [ 4] 3749         LD      B,A                           ; Digits after point counter
   17B6 57            [ 4] 3750         LD      D,A                           ; Sign of exponent
   17B7 5F            [ 4] 3751         LD      E,A                           ; Exponent of ten
   17B8 2F            [ 4] 3752         CPL
   17B9 4F            [ 4] 3753         LD      C,A                           ; Before or after point flag
   17BA CD 50 08      [17] 3754 MANLP:  CALL    GETCHR                        ; Get next character
   17BD DA 03 18      [10] 3755         JP      C,ADDIG                       ; Digit - Add to number
   17C0 FE 2E         [ 7] 3756         CP      '.
   17C2 CA DE 17      [10] 3757         JP      Z,DPOINT                      ; '. - Flag point
   17C5 FE 45         [ 7] 3758         CP      'E
   17C7 C2 E2 17      [10] 3759         JP      NZ,CONEXP                     ; Not 'E - Scale number
   17CA CD 50 08      [17] 3760         CALL    GETCHR                        ; Get next character
   17CD CD F6 0D      [17] 3761         CALL    SGNEXP                        ; Get sign of exponent
   17D0 CD 50 08      [17] 3762 EXPLP:  CALL    GETCHR                        ; Get next character
   17D3 DA 25 18      [10] 3763         JP      C,EDIGIT                      ; Digit - Add to exponent
   17D6 14            [ 4] 3764         INC     D                             ; Is sign negative?
   17D7 C2 E2 17      [10] 3765         JP      NZ,CONEXP                     ; No - Scale number
   17DA AF            [ 4] 3766         XOR     A
   17DB 93            [ 4] 3767         SUB     E                             ; Negate exponent
   17DC 5F            [ 4] 3768         LD      E,A                           ; And re-save it
   17DD 0C            [ 4] 3769         INC     C                             ; Flag end of number
   17DE 0C            [ 4] 3770 DPOINT: INC     C                             ; Flag point passed
   17DF CA BA 17      [10] 3771         JP      Z,MANLP                       ; Zero - Get another digit
   17E2 E5            [11] 3772 CONEXP: PUSH    HL                            ; Save code string address
   17E3 7B            [ 4] 3773         LD      A,E                           ; Get exponent
   17E4 90            [ 4] 3774         SUB     B                             ; Subtract digits after point
   17E5 F4 FB 17      [17] 3775 SCALMI: CALL    P,SCALPL                      ; Positive - Multiply number
   17E8 F2 F1 17      [10] 3776         JP      P,ENDCON                      ; Positive - All done
   17EB F5            [11] 3777         PUSH    AF                            ; Save number of times to /10
   17EC CD E7 15      [17] 3778         CALL    DIV10                         ; Divide by 10
   17EF F1            [10] 3779         POP     AF                            ; Restore count
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 70
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   17F0 3C            [ 4] 3780         INC     A                             ; Count divides
                           3781 ;
   17F1 C2 E5 17      [10] 3782 ENDCON: JP      NZ,SCALMI                     ; More to do
   17F4 D1            [10] 3783         POP     DE                            ; Restore code string address
   17F5 F1            [10] 3784         POP     AF                            ; Restore sign of number
   17F6 CC C8 16      [17] 3785         CALL    Z,INVSGN                      ; Negative - Negate number
   17F9 EB            [ 4] 3786         EX      DE,HL                         ; Code string address to HL
   17FA C9            [10] 3787         RET
                           3788 ;
   17FB C8            [11] 3789 SCALPL: RET     Z                             ; Exit if no scaling needed
   17FC F5            [11] 3790 MULTEN: PUSH    AF                            ; Save count
   17FD CD 88 16      [17] 3791         CALL    MLSP10                        ; Multiply number by 10
   1800 F1            [10] 3792         POP     AF                            ; Restore count
   1801 3D            [ 4] 3793         DEC     A                             ; Count multiplies
   1802 C9            [10] 3794         RET
                           3795 ;
   1803 D5            [11] 3796 ADDIG:  PUSH    DE                            ; Save sign of exponent
   1804 57            [ 4] 3797         LD      D,A                           ; Save digit
   1805 78            [ 4] 3798         LD      A,B                           ; Get digits after point
   1806 89            [ 4] 3799         ADC     A,C                           ; Add one if after point
   1807 47            [ 4] 3800         LD      B,A                           ; Re-save counter
   1808 C5            [11] 3801         PUSH    BC                            ; Save point flags
   1809 E5            [11] 3802         PUSH    HL                            ; Save code string address
   180A D5            [11] 3803         PUSH    DE                            ; Save digit
   180B CD 88 16      [17] 3804         CALL    MLSP10                        ; Multiply number by 10
   180E F1            [10] 3805         POP     AF                            ; Restore digit
   180F D6 30         [ 7] 3806         SUB     '0                            ; Make it absolute
   1811 CD 1A 18      [17] 3807         CALL    RSCALE                        ; Re-scale number
   1814 E1            [10] 3808         POP     HL                            ; Restore code string address
   1815 C1            [10] 3809         POP     BC                            ; Restore point flags
   1816 D1            [10] 3810         POP     DE                            ; Restore sign of exponent
   1817 C3 BA 17      [10] 3811         JP      MANLP                         ; Get another digit
                           3812 ;
   181A CD D0 16      [17] 3813 RSCALE: CALL    STAKFP                        ; Put number on stack
   181D CD B1 16      [17] 3814         CALL    FLGREL                        ; Digit to add to FPREG
   1820 C1            [10] 3815 PADD:   POP     BC                            ; Restore number
   1821 D1            [10] 3816         POP     DE
   1822 C3 59 14      [10] 3817         JP      FPADD                         ; Add BCDE to FPREG and return
                           3818 ;
   1825 7B            [ 4] 3819 EDIGIT: LD      A,E                           ; Get digit
   1826 07            [ 4] 3820         RLCA                                  ; Times 2
   1827 07            [ 4] 3821         RLCA                                  ; Times 4
   1828 83            [ 4] 3822         ADD     A,E                           ; Times 5
   1829 07            [ 4] 3823         RLCA                                  ; Times 10
   182A 86            [ 7] 3824         ADD     A,(HL)                        ; Add next digit
   182B D6 30         [ 7] 3825         SUB     '0                            ; Make it absolute
   182D 5F            [ 4] 3826         LD      E,A                           ; Save new digit
   182E C3 D0 17      [10] 3827         JP      EXPLP                         ; Look for another digit
                           3828 ;
   1831 E5            [11] 3829 LINEIN: PUSH    HL                            ; Save code string address
   1832 21 90 03      [10] 3830         LD      HL,INMSG                      ; Output " in "
   1835 CD 96 11      [17] 3831         CALL    PRS                           ; Output string at HL
   1838 E1            [10] 3832         POP     HL                            ; Restore code string address
   1839 EB            [ 4] 3833 PRNTHL: EX      DE,HL                         ; Code string address to DE
   183A AF            [ 4] 3834         XOR     A
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 71
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   183B 06 98         [ 7] 3835         LD      B,0x80+24                     ; 24 bits
   183D CD B6 16      [17] 3836         CALL    RETINT                        ; Return the integer
   1840 21 95 11      [10] 3837         LD      HL,PRNUMS                     ; Print number string
   1843 E5            [11] 3838         PUSH    HL                            ; Save for return
   1844 21 2E 81      [10] 3839 NUMASC: LD      HL,PBUFF                      ; Convert number to ASCII
   1847 E5            [11] 3840         PUSH    HL                            ; Save for return
   1848 CD 9F 16      [17] 3841         CALL    TSTSGN                        ; Test sign of FPREG
   184B 36 20         [10] 3842         LD      (HL),0x20                     ; Space at start
   184D F2 52 18      [10] 3843         JP      P,SPCFST                      ; Positive - Space to start
   1850 36 2D         [10] 3844         LD      (HL),'-                       ; '- sign at start
   1852 23            [ 6] 3845 SPCFST: INC     HL                            ; First byte of number
   1853 36 30         [10] 3846         LD      (HL),'0                       ; '0 if zero
   1855 CA 08 19      [10] 3847         JP      Z,JSTZER                      ; Return '0 if zero
   1858 E5            [11] 3848         PUSH    HL                            ; Save buffer address
   1859 FC C8 16      [17] 3849         CALL    M,INVSGN                      ; Negate FPREG if negative
   185C AF            [ 4] 3850         XOR     A                             ; Zero A
   185D F5            [11] 3851         PUSH    AF                            ; Save it
   185E CD 0E 19      [17] 3852         CALL    RNGTST                        ; Test number is in range
   1861 01 43 91      [10] 3853 SIXDIG: LD      BC,0x9143                     ; BCDE - 99999.9
   1864 11 F8 4F      [10] 3854         LD      DE,0x4FF8
   1867 CD 1A 17      [17] 3855         CALL    CMPNUM                        ; Compare numbers
   186A B7            [ 4] 3856         OR      A
   186B E2 7F 18      [10] 3857         JP      PO,INRNG                      ; > 99999.9 - Sort it out
   186E F1            [10] 3858         POP     AF                            ; Restore count
   186F CD FC 17      [17] 3859         CALL    MULTEN                        ; Multiply by ten
   1872 F5            [11] 3860         PUSH    AF                            ; Re-save count
   1873 C3 61 18      [10] 3861         JP      SIXDIG                        ; Test it again
                           3862 ;
   1876 CD E7 15      [17] 3863 GTSIXD: CALL    DIV10                         ; Divide by 10
   1879 F1            [10] 3864         POP     AF                            ; Get count
   187A 3C            [ 4] 3865         INC     A                             ; Count divides
   187B F5            [11] 3866         PUSH    AF                            ; Re-save count
   187C CD 0E 19      [17] 3867         CALL    RNGTST                        ; Test number is in range
   187F CD 47 14      [17] 3868 INRNG:  CALL    ROUND                         ; Add 0.5 to FPREG
   1882 3C            [ 4] 3869         INC     A
   1883 CD 47 17      [17] 3870         CALL    FPINT                         ; F.P to integer
   1886 CD E0 16      [17] 3871         CALL    FPBCDE                        ; Move BCDE to FPREG
   1889 01 06 03      [10] 3872         LD      BC,0x0306                     ; 1E+06 to 1E-03 range
   188C F1            [10] 3873         POP     AF                            ; Restore count
   188D 81            [ 4] 3874         ADD     A,C                           ; 6 digits before point
   188E 3C            [ 4] 3875         INC     A                             ; Add one
   188F FA 9B 18      [10] 3876         JP      M,MAKNUM                      ; Do it in 'E form if < 1E-02
   1892 FE 08         [ 7] 3877         CP      6+1+1                         ; More than 999999 ?
   1894 D2 9B 18      [10] 3878         JP      NC,MAKNUM                     ; Yes - Do it in 'E form
   1897 3C            [ 4] 3879         INC     A                             ; Adjust for exponent
   1898 47            [ 4] 3880         LD      B,A                           ; Exponent of number
   1899 3E 02         [ 7] 3881         LD      A,2                           ; Make it zero after
                           3882 ;
   189B 3D            [ 4] 3883 MAKNUM: DEC     A                             ; Adjust for digits to do
   189C 3D            [ 4] 3884         DEC     A
   189D E1            [10] 3885         POP     HL                            ; Restore buffer address
   189E F5            [11] 3886         PUSH    AF                            ; Save count
   189F 11 21 19      [10] 3887         LD      DE,POWERS                     ; Powers of ten
   18A2 05            [ 4] 3888         DEC     B                             ; Count digits before point
   18A3 C2 AC 18      [10] 3889         JP      NZ,DIGTXT                     ; Not zero - Do number
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 72
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   18A6 36 2E         [10] 3890         LD      (HL),'.                       ; Save point
   18A8 23            [ 6] 3891         INC     HL                            ; Move on
   18A9 36 30         [10] 3892         LD      (HL),'0                       ; Save zero
   18AB 23            [ 6] 3893         INC     HL                            ; Move on
   18AC 05            [ 4] 3894 DIGTXT: DEC     B                             ; Count digits before point
   18AD 36 2E         [10] 3895         LD      (HL),'.                       ; Save point in case
   18AF CC F5 16      [17] 3896         CALL    Z,INCHL                       ; Last digit - move on
   18B2 C5            [11] 3897         PUSH    BC                            ; Save digits before point
   18B3 E5            [11] 3898         PUSH    HL                            ; Save buffer address
   18B4 D5            [11] 3899         PUSH    DE                            ; Save powers of ten
   18B5 CD EB 16      [17] 3900         CALL    BCDEFP                        ; Move FPREG to BCDE
   18B8 E1            [10] 3901         POP     HL                            ; Powers of ten table
   18B9 06 2F         [ 7] 3902         LD      B,'0-1                        ; ASCII '0 - 1
   18BB 04            [ 4] 3903 TRYAGN: INC     B                             ; Count subtractions
   18BC 7B            [ 4] 3904         LD      A,E                           ; Get LSB
   18BD 96            [ 7] 3905         SUB     (HL)                          ; Subtract LSB
   18BE 5F            [ 4] 3906         LD      E,A                           ; Save LSB
   18BF 23            [ 6] 3907         INC     HL
   18C0 7A            [ 4] 3908         LD      A,D                           ; Get NMSB
   18C1 9E            [ 7] 3909         SBC     A,(HL)                        ; Subtract NMSB
   18C2 57            [ 4] 3910         LD      D,A                           ; Save NMSB
   18C3 23            [ 6] 3911         INC     HL
   18C4 79            [ 4] 3912         LD      A,C                           ; Get MSB
   18C5 9E            [ 7] 3913         SBC     A,(HL)                        ; Subtract MSB
   18C6 4F            [ 4] 3914         LD      C,A                           ; Save MSB
   18C7 2B            [ 6] 3915         DEC     HL                            ; Point back to start
   18C8 2B            [ 6] 3916         DEC     HL
   18C9 D2 BB 18      [10] 3917         JP      NC,TRYAGN                     ; No overflow - Try again
   18CC CD FE 14      [17] 3918         CALL    PLUCDE                        ; Restore number
   18CF 23            [ 6] 3919         INC     HL                            ; Start of next number
   18D0 CD E0 16      [17] 3920         CALL    FPBCDE                        ; Move BCDE to FPREG
   18D3 EB            [ 4] 3921         EX      DE,HL                         ; Save point in table
   18D4 E1            [10] 3922         POP     HL                            ; Restore buffer address
   18D5 70            [ 7] 3923         LD      (HL),B                        ; Save digit in buffer
   18D6 23            [ 6] 3924         INC     HL                            ; And move on
   18D7 C1            [10] 3925         POP     BC                            ; Restore digit count
   18D8 0D            [ 4] 3926         DEC     C                             ; Count digits
   18D9 C2 AC 18      [10] 3927         JP      NZ,DIGTXT                     ; More - Do them
   18DC 05            [ 4] 3928         DEC     B                             ; Any decimal part?
   18DD CA EC 18      [10] 3929         JP      Z,DOEBIT                      ; No - Do 'E bit
   18E0 2B            [ 6] 3930 SUPTLZ: DEC     HL                            ; Move back through buffer
   18E1 7E            [ 7] 3931         LD      A,(HL)                        ; Get character
   18E2 FE 30         [ 7] 3932         CP      '0                            ; '0 character?
   18E4 CA E0 18      [10] 3933         JP      Z,SUPTLZ                      ; Yes - Look back for more
   18E7 FE 2E         [ 7] 3934         CP      '.                            ; A decimal point?
   18E9 C4 F5 16      [17] 3935         CALL    NZ,INCHL                      ; Move back over digit
                           3936 ;
   18EC F1            [10] 3937 DOEBIT: POP     AF                            ; Get 'E flag
   18ED CA 0B 19      [10] 3938         JP      Z,NOENED                      ; No 'E needed - End buffer
   18F0 36 45         [10] 3939         LD      (HL),'E                       ; Put 'E in buffer
   18F2 23            [ 6] 3940         INC     HL                            ; And move on
   18F3 36 2B         [10] 3941         LD      (HL),'+                       ; Put '+ in buffer
   18F5 F2 FC 18      [10] 3942         JP      P,OUTEXP                      ; Positive - Output exponent
   18F8 36 2D         [10] 3943         LD      (HL),'-                       ; Put '- in buffer
   18FA 2F            [ 4] 3944         CPL                                   ; Negate exponent
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 73
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   18FB 3C            [ 4] 3945         INC     A
   18FC 06 2F         [ 7] 3946 OUTEXP: LD      B,'0-1                        ; ASCII '0 - 1
   18FE 04            [ 4] 3947 EXPTEN: INC     B                             ; Count subtractions
   18FF D6 0A         [ 7] 3948         SUB     10                            ; Tens digit
   1901 D2 FE 18      [10] 3949         JP      NC,EXPTEN                     ; More to do
   1904 C6 3A         [ 7] 3950         ADD     A,'0+10                       ; Restore and make ASCII
   1906 23            [ 6] 3951         INC     HL                            ; Move on
   1907 70            [ 7] 3952         LD      (HL),B                        ; Save MSB of exponent
   1908 23            [ 6] 3953 JSTZER: INC     HL                            ;
   1909 77            [ 7] 3954         LD      (HL),A                        ; Save LSB of exponent
   190A 23            [ 6] 3955         INC     HL
   190B 71            [ 7] 3956 NOENED: LD      (HL),C                        ; Mark end of buffer
   190C E1            [10] 3957         POP     HL                            ; Restore code string address
   190D C9            [10] 3958         RET
                           3959 ;
   190E 01 74 94      [10] 3960 RNGTST: LD      BC,0x9474                     ; BCDE = 999999.
   1911 11 F7 23      [10] 3961         LD      DE,0x23F7
   1914 CD 1A 17      [17] 3962         CALL    CMPNUM                        ; Compare numbers
   1917 B7            [ 4] 3963         OR      A
   1918 E1            [10] 3964         POP     HL                            ; Return address to HL
   1919 E2 76 18      [10] 3965         JP      PO,GTSIXD                     ; Too big - Divide by ten
   191C E9            [ 4] 3966         JP      (HL)                          ; Otherwise return to caller
                           3967 ;
   191D 00 00 00 80        3968 HALF:   .db     0x00,0x00,0x00,0x80           ; 0.5
                           3969 ;
   1921 A0 86 01           3970 POWERS: .db     0x0A0,0x086,0x001             ; 100000
   1924 10 27 00           3971         .db     0x010,0x027,0x000             ; 10000
   1927 E8 03 00           3972         .db     0x0E8,0x003,0x000             ; 1000
   192A 64 00 00           3973         .db     0x064,0x000,0x000             ; 100
   192D 0A 00 00           3974         .db     0x00A,0x000,0x000             ; 10
   1930 01 00 00           3975         .db     0x001,0x000,0x000             ; 1
                           3976 ;
   1933 21 C8 16      [10] 3977 NEGAFT: LD      HL,INVSGN                     ; Negate result
   1936 E3            [19] 3978         EX      (SP),HL                       ; To be done after caller
   1937 E9            [ 4] 3979         JP      (HL)                          ; Return to caller
                           3980 ;
   1938 CD D0 16      [17] 3981 SQR:    CALL    STAKFP                        ; Put value on stack
   193B 21 1D 19      [10] 3982         LD      HL,HALF                       ; Set power to 1/2
   193E CD DD 16      [17] 3983         CALL    PHLTFP                        ; Move 1/2 to FPREG
                           3984 ;
   1941 C1            [10] 3985 POWER:  POP     BC                            ; Get base
   1942 D1            [10] 3986         POP     DE
   1943 CD 9F 16      [17] 3987         CALL    TSTSGN                        ; Test sign of power
   1946 78            [ 4] 3988         LD      A,B                           ; Get exponent of base
   1947 CA 86 19      [10] 3989         JP      Z,EXP                         ; Make result 1 if zero
   194A F2 51 19      [10] 3990         JP      P,POWER1                      ; Positive base - Ok
   194D B7            [ 4] 3991         OR      A                             ; Zero to negative power?
   194E CA FB 03      [10] 3992         JP      Z,DZERR                       ; Yes - ?/0 Error
   1951 B7            [ 4] 3993 POWER1: OR      A                             ; Base zero?
   1952 CA C0 14      [10] 3994         JP      Z,SAVEXP                      ; Yes - Return zero
   1955 D5            [11] 3995         PUSH    DE                            ; Save base
   1956 C5            [11] 3996         PUSH    BC
   1957 79            [ 4] 3997         LD      A,C                           ; Get MSB of base
   1958 F6 7F         [ 7] 3998         OR      0b01111111                    ; Get sign status
   195A CD EB 16      [17] 3999         CALL    BCDEFP                        ; Move power to BCDE
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 74
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   195D F2 6E 19      [10] 4000         JP      P,POWER2                      ; Positive base - Ok
   1960 D5            [11] 4001         PUSH    DE                            ; Save power
   1961 C5            [11] 4002         PUSH    BC
   1962 CD 72 17      [17] 4003         CALL    INT                           ; Get integer of power
   1965 C1            [10] 4004         POP     BC                            ; Restore power
   1966 D1            [10] 4005         POP     DE
   1967 F5            [11] 4006         PUSH    AF                            ; MSB of base
   1968 CD 1A 17      [17] 4007         CALL    CMPNUM                        ; Power an integer?
   196B E1            [10] 4008         POP     HL                            ; Restore MSB of base
   196C 7C            [ 4] 4009         LD      A,H                           ; but don't affect flags
   196D 1F            [ 4] 4010         RRA                                   ; Exponent odd or even?
   196E E1            [10] 4011 POWER2: POP     HL                            ; Restore MSB and exponent
   196F 22 2B 81      [16] 4012         LD      (FPREG+2),HL                  ; Save base in FPREG
   1972 E1            [10] 4013         POP     HL                            ; LSBs of base
   1973 22 29 81      [16] 4014         LD      (FPREG),HL                    ; Save in FPREG
   1976 DC 33 19      [17] 4015         CALL    C,NEGAFT                      ; Odd power - Negate result
   1979 CC C8 16      [17] 4016         CALL    Z,INVSGN                      ; Negative base - Negate it
   197C D5            [11] 4017         PUSH    DE                            ; Save power
   197D C5            [11] 4018         PUSH    BC
   197E CD 53 15      [17] 4019         CALL    LOG                           ; Get LOG of base
   1981 C1            [10] 4020         POP     BC                            ; Restore power
   1982 D1            [10] 4021         POP     DE
   1983 CD 94 15      [17] 4022         CALL    FPMULT                        ; Multiply LOG by power
                           4023 ;
   1986 CD D0 16      [17] 4024 EXP:    CALL    STAKFP                        ; Put value on stack
   1989 01 38 81      [10] 4025         LD      BC,0x08138                    ; BCDE = 1/Ln(2)
   198C 11 3B AA      [10] 4026         LD      DE,0x0AA3B
   198F CD 94 15      [17] 4027         CALL    FPMULT                        ; Multiply value by 1/LN(2)
   1992 3A 2C 81      [13] 4028         LD      A,(FPEXP)                     ; Get exponent
   1995 FE 88         [ 7] 4029         CP      0x80+8                        ; Is it in range?
   1997 D2 7B 16      [10] 4030         JP      NC,OVTST1                     ; No - Test for overflow
   199A CD 72 17      [17] 4031         CALL    INT                           ; Get INT of FPREG
   199D C6 80         [ 7] 4032         ADD     A,0x80                        ; For excess 128
   199F C6 02         [ 7] 4033         ADD     A,2                           ; Exponent > 126?
   19A1 DA 7B 16      [10] 4034         JP      C,OVTST1                      ; Yes - Test for overflow
   19A4 F5            [11] 4035         PUSH    AF                            ; Save scaling factor
   19A5 21 42 15      [10] 4036         LD      HL,UNITY                      ; Point to 1.
   19A8 CD 4A 14      [17] 4037         CALL    ADDPHL                        ; Add 1 to FPREG
   19AB CD 8B 15      [17] 4038         CALL    MULLN2                        ; Multiply by LN(2)
   19AE F1            [10] 4039         POP     AF                            ; Restore scaling factor
   19AF C1            [10] 4040         POP     BC                            ; Restore exponent
   19B0 D1            [10] 4041         POP     DE
   19B1 F5            [11] 4042         PUSH    AF                            ; Save scaling factor
   19B2 CD 56 14      [17] 4043         CALL    SUBCDE                        ; Subtract exponent from FPREG
   19B5 CD C8 16      [17] 4044         CALL    INVSGN                        ; Negate result
   19B8 21 C6 19      [10] 4045         LD      HL,EXPTAB                     ; Coefficient table
   19BB CD F6 19      [17] 4046         CALL    SMSER1                        ; Sum the series
   19BE 11 00 00      [10] 4047         LD      DE,0                          ; Zero LSBs
   19C1 C1            [10] 4048         POP     BC                            ; Scaling factor
   19C2 4A            [ 4] 4049         LD      C,D                           ; Zero MSB
   19C3 C3 94 15      [10] 4050         JP      FPMULT                        ; Scale result to correct value
                           4051 ;
   19C6 08                 4052 EXPTAB: .db     8                             ; Table used by EXP
   19C7 40 2E 94 74        4053         .db     0x040,0x02E,0x094,0x074       ; -1/7! (-1/5040)
   19CB 70 4F 2E 77        4054         .db     0x070,0x04F,0x02E,0x077       ;  1/6! ( 1/720)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 75
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   19CF 6E 02 88 7A        4055         .db     0x06E,0x002,0x088,0x07A       ; -1/5! (-1/120)
   19D3 E6 A0 2A 7C        4056         .db     0x0E6,0x0A0,0x02A,0x07C       ;  1/4! ( 1/24)
   19D7 50 AA AA 7E        4057         .db     0x050,0x0AA,0x0AA,0x07E       ; -1/3! (-1/6)
   19DB FF FF 7F 7F        4058         .db     0x0FF,0x0FF,0x07F,0x07F       ;  1/2! ( 1/2)
   19DF 00 00 80 81        4059         .db     0x000,0x000,0x080,0x081       ; -1/1! (-1/1)
   19E3 00 00 00 81        4060         .db     0x000,0x000,0x000,0x081       ;  1/0! ( 1/1)
                           4061 ;
   19E7 CD D0 16      [17] 4062 SUMSER: CALL    STAKFP                        ; Put FPREG on stack
   19EA 11 92 15      [10] 4063         LD      DE,MULT                       ; Multiply by "X"
   19ED D5            [11] 4064         PUSH    DE                            ; To be done after
   19EE E5            [11] 4065         PUSH    HL                            ; Save address of table
   19EF CD EB 16      [17] 4066         CALL    BCDEFP                        ; Move FPREG to BCDE
   19F2 CD 94 15      [17] 4067         CALL    FPMULT                        ; Square the value
   19F5 E1            [10] 4068         POP     HL                            ; Restore address of table
   19F6 CD D0 16      [17] 4069 SMSER1: CALL    STAKFP                        ; Put value on stack
   19F9 7E            [ 7] 4070         LD      A,(HL)                        ; Get number of coefficients
   19FA 23            [ 6] 4071         INC     HL                            ; Point to start of table
   19FB CD DD 16      [17] 4072         CALL    PHLTFP                        ; Move coefficient to FPREG
   19FE 06                 4073         .db     0x06                          ; Skip "POP AF"
   19FF F1            [10] 4074 SUMLP:  POP     AF                            ; Restore count
   1A00 C1            [10] 4075         POP     BC                            ; Restore number
   1A01 D1            [10] 4076         POP     DE
   1A02 3D            [ 4] 4077         DEC     A                             ; Cont coefficients
   1A03 C8            [11] 4078         RET     Z                             ; All done
   1A04 D5            [11] 4079         PUSH    DE                            ; Save number
   1A05 C5            [11] 4080         PUSH    BC
   1A06 F5            [11] 4081         PUSH    AF                            ; Save count
   1A07 E5            [11] 4082         PUSH    HL                            ; Save address in table
   1A08 CD 94 15      [17] 4083         CALL    FPMULT                        ; Multiply FPREG by BCDE
   1A0B E1            [10] 4084         POP     HL                            ; Restore address in table
   1A0C CD EE 16      [17] 4085         CALL    LOADFP                        ; Number at HL to BCDE
   1A0F E5            [11] 4086         PUSH    HL                            ; Save address in table
   1A10 CD 59 14      [17] 4087         CALL    FPADD                         ; Add coefficient to FPREG
   1A13 E1            [10] 4088         POP     HL                            ; Restore address in table
   1A14 C3 FF 19      [10] 4089         JP      SUMLP                         ; More coefficients
                           4090 ;
   1A17 CD 9F 16      [17] 4091 RND:    CALL    TSTSGN                        ; Test sign of FPREG
   1A1A 21 5E 80      [10] 4092         LD      HL,SEED+2                     ; Random number seed
   1A1D FA 78 1A      [10] 4093         JP      M,RESEED                      ; Negative - Re-seed
   1A20 21 7F 80      [10] 4094         LD      HL,LSTRND                     ; Last random number
   1A23 CD DD 16      [17] 4095         CALL    PHLTFP                        ; Move last RND to FPREG
   1A26 21 5E 80      [10] 4096         LD      HL,SEED+2                     ; Random number seed
   1A29 C8            [11] 4097         RET     Z                             ; Return if RND(0)
   1A2A 86            [ 7] 4098         ADD     A,(HL)                        ; Add (SEED)+2)
   1A2B E6 07         [ 7] 4099         AND     0b00000111                    ; 0 to 7
   1A2D 06 00         [ 7] 4100         LD      B,0
   1A2F 77            [ 7] 4101         LD      (HL),A                        ; Re-save seed
   1A30 23            [ 6] 4102         INC     HL                            ; Move to coefficient table
   1A31 87            [ 4] 4103         ADD     A,A                           ; 4 bytes
   1A32 87            [ 4] 4104         ADD     A,A                           ; per entry
   1A33 4F            [ 4] 4105         LD      C,A                           ; BC = Offset into table
   1A34 09            [11] 4106         ADD     HL,BC                         ; Point to coefficient
   1A35 CD EE 16      [17] 4107         CALL    LOADFP                        ; Coefficient to BCDE
   1A38 CD 94 15      [17] 4108         CALL    FPMULT                        ;	; Multiply FPREG by coefficient
   1A3B 3A 5D 80      [13] 4109         LD      A,(SEED+1)                    ; Get (SEED+1)
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 76
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1A3E 3C            [ 4] 4110         INC     A                             ; Add 1
   1A3F E6 03         [ 7] 4111         AND     0b00000011                    ; 0 to 3
   1A41 06 00         [ 7] 4112         LD      B,0
   1A43 FE 01         [ 7] 4113         CP      1                             ; Is it zero?
   1A45 88            [ 4] 4114         ADC     A,B                           ; Yes - Make it 1
   1A46 32 5D 80      [13] 4115         LD      (SEED+1),A                    ; Re-save seed
   1A49 21 7C 1A      [10] 4116         LD      HL,RNDTAB-4                   ; Addition table
   1A4C 87            [ 4] 4117         ADD     A,A                           ; 4 bytes
   1A4D 87            [ 4] 4118         ADD     A,A                           ; per entry
   1A4E 4F            [ 4] 4119         LD      C,A                           ; BC = Offset into table
   1A4F 09            [11] 4120         ADD     HL,BC                         ; Point to value
   1A50 CD 4A 14      [17] 4121         CALL    ADDPHL                        ; Add value to FPREG
   1A53 CD EB 16      [17] 4122 RND1:   CALL    BCDEFP                        ; Move FPREG to BCDE
   1A56 7B            [ 4] 4123         LD      A,E                           ; Get LSB
   1A57 59            [ 4] 4124         LD      E,C                           ; LSB = MSB
   1A58 EE 4F         [ 7] 4125         XOR     0b01001111                    ; Fiddle around
   1A5A 4F            [ 4] 4126         LD      C,A                           ; New MSB
   1A5B 36 80         [10] 4127         LD      (HL),0x80                     ; Set exponent
   1A5D 2B            [ 6] 4128         DEC     HL                            ; Point to MSB
   1A5E 46            [ 7] 4129         LD      B,(HL)                        ; Get MSB
   1A5F 36 80         [10] 4130         LD      (HL),0x80                     ; Make value -0.5
   1A61 21 5C 80      [10] 4131         LD      HL,SEED                       ; Random number seed
   1A64 34            [11] 4132         INC     (HL)                          ; Count seed
   1A65 7E            [ 7] 4133         LD      A,(HL)                        ; Get seed
   1A66 D6 AB         [ 7] 4134         SUB     171                           ; Do it modulo 171
   1A68 C2 6F 1A      [10] 4135         JP      NZ,RND2                       ; Non-zero - Ok
   1A6B 77            [ 7] 4136         LD      (HL),A                        ; Zero seed
   1A6C 0C            [ 4] 4137         INC     C                             ; Fillde about
   1A6D 15            [ 4] 4138         DEC     D                             ; with the
   1A6E 1C            [ 4] 4139         INC     E                             ; number
   1A6F CD AA 14      [17] 4140 RND2:   CALL    BNORM                         ; Normalise number
   1A72 21 7F 80      [10] 4141         LD      HL,LSTRND                     ; Save random number
   1A75 C3 F7 16      [10] 4142         JP      FPTHL                         ; Move FPREG to last and return
                           4143 ;
   1A78 77            [ 7] 4144 RESEED: LD      (HL),A                        ; Re-seed random numbers
   1A79 2B            [ 6] 4145         DEC     HL
   1A7A 77            [ 7] 4146         LD      (HL),A
   1A7B 2B            [ 6] 4147         DEC     HL
   1A7C 77            [ 7] 4148         LD      (HL),A
   1A7D C3 53 1A      [10] 4149         JP      RND1                          ; Return RND seed
                           4150 ;
   1A80 68 B1 46 68        4151 RNDTAB: .db     0x068,0x0B1,0x046,0x068       ; Table used by RND
   1A84 99 E9 92 69        4152         .db     0x099,0x0E9,0x092,0x069
   1A88 10 D1 75 68        4153         .db     0x010,0x0D1,0x075,0x068
                           4154 ;
   1A8C 21 D6 1A      [10] 4155 COS:    LD      HL,HALFPI                     ; Point to PI/2
   1A8F CD 4A 14      [17] 4156         CALL    ADDPHL                        ; Add it to PPREG
   1A92 CD D0 16      [17] 4157 SIN:    CALL    STAKFP                        ; Put angle on stack
   1A95 01 49 83      [10] 4158         LD      BC,0x8349                     ; BCDE = 2 PI
   1A98 11 DB 0F      [10] 4159         LD      DE,0x0FDB
   1A9B CD E0 16      [17] 4160         CALL    FPBCDE                        ; Move 2 PI to FPREG
   1A9E C1            [10] 4161         POP     BC                            ; Restore angle
   1A9F D1            [10] 4162         POP     DE
   1AA0 CD F5 15      [17] 4163         CALL    DVBCDE                        ; Divide angle by 2 PI
   1AA3 CD D0 16      [17] 4164         CALL    STAKFP                        ; Put it on stack
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 77
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1AA6 CD 72 17      [17] 4165         CALL    INT                           ; Get INT of result
   1AA9 C1            [10] 4166         POP     BC                            ; Restore number
   1AAA D1            [10] 4167         POP     DE
   1AAB CD 56 14      [17] 4168         CALL    SUBCDE                        ; Make it 0 <= value < 1
   1AAE 21 DA 1A      [10] 4169         LD      HL,QUARTR                     ; Point to 0.25
   1AB1 CD 50 14      [17] 4170         CALL    SUBPHL                        ; Subtract value from 0.25
   1AB4 CD 9F 16      [17] 4171         CALL    TSTSGN                        ; Test sign of value
   1AB7 37            [ 4] 4172         SCF                                   ; Flag positive
   1AB8 F2 C2 1A      [10] 4173         JP      P,SIN1                        ; Positive - Ok
   1ABB CD 47 14      [17] 4174         CALL    ROUND                         ; Add 0.5 to value
   1ABE CD 9F 16      [17] 4175         CALL    TSTSGN                        ; Test sign of value
   1AC1 B7            [ 4] 4176         OR      A                             ; Flag negative
   1AC2 F5            [11] 4177 SIN1:   PUSH    AF                            ; Save sign
   1AC3 F4 C8 16      [17] 4178         CALL    P,INVSGN                      ; Negate value if positive
   1AC6 21 DA 1A      [10] 4179         LD      HL,QUARTR                     ; Point to 0.25
   1AC9 CD 4A 14      [17] 4180         CALL    ADDPHL                        ; Add 0.25 to value
   1ACC F1            [10] 4181         POP     AF                            ; Restore sign
   1ACD D4 C8 16      [17] 4182         CALL    NC,INVSGN                     ; Negative - Make positive
   1AD0 21 DE 1A      [10] 4183         LD      HL,SINTAB                     ; Coefficient table
   1AD3 C3 E7 19      [10] 4184         JP      SUMSER                        ; Evaluate sum of series
                           4185 ;
   1AD6 B0 0F 49 81        4186 HALFPI: .db     0x0D0b0,0x00F,0x049,0x081     ; 1.5708 (PI/2)
                           4187 ;
   1ADA 00 00 00 7F        4188 QUARTR: .db     0x000,0x000,0x000,0x07F       ; 0.25
                           4189 ;
   1ADE 05                 4190 SINTAB: .db     5                             ; Table used by SIN
   1ADF BA D7 1E 86        4191         .db     0x0BA,0x0D7,0x01E,0x086       ; 39.711
   1AE3 64 26 99 87        4192         .db     0x064,0x026,0x099,0x087       ;-76.575
   1AE7 58 34 23 87        4193         .db     0x058,0x034,0x023,0x087       ; 81.602
   1AEB E0 5D A5 86        4194         .db     0x0E0,0x05D,0x0A5,0x086       ;-41.342
   1AEF DA 0F 49 83        4195         .db     0x0DA,0x00F,0x049,0x083       ; 6.2832
                           4196 ;
   1AF3 CD D0 16      [17] 4197 TAN:    CALL    STAKFP                        ; Put angle on stack
   1AF6 CD 92 1A      [17] 4198         CALL    SIN                           ; Get SIN of angle
   1AF9 C1            [10] 4199         POP     BC                            ; Restore angle
   1AFA E1            [10] 4200         POP     HL
   1AFB CD D0 16      [17] 4201         CALL    STAKFP                        ; Save SIN of angle
   1AFE EB            [ 4] 4202         EX      DE,HL                         ; BCDE = Angle
   1AFF CD E0 16      [17] 4203         CALL    FPBCDE                        ; Angle to FPREG
   1B02 CD 8C 1A      [17] 4204         CALL    COS                           ; Get COS of angle
   1B05 C3 F3 15      [10] 4205         JP      DIV                           ; TAN = SIN / COS
                           4206 ;
   1B08 CD 9F 16      [17] 4207 ATN:    CALL    TSTSGN                        ; Test sign of value
   1B0B FC 33 19      [17] 4208         CALL    M,NEGAFT                      ; Negate result after if -ve
   1B0E FC C8 16      [17] 4209         CALL    M,INVSGN                      ; Negate value if -ve
   1B11 3A 2C 81      [13] 4210         LD      A,(FPEXP)                     ; Get exponent
   1B14 FE 81         [ 7] 4211         CP      0x81                          ; Number less than 1?
   1B16 DA 25 1B      [10] 4212         JP      C,ATN1                        ; Yes - Get arc tangnt
   1B19 01 00 81      [10] 4213         LD      BC,0x8100                     ; BCDE = 1
   1B1C 51            [ 4] 4214         LD      D,C
   1B1D 59            [ 4] 4215         LD      E,C
   1B1E CD F5 15      [17] 4216         CALL    DVBCDE                        ; Get reciprocal of number
   1B21 21 50 14      [10] 4217         LD      HL,SUBPHL                     ; Sub angle from PI/2
   1B24 E5            [11] 4218         PUSH    HL                            ; Save for angle > 1
   1B25 21 2F 1B      [10] 4219 ATN1:   LD      HL,ATNTAB                     ; Coefficient table
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 78
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1B28 CD E7 19      [17] 4220         CALL    SUMSER                        ; Evaluate sum of series
   1B2B 21 D6 1A      [10] 4221         LD      HL,HALFPI                     ; PI/2 - angle in case > 1
   1B2E C9            [10] 4222         RET                                   ; Number > 1 - Sub from PI/2
                           4223 ;
   1B2F 09                 4224 ATNTAB: .db     9                             ; Table used by ATN
   1B30 4A D7 B0 78        4225         .db     0x04A,0x0D7,0x030b0,0x078     ; 1/17
   1B34 02 6E 84 B0        4226         .db     0x002,0x06E,0x084,0x070b0     ;-1/15
   1B38 FE C1 2F 7C        4227         .db     0x0FE,0x0C1,0x02F,0x07C       ; 1/13
   1B3C 74 31 9A 7D        4228         .db     0x074,0x031,0x09A,0x07D       ;-1/11
   1B40 84 3D 5A 7D        4229         .db     0x084,0x03D,0x05A,0x07D       ; 1/9
   1B44 C8 7F 91 7E        4230         .db     0x0C8,0x07F,0x091,0x07E       ;-1/7
   1B48 E4 B0 4C 7E        4231         .db     0x0E4,0x0B0b0,0x04C,0x07E     ; 1/5
   1B4C 6C AA AA 7F        4232         .db     0x06C,0x0AA,0x0AA,0x07F       ;-1/3
   1B50 00 00 00 81        4233         .db     0x000,0x000,0x000,0x081       ; 1/1
                           4234 ;
                           4235 
   1B54 C9            [10] 4236 ARET:   RET                                   ; A RETurn instruction
                           4237 ;
   1B55 D7            [11] 4238 GETINP: RST     0x10                          ;input a character
   1B56 C9            [10] 4239         RET
                           4240 ;
   1B57                    4241 CLS:
   1B57 3E 0C         [ 7] 4242         LD      A,CS                          ; ASCII Clear screen
   1B59 C3 8D 1C      [10] 4243         JP      MONOUT                        ; Output character
                           4244 ;
   1B5C CD 1E 14      [17] 4245 WIDTH:  CALL    GETINT                        ; Get integer 0-255
   1B5F 7B            [ 4] 4246         LD      A,E                           ; Width to A
   1B60 32 87 80      [13] 4247         LD      (LWIDTH),A                    ; Set width
   1B63 C9            [10] 4248         RET
                           4249 ;
   1B64 CD BD 0C      [17] 4250 LINES:  CALL    GETNUM                        ; Get a number
   1B67 CD 02 09      [17] 4251         CALL    DEINT                         ; Get integer -32768 to 32767
   1B6A ED 53 8B 80   [20] 4252         LD      (LINESC),DE                   ; Set lines counter
   1B6E ED 53 8D 80   [20] 4253         LD      (LINESN),DE                   ; Set lines number
   1B72 C9            [10] 4254         RET
                           4255 ;
   1B73 CD 02 09      [17] 4256 DEEK:   CALL    DEINT                         ; Get integer -32768 to 32767
   1B76 D5            [11] 4257         PUSH    DE                            ; Save number
   1B77 E1            [10] 4258         POP     HL                            ; Number to HL
   1B78 46            [ 7] 4259         LD      B,(HL)                        ; Get LSB of contents
   1B79 23            [ 6] 4260         INC     HL
   1B7A 7E            [ 7] 4261         LD      A,(HL)                        ; Get MSB of contents
   1B7B C3 78 10      [10] 4262         JP      ABPASS                        ; Return integer AB
                           4263 ;
   1B7E CD BD 0C      [17] 4264 DOKE:   CALL    GETNUM                        ; Get a number
   1B81 CD 02 09      [17] 4265         CALL    DEINT                         ; Get integer -32768 to 32767
   1B84 D5            [11] 4266         PUSH    DE                            ; Save address
   1B85 CD C6 06      [17] 4267         CALL    CHKSYN                        ; Make sure ', follows
   1B88 2C                 4268         .db     ',
   1B89 CD BD 0C      [17] 4269         CALL    GETNUM                        ; Get a number
   1B8C CD 02 09      [17] 4270         CALL    DEINT                         ; Get integer -32768 to 32767
   1B8F E3            [19] 4271         EX      (SP),HL                       ; Save value,get address
   1B90 73            [ 7] 4272         LD      (HL),E                        ; Save LSB of value
   1B91 23            [ 6] 4273         INC     HL
   1B92 72            [ 7] 4274         LD      (HL),D                        ; Save MSB of value
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 79
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1B93 E1            [10] 4275         POP     HL                            ; Restore code string address
   1B94 C9            [10] 4276         RET
                           4277 ;
                           4278 
                           4279 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                           4280 ;
   1B95 CD C0 0C      [17] 4281 HEX:    CALL    TSTNUM                        ; Verify it's a number
   1B98 CD 02 09      [17] 4282         CALL    DEINT                         ; Get integer -32768 to 32767
   1B9B C5            [11] 4283         PUSH    BC                            ; Save contents of BC
   1B9C 21 2E 81      [10] 4284         LD      HL,PBUFF
   1B9F 7A            [ 4] 4285         LD      A,D                           ; Get high order into A
   1BA0 FE 00         [ 7] 4286         CP      0
   1BA2 28 0C         [12] 4287         JR      Z,HEX2                        ; Skip output if both high digits are zero
   1BA4 CD CD 1B      [17] 4288         CALL    BYT2ASC                       ; Convert D to ASCII
   1BA7 78            [ 4] 4289         LD      A,B
   1BA8 FE 30         [ 7] 4290         CP      '0
   1BAA 28 02         [12] 4291         JR      Z,HEX1                        ; Don't store high digit if zero
   1BAC 70            [ 7] 4292         LD      (HL),B                        ; Store it to PBUFF
   1BAD 23            [ 6] 4293         INC     HL                            ; Next location
   1BAE 71            [ 7] 4294 HEX1:   LD      (HL),C                        ; Store C to PBUFF+1
   1BAF 23            [ 6] 4295         INC     HL                            ; Next location
   1BB0 7B            [ 4] 4296 HEX2:   LD      A,E                           ; Get lower byte
   1BB1 CD CD 1B      [17] 4297         CALL    BYT2ASC                       ; Convert E to ASCII
   1BB4 7A            [ 4] 4298         LD      A,D
   1BB5 FE 00         [ 7] 4299         CP      0
   1BB7 20 05         [12] 4300         JR      NZ,HEX3                       ; If upper byte was not zero then always print lower byte
   1BB9 78            [ 4] 4301         LD      A,B
   1BBA FE 30         [ 7] 4302         CP      '0                            ; If high digit of lower byte is zero then don't print
   1BBC 28 02         [12] 4303         JR      Z,HEX4
   1BBE 70            [ 7] 4304 HEX3:   LD      (HL),B                        ; to PBUFF+2
   1BBF 23            [ 6] 4305         INC     HL                            ; Next location
   1BC0 71            [ 7] 4306 HEX4:   LD      (HL),C                        ; to PBUFF+3
   1BC1 23            [ 6] 4307         INC     HL                            ; PBUFF+4 to zero
   1BC2 AF            [ 4] 4308         XOR     A                             ; Terminating character
   1BC3 77            [ 7] 4309         LD      (HL),A                        ; Store zero to terminate
   1BC4 23            [ 6] 4310         INC     HL                            ; Make sure PBUFF is terminated
   1BC5 77            [ 7] 4311         LD      (HL),A                        ; Store the double zero there
   1BC6 C1            [10] 4312         POP     BC                            ; Get BC back
   1BC7 21 2E 81      [10] 4313         LD      HL,PBUFF                      ; Reset to start of PBUFF
   1BCA C3 26 11      [10] 4314         JP      STR1                          ; Convert the PBUFF to a string and return it
                           4315 ;
   1BCD 47            [ 4] 4316 BYT2ASC:LD      B,A                           ; Save original value
   1BCE E6 0F         [ 7] 4317         AND     0x0F                          ; Strip off upper nybble
   1BD0 FE 0A         [ 7] 4318         CP      0x0A                          ; 0-9?
   1BD2 38 02         [12] 4319         JR      C,ADD30                       ; If A-F, add 7 more
   1BD4 C6 07         [ 7] 4320         ADD     A,0x07                        ; Bring value up to ASCII A-F
   1BD6 C6 30         [ 7] 4321 ADD30:  ADD     A,0x30                        ; And make ASCII
   1BD8 4F            [ 4] 4322         LD      C,A                           ; Save converted char to C
   1BD9 78            [ 4] 4323         LD      A,B                           ; Retrieve original value
   1BDA 0F            [ 4] 4324         RRCA                                  ; and Rotate it right
   1BDB 0F            [ 4] 4325         RRCA
   1BDC 0F            [ 4] 4326         RRCA
   1BDD 0F            [ 4] 4327         RRCA
   1BDE E6 0F         [ 7] 4328         AND     0x0F                          ; Mask off upper nybble
   1BE0 FE 0A         [ 7] 4329         CP      0x0A                          ; 0-9? < A hex?
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 80
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1BE2 38 02         [12] 4330         JR      C,ADD301                      ; Skip Add 7
   1BE4 C6 07         [ 7] 4331         ADD     A,0x07                        ; Bring it up to ASCII A-F
   1BE6 C6 30         [ 7] 4332 ADD301: ADD     A,0x30                        ; And make it full ASCII
   1BE8 47            [ 4] 4333         LD      B,A                           ; Store high order byte
   1BE9 C9            [10] 4334         RET
                           4335 ;
                           4336 ; Convert "&Hnnnn" to FPREG
                           4337 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                           4338 ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
   1BEA EB            [ 4] 4339 HEXTFP: EX      DE,HL                         ; Move code string pointer to DE
   1BEB 21 00 00      [10] 4340         LD      HL,0x0000                     ; Zero out the value
   1BEE CD 03 1C      [17] 4341         CALL    GETHEX                        ; Check the number for valid hex
   1BF1 DA 23 1C      [10] 4342         JP      C,HXERR                       ; First value wasn't hex, HX error
   1BF4 18 05         [12] 4343         JR      HEXLP1                        ; Convert first character
   1BF6 CD 03 1C      [17] 4344 HEXLP:  CALL    GETHEX                        ; Get second and addtional characters
   1BF9 38 1F         [12] 4345         JR      C,HEXIT                       ; Exit if not a hex character
   1BFB 29            [11] 4346 HEXLP1: ADD     HL,HL                         ; Rotate 4 bits to the left
   1BFC 29            [11] 4347         ADD     HL,HL
   1BFD 29            [11] 4348         ADD     HL,HL
   1BFE 29            [11] 4349         ADD     HL,HL
   1BFF B5            [ 4] 4350         OR      L                             ; Add in D0-D3 into L
   1C00 6F            [ 4] 4351         LD      L,A                           ; Save new value
   1C01 18 F3         [12] 4352         JR      HEXLP                         ; And continue until all hex characters are in
                           4353 ;
   1C03 13            [ 6] 4354 GETHEX: INC     DE                            ; Next location
   1C04 1A            [ 7] 4355         LD      A,(DE)                        ; Load character at pointer
   1C05 FE 20         [ 7] 4356         CP      0x20
   1C07 CA 03 1C      [10] 4357         JP      Z,GETHEX                      ; Skip spaces
   1C0A D6 30         [ 7] 4358         SUB     0x30                          ; Get absolute value
   1C0C D8            [11] 4359         RET     C                             ; < "0", error
   1C0D FE 0A         [ 7] 4360         CP      0x0A
   1C0F 38 05         [12] 4361         JR      C,NOSUB7                      ; Is already in the range 0-9
   1C11 D6 07         [ 7] 4362         SUB     0x07                          ; Reduce to A-F
   1C13 FE 0A         [ 7] 4363         CP      0x0A                          ; Value should be $0A-$0F at this point
   1C15 D8            [11] 4364         RET     C                             ; CY set if was :		; < = > ? @
   1C16 FE 10         [ 7] 4365 NOSUB7: CP      0x10                          ; > Greater than "F"?
   1C18 3F            [ 4] 4366         CCF
   1C19 C9            [10] 4367         RET                                   ; CY set if it wasn't valid hex
                           4368 
   1C1A EB            [ 4] 4369 HEXIT:  EX      DE,HL                         ; Value into DE, Code string into HL
   1C1B 7A            [ 4] 4370         LD      A,D                           ; Load DE into AC
   1C1C 4B            [ 4] 4371         LD      C,E                           ; For prep to
   1C1D E5            [11] 4372         PUSH    HL
   1C1E CD 77 10      [17] 4373         CALL    ACPASS                        ; ACPASS to set AC as integer into FPREG
   1C21 E1            [10] 4374         POP     HL
   1C22 C9            [10] 4375         RET
                           4376 ;
   1C23 1E 26         [ 7] 4377 HXERR:  LD      E,HX                          ; ?HEX Error
   1C25 C3 0C 04      [10] 4378         JP      ERROR
                           4379 ;
                           4380 ; BIN$(NN) Convert integer to a 1-16 char binary string
   1C28 CD C0 0C      [17] 4381 BIN:    CALL    TSTNUM                        ; Verify it's a number
   1C2B CD 02 09      [17] 4382         CALL    DEINT                         ; Get integer -32768 to 32767
   1C2E C5            [11] 4383 BIN2:   PUSH    BC                            ; Save contents of BC
   1C2F 21 2E 81      [10] 4384         LD      HL,PBUFF
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 81
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1C32 06 11         [ 7] 4385         LD      B,17                          ; One higher than max char count
   1C34                    4386 ZEROSUP:                                      ; Suppress leading zeros
   1C34 05            [ 4] 4387         DEC     B                             ; Max 16 chars
   1C35 78            [ 4] 4388         LD      A,B
   1C36 FE 01         [ 7] 4389         CP      0x01
   1C38 28 08         [12] 4390         JR      Z,BITOUT                      ; Always output at least one character
   1C3A CB 13         [ 8] 4391         RL      E
   1C3C CB 12         [ 8] 4392         RL      D
   1C3E 30 F4         [12] 4393         JR      NC,ZEROSUP
   1C40 18 04         [12] 4394         JR      BITOUT2
   1C42                    4395 BITOUT:
   1C42 CB 13         [ 8] 4396         RL      E
   1C44 CB 12         [ 8] 4397         RL      D                             ; Top bit now in carry
   1C46                    4398 BITOUT2:
   1C46 3E 30         [ 7] 4399         LD      A,'0                          ; Char for '0
   1C48 CE 00         [ 7] 4400         ADC     A,0                           ; If carry set then '0 --> '1
   1C4A 77            [ 7] 4401         LD      (HL),A
   1C4B 23            [ 6] 4402         INC     HL
   1C4C 05            [ 4] 4403         DEC     B
   1C4D 20 F3         [12] 4404         JR      NZ,BITOUT
   1C4F AF            [ 4] 4405         XOR     A                             ; Terminating character
   1C50 77            [ 7] 4406         LD      (HL),A                        ; Store zero to terminate
   1C51 23            [ 6] 4407         INC     HL                            ; Make sure PBUFF is terminated
   1C52 77            [ 7] 4408         LD      (HL),A                        ; Store the double zero there
   1C53 C1            [10] 4409         POP     BC
   1C54 21 2E 81      [10] 4410         LD      HL,PBUFF
   1C57 C3 26 11      [10] 4411         JP      STR1
                           4412 ;
                           4413 ; Convert "&Bnnnn" to FPREG
                           4414 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
   1C5A EB            [ 4] 4415 BINTFP: EX      DE,HL                         ; Move code string pointer to DE
   1C5B 21 00 00      [10] 4416         LD      HL,0x0000                     ; Zero out the value
   1C5E CD 77 1C      [17] 4417         CALL    CHKBIN                        ; Check the number for valid bin
   1C61 DA 85 1C      [10] 4418         JP      C,BINERR                      ; First value wasn't bin, HX error
   1C64 D6 30         [ 7] 4419 BINIT:  SUB     '0
   1C66 29            [11] 4420         ADD     HL,HL                         ; Rotate HL left
   1C67 B5            [ 4] 4421         OR      L
   1C68 6F            [ 4] 4422         LD      L,A
   1C69 CD 77 1C      [17] 4423         CALL    CHKBIN                        ; Get second and addtional characters
   1C6C 30 F6         [12] 4424         JR      NC,BINIT                      ; Process if a bin character
   1C6E EB            [ 4] 4425         EX      DE,HL                         ; Value into DE, Code string into HL
   1C6F 7A            [ 4] 4426         LD      A,D                           ; Load DE into AC
   1C70 4B            [ 4] 4427         LD      C,E                           ; For prep to
   1C71 E5            [11] 4428         PUSH    HL
   1C72 CD 77 10      [17] 4429         CALL    ACPASS                        ; ACPASS to set AC as integer into FPREG
   1C75 E1            [10] 4430         POP     HL
   1C76 C9            [10] 4431         RET
                           4432 ;
                           4433 ; Char is in A, NC if char is 0 or 1
   1C77 13            [ 6] 4434 CHKBIN: INC     DE
   1C78 1A            [ 7] 4435         LD      A,(DE)
   1C79 FE 20         [ 7] 4436         CP      0x20
   1C7B CA 77 1C      [10] 4437         JP      Z,CHKBIN                      ; Skip spaces
   1C7E FE 30         [ 7] 4438         CP      '0                            ; Set C if < '0
   1C80 D8            [11] 4439         RET     C
ASxxxx Assembler V05.31  (Zilog Z80 / Hitachi HD64180)                 Page 82
Hexadecimal [16-Bits]                                 Sun Mar  9 07:17:37 2025



   1C81 FE 32         [ 7] 4440         CP      '2
   1C83 3F            [ 4] 4441         CCF                                   ; Set C if > '1
   1C84 C9            [10] 4442         RET
                           4443 ;
   1C85 1E 28         [ 7] 4444 BINERR: LD      E,BN                          ; ?BIN Error
   1C87 C3 0C 04      [10] 4445         JP      ERROR
                           4446 ;
   1C8A C3 51 00      [10] 4447 JJUMP1: JP      CSTART                        ; Go and initialise
                           4448 ;
   1C8D C3 08 00      [10] 4449 MONOUT: JP      0x0008                        ; output a char
                           4450 ;
   1C90 C3 00 00      [10] 4451 MONITR: JP      0x0000                        ; Restart (Normally Monitor Start)
                           4452 ;
   1C93 3E 00         [ 7] 4453 INITST: LD      A,0                           ; Clear break flag
   1C95 32 92 80      [13] 4454         LD      (BRKFLG),A
   1C98 C3 58 00      [10] 4455         JP      INIT
                           4456 ;
   1C9B F5            [11] 4457 TSTBIT: PUSH    AF                            ; Save bit mask
   1C9C A0            [ 4] 4458         AND     B                             ; Get common bits
   1C9D C1            [10] 4459         POP     BC                            ; Restore bit mask
   1C9E B8            [ 4] 4460         CP      B                             ; Same bit set?
   1C9F 3E 00         [ 7] 4461         LD      A,0                           ; Return 0 in A
   1CA1 C9            [10] 4462         RET
                           4463 ;
   1CA2 CD D1 06      [17] 4464 OUTNCR: CALL    OUTC                          ; Output character in A
   1CA5 C3 F8 0A      [10] 4465         JP      PRCRLF                        ; Output CRLF
                           4466 ;
                           4467         .end
